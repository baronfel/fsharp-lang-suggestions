{"10020264":{"Number":"10020264","Submitter":"Anonymous","Submitted":"2015-10-01T00:00:00","Title":"implicit upcast of return values","Text":"It gets to be very frustrating when working with many C# libraries from F# because F# lacks implicit upcasting of return values. In some cases, this is just annoying. But it is particularly intractable when dealing with libraries expecting Expressions, because upcasting changes how the expression is evaluated by the library. See this question, where in the comments, the author comes to the conclusion that he can't make it work with F#.\r\nhttp://stackoverflow.com/questions/10647198/how-to-convert-expra-b-to-expressionfunca-obj\r\nThere does exist a work-around, but it is quite horrible.\r\nhttp://www.fssnip.net/c7\r\nAside from this show-stopping issue, there are many other scenarios where libraries expect implicit upcasts and it becomes annoying to have to litter your code with explicit upcasts. Interfaces and System.Object are the usual suspects for upcasting.\r\nRequest implicit upcasting of return values.","Votes":6,"Comments":[],"Status":"","Response":null},"10256475":{"Number":"10256475","Submitter":"William Blum","Submitted":"2015-10-17T00:00:00","Title":"Catch improper use of monadic return in async","Text":"The following code should issue a type checking error since return () should yield an Async<unit> and return 42 should yield an Async<int>.\r\nlet f c =\r\nasync {\r\nreturn ()\r\nprintfn \"You passed %A and I am returning 42\" c\r\nreturn 42\r\n}\r\nAdditionally the following code should issue a warning since the return statement does not actually affect the flow of execution as the name suggests (The printf statement is actually executed).\r\nlet g c =\r\nasync {\r\nreturn ()\r\nprintfn \"You passed %A and I am returning 42\" c\r\nreturn ()\r\n}","Votes":11,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2015-10-18T15:09:00","Content":"Return in computation expressions is the monodic \"return\" (or \"pure\") and has nothing in common with return in imperative languages like C#. What's more, return usually == yield."},{"Submitter":"Don Syme","Submitted":"2016-01-23T11:50:00","Content":"I do agree that ideally this should be caught, and some kind of warning given.\r\nI don't specifically have a design in mind, but I am going to mark this as \"planned\", though subject to a detailed design, implementation and testing. I don't expect it to be a top-priority, but from the design perspective I'm ok with us looking for a solution to this specific problem."}],"Status":"planned","Response":{"Responded":"2016-01-23T00:00:00","Text":"See comment\r\nApproved in principle, though definitely subject to a more detailed satisfactory design (not to adhoc,not specific to “async”)\r\nDon Syme, F# Language and Core Library Evolution"}},"10276974":{"Number":"10276974","Submitter":"Kevin Ransom","Submitted":"2015-10-19T00:00:00","Title":"Allow all declarations to be mutually referential and the compiler takes files in any order","Text":"With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to just change F# to use no file order at all, allowing all declarations in an assembly to be mutually referential with other declarations.\r\nRelated alternative: Keep a file order, but infer it from #load/#require declarations. This is covered by [/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files](/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files.md)\r\nRelated alternative: Keep a file order, but optionally have it specified by a fileorder.fsx or fileorder.txt or fileorder.json: [/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx](/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx.md)","Votes":39,"Comments":[{"Submitter":"Daniel Robinson","Submitted":"2015-10-19T13:55:00","Content":"I'm confused. Isn't being able to view file dependencies at a glance, based on file order, a good thing for the same reason types are required to be defined in order?"},{"Submitter":"Daniel Robinson","Submitted":"2015-10-19T13:59:00","Content":"If we go the #include/#load route, I hope VS will still require dependency order. My 2 cents."},{"Submitter":"Mark Seemann","Submitted":"2015-10-19T14:00:00","Content":"Like Daniel Robinson, I think that since the order matters, being able to view that order at a glance is valuable.\r\nIf that feature is removed, I suspect we'll see files named 010Foo.fs, 050Bar.fs, etc. That's not a place I'd like to go."},{"Submitter":"Colin Bull","Submitted":"2015-10-19T14:16:00","Content":"Personally, having the enforced order of the files is a big win for me. It allows me to pick up a project and instantly know where to start figuring out how things work. This is especially useful for libraries which do not have such an obvious entry point as is available in console apps; also since the compiler enforces it is the same across all projects, no matter the developer. I realise that this can be somewhat of a hurdle for beginners, but for maintainability of a code base it is invaluable."},{"Submitter":"Onorio Catenacci","Submitted":"2015-10-19T14:16:00","Content":"Can someone vote against an idea? This is a bad idea.\r\nF#'s enforced compilation order is a _good_thing_."},{"Submitter":"DK","Submitted":"2015-10-19T14:22:00","Content":"I think this is a brilliant idea! And the best part is -- it doesn't cancel out the enforced file order.\r\nHaving a tool deduce file order (and for example, update file order in solution explorer automatically) will let us keep the best of both worlds."},{"Submitter":"Radek Micek","Submitted":"2015-10-19T14:37:00","Content":"@DK Unfortunately this is not so simple. Different file orders may result in different behaviours (eg. when a type is in referenced assembly and a type with the same name is also in current assembly)."},{"Submitter":"Jack Fox","Submitted":"2015-10-19T15:48:00","Content":"Unless this is a win in some area I do not understand (like tooling) I too would down-vote this idea."},{"Submitter":"Yaar Hever","Submitted":"2015-10-19T15:56:00","Content":"I'm also against it. Letting the compiler figure out the order of dependency only postpones the problem and eventually leads to spaghetti code and cyclic dependencies.\r\nI find that this constraint + the fact that mutually recursive functions and types require the \"let/type ... and ...\" syntax actually help in reasoning about the structure of the code.\r\nSee also this article (and the references at its end): http://fsharpforfunandprofit.com/posts/recipe-part3/"},{"Submitter":"Daniel Robinson","Submitted":"2015-10-19T17:08:00","Content":"Kevin, would the files in Solution Explorer re-order automatically based on #load's?"},{"Submitter":"x","Submitted":"2015-10-19T17:19:00","Content":"Do this in external tooling to sort your files in the solution, and not in the compiler! As it is, its a great feature for keeping the architecture clean."},{"Submitter":"Anonymous","Submitted":"2015-10-20T03:44:00","Content":"As already commented on Twitter: Please don't break compilation order. It's what makes my code sane."},{"Submitter":"mavnn","Submitted":"2015-10-20T07:57:00","Content":"I'd also like to go on record as not wanting this as a feature; I say this dispite having written build scripts that *do* use #load statements in fsx files to feed the compiler source in the correct order.\r\nIt works, but it's ugly and it's not an improvement; optionally moving this information out of fsproj files might be helpful, but I'd rather see a dedicated file for this (like fsi files for signature information)."},{"Submitter":"Shawn Martin","Submitted":"2015-10-21T12:47:00","Content":"Since there's no downvote button, I guess I'll pile on with many of the other commenters. I like the existing enforcement of an explicit, user-specified order."},{"Submitter":"Anonymous","Submitted":"2015-10-21T15:53:00","Content":"If I could spend votes to down vote this suggestion I would.\r\nThis is a feature not a bug. It's a small bit of pain to start with that improves the overall quality / understandability later."},{"Submitter":"Bent Tranberg","Submitted":"2015-10-31T15:01:00","Content":"I'd also like to go on record as not wanting this. Colin Bull and others has already explained why it should stay the way it is."},{"Submitter":"Anonymous","Submitted":"2015-11-04T21:43:00","Content":"Please don't do this."},{"Submitter":"Semyon Grigorev","Submitted":"2015-12-08T09:01:00","Content":"Bad idea. Fixed compilation order is a good feature."},{"Submitter":"Siro Mateos","Submitted":"2015-12-11T10:13:00","Content":"Add another \"downvote\", for NOT doing this."},{"Submitter":"Joakim","Submitted":"2015-12-23T18:12:00","Content":"Semantic file order and lack of cyclic dependencies makes it so much easier to figure out what's going on in a project. Consider this a downvote."},{"Submitter":"Harald Steinlechner","Submitted":"2016-02-03T06:20:00","Content":"Another downvote. although it seems nice, we'd increase complexity in f# libraries, .e.g. see http://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild/"},{"Submitter":"Don Syme","Submitted":"2016-02-03T14:53:00","Content":"See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an which suggests\r\nopen \"Helpers.fs\"\r\nor\r\n#requires \"Helpers.fs\"\r\nor\r\n#load \"Helpers.fs\" (which already describes dependencies in scripts)\r\nNote that F# scripts already have syntactic description of non-cyclic dependencies through #load. So a file ordering inferred from syntax is already part of the F# programming model, at least for scripting."},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:32:00","Content":"Jus to mention that I don't see anything fundamentally \"non-F#\" about optionally describing file dependencies explicitly within files - indeed we already do this for F# scripting using ``#load``. The file ordering would still exist.\r\nSee http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an for example"},{"Submitter":"Kurren Nischal","Submitted":"2016-04-14T03:23:00","Content":"Downvote. The ability to open a project and immediately see the dependency hierarchy is a major reason why we use F#."},{"Submitter":"Stefano Pian","Submitted":"2016-04-18T03:37:00","Content":"Downvote. The compilation order has been a huge blessing for me whenever I need to pick up a moderate-sized or bigger F# project.\r\nI agree that the F# compilation should become editor-agnostic, but either of the related alternatives would solve the problem without sacrificing F#'s excellent enforced code structure."},{"Submitter":"Jason Ritchie","Submitted":"2016-06-28T06:49:00","Content":"Downvote. Having circular dependencies be impossible helps me fall into a 'pit of success' in my designs."},{"Submitter":"Gauthier Segay","Submitted":"2016-06-28T06:58:00","Content":"It is unfortunate that this suggestion mixes 2 concerns:\r\n* declarations to be mutually referential (which most people don't want as seen in comments)\r\n* have the compiler figure out the order rather than have to specify it manually\r\nI think the later point would be a great thing for end-users, and that doesn't circumvent at all file ordering being there and necessary, only it would be figured out by the compiler."},{"Submitter":"Loic Denuziere","Submitted":"2016-07-01T08:51:00","Content":"100% agree with Gauthier. It would be quite good if the compiler could figure out the order of the files, but total circular dependency is way too error-prone."},{"Submitter":"Alex Yakunin","Submitted":"2016-09-24T02:09:00","Content":"Upvote.\r\nThere were many points saying that explicit file order is one of core F# features, and it's crucial. It lets you immediately see the order of dependencies, and thus it prevents possible issues with circular / spaghetti dependencies.\r\nI am fully disagree with this:\r\na) Dependencies aren't simply chained in most of projects -- usually there is a good amount of flexibility in how to order them. And it's not fully clear why a specific order is preferable over others.\r\nb) This also means that actually order doesn't show the dependencies: on contrary, it shows which dependencies do not exist. The only relationship it exposes is: \"if A is above B, A definitely does not depend on B\". Though the same doesn't mean \"B definitely depends on A\".\r\nc) Finally, dependency graph is a graph, not a sequence. So I don't understand why it's good to force developers to model it as a sequence. Especially assuming that almost any modern compiler is smart enough to figure out both dependencies and compilation sequence.\r\nd) Nevertheless, I see a value in having an ability to display the dependencies of your F# files. But \"display\" is not what compilers do -- this is what IDEs and other tools do. So I totally support to have this feature in IDE, but I don't see a single reason to have it baked into the compiler -- at least in such a way.\r\nMoreover, if I'd be building a feature allowing me to see these dependencies, I'd prefer to show differently -- one of good ways is to show it as a tree listing the most independent files on the first level, their dependencies -- on the second, and so on. The opposite order (from the mostly dependent components to their deepest dependencies) is totally valid too. Any profiler is capable of showing a similar structure for your call tree.\r\nAnd I don't think I'd prefer this dependency graph to be shown simply as an ordered sequence.\r\nPlease consider all these arguments before downvoting this feature."}],"Status":"","Response":null},"10837866":{"Number":"10837866","Submitter":"John Azariah","Submitted":"2015-11-23T00:00:00","Title":"Introduce the ?. operator into F#","Text":"Since we allow the . operator to reference fields and properties of objects in F#, we're faced with the same problem of null checking that plagued C# until C# 5.\r\nThe C# 6 'elvis' operator propagates nulls in a succinct way, and I think that working with objects in F# will be similarly simplified if we introduce it here as well!","Votes":16,"Comments":[{"Submitter":"Radek Micek","Submitted":"2015-11-28T06:18:00","Content":"I prefer using None instead of null in F#."},{"Submitter":"Fraser Waters","Submitted":"2015-12-01T06:54:00","Content":"@radek, maybe semantics like\r\na.?b\r\n===\r\nif a = null then None else Some (a.b)\r\nAnd chained together so\r\na.?b.?c\r\n===\r\nif a = null then None else (if b = null then None else Some (a.b.c))\r\nWould allow easy matching as well:\r\nmatch a.?b with\r\n| Some b -> printf \"a.b is %A\" b\r\n| None -> printf \"a is null\""},{"Submitter":"Colin Bull","Submitted":"2015-12-01T07:46:00","Content":"There is already an Option.ofObj(F# 4) that can help here\r\nYou can do something like,\r\nlet a = new System.IO.FileInfo(\"Foo\")\r\nlet (<*>) a f = a |> Option.map f\r\nlet ($) a f = (Option.ofObj a) <*> f\r\nlet x =\r\na$(fun x -> x.CreationTime) <*> (fun x -> x.ToShortDateString())\r\nNot quiet as succinct but you can always lift those accessors to functions to make things tidier.\r\nIn general though I'm opposed to using this type of symbolics as it hides meaning, however well documented it is from (C# etc...). I'd prefer to define these locally like this and just use the functions from F# core."},{"Submitter":"Bartosz Sypytkowski","Submitted":"2015-12-04T03:12:00","Content":"\"maybe{}\" is a basic lesson about computation expressions and it already solves problems, that \"elvis operator\" is trying to solve. F# doesn't need to solve monad problems using syntax sugar like C# does. We can use existing tools instead."},{"Submitter":"Ryan Riley","Submitted":"2016-01-15T13:07:00","Content":"I agree with Bartosz. Even though ?. would be more succinct, I would prefer the built-in language symbols remain as few in number as possible."},{"Submitter":"Harald Steinlechner","Submitted":"2016-01-18T12:29:00","Content":"this snippet is a superstrong argument against such a feature ;)\r\nhttp://pastebin.com/Z6kbuTEE\r\n(be proud if you can compute all types of the variables as well as the return value)"}],"Status":"","Response":null},"11109258":{"Number":"11109258","Submitter":"Tom Rathbone","Submitted":"2015-12-16T00:00:00","Title":"Richer literals: TimeSpan/DateTime/Char array/UTF8","Text":"Combining several suggestions for richer literals\r\n- New literals for TimeSpan and DateTime. e.g.\r\n\"01:02:03\"T --> new TimeSpan(1,2,3)\r\n\"2015-01-02 10:30:00\"D -> new DateTime(2015,01,02,10,30,00)\r\n- Char[] e.g\r\n\"abcd\"C\r\n- UTF8 encoded strings \"abc££def\"U\r\nand indeed perhaps the whole mechanism should be extensible like QZRING literals","Votes":4,"Comments":[{"Submitter":"Sergey Tihon","Submitted":"2015-12-20T01:17:00","Content":"F# allow you to define your own behavior for suffixes Q, R, Z, I, N & G - https://sergeytihon.wordpress.com/2014/01/11/f-kung-fu-2-custom-numeric-literals/"}],"Status":"","Response":null},"11125137":{"Number":"11125137","Submitter":"Keith Battocchi","Submitted":"2015-12-17T00:00:00","Title":"Expand support for byref to match C# 7","Text":"C# is adding support for byref locals and returns (see https://github.com/dotnet/roslyn/issues/118, slated for milestone 1.3). This will result in many libraries that expose these features (which the CLR already supports), but methods with such return types aren't currently usable from F#. F# already supports byref locals, but doesn't support implementing byref-returning methods nor does it support calling byref-returning methods.\r\nAt a minimum, F# should support calling byref-returning-methods (e.g. SomeRefReturningMethod(x,y,z) <- w), since C# users will be creating methods like these and being unable to call them will limit F#'s reach.\r\nIt would be nice if on top of that base level of support F# also supported declaring such methods, using the same safety rules that C# is using (e.g. the only refs that are safe to return are those that point to values stored on the heap or existing refs that are passed into the method).","Votes":14,"Comments":[{"Submitter":"Keith Battocchi","Submitted":"2015-12-17T10:40:00","Content":"Concretely, this code works today:\r\nlet array = [| 1 .. 10 |]\r\nlet r = &array.[0]\r\nr <- -1\r\nBut if you create a method using ildasm that wraps int[]'s Address method (with signature int[] * int -> int&), then this doesn't\r\nlet arr = [| 1 .. 10 |]\r\nlet r = ArrayHelper.GetAddress(arr, 0) // error FS0412: A type instantiation involves a byref type. This is not permitted by the rules of Common IL.\r\nr <- -1"},{"Submitter":"exercitus vir","Submitted":"2016-07-02T07:06:00","Content":"Would it be possible to simply return a `byref` type to implement this feature?"}],"Status":"planned","Response":{"Responded":"2016-01-23T00:00:00","Text":"Yes, this should be done, thanks\r\nApproved in primciple subject to a detailed design, resolution of any remaining issues, and an implementation, with testing. Also subject to the feature actually appearing in C# 7 :)\r\nDon Syme, F# Language Evolution"}},"11273478":{"Number":"11273478","Submitter":"Eric Stokes","Submitted":"2015-12-31T00:00:00","Title":"In a pattern match use the record field name as a default binding if none is provided","Text":"In OCaml we can do,\r\nmatch somrecord with\r\n| {foo; bar; baz} -> foo + bar + baz\r\nIf we don't provide a binding, then the field name is used as the default. In F# we still have to write,\r\nmatch somerecord with\r\n| {foo=foo;bar=bar;baz=baz} -> foo + bar + baz\r\nThis is quite a simple syntactic enhancement, however it's very nice to have. It also pushes us to use the (presumably) well chosen record field names for our variables instead of picking a single letter variable name.\r\nAlso, in OCaml we get a warning if we don't bind all the record fields in a pattern match, unless we include _. e.g. {foo;bar;_}. This would be a nice thing to have as well, because in a pattern match where we DO want to bind all the fields, we are now told when the record type changes that we need to consider the new field. This is very useful for large projects.","Votes":13,"Comments":[],"Status":"","Response":null},"11356293":{"Number":"11356293","Submitter":"Eric Stokes","Submitted":"2016-01-08T00:00:00","Title":"Allow implementation of abstract slots with generic return type instantiated at type 'unit'","Text":"The behavior described here,\r\nhttp://stackoverflow.com/questions/26296401/why-is-unit-treated-differently-by-the-f-type-system-when-used-as-a-generic-i\r\nis quite surprising to someone coming from other typed FP languages. The fact that a generic type parameter can't be unit makes the whole generics abstraction feel a bit leaky and hacky, which isn't great publicity, as F# actually has a lot of great ideas.\r\nIn practice this comes up when implementing type indexed values of various sorts, as an interface is an ideal and natural way to do that, and of course one often wants to have a sometype<unit> value. The compiler error is rather surprising as well, as it implies the object expression doesn't implement the interface, which of course isn't the case.","Votes":7,"Comments":[],"Status":"planned","Response":{"Responded":"2016-02-05T00:00:00","Text":"Approving this in principle, it would be great to fix this behavior.\r\nWe will open an RFC on this in due course, https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThere are reasons for the existing behaviour due to unit v. void, as explained in the various stackoverflow topics on this question, but it should be possible to workaround those.\r\nDon Syme, F# Language Evolution"}},"11356425":{"Number":"11356425","Submitter":"Don Syme","Submitted":"2016-01-08T00:00:00","Title":"Optionally relax signatures of -X, sin X, cos X to allow use w.r.t. subtyping","Text":"See https://github.com/Microsoft/visualfsharp/issues/799\r\ntype Base(x : int) =\r\nmember self.X = x\r\nstatic member (~-) (a : Base) = Base(-a.X)\r\nstatic member (+) (a : Base, b : Base) = Base(a.X + b.X)\r\nstatic member Cos(a : Base) = Base(2*a.X)\r\ntype Derived(x : int) =\r\ninherit Base(x)\r\nlet a = Base(1)\r\nlet minusa = -a // OK\r\nlet cosa = cos a // OK\r\nlet twoa = a + a // OK\r\nlet b = Derived(1)\r\nlet minusb = -b // Compile error\r\nlet cosb = cos b // Compile error\r\nlet twob = b + b // OK","Votes":3,"Comments":[{"Submitter":"Don Syme","Submitted":"2016-02-04T15:56:00","Content":"This is a reasonable request and we should accommodate this somehow. Unfortunately we will likely only be able to do it by having the user open a new module."}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Marking as approved-in-principle per my comment below\r\nWe will post an RFC for it in due course.\r\nDon Syme, F# Language and Core Library Evolution"}},"11661270":{"Number":"11661270","Submitter":"Georg Haaser","Submitted":"2016-01-31T00:00:00","Title":"extend ComputationExpression builders with Map : m<'a> * ('a -> 'b) -> m<'b>","Text":"In many scenarios computation expressions could be executed way more efficiently when having just a little more information.\r\nThe typical use-case for that would be something like\r\nasync {\r\nlet! a = something\r\nreturn 2*a\r\n}\r\nwhich currently gets translated to:\r\nasync.Bind(something, fun a -> async.Return(2*a))\r\nBy monad laws (borrowed from haskell here) this must be equal to:\r\nasync.Map(something, fun a -> 2*a)\r\nIn many scenarios the latter can be implemented with a lot less overhead, so in my opinion it would be profitable to allow users to provide this \"shortcut\".","Votes":8,"Comments":[],"Status":"","Response":null},"12425811":{"Number":"12425811","Submitter":"Jared Hester","Submitted":"2016-02-21T00:00:00","Title":"Add Polymorphic Variants (ad-hoc Discriminated Unions)","Text":"Creating strongly typed data constructs with some level of heterogeneity is often accomplished with DUs so lets take the trivial case of wanting\r\nto have lists of floats & ints, ints & strings, and ints & floats & strings\r\nWe'd need the types -\r\ntype IntString =\r\n| Int of int\r\n| String' of string\r\ntype FloatInt =\r\n| Float of int\r\n| Int of int\r\n\r\ntype IntFloatString =\r\n| Float of int\r\n| Int of int\r\n| String' of string\r\nBut in practice using these would require qualified access to make sure you're getting the right case from the right type and as types you\r\nwant to group grow in number there's a combinatory explosion of boilerplate and verbose code necessary to put it to work.\r\nPolymorphic variants cut down the noise and increase the flexibility and expressiveness of your code.\r\nThe declaration of a polymorphic variant in OCaml is not unlike that of the single case DUs that are already commonly found in F# code\r\nInstead of -\r\ntype Int = Int of int;;\r\n> type Int = | Int of int\r\nInt 3;;\r\n> val it : Int = Int 3\r\nOCaml and uses a preceding backtick convention for a simplified syntax-\r\nlet three = `Int 3;;\r\n> val three : [> `Int of int ] = `Int 3\r\nlet four = `Float 4.;;\r\n> val four : [> `Float of float ] = `Float 4.\r\nThe `>` at the beginning of the variant types above marks the types as being open to combination with other variant types.\r\nWhich means a list could be declared as such -\r\nlet ls = [three; four]\r\n> val ls : [> `Int of int | `Float of float]\r\nand the type would be an ad-hoc Discriminated Union where its cases match the polymorphic variants used\r\nthis also applies to function declarations\r\nlet is_positive = function\r\n| `Int x -> x > 0\r\n| `Float x -> x > 0.\r\n;;\r\n> val is_positive : [< `Float of float | `Int of int ] -> bool = <fun>\r\nThe `<` is there because is_positive has no way of dealing with values that have tags other than `Float of float or `Int of int.\r\nThe `<` and `>` markers are indicators of the upper and lower bounds on the tags involved.\r\nIf the same set of tags are both an upper and a lower bound, we end up with an exact polymorphic variant type, which has neither marker\r\nlet exact = List.filter is_positive [three;four];;\r\n> val exact : [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.]\r\n^ summarizing the part of Real World Ocaml on Polymorphic Variants\r\nhttps://realworldocaml.org/v1/en/html/variants.html\r\nfurther reference - http://caml.inria.fr/pub/docs/manual-ocaml-400/manual006.html#toc36","Votes":36,"Comments":[{"Submitter":"Jack Fox","Submitted":"2016-03-06T11:36:00","Content":"Would there be a single ad-hoc Discriminated Union for all polymorphic variants currently in scope? Then depending on program structure and scope different sets of polymorphic variants would be available.\r\nI think I like this idea..."}],"Status":"","Response":null},"12488550":{"Number":"12488550","Submitter":"mikero","Submitted":"2016-02-26T00:00:00","Title":"Map keys <--> set compatibility","Text":"A map's key collection is a set and should be treatable as such. Currently (AFAIK) you must get the keys from the map like so:\r\nlet keys = Map.toSeq >> Seq.map fst\r\nthen create a set from the (k,v) seq:\r\nlet set1 = keys map1 |> Set.ofSeq\r\nand then perform your set operation:\r\nlet common = Set.intersect set1 set2\r\nThis involves creating a temporary collection and a new set.\r\nThere are several ways to improve things:\r\n(1) Provide a Map.toKeySet & Set.ofMapKeys functions that will directly and efficiently create a new set from the Map's keys. This is straightforward and should be done, but will create a new set, which may not always be warranted.\r\n(2) Provide a functions that treat the Map's key as a set, exposing some/all of the set operations - at least intersect/difference.\r\nFor example: Map.keySetIntersect & Map.keysetDifference, or using a nested name Map.keySet.intersect, etc.\r\n(3) Provide set-like functions that work on Maps and produce new Maps. Map.difference and Map.intersect. (Note map intersect would be Map<k,v> -> Map<k,v> -> Map<k,v*v> )\r\nEach of these has it's own use case.","Votes":2,"Comments":[],"Status":"","Response":null},"12510276":{"Number":"12510276","Submitter":"Steven Taylor","Submitted":"2016-02-28T00:00:00","Title":"#r #load via fsi method","Text":"fsi.Load(\"script.fsx\")\r\nfsi.Reference(\"bin/debug/someDllReference.dll\")\r\nIt would be very useful to be able to fsi.Load / fsi.Reference through type providers, for use by those who are designing them.","Votes":1,"Comments":[{"Submitter":"Don Syme","Submitted":"2016-02-29T12:58:00","Content":"While tempting, the problem is that type checking of a script would not detect these and so the static type checking of the script would not be possible."},{"Submitter":"Steven Taylor","Submitted":"2016-03-13T19:00:00","Content":"Is there a way to also dynamically insert into the static type checker?\r\nIn the spirit of exploratory programming, there are a range of useful cross .dll / tool chain workflows that this would enable. This would make it a more fluid experience. It would be quite useful for those who are new to whatever modelling domain it is. I've observed that the extra referencing exercise can be jarring to some programmers. Can provide additional use cases if of interest.\r\ncheers."}],"Status":"","Response":null},"12512739":{"Number":"12512739","Submitter":"Steven Taylor","Submitted":"2016-02-29T00:00:00","Title":"Improve Discriminated Union Type Inference","Text":"Sometimes the most logical name for an element of a Discriminated Union (DU), is a common concept such as a list\r\n-- something that you've used before elsewhere.\r\nThe only way around the last resolved resolution is either through namespaces, or by adopting a naming convention.\r\nSometimes getting nagged about name overuse can lead to clearer code, but what if our intention is exactly as\r\nwritten? In the below, if we named elements to be ListOfA and ListOfB, then the problem goes away.\r\nSounds and often is simple, but it can lead to additional code noise and moves us away ever so slightly\r\nfrom the problem domain.\r\ntype A =\r\n| Element\r\n| List of A list\r\ntype B =\r\n| ElementB\r\n| List of B list\r\nlet u : B = List([]) // okay : takes last defined\r\nlet v : A = List([]) // fails : last defined is B\r\nlet w = List([]) : A // fails : ignores hint\r\nlet x = A.List([]) // okay : fully qualified\r\nlet y = List([ElementA]) // fails : expects ElementA\r\nnote: this request is similar to this accepted request [/ideas/suggestion-7138324-record-based-improve-type-inference-bug?tracking_code=3364d3565b19a0c518474dccbc2a1ec0](/ideas/suggestion-7138324-record-based-improve-type-inference-bug?tracking_code=3364d3565b19a0c518474dccbc2a1ec0.md)","Votes":1,"Comments":[],"Status":"","Response":null},"12529242":{"Number":"12529242","Submitter":"Zhen","Submitted":"2016-03-01T00:00:00","Title":"warnon:1182 seems like a good idea, why is it off by default ?","Text":"","Votes":3,"Comments":[],"Status":"","Response":null},"12533019":{"Number":"12533019","Submitter":"Jeff Heon","Submitted":"2016-03-01T00:00:00","Title":"Allow function names to end with a question mark.","Text":"I find it really elegant in some language where predicate functions can end with a question mark.\r\nConsider `odd? 5` vs `isOdd 5` or `areRelated a b` vs `related? a b`\r\nThere might be some reason why it's a terrible idea grammar-wise or something in F#. I'm still very much a newbie I'm afraid. I apologize if it's featured in a FAQ I missed or even here and I search badly.","Votes":1,"Comments":[{"Submitter":"Isaac Abraham","Submitted":"2016-03-06T11:53:00","Content":"You can get this to work with backtick declarations which let you put lots of stuff e.g. spaces in the declaration e.g.\r\nlet ``odd?`` a = a % 2 <> 0\r\nIntellisense in e.g. Visual Studio doesn't work for them though, unfortunately."},{"Submitter":"Jeff Heon","Submitted":"2016-03-06T15:53:00","Content":"That's great to know Isaac. Thank you very much for taking the time to educate me 8)"}],"Status":"","Response":null},"12536532":{"Number":"12536532","Submitter":"Brad Collins","Submitted":"2016-03-01T00:00:00","Title":"Add a shorthand/literal syntax for creating Maps","Text":"A shorthand/literal syntax or computation expression for building Maps would be nice—something like the following:\r\nlet m = map [\"a\",97; \"b\",98; \"c\",99]\r\nThe shorthand for dictionaries ...\r\nlet d = dict [\"a\",97; \"b\",98; \"c\",99]\r\n... is nice, but while Maps implement IDictionary, dictionaries do not play well with Map module functions. One must inevitably convert a dictionary to a Map or create a Map with Map.ofArray, .ofList, or .ofSeq.","Votes":3,"Comments":[{"Submitter":"amazingant","Submitted":"2016-03-07T06:15:00","Content":"You can add this yourself fairly easily by adding the following anywhere in your code:\r\nlet map = Map.ofList\r\nand then your first code sample works"},{"Submitter":"Brad Collins","Submitted":"2016-03-07T09:08:00","Content":"@amazingant, no argument that it's an easy fix, but its seems like an obvious oversight (and perhaps even that's too strong a word) when we have shorthand for every other built-in F# container: lists, sequences, arrays, and sets. As someone who came to the language just a little over a year ago, I found it incongruous for map shorthand to be missing."},{"Submitter":"AK","Submitted":"2016-03-10T15:41:00","Content":"You can already do this\r\ni.e Map [(\"Key\", \"Value); (\"Key2\", \"Value2\")] works fine in my code. Notice the capital M on Map"},{"Submitter":"Brad Collins","Submitted":"2016-03-10T17:31:00","Content":"@ak, ah, I see! I am embarrassed that I had not explored that option. But I see now that it's merely a call to the Map constructor.\r\nI will quibble that the style is inconsistent. That is, it's set [ ... ] for sets, dict [ ... ] for dictionaries, seq [ ... ] for sequences, but it's Map [ ... ] for maps. That inconsistency is not satisfying.\r\nNevertheless, I concede the point that a shorthand clearly already exists. I just overlooked it."}],"Status":"","Response":null},"12546456":{"Number":"12546456","Submitter":"George","Submitted":"2016-03-01T00:00:00","Title":"Allow more flexible layout for constraint syntax","Text":"The following layout of constraints for a sample class should be possible.\r\nGroupedFixtures<'A, 'B\r\nwhen\r\n'A :> Remote.RemoteWebDriver and\r\n'A : (new: unit -> 'A) and\r\n'B :> ServerFixture\r\n>() as this =\r\nPresently it almost was but the `new()` constraint use of parenthesis caused problems. currently all the constraints layout forces them on the same line which is not as clear or convenient (note the text, that `>() as this`, is allowed on a separate line):\r\nGroupedFixtures<'A, 'B when 'A :> Remote.RemoteWebDriver and 'A : (new: unit -> 'A) and 'B :> ServerFixture\r\n>() as this =","Votes":1,"Comments":[],"Status":"","Response":null},"12546540":{"Number":"12546540","Submitter":"George","Submitted":"2016-03-01T00:00:00","Title":"Allow flexible types in default constructor constraint","Text":"This would permit,\r\nlet ctor<'a when 'a:(new: unit -> #IWebDriver)> : unit -> IWebDriver = ...\r\nversus\r\nlet ctor<'a when 'a:(new: unit- > 'a) and 'a :> IWebDriver> = fun () -> new 'a() :> IWebDriver","Votes":2,"Comments":[],"Status":"","Response":null},"12555765":{"Number":"12555765","Submitter":"Jared Hester","Submitted":"2016-03-02T00:00:00","Title":"Inline Record Definition in Discriminated Unions","Text":"type shape =\r\n(**)| Circle of\r\n(*....*) { centerX : float\r\n(*......*) centerY : float\r\n(*......*) radius : float\r\n(*....*) }\r\n| Rect of\r\n(*....*) { x_lo : float\r\n(*......*) y_lo : float\r\n(*......*) x_hi : float\r\n(*......*) y_hi : float\r\n(*....*) }\r\nRecently Added to OCaml\r\nhttps://blogs.janestreet.com/ocaml-4-03-everything-else/","Votes":30,"Comments":[{"Submitter":"Huw Simpson","Submitted":"2016-03-04T07:29:00","Content":"This feature already exists in the form:\r\ntype Shame =\r\n| Circle of centerX: float * centerY:float * radius:float\r\n| ...\r\nIt supports pattern matching by the order of the field as well as the name."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-06T04:27:00","Content":"I believe that discriminated unions containing inline records in their declarations is a great idea. It would improve the F# expressiveness. It is good that the F# language supports tuples with named items as Huw Simpson mentioned, but inline records in declarations of discriminated union types would be a new way of expressing programmers' ideas in code. F# should remain competitive and be better than OCaml, I think."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-07T14:23:00","Content":"I think inline records can be named as \"record expressions\" or \"records of an anonymous type\" for the sake of terminology consistency in F#. There are object expressions in F# that are useful when there is no need to define a class. I think a situation when a language user needs to use a record expression of a compiler-generated anonymous record type instead of a user-defined record type is quite possible in practice and it will be good if the language has a solution able to meet competition with other programming languages."},{"Submitter":"Bikal Gurung","Submitted":"2016-05-19T05:34:00","Content":"This feature is currently deprecated in F# 3.0 and above. It was available I believe until F# 2.0. Maybe we can change the title to 'Undeprecate inline record in DU'. I have also created a ticket/issue in github visual f# repo. https://github.com/Microsoft/visualfsharp/issues/1196#issuecomment-220172524"},{"Submitter":"Demetrios Obenour","Submitted":"2016-07-07T21:03:00","Content":"For me, the big advantage is that it would allow mutable inline records. This can be huge for performance."}],"Status":"","Response":null},"12560184":{"Number":"12560184","Submitter":"Alexei Odeychuk","Submitted":"2016-03-02T00:00:00","Title":"Use the in keyword and \"|\" symbol for membership tests and better readability (from Ada 2012)","Text":"I suggest using the in keyword for membership tests (from Ada 2012).\r\nExample # 1:\r\nif x in 1 .. 100 then ... // the in keyword would be especially useful within the if expressions. That form of the if expression has better readability than: if x >= 1 && x <= 100 then...\r\nExample # 2:\r\nmatch counter with n when n in 1 .. 10 .. 101 -> ... // the when expression here has a succinct form and better readability than the current syntax: match counter with n when [ 1 .. 10 .. 101 ] |> List.exists (fun x -> x = n) -> ...\r\nExample # 3:\r\nlet x = 21\r\nlet testX = x in 1 .. 5 .. 21 // testX = true because 1 .. 5 .. 21 is the sequence of integers: 1; 6; 11; 16; 21.\r\nInterdependent suggestion (from Ada 2012):\r\nI suggest using \"I\" symbol along with the in keyword for membership tests, for example:\r\ntype Animals =\r\n| Dog\r\n| Cat\r\n| Mouse\r\n| Chinchilla\r\nlet mutable pet = Chinchilla\r\nif pet in Dog | Cat then ... // if pet = Dog || pet = Cat then ...\r\nThe same role for \"I\" has already assigned within the match expressions in F#:\r\nmatch pet with\r\n| Dog | Cat -> ...\r\nMoreover, the \"I\" symbol can be used in F#:\r\na) for specifying ranges, generating lists, sequences, arrays etc., for example: let lst = [ 1 .. 2 .. 100 | 200 | 1000 .. 3 .. 5000 ];\r\nb) for membership tests (if n in 1 .. 2 .. 100 | 200 | 1000 .. 3 .. 5000 then ...);\r\nc) and within the for loops (for i in 1 .. 2 .. 100 | 200 | 1000 .. 5000 do ... // i is changed from 1 to 99, then becomes equal to 200, then is changed from 1000 to 5000). It's a succinct and easy-to-read notation.\r\nI think it's a good idea to take this notation from Ada 2012 to bolster competitive strengths and popularity of the F# language.\r\nP.S. Ada 2012 is a statically typed, imperative, object-oriented programming language offering extremely strong typing, explicit concurrency, tasks (named and anonymous task types), synchronous message passing between task entries, protected (armored) objects for mutual exclusion. It designed for code readability, safety and maintainability of large, long-lived, mission-critical, safety-critical and security-critical applications. Ada 2012 is the latest version of the Ada language.","Votes":6,"Comments":[],"Status":"","Response":null},"12563118":{"Number":"12563118","Submitter":"Alexei Odeychuk","Submitted":"2016-03-02T00:00:00","Title":"Allow enumeration type names and discriminated union type names in a for loop (from Ada 2012)","Text":"I suggest using enumeration type names and discriminated union type names in a for loop meaning to try every value (from Ada 2012).\r\nFor example,\r\na) Enumeration type name in a for loop:\r\ntype Animals =\r\n| Tiger = 1\r\n| Cat = 2\r\n| Lion = 3\r\nfor animal in Animals do printf \"%A\" animal\r\nAs of today, the F# compiler posts a message: error FS0039: The value or constructor 'Animals' is not defined.\r\nb) Discriminated union type name in a for loop (Ada 2012 does not have discriminated union types, but it has record types with a discriminant (parameter) that resemble discriminated union behavior, but they have completely different syntax):\r\ntype Animals = Tiger | Cat | Lion\r\nfor animal in Animals do printf \"%A\" animal\r\nAs of today, the F# compiler posts a message: error FS0693: The type '(unit -> Animals)' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq<_>, IEnumerable<_> or IEnumerable and does not have a GetEnumerator method\r\nc) For loop can be applied to generate a list, sequence etc., for example:\r\ntype Animals = Tiger | Cat | Lion\r\nlet animalSequence =\r\nseq { for animal in Animals -> animal } // seq { Tiger; Cat; Lion }\r\nI think it's a good idea to allow enumeration type names and discriminated union type names in for loops and treat enumeration types and discriminated union types by the F# compiler as types compatible with IEnumerable and having a GetEnumerator method (even if they don't). It will make the F# syntax more expressive and bolster F# competitive strengths.","Votes":2,"Comments":[{"Submitter":"Jack Fox","Submitted":"2016-03-06T11:13:00","Content":"I see merit in this, but I'm withholding my vote as I would rather see this implemented as the having the standard collection functions (fold, map, etc.) over enumerations and discriminated unions. Then this all becomes composable. For loops are not so composable."},{"Submitter":"Gauthier Segay","Submitted":"2016-03-06T21:33:00","Content":"What is expected error message if any of the DU member has data defined for it?"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-10T09:29:00","Content":"Gauthier Segay, I think the situation where a discriminated union case has data associated with it should not stand in the way of the introduction of the syntax allowing the usage of discriminated union type names in a for loop. I think there is no need to raise an exception here. The discriminated union is a foundational type in functional programming. So, I suggest default initializing all data fields associated with the appropriate discriminated union case. There is function Unchecked.defaultof<'T> to generate a default value for any type in F#. The compiler can use it to generate compiled code.\r\nIf a language user wants to change any default initialized data field associated with a particular union case, this can be done by writing the code snippet like this:\r\ntype Animals = Tiger of age : int * name : string | Cat | Lion\r\n[ for animal in Animals ->\r\nmatch animal with\r\n| Tiger(age, name) -> Tiger(2, Kitty) // change the initial\r\n// default value\r\n| predator -> predator ]\r\n|> List.iter (printfn \"%A\")\r\nAs to a comment by Jack Fox: I believe that the syntax suggested can be implemented in the compiler even without standard collection functions (fold, map, etc.) over enumerations and discriminated unions.\r\nThe compiler can obtain information on all union cases defined by a language user for a particular discriminated union type from code (The similar applies to enumeration types). So, the F# compiler can convert the expression \"for animal in Animals\" to \"for animal in seq { yield Tiger(Unchecked.defaultof<int>, Unchecked.defaultof<string>); yield Cat; yield Lion }\" behind the scenes in order to reach the goal of the syntax suggested."}],"Status":"","Response":null},"12564057":{"Number":"12564057","Submitter":"Alexei Odeychuk","Submitted":"2016-03-02T00:00:00","Title":"Allow basic integer numeric type names in a for loop (from Ada 2012)","Text":"I suggest using basic integer numeric type names (namely, sbyte, byte, int16, uint16, int (int32), uint32, int64, uint64) in a for loop meaning to try every value of the type (from Ada 2012).\r\nFor example,\r\nlet ourSequence = seq { for i in int -> i } // ourSequence : seq<int>\r\nlet ourList = [ for i in byte -> i ] // ourList : byte list\r\nfor i in sbyte do printf \"%A\" i\r\nI think it's a good idea to allow basic integer numeric type names in for loops just as in Ada 2012 and treat such types by the F# compiler as types compatible with IEnumerable and having a GetEnumerator method (even if they don't). It will make the F# syntax more expressive and bolster F# competitive strengths in writing clear and concise code.","Votes":2,"Comments":[],"Status":"","Response":null},"12564486":{"Number":"12564486","Submitter":"Alexei Odeychuk","Submitted":"2016-03-02T00:00:00","Title":"Types with predicates to create subtypes easily (from Ada 2012)","Text":"I suggest introducing type predicates as an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of creating subtypes easily.\r\nSuppose, we are concerned with animal species and that we have a\r\ntype Animals thus:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\nNow suppose we wish to declare subtypes for predators and prey.\r\nSo we would like to declare a type Predators embracing Tiger, Cat and Lion, and a type Prey embracing Mouse and Hamster.\r\nI suggest two ways to do this:\r\n1) We can do this with an anonymous function performing pattern matching (subtype predicate in Ada 2012) by writing:\r\ntype Prey = Animals with function\r\n| Mouse\r\n| Hamster -> true\r\n| _ -> false\r\ntype Predators = Animals with function Tiger | Cat | Lion -> true\r\n| _ -> false\r\nand then we are assured that objects of type Predators can only be Tiger, Cat or Lion, and objects of type Prey can only be Mouse or Hamster.\r\nAnother example:\r\ntype Even = int with function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nThe aspect should be checked (checks for admissible values should be generated in compiled code by the F# compiler and performed) whenever an object of the type is default initialized, on assignments, on type casts, on parameter passing, in the match expressions and so on.\r\n2) If we want to use a named function performing pattern matching, then we have to write:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\nlet isPredator(animal: Animals): bool =\r\nmatch animal with\r\n| Tiger | Cat | Lion -> true\r\n| _ -> false\r\ntype Predator = Animals with isPredator;\r\nAnd last but not least, types with predicates should be allowed in a for loop meaning to try every value. So F# programmers should be able to write:\r\nfor animal in Predators do ...\r\nfor digit in Even do ...\r\nPlease see my previous suggestions for more details:\r\na) Allow enumeration type names and discriminated union type names in a for loop (from Ada 2012): [/ideas/suggestion-12563118-allow-enumeration-type-names-and-discriminated-uni;](/ideas/suggestion-12563118-allow-enumeration-type-names-and-discriminated-uni;.md)\r\nb) Allow basic integer numeric type names in a for loop (from Ada 2012): [/ideas/suggestion-12564057-allow-basic-integer-numeric-type-names-in-a-for-lo](/ideas/suggestion-12564057-allow-basic-integer-numeric-type-names-in-a-for-lo.md)\r\nThe suggested syntax allows writing clear, concise and easy-to-understand code. It will not affect existing codebase.\r\nI think it will help bolster F# competitive strengths and improve its position in the TIOBE language popularity index.","Votes":7,"Comments":[{"Submitter":"NhlCrd","Submitted":"2016-03-14T16:56:00","Content":"It is not obvious to me what advantages this feature would provide over active patterns and partial active patterns.\r\nSyntactically speaking, (P)APs are also more concise:\r\nlet (|Predator|Prey|) = function\r\n|Tiger|Lion -> Predator\r\n|Mouse -> Prey"},{"Submitter":"OneWingedShark","Submitted":"2016-03-14T23:25:00","Content":"Per haps a better demonstration would be user-input or data-validation; here's a couple simple examples using Ada 2012's type-system to ensure formatting/data consistsancy:\r\nhttps://m.reddit.com/r/programming/comments/2770qx/computer_science_and_math/chz389x\r\nhttps://m.reddit.com/r/programming/comments/238v7g/three_flaws_in_software_design_part_1_writing/cgv37g7"}],"Status":"","Response":null},"12800967":{"Number":"12800967","Submitter":"Alexei Odeychuk","Submitted":"2016-03-04T00:00:00","Title":"Types with default initial values specified (from Ada 2012)","Text":"I suggest introducing an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of specifying their default initial values in code easily.\r\nThis suggestion is an extension of my previous suggestion:\r\nTypes with predicates to create subtypes easily (from Ada 2012)\r\nPlease see it for more details:\r\n[/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f](/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f.md)\r\nExample # 1:\r\ntype OK = bool [with] default true // type with true as its default initial value\r\nExample # 2:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\n[with] default Cat\r\ntype Prey = Animals\r\nwith function\r\n| Mouse\r\n| Hamster -> true\r\n| _ -> false\r\n[and] default Hamster\r\nlet a : Prey array = Array.zeroCreate 3 // array of 3 hamsters\r\nRemark: \"[and]\" or \"[with]\" means that the \"and\", \"with\" keywords are optional in the above-mentioned lines of code.\r\nIt's not a breaking change in the language; no new keywords are needed to implement this syntax in the F# language. I think this syntax will help represent a programmer's intent in code and improve the expressiveness of the F# language.","Votes":3,"Comments":[{"Submitter":"Jack Fox","Submitted":"2016-03-06T11:41:00","Content":"I suggest making the \"and\" and \"with\" keywords mandatory...I think it improves readability."},{"Submitter":"Richard Gibson","Submitted":"2016-04-13T09:56:00","Content":"This would be great, especially if the F# library would come with a function similar to `genericOne` and we can use this as a static type constraint.\r\nThat way you could write a generic function that works on any type that defines a default value."}],"Status":"","Response":null},"12802701":{"Number":"12802701","Submitter":"Alexei Odeychuk","Submitted":"2016-03-04T00:00:00","Title":"Code robustness: Types with ranges of admissible values (from Ada 2012)","Text":"I suggest introducing an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of specifying the range of admissible values for subtypes derived from base types easily.\r\nThis suggestion is an extension of my previous suggestions:\r\n1) Types with predicates to create subtypes easily (from Ada 2012);\r\n2) Types with default initial values specified (from Ada 2012).\r\nPlease see them for more details:\r\n1) [/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f](/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f.md)\r\n2) [/ideas/suggestion-12800967-types-with-default-initial-values-specified-from](/ideas/suggestion-12800967-types-with-default-initial-values-specified-from.md)\r\nExample # 1. Type with range of admissible values specified.\r\ntype scores = int range 1 .. 100 // admissible values: 1, 2, 3 .. 100\r\nThe aspect should be checked (checks for admissible values should be generated in compiled code by the F# compiler and performed) whenever an object of the type is default initialized, on assignments, on type casts, on parameter passing, in the match expressions and so on.\r\nExample # 2: Type with range of admissible values and default initial value.\r\ntype rating =\r\n| A\r\n| B\r\n| C\r\n| D\r\n| E\r\n| F\r\ntype goodRating = rating range A .. C default A\r\nExample # 3: Type with range of admissible values, default initial value and subtype predicate.\r\n// admissible values of the type: 0, 2, 4, 6, 8 .. 100\r\nSyntax version # 1:\r\ntype Even = int range 0 .. 100 default 0 with function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nor\r\nSyntax version # 2 (both versions may be acceptable):\r\ntype Even = int range 0 .. 100 with default 0 and function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nThis feature would be exceptionally useful when paired with units of measure.\r\nExample # 4: Type with unit of measure, range of admissible values, and default initial value.\r\n[<Measure>]\r\ntype celsius\r\nSyntax version # 1:\r\ntype temperature = float<celsius> range -80.0<_> .. 60.0<_> default 0.0<_>\r\nor\r\nSyntax version # 2 (both versions may be acceptable):\r\ntype temperature = float<celsius> range -80.0<celsius> .. 60.0<celsius> default 0.0<celsius>\r\nThis change in the F# language syntax will not affect existing codebase. It requires introducing a new keyword: range. I think this syntax will help represent a programmer's intents in code and improve code robustness and expressiveness of the F# language.","Votes":5,"Comments":[],"Status":"","Response":null},"12804867":{"Number":"12804867","Submitter":"Huw Simpson","Submitted":"2016-03-04T00:00:00","Title":"Allow generic type constraints for union and record","Text":"I suggest that the ability to express the following type constraints be added:\r\nwhen 'T : union\r\nwhen 'T : record\r\nThis would enable apis which use quotations or reflection over the supplied record or union to be safer.\r\nThe constraint could be enforced at runtime if unions or records implemented some sort of marker interface, perhaps there is a better way.","Votes":2,"Comments":[],"Status":"","Response":null},"12805656":{"Number":"12805656","Submitter":"Anonymous","Submitted":"2016-03-04T00:00:00","Title":"Code succinctness: Relax syntax rules for the else branch of an if expression (from Ada 2012)","Text":"For the sake of code succinctness, I suggest relaxing syntax rules for the else branch of an if expression in two special cases:\r\n1) When there is no else branch in an if expression and the type of the if expression is inferred to be bool, then the F# compiler should treat the absent else branch as equal to false, type bool (like in Ada 2012 for if expressions).\r\n2) When there is no else branch in an if expression and the type of the if expression is inferred to be option, then the compiler should treat the absent else branch as equal to None, type option.\r\nNow, when there is no else branch written in an if expression, the type of the absent else branch is inferred to be unit, and the F# compiler emits an error: FS0001: This expression was expected to have type unit but here has type... .\r\nNew syntax. Example # 1:\r\n[<Measure>]\r\ntype GBP\r\nlet status = false\r\n// money = None here\r\nlet money = if status then Some(100<GBP>)\r\nExample # 2:\r\nlet cashAvailable = false\r\nlet accountCorrect = true\r\n// status = false here due to cashAvailable = false\r\nlet status = if cashAvailable && accountCorrect then true\r\nelif not accountCorrect then false\r\nThese changes in the F# language syntax will not affect existing codebase. The if constructs with no else branch are allowed in Java, C#, Ada 2012, C++, VB.NET, just to name a few. I think this syntax will help remove an unnecessary burden from F# users (who have to write \"else false\", \"else None\" in their if expressions) and improve succinctness of F# code.","Votes":0,"Comments":[{"Submitter":"Dominick Joseph","Submitted":"2016-03-04T12:39:00","Content":"I don't think is a bad idea. I do feel it makes the language less safe. The reason it defaults to unit if the if branch returns unit is because the else branch can only return unit. For everything else you need to explicitly state the else branch. This causes you to think about what the else branch needs to return. Having it just return none or false can cause you to miss something.\r\nfor example:\r\ntype person = { ShirtColor : string }\r\nlet maybePerson = Some { ShirtColor = \"blue\" }\r\nlet shirtIsBlue (x:person option) = if x.IsSome then x.Value.ShirtColor = \"blue\"\r\nThis will return false if the person is None. Is that what we want? Do we want to return bool option and return none? Do we want to wrap it in a different success/error type? But with this we will just keep processing as if the shirt is not blue. Obviously we would never write this code but imagine more complex types and expressions that don't necessarily have idiomatic ways of dealing with them.\r\nSo do we want safeness or succinctness?"},{"Submitter":"Charles","Submitted":"2016-03-06T11:41:00","Content":"I like the existing unit default for imperative code.\r\nI don't see the value of defaulting to false for Boolean conditionals. Can't \"if a then b else false\" be rewritten as \"a and b\"?"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-07T13:41:00","Content":"I tried to delete the above-mentioned suggestion shared by me, but failed due to the availability of a comment posted by Dominick Joseph. (Now a comment by Charles was appeared. I would like to thank him for another useful comment). Dominick convinced me that my suggestion is not a good fit for the F# language design due to its potential to undermine code safeness. Now the author of the suggestion is indicated as Anonymous. Dear Admin, please check in the website logs that I (Alexei Odeychuk) posted this suggestion, and delete it along with comments by Dominick Joseph and Charles or mark it as DECLINED. Thank you very much in advance for your rapid response."}],"Status":"","Response":null},"12814485":{"Number":"12814485","Submitter":"Friedrich von Never","Submitted":"2016-03-05T00:00:00","Title":"Add units of measure for standard type aliases","Text":"Currently there is a support for `float<cm>`, but not `double<cm>`; I should call it `float32<cm>`. Almost in every other position `float` and `double` are completely equivalent (and some programmers prefer `double` over `float`). Shouldn't it be the case for units of measure support?\r\nAlso, it seems that units of measure are not supported for unsigned types at all. Was it a design decision? I suggest adding these.","Votes":3,"Comments":[],"Status":"","Response":null},"12820011":{"Number":"12820011","Submitter":"Gauthier Segay","Submitted":"2016-03-05T00:00:00","Title":"Make tuple defined DU cases more consistent with tuple","Text":"It is possible to pattern match tuples in a flexible way:\r\nlet a = 1,2\r\nmatch a with\r\n| 1, _ -> ()\r\n| _ -> ()\r\nbut it's not possible to do this on tuple defined DU cases, one has to write this:\r\nmatch pat with\r\n| SynPat.LongIdent(_, _, _, _, _, _) -> ()\r\n| ...\r\nwhich breaks whenever the case definition change (even at place where we don't care of the contents)\r\nwhile supporting this would be friendlier / more resilient to DU case change:\r\nmatch pat with\r\n| SynPat.LongIdent _ -> ()\r\nor even\r\nmatch pat with\r\n| SynPat.LongIdent foo -> () // can deconstruct foo like a normal tuple","Votes":9,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2016-03-05T14:38:00","Content":"Actually found out it works with enclosing parens:\r\nmatch pat with\r\n| SynPat.LongIdent(_) -> ()\r\nbut it doesn't work with identifier (case whose utility is close to 0)\r\nmatch pat with\r\n| SynPat.LongIdent(a) -> ()"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-05T15:02:00","Content":"I support the idea shared by Gauthier Segay in respect of \"match pat with\r\n| SynPat.LongIdent foo -> ...\"! When I developed a natural language processing application in F#, I often wrote something like: match arabicLexeme with\r\n| Participle(_, _, _, _, _, _, _) -> ...\r\n| FiniteVerb(_, _, _, _, _, _, _, _, _, _) -> ... Right now, the F# 4.0 compiler emits an error FS0019: This constructor is applied to 1 argument(s) but expects 6 in response to a line of code like \"match pat with SynPat.LongIdent foo -> ...\". There is no doubt, syntax for discriminated union cases is worth to be improved in this context.\r\nP.S. As to \"match pat with SynPat.LongIdent _ ->\" I tested it and found that the compiler (F# 4.0, Visual Studio 2015, Windows 7) accepted it.\r\nMy test code for the F# Interactive was:\r\ntype SynPat =\r\n| LongIdent of int * int * int * int * int * int\r\nlet x : SynPat = LongIdent(1, 2, 3, 4, 5, 6)\r\nlet y = match x with LongIdent _ -> true\r\nThe F# Interactive response was:\r\ntype SynPat = | LongIdent of int * int * int * int * int * int\r\nval x : SynPat = LongIdent (1,2,3,4,5,6)\r\nval y : bool = true\r\nNo warnings or errors from the F# 4.0 compiler.\r\nP.P.S. When I tried to write in the F# Interactive:\r\nlet y = match x with LongIdent foo -> true\r\nI received a compiler error FS0019: This constructor is applied to 1 argument(s) but expects 6."}],"Status":"","Response":null},"12826233":{"Number":"12826233","Submitter":"Matthias Dittrich","Submitted":"2016-03-06T00:00:00","Title":"Hide Obsolete warnings on record initializer not using the obsolete field.","Text":"Basically the compiler emits a warning even when a obsolete field is not used directly in the source code. Here is a code example showing what I mean:\r\n// def version 1\r\ntype TestRecordV1 =\r\n{ Field1 : string\r\nFeild2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nFeild2 = null }\r\n// usage\r\nlet v1var1 = { TestRecordV1.Emtpy with Field1 = \"field1\" }\r\nlet v1var2 = { TestRecordV1.Emtpy with Feild2 = \"field2\" }\r\nlet v1var3 = { TestRecordV1.Field1 = \"field1\"; Feild2 = \"field2\" }\r\nlet v1access1 = v1var1.Field1\r\nlet v1access2 = v1var1.Feild2\r\n// def version 2\r\ntype TestRecordV2 =\r\n{ Field1 : string\r\n[<Obsolete(\"Use Field2 instead\")>]\r\nFeild2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nFeild2 = null } // can we somehow hide the warning here\r\n// (as it is obvious that we need to address it)\r\n// usage\r\nlet v2var1 = { TestRecordV2.Emtpy with Field1 = \"field1\" } // why?\r\nlet v2var2 = { TestRecordV2.Emtpy with Feild2 = \"field2\" }\r\nlet v2var3 = { TestRecordV2.Field1 = \"field1\"; Feild2 = \"field2\" }\r\nlet v2access1 = v2var1.Field1\r\nlet v2access2 = v2var1.Feild2\r\n// def version 3\r\ntype TestRecordV3 =\r\n{ Field1 : string\r\nField2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nField2 = null } // was broken\r\n[<Obsolete(\"Use Field2 instead\")>]\r\nmember x.Feild2 = x.Field2\r\n// usage\r\nlet v3var1 = { TestRecordV3.Emtpy with Field1 = \"field1\" } // not broken (yes, old compiled versions are still broken)\r\n//let v3var2 = { TestRecordV3.Emtpy with Feild2 = \"field2\" } // broken\r\nlet v3var2 = { TestRecordV3.Emtpy with Field2 = \"field2\" }\r\n//let v3var3 = { TestRecordV3.Field1 = \"field1\"; Feild2 = \"field2\" } // broken\r\nlet v3var3 = { TestRecordV3.Field1 = \"field1\"; Field2 = \"field2\" }\r\nlet v3access1 = v3var1.Field1\r\nlet v3access2 = v3var1.Feild2 // obsolete, OK\r\nI'm pretty sure this is because the code will still break (and use the obsolete field behind the scenes). So even if the suggestion can not be accepted in general (but I think still worth the discussion) we should consider this is in scripting contexts (where binary compatibility is not really a problem). Scripting is the place where I realized this, so currently there really is no good way to use Obsolete on records at all (besides using constructor functions, but then I think the compiler should generate them for me behind the scenes).","Votes":3,"Comments":[{"Submitter":"Matthias Dittrich","Submitted":"2016-03-06T04:31:00","Content":"As the formatting was completely broken: http://fssnip.net/7OE\r\nThe line with \"// Why?\" is triggering an obsolete compiler warning!"},{"Submitter":"Matthias Dittrich","Submitted":"2016-03-06T04:46:00","Content":"I noticed one more thing: The complete record initializer is triggering the obsolete warning instead of the line accessing the obsoleted field (updated the fssnip version)"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-06T05:47:00","Content":"I support the idea shared by Matthias Dittrich."}],"Status":"","Response":null},"12838449":{"Number":"12838449","Submitter":"Gauthier Segay","Submitted":"2016-03-07T00:00:00","Title":"allow use to not bind the expression to a name","Text":"In C#, one can use using(CreateSomeDisposable()) without binding the expression to a name.\r\nSame construct in F# is not allowed, forcing a workaround such as\r\nuse __ = CreateSomeDisposable()\r\nallow to make it like this:\r\nuse CreateSomeDisposable()","Votes":6,"Comments":[{"Submitter":"lr","Submitted":"2016-10-06T13:22:00","Content":"In my opinion the bigger annoyance is that a use expression can't even be bound to _ (single underscore), so if I want to use multiple uses, I need to write something like\r\nuse _1 = CreateSomeDisposable()\r\nuse _2 = CreateSomeDisposable()\r\nIf I could instead bind it to the wildcard character _, then I would be happy:\r\nuse _ = CreateSomeDisposable()\r\nuse _ = CreateSomeDisposable()"}],"Status":"","Response":null},"12838959":{"Number":"12838959","Submitter":"Pierre Irrmann","Submitted":"2016-03-07T00:00:00","Title":"Allow record types to implement interfaces just by adding the interface name when compatible","Text":"When a record type already has all the members necessary to impement an interface, it could implement it without having to write the code.\r\nFor instance:\r\ntype IHasAnAge =\r\nabstract member Age: int\r\ntype Person = {\r\nName : string\r\nAge: int\r\n} with interface IHasAnAge","Votes":32,"Comments":[],"Status":"","Response":null},"12839142":{"Number":"12839142","Submitter":"Pierre Irrmann","Submitted":"2016-03-07T00:00:00","Title":"Allow overloads of custom keywords in computation expressions","Text":"I've been using custom keywords in computation expressions to write DSLs, and I would have loved to be able to have several signatures for the same custom keyword, in order to make some arguments optional in the expression.\r\nWhen you try do it today, there is an error message such as \"The custom operation 'myOperation' refers to a method which is overloaded. The implementations of custom operations may not be overloaded\"\r\nI'm aware this is a not-so-used feature, but I'd like to know how hard you think it could be (I would event be willing to have a look at how to implement it).","Votes":13,"Comments":[{"Submitter":"Jared Hester","Submitted":"2016-06-28T00:26:00","Content":"This would be great. If custom operators could take other custom operators as arguments it'd be even better."}],"Status":"","Response":null},"12879717":{"Number":"12879717","Submitter":"Vasily Kirichenko","Submitted":"2016-03-10T00:00:00","Title":"Allow record inheritance / multiple \"inheritance\"","Text":"I propose to add multiple ***fields*** inheritance into records:\r\ntype Person =\r\n{ First: string\r\nLast: string }\r\ntype Foo = { Bar: int }\r\ntype Student =\r\ninherit Person\r\ninherit Foo\r\n{ GPA: float }\r\nlet student = { First = \"a\"; Last = \"b\"; Bar = 2; GPA = 1.0 }\r\nMaking the same thing with composition results with not such an elegance flat records.\r\nThis approach is used, for example, in Nitra AST DSL, see https://github.com/rsdn/Nitra-Mini-C/blob/master/Nitra-Mini-C/MiniC-ast.nitra#L94","Votes":17,"Comments":[],"Status":"","Response":null},"12880398":{"Number":"12880398","Submitter":"Zhen","Submitted":"2016-03-10T00:00:00","Title":"Add Map.count","Text":"Implement Map.count","Votes":3,"Comments":[{"Submitter":"Robert Pickering","Submitted":"2016-03-11T15:43:00","Content":"Sent pull request! https://github.com/Microsoft/visualfsharp/pull/1007"}],"Status":"","Response":null},"12880410":{"Number":"12880410","Submitter":"Zhen","Submitted":"2016-03-10T00:00:00","Title":"Make Set.count O(1)","Text":"Seems easy to track items when they are added and removed","Votes":3,"Comments":[{"Submitter":"Robert Pickering","Submitted":"2016-03-11T15:28:00","Content":"Sadly, not as straight forward as it sounds, since set also support filter and partition as well as add. filter and partition work directly on the SetTree type that represents set internally, so these operation would need to return the new count. It could be done, but the question is should it be done, as the extra over heads may out weight the perf gains from have Set.count O(1). Difficult call to make imho."},{"Submitter":"Jack Fox","Submitted":"2016-03-13T12:08:00","Content":"You are going to incur the cost somewhere. It's usually preferable to incur it when you request count."}],"Status":"","Response":null},"12882690":{"Number":"12882690","Submitter":"Alexei Odeychuk","Submitted":"2016-03-10T00:00:00","Title":"Code clarity: To change the default value returned by function Unchecked.defaultof<string> to \"\" from null","Text":"I suggest changing the default value returned by function Unchecked.defaultof<string> to \"\" from null. I think the function should return a value of type string indicating an empty string \"\" as expected by a majority of language users who writes string processing code.\r\nNull indicates that there is no value at all.\r\nI am inclined to think from my own experience that null returned by Unchecked.defaultof<string> leads to unnecessary complications in the code dealing with value names of type string, namely in the form of mandatory checks both for \"\" and null, instead of a check for \"\" only in situations when you expect to encounter an empty string.\r\nThe change suggested in the F# language will allow writing more simple and clear code for string processing.","Votes":2,"Comments":[{"Submitter":"Dax Fohl","Submitted":"2016-03-25T12:16:00","Content":"This would be a breaking change and would break the \"principle of least surprise\" for anyone coming from C#. I see the value but don't see this ever happening."},{"Submitter":"Richard Gibson","Submitted":"2016-04-13T09:29:00","Content":"Although I get where you're coming from, I don't think that changing what Unchecked.defaultof<> does is a good idea because: (a) it's a breaking change and (b) it's the equivalent of default(T) in other .NET languages.\r\nI'd love for F# to support the idea of types that have a sensible default value (such as \"\" for strings, 0 for ints, [] for lists) but I don't know how you'd do it without support for higher kinds first.\r\nNote: We *sort of* have this with static type member constraints, but unfortunately there's no common member name from .NET type to .NET type. Int defines 'Zero' (through F# extensions), String defines 'Empty', and I'm not sure if Array defines anything at all."}],"Status":"","Response":null},"12900021":{"Number":"12900021","Submitter":"Alexei Odeychuk","Submitted":"2016-03-11T00:00:00","Title":"Code clarity: Make syntax for sequence expressions as simple as syntax for lists","Text":"I suggest simplifying syntax for generating sequences. It would be great to make it as simple as syntax for lists in F#.\r\nFor example,\r\nlet lst = [ 1; 2; 3; 4 ] // allowed\r\nlet sq = seq { 1; 2; 3; 4 } // not allowed, why?\r\n// error FS0739: Invalid object, sequence or record expression.\r\nNow, the F# syntax rules allow declaring a simple sequence expression as follows:\r\nlet se = seq { yield 1; yield 2; yield 3 }\r\nI think syntax rules may well be simplified in that case. It would be more comfortable for language users to declare sequences with no need to write the yield keyword each time when they specify a new value for the sequence expression.\r\nP.S. At the same time, there is no need to make any improvements in syntax for generating sequences using ranges specified in the form like 1 .. 10.\r\nlet lst = [ 1 .. 10 ] // allowed\r\nlet sq = seq { 1 .. 10 } // allowed, and that's good!","Votes":4,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2016-03-13T10:24:00","Content":"You can write\r\nlet sq = seq [ 1; 2; 3 ]"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-14T03:09:00","Content":"Thank you, Vasily. Of course, I can, but let sq = seq { 1; 2; 3 } would be better and consistent with the existing F# syntax rules for sequence expressions, I mean the use of {}."},{"Submitter":"Jared Hester","Submitted":"2016-06-28T00:23:00","Content":"However this would not be consistent with the rules for computation expressions.\r\n\"Sequence expressions are an example of a computation expression, as are asynchronous workflows and query expressions.\" [1]\r\nIf you're using a seq expr it should be able to take advantage of complex internal logic, recursive looping, lifting nested sequences with yield!, etc.\r\nVasily is right, if all you want is a simple sequence use\r\nseq [10;55;0] or seq [| 40; 5; 0; 40 |]|\r\nPerhaps that error should be improved to say \"invalid sequence expression ...\" with some more details and a suggestion\r\n[1] https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/computation-expressions-%5Bfsharp%5D"}],"Status":"","Response":null},"12902226":{"Number":"12902226","Submitter":"Matthew Orlando","Submitted":"2016-03-11T00:00:00","Title":"Support partial record prototypes","Text":"I have a case where I have several related types (categories of parameter sets for an analytics API). I want to create a set of new types such that every category is required in exactly one of the new types, and all of the other categories are optional.\r\nThis is fairly easy to express in a variety of ways in F#, but enforcement becomes difficult. I'd prefer to use record types with a default prototype, but there are no good defaults for the required parameters. I either have to clutter up my types with bona fide classes with constructors, or use a module with a create function (as seems common in cases like this).\r\nSo I propose something like the following:\r\ntype Foo = Foo of string\r\ntype Bar = Bar of int\r\ntype Baz = Baz of Guid\r\ntype Foo' = { Foo : Foo ; Bar : Bar option ; Baz : Baz option }\r\nlet defaultFoo' = { Bar = None; Baz = None } : Foo' partial\r\nAlternatively, I'll accept any comments that help point out something I've missed in F#... I'm still only about knee deep in the waters around here.\r\nNow that I think about it a bit more, I wonder if the way I used \"partial\" in my example can be implemented with reflection... Still, I think language support would give a better developer experience.","Votes":1,"Comments":[],"Status":"","Response":null},"12913179":{"Number":"12913179","Submitter":"Adnan Gazi","Submitted":"2016-03-12T00:00:00","Title":"add a keyword for module-local construction but public deconstruction of types","Text":"Similar to dependant types, except you wouldn't enforce the predicate on which the type is dependant on to be defined WITH the type.\r\nThis keyword could stop clients of a module from constructing the type, but would allow them to 'see' that it exists, and therefore allow them to deconstruct it for their own use.\r\nFor example, if you want a string constrained to 50 chars, you could have\r\ntype String50 = constrained String50 of string\r\nlet createString50 s = if String.length s <= 50 then Some s else None\r\nwhere 'createString50' is a constructor.\r\nCorrect me if I am mistaken, but it seems to be a lot less complicated than dependant types since the dependancy is implicit, and therefore wouldn't be as difficult for the type inference","Votes":5,"Comments":[{"Submitter":"trek42","Submitted":"2016-03-17T21:01:00","Content":"I think this is a good idea. Similarly for record types, it would be very useful to restrict record type so that external (outside of the module) user code can use the fields (like A.field), but not construct the record or use the { A with field =... } syntax. Having this restriction for records can make code maintenance a lot easier, especially when adding new fields or new invariants among fields we are sure the invariants are always held.\r\nProbably it's better to use an attribute instead of a keyword. Something like [<PrivateConstructor>] would be good.\r\nA new"}],"Status":"","Response":null},"12920034":{"Number":"12920034","Submitter":"Matthew Orlando","Submitted":"2016-03-13T00:00:00","Title":"Add constraints to match FSharpType.Is* predicates","Text":"I have a type, CaseSet<'a>, that is only meant to be used with descriminated unions. The only way I've found to enforce this is at runtime using FSharpType.IsUnion. I considered using type providers, but those aren't supported in PCLs.\r\nI propose adding the following constraints based on the corresponding FSharpType reflection functions.\r\nfunction : IsFunction\r\ntuple : IsTuple\r\nunion : IsUnion\r\nrecord : IsRecord\r\nmodule : IsModule\r\nexception : IsExceptionRepresentation\r\n(I'm not really sure about that last one... I included it for completeness but maybe just testing for some subclass is sufficient?)","Votes":1,"Comments":[],"Status":"","Response":null},"12940554":{"Number":"12940554","Submitter":"Gauthier Segay","Submitted":"2016-03-15T00:00:00","Title":"allow defining function with generic type parameter within another function","Text":"I encounter cases where I'd like to define a function taking a generic type parameter within another functions.\r\ntype Foo = {Bar: int option; Baz: string option}\r\nlet doSomething () =\r\n(**)let writer = Console.Out\r\n(**)let writeOption o =\r\n(* *)match o with\r\n(* *)| Some v -> writer.Write(string v)\r\n(* *)| None -> writer.Write(\"\")\r\n(**)writeOption foo.Bar\r\n(**)writeOption foo.Baz\r\nIt's not possible to do that right now and even if I define the function outside at module level (with extra writer parameter), I can't curry it to avoid passing the context (writer) parameter I'm trying to elide to keep my code concise.","Votes":1,"Comments":[{"Submitter":"Paul Westcott","Submitted":"2016-03-21T15:28:00","Content":"If you make writeOption inline then this is currently valid synatx..."}],"Status":"","Response":null},"12951354":{"Number":"12951354","Submitter":"Steven Taylor","Submitted":"2016-03-15T00:00:00","Title":"custom set the 'last defined'","Text":"Say we implement something like:\r\ntype BinaryOp =\r\n| And\r\n| Or\r\n| Not\r\n| None\r\nmodule test =\r\nlet aMatchFunction (s:string option) = match s with\r\n| Some s -> printfn \"%s\" s\r\n| None -> printfn \"(none)\"\r\n// Error This expression was expected to\r\n// have type string option but here has\r\n// type BinaryOp\r\nSome of the F# conventions are nice, and it'd be good to be able to stay consistent with them across our code base if we choose. In this case, I feel we shouldn't be forced to adopt the longhand convention of:\r\nOption<string>.None just to get the point across to the compiler. Likewise, pushing the definition up the tree -- ie. in this case (aVarName : BinaryOp option) is not always the sensible thing to do.\r\nThis is just a simple example where it doesn't make much difference one way or the other. I suggest we have more preferences for hints and context. Pithy code probably leads to more name clashes. Sometimes these are acceptable.","Votes":1,"Comments":[],"Status":"","Response":null},"12998517":{"Number":"12998517","Submitter":"Vasily Kirichenko","Submitted":"2016-03-17T00:00:00","Title":"Inlined default argument values","Text":"Instead of\r\nmember __.Foo(?a: int) =\r\nlet a = defaultArg a 2\r\nit would be great to write it C#-slyle:\r\nmember __.Foo(?a: int = 2)","Votes":6,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-03-17T12:13:00","Content":"I agree with Vasily, but I think the \"?\" symbol is not necessary at all for the syntax suggested. In my opinion, that symbol has no value added; it worsens the readability of code only.\r\nI think it would be even better to write it in the VB.NET or Ada 2012 style:\r\nmember _.Foo(a : int = 2).\r\nSidenote: the value \"a\" has to belong to type int during all its lifetime (as declared in a member or function).\r\nFor example,\r\nmember ___.Foo(a : int = 2): int =\r\n(*…….……*) if a = 2 then 0 else a\r\nFor the sake of the F# language stability, let the two syntax models co-exist. Let the \"member __.Foo(?a: int)\" syntax remain in the existing codebase, and let's open opportunities for the new syntax \"member _.Foo(a : int = 2)\" to become widely used in new code!"}],"Status":"","Response":null},"13056630":{"Number":"13056630","Submitter":"Alexei Odeychuk","Submitted":"2016-03-21T00:00:00","Title":"Code clarity: Dot notation for casting objects to interfaces","Text":"I suggest introducing the dot notation syntax for casting an object to an interface.\r\nIt would be great to write, for example:\r\nthis.InterfaceName.methodName(param1, param2, ..., paramN)\r\nmyObject.InterfaceName.methodName(param1, ..., paramN)\r\ninstead of:\r\n(this :> InterfaceName).methodName(param1, param2, ..., paramN)\r\n(myObject :> InterfaceName).methodName(param1, ..., paramN)\r\nI think the use of one symbol \".\" instead of four symbols \"(\", \":\", \">\", \")\" to convey the same idea can improve F# code clarity.\r\nThe syntax suggested would be especially useful in the body of methods of classes that implement multiple interfaces.\r\nP.S. My suggestion does not mean a breaking change in the F# language. I think the existing syntax and the dot notation syntax for casts to interfaces can be used interchangeably.","Votes":5,"Comments":[],"Status":"","Response":null},"13133787":{"Number":"13133787","Submitter":"Anthony Lloyd","Submitted":"2016-03-25T00:00:00","Title":"Add (binary) search function to Map and Set","Text":"Often in interpolation the nearest collection items to a given value are needed. Map and Set both have a data structure that could be binary searched returning the two nearest neighbours optionally. The function should only be called something like 'nearest' so the implementation isn't exposed.\r\nAt the moment you would have to replicate the collections to be able to do this.","Votes":3,"Comments":[{"Submitter":"Jon Harrop","Submitted":"2016-03-28T18:00:00","Content":"Implementing \"nearest\" will require the concept of distance, above and beyond a mere total ordering. OCaml provides a Set.split function that splits a set into two sets at the given element, returning a boolean if that element was present.\r\nI wish there were many more functions in Map and Set. I'd like a subset function for Map where you give it a Set of keys. And a merge function for Map that adds binding from one Map to another efficiently (can be done in sub-linear time with pure collections). FWIW, my preference would be for more jack-of-all-trades-and-master-of-none purely functional collections. Their performance inevitably sucks so their value is really ease of use and clarity."},{"Submitter":"Anthony Lloyd","Submitted":"2016-03-29T03:23:00","Content":"It would only need comparison on the key which it already has. I'm thinking of a function a little like Array.BinarySearch. It should probably be called something like search unless that conflicts with some other use.\r\nA more generic iter or fold function could be a possibility if it would be useful for exposing other functionality based on the fact that the structure is a tree."}],"Status":"","Response":null},"13134246":{"Number":"13134246","Submitter":"Dax Fohl","Submitted":"2016-03-25T00:00:00","Title":"Add (^%) f = f to core library","Text":"This allows method chaining with sequences etc need no parens:\r\nhttp://stackoverflow.com/questions/36220283/anything-else-similar-to-haskells-in-f-other-than\r\nOptionally call it ^$ for Haskell users, though it's not exactly the same as Haskell's $. ^% is (imo) the nicest on the fingers.","Votes":2,"Comments":[{"Submitter":"Dax Fohl","Submitted":"2016-03-25T15:11:00","Content":"In particular note the conversation below Mark's answer."}],"Status":"","Response":null},"13218072":{"Number":"13218072","Submitter":"Vasily Kirichenko","Submitted":"2016-03-30T00:00:00","Title":"Add a \"with\" syntax for patterns","Text":"See detailed OCaml RFC https://github.com/ocamllabs/compiler-hacking/wiki/Add-a-%22with%22-syntax-for-patterns","Votes":26,"Comments":[{"Submitter":"Richard Minerich","Submitted":"2016-04-05T18:53:00","Content":"I do like this idea, it would be so nice to be able to combine more active pattern cases like this."}],"Status":"","Response":null},"13302753":{"Number":"13302753","Submitter":"Alexei Odeychuk","Submitted":"2016-04-04T00:00:00","Title":"Code clarity: Remove Object Pascal-style for ... to|downto ... do ... loops from the language (from Swift)","Text":"The for ... to|downto ... do ... loop appears to be a mechanical carry-over from Object Pascal rather than a genuinely F#-specific construct. The for ...to|downto ... do ... loops do not lend themselves to use with sequences and other core F# types supporting IEnumerable interface. It is rarely if ever used in pro-level apps. More F#-typical construction is already available in the language with the for ... in ... do ... loop that has much better readability and expressiveness.\r\nExample # 1:\r\n// it provides equivalent behavior to: for i = 1 to 100 do ...\r\nfor i in 1 .. 100 do ...\r\n// it provides equivalent behavior to: for i = 100 downto 1 do ...\r\nfor i in 100 .. -1 .. 1 do\r\nExample # 2: Clear advantage in using the for … in … do … loop compared to the for … to|downto … do … loop in expressiveness\r\n// some complicated expression to generate a sequence\r\nlet sq = seq { 1 .. 2 .. 999 }\r\n(*........*)|> Seq.filter (fun item -> item <= 199 || item >= 501)\r\n// simply try each item of the sequence supporting\r\n// IEnumerable interface\r\nfor s in sq do …\r\nRemoving the for .. to|downto ... loops would simplify the language. The value added of this construct is limited and I believe its gradual removal from F# should be seriously considered.\r\nAlternative to be considered:\r\nNot removing the for ... to|downto ... do ... loop from F#, losing the opportunity to streamline the language and discard an unneeded control flow item.\r\nApproach suggested:\r\nI suggest that the for ... to|downto ... do ... loop be deprecated in F# vNext and removed entirely in F# vNext vNext.","Votes":4,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-04T05:09:00","Content":"Removing the for .. to|downto ... loops would mean the removal of the unneeded \"to\" and \"downto\" keywords from F#."},{"Submitter":"Vasily Kirichenko","Submitted":"2016-04-10T13:03:00","Content":"Nothing can be removed from the language."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-11T04:16:00","Content":"Vasily, obsolescences and deletions are part of the history of programming languages. Some features are identified as obsolescent; some features are deleted from programming languages in the course of time.\r\nThe languages are rid of rarely used or unsafe features, borrows new features from others in order to survive, boost their competitive strengths, and be modern after all.\r\nFeatures removal occurs not only in old programming languages like Fortran (list of obsolescent and deleted features in Fortran: https://en.wikipedia.org/wiki/Fortran#Obsolescence_and_deletions), but also in new languages that are actively developed, for example, Swift (Remove C-style for-loops with conditions and incrementers. Status: Accepted for Swift 3.0: https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md).\r\nI believe it would be OK to deprecate and then remove the rarely-if-ever-used for ... to|downto ... do ... loop from the language.\r\nI think the list of obsolescent and deleted features has to be an integral, normal part of the F# programming language specification."}],"Status":"","Response":null},"13306077":{"Number":"13306077","Submitter":"Alexei Odeychuk","Submitted":"2016-04-04T00:00:00","Title":"Add the do .. while loops to the language (from Java, C, C++, C#)","Text":"I suggest adding the do .. while loops to F#. This feature would improve the expressiveness of the language and facilitate the migration of large codebases to F# from imperative languages such as Java, C, C++, C#.\r\nI suggest using time-tested and popular syntax from Java, C, C++, C# (TIOBE TOP 4 languages as of March 2016), but with F#-style indentation instead of {}:\r\ndo\r\n(* indentation to indicate the body of the loop *) body-expression\r\nwhile test-condition\r\nThe difference between the do .. while loop and the already existing in F# while .. do loop is that do .. while evaluates its test expression at the bottom of the loop instead of the top. Therefore, the body of the loop is always evaluated at least once before the condition is tested. If the test condition is true, the flow of control jumps back up to do, and the body of the loop evaluates again. This process repeats until the given test condition becomes false. Indentation indicates which expressions are in the loop, so code is clear and easy-to-understand.\r\nIt's good that F# is not pure functional language. I like that F# is a functional-imperative programming language suitable for writing real-world applications. So, it would be nice if F# would be fully developed language in terms of imperative programming features. It certainly would boost the F# popularity and facilitate the migration of existing code from C, C++, C#, Java.","Votes":4,"Comments":[{"Submitter":"Bent Tranberg","Submitted":"2016-04-10T01:33:00","Content":"I do not like that existing keywords - do, while - are used for this loop construct, especially since \"while\" is already used for another loop construct. In Pascal syntax this loop construct is called repeat-until. It tells you immediately on top of the loop what this is (\"do\" doesn't since it's used already), and to expect an \"until\" at the bottom."},{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T19:20:00","Content":"I'm concerned that \"do blocks\" will be difficult to discern from \"do while\" blocks.\r\nI'd appreciate this feature be brought to F# but it needs to not clash with do blocks IMHO."},{"Submitter":"Graham Sharp","Submitted":"2016-05-03T12:55:00","Content":"This can be accomplished with\r\nwhile (\r\nbody-expression\r\ntest-condition\r\n) do ()"}],"Status":"","Response":null},"13307676":{"Number":"13307676","Submitter":"Alexei Odeychuk","Submitted":"2016-04-04T00:00:00","Title":"Add the (..<), (>..) half-open range operators and (>..<) open range operator (from Swift)","Text":"I suggest adding the (..<) and (>..) half-open range operators and (>..<) open range operator to the language in order to reduce risks of introducing off-by-one errors in code.\r\nThere is the (..) closed range operator in F# to generate ranges of consecutive values, but now the language lacks the (..<) and (>..) half-open range operators to generate ranges of consecutive values without the first or last value specified respectively. Furthermore, there is no open range operator (>..<) to generate a range of consecutive values without both the first and last value.\r\nSyntax suggested:\r\na) from Swift:\r\n1 ..< 10 // means: 1 .. 9 in the already existing F# syntax\r\nb) my suggestions:\r\n0 >.. 5 // means: 1 .. 5, the first value (0) is excluded from the range\r\n// means: 0 .. 3 .. 99; the operators (>..), (..), (..<) can be combined\r\n0 .. 3 ..< 100\r\n// means: 1 .. 9 in the existing F# syntax,\r\n// 0 and 10 are excluded from the range\r\n0 >..< 10\r\nlet lst = [ ... some list comprehension ... ]\r\nfor i in 0 ..< lst.Length do ... // instead of: for i in 0 .. lst.Length - 1 do\r\nAs Edsger W. Dijkstra said, programming is a human activity. The off-by-one errors are often introduced by human programmers because it's easier for them to read and write code like: 0 ..< lst.Length (range from 0 to lst.Length, the last value excluded) instead of: 0 .. lst.Length - 1 (range from 0 to the last value, and the last value is: subtract 1 from lst.Length). We see in life that human programmers often forget to write \"- 1\" in code.\r\nThe syntax suggested helps eliminate off-by-one errors in code.\r\nIt would improve F# code robustness and clarity.","Votes":1,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T20:28:00","Content":"Interesting, what about a notation that would bring closer to mathematical notation?\r\n[0..lst.Length[\r\nor\r\n[0..lst.Length)"}],"Status":"","Response":null},"13308666":{"Number":"13308666","Submitter":"Musa","Submitted":"2016-04-04T00:00:00","Title":"Can we build a pre-processor so we don't have to use the word: let ? Makes the function name standout and saves typing similar to R ?","Text":"Makes the function name standout and saves typing similar to R, ofcourse if it can be done without breaking something else ?\r\nf := 3 //or ... rather than\r\nlet f = 3","Votes":4,"Comments":[{"Submitter":"trek42","Submitted":"2016-04-09T15:26:00","Content":"Admittedly, after using f# for years now I feel 'let' is too noisy/repetitive and wish it's gone. The benefits I can see are:\r\n* Make the language feel lighter-weight and the code more \"direct to the point\", without sacrificing readability. (subjectively, I would say it improves readability, especially so in subareas like math/science/finance).\r\n* It's a huge win when using FSI, where virtually every line starts with a \"let\" which doesn't do much.\r\n* Save 4 characters in each line, the saving is big if your coding style requires a maximum (either it's 80 or 100) line width.\r\nSaying the above, personally I don't think it's possible to do this in F#. There probably isn't a backward-compatibility way to achieve this, and all other approaches (e.g., source code transformation) is effectively forking the language, which isn't a good thing to F# in the large.\r\nThe only way one could imagine is to start a new language with a lighter syntax (yes, even lighter than F#) and incorporate the lessons learned from F#. But a new general-purpose language is a huge endeavor, and it would better bring new ideas rather than just different syntax.\r\n(saying that, in an imaginary world my favorite general-purpose language would change the following syntax aspects in F#:\r\n* no let keyword. Use \"=\" for let-binding and \"==\" for equality. (I think it needs to differentiate name-binding from equality when there is no \"let\"). Also without \"let\" it will be problematic when defining a function and put its parameters in multiple lines, for example:\r\nfunction_name param1\r\n........................param2 = (* fund-body *)\r\nwould not work because the first line can also be interpreted as function application. So some special treatment is needed here, e.g., still use some keyword (e.g., \"def\") to mark the beginning of a function definition, or always use lambda syntax \"f = \\(param1, param2) -> ..\" for function definition.\r\n* also replace \"fun\" keyword to something shorter. Probably \"\\\".\r\n* reverse a few default settings. For example, \"CompilationRepresentation(ModuleSuffix)\" should be the default, so that there isn't a need to mention it unless you really need to NOT have it.\r\n* Have a general solution to convert between module functions and instance methods. Ideally every instance method \"a.Func\" could also be called like a free, curried function using \"A.Func\" (A is the typename), and every module function \"M.func x y z\" could be called as an instance function through \"x.func\" (or maybe z.func?), whenever it makes sense. The first is challenging in .NET/F# because .NET methods have method overloading, among other things. The second is challenging itself because it allows calling a module function without opening the module M, and it's like C++'s argument-dependent lookup, which is a big can of worm with tons of ambiguity issues.\r\n* Make Record syntax terser. e.g., the 'with\" keyword is kind of annoying in { a with x = ..}.\r\n* Unify tuple and records. (get rid of the concept of \"tuple\", which is just record with special field names like _0, _1. Make record types by-default structural instead of nominal)\r\nArguably the last one isn't just a syntax feature. So I'll stop here :-) )."},{"Submitter":"Boris","Submitted":"2016-04-10T13:43:00","Content":"I think it will sacrifice readability very much.\r\nIt's just an ancient C(+ - # ) programmer's mental force overestimation.\r\nSuch a quirks make you constantly analyze complex textual patterns to understand what does\r\none code line exactly mean.\r\nIMHO programming languages are much more about reading(and thinking) then about writing."},{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T20:43:00","Content":"F# is functional first but has to support quite a bit of imperative style constructs which makes it very practical.\r\nWithout let, it would be difficult to understand the scope of definitions, difficult to catch if I mistyped a symbol name.\r\nI think the list of ambiguity this would create is huge and I'm not in favor of this proposition."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-11T02:14:00","Content":"I agree with Boris and Gauthier Segay.\r\nIt would be really difficult to understand the scope of definitions without let.\r\nAs Edsger W. Dijkstra said, programming is a human activity. It's really much more about reading and thinking then about writing code. Code maintenance takes 50% (pro-level mid-size apps) to 90% (large, long-lived apps containing several million lines of code intended to be in use for 5 to 20 years) of time professional programmers spent on software projects.\r\nFrom code readability and maintenance perspective, I see no value added for dropping the let keyword. I think F# has an excellent syntax in this respect. The let keyword helps writing readable code."}],"Status":"","Response":null},"13335678":{"Number":"13335678","Submitter":"Lenne","Submitted":"2016-04-06T00:00:00","Title":"Compiler directive for environment variables","Text":"It would be nice to have a compiler directive for environment variables which can be used in string literals.\r\nThis way we can pass different parameters to type providers on a build server.\r\n[<Literal>]\r\nlet ConnectionString = #env \"MY_DB_CONNECTIONSTRING\"\r\nlet cmd = new SqlCommandProvider<\"...\", ConnectionString>()","Votes":4,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-08T01:33:00","Content":"Lenne, what's wrong with already-existing .NET built-in Environment.GetEnvironmentVariable method (from namespace System)?\r\nYou can use a .NET built-in method instead of the #env syntax suggested. The name of the built-in method would make your code more readable.\r\nCode example:\r\nopen System\r\n[<Literal>]\r\nlet ConnectionString = Environment.GetEnvironmentVariable(\"MY_DB_CONNECTIONSTRING\")\r\nlet cmd = new SqlCommandProvider<\"...\", ConnectionString>()\r\nPlease see for more details:\r\nEnvironment.GetEnvironmentVariable Method (String)\r\nhttps://msdn.microsoft.com/en-us/library/77zkk0b6(v=vs.110).aspx\r\nHope it helps."},{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T20:35:00","Content":"Alexey, your example would cause \"This is not a valid constant expression.\" error.\r\nLenne, do you mean the value to be substituted at compile time? (I guess yes as it is a compiler directive).\r\nI'm not sure I see value in this, is there prior art (any other compiler does that?)\r\nI generally move those type of strings in a separate module, and can consider generating this module file as a preliminary build step.\r\nAlso, I think this can be addressed by a type provider altogether, maybe you should consider this instead?"}],"Status":"","Response":null},"13345104":{"Number":"13345104","Submitter":"Anonymous","Submitted":"2016-04-07T00:00:00","Title":"Add triple-questionmark not yet implemented operator (???) from Scala","Text":"In Scala, there is an operator `???`, which is used as a \"Convenient as a placeholder for a missing right-hand-side of a method.\"\r\nThis is defined as follows:\r\ndef ??? : Nothing = throw new NotImplementedError\r\nIn F# I would imagine that we'd define it something like:\r\n[<GeneralizableValue>]\r\nlet ???<'a> = raise (NotImplementedException())\r\nUnfortunately, ??? is not a valid name, which is why a library solution won't solve this problem.\r\nThe major merit of including this in F#, is that it provides a standardized way to declare incomplete parts of the code, allowing users and tooling to detect this.\r\nYou can read the original reasoning by Martin Odersky here at http://www.scala-lang.org/old/node/11113.html\r\nFinally, an article offering more explanation as to it's value and usage can be found here:\r\nhttp://alvinalexander.com/scala/what-does-three-question-marks-in-scala-mean","Votes":11,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-08T08:52:00","Content":"Varon, did you consider any other options, for example:\r\n1) Simple comment: // ??? to be done\r\nYou can find an uncompleted code fragment in your source code file using Ctrl+F in the Visual Studio and writing: “??? to be done”.\r\n2) Toggle a breakpoint in the Visual Studio when necessary to mark an uncompleted fragment of your code. So, you can run and test your code before a breakpoint.\r\n3) let valueToBeDeveloped<'a>(param1, param2) = Unchecked.defaultof<'a>\r\n// if your function has to return a value of unit type\r\nor: let valueToBeDeveloped<'a>(param1, param2) = ()\r\ninstead of: let valueToBeDeveloped<'a>(param1, param2) = ???\r\nThe already-existing in F# function Unchecked.defaultof<'a> returns the default value of any type and has a much more readable English name than \"???\". Paired with a comment describing your intent \"to write the body of expression here\", such a fragment of your code would be easy-to-understand.\r\nAs to maintenance of code containing \"???\". Code maintenance takes 50% (pro-level mid-size apps) to 90% (large, long-lived apps containing several million lines of code intended to be in use for 5 to 20 years) of time professional programmers spent on software projects. So, how much would \"???\" say about intents of authors of code to a programmer newly assigned to maintain such a project?\r\nOf course, most of the programming languages borrow new language features from others in order to survive and boost their competitive strengths. But from code readability and maintenance perspective, I see no competitive advantages for F# to borrow this syntax from Scala. I think F# has a better syntax (mentioned in point 3) in this respect as of today."},{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T19:51:00","Content":"I believe a library solution is good enough:\r\nlet undefined () = raise (System.NotImplementedException())"},{"Submitter":"Dzmitry Lahoda","Submitted":"2016-04-12T06:50:00","Content":"Would be good if F# to support\r\n```\r\nlet undefined () = raise NotImplemented\r\n```\r\nI.e. omit `Exception` after raise like with `Attribute`s and new without `()`"}],"Status":"","Response":null},"13361034":{"Number":"13361034","Submitter":"Francois Brodeur","Submitted":"2016-04-08T00:00:00","Title":"Implement implicit casts for yield","Text":"As described here: https://github.com/fsharp/fsharp/issues/545#event-620769998","Votes":4,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2016-04-10T20:38:00","Content":"It seems there are other areas where this could also take place?\r\nIt is a bit annoying to have to explicitly cast but at least it is consistent wherever expected type is not an exact match.\r\nIntroducing this for yield only would create a special case."}],"Status":"","Response":null},"13369500":{"Number":"13369500","Submitter":"lr","Submitted":"2016-04-09T00:00:00","Title":"Handle null values in Records gracefully instead of crashing with a NRE","Text":"Please see https://github.com/Microsoft/visualfsharp/issues/1044\r\nCurrently, if a nonnull field in a record (e.g. another record, or FSharpList<'T>, ...) is null, .GetHashCode (and potentially other methods) throw a NullReferenceException.\r\nWhile these objects are obviously invalid and AFAIK can't be easily created in pure F#, this case sometimes happens out of the control of the user.\r\nExamples are DataBinding in WPF and Serialization.\r\nIf the external code ever calls .GetHashCode on an object under construction, it will blow up.\r\nThe suggestion is NOT to change anything semantically but to handle null values gracefully where possible to ease the interop with these external libraries. This is especially important for .GetHashCode, since it is expected that it is always safe to call this method.\r\nIn the case of .GetHashCode, this could be handled backwards-compatible by returning a fixed hash for a null value.","Votes":0,"Comments":[],"Status":"","Response":null},"13380336":{"Number":"13380336","Submitter":"Alexei Odeychuk","Submitted":"2016-04-11T00:00:00","Title":"Code expressiveness: Add loops with test condition in the middle","Text":"Sometimes programmers need to first make a calculation and exit the loop when a certain condition is met. However when the condition is not met there is something else to be done. Hence we need a loop where the test condition is in the middle. That loop was first suggested in 1972 by Ole-Johan Dahl, a Norwegian computer scientist who is deemed to be one of the fathers of object-oriented programming.\r\nI suggest using the syntax for that loop that requires no new keywords:\r\ndo\r\n(* indentation to indicate the first part of the loop body *) body-expression\r\nwhile test-condition (* this line of code has to contain the test condition only for code readability *)\r\n(* indentation to indicate the second part of the loop body *) body-expression\r\ndone\r\nRemark: I think the syntax: “do … while test-condition do … done” containing the do twice would be verbose. We can visually separate the two parts of the loop body by enforcing that the line of code beginning with the while keyword contains the test condition only.\r\nThe do .. while .. done loop evaluates its test expression in the middle of the loop instead of the top or bottom. Therefore, the first part of the loop body is always evaluated at least once before the condition is tested. If the test condition is true, the second part of the loop body evaluates and the flow of control jumps back up to do. This process repeats until the given test condition becomes false. Indentation indicates which expressions are in the first or second part of the loop body; the line of code beginning with the while keyword contains the test condition only, so code is clear and easy-to-understand.\r\nI like that F# is a functional-imperative programming language suitable for writing real-world applications. It would be nice if F# would be a language fully developed in terms of imperative programming features, a language containing loops with the test condition at the beginning, in the middle, and at the end. It would improve the F# popularity and facilitate the migration of imperative code from other mainstream languages.\r\nP.S. This suggestion is an extension of my previous suggestion about introducing loops with the test condition at the end: [/ideas/suggestion-13306077-add-the-do-while-loops-to-the-language-from-ja](/ideas/suggestion-13306077-add-the-do-while-loops-to-the-language-from-ja.md)","Votes":2,"Comments":[],"Status":"","Response":null},"13393365":{"Number":"13393365","Submitter":"Dave Thomas","Submitted":"2016-04-12T00:00:00","Title":"Allow printfn to support repeated arguments","Text":"Rather than:\r\nprintfn \"%i %x %A\" mySecretNumber mySecretNumber mySecretNumber\r\nPerhaps an index argument could be added\r\nprintfn \"%[1]i %[1]x %[1]A\" mySecretNumber","Votes":1,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2016-04-17T20:08:00","Content":"Dave, do you think that would still be useful with making your variable name short in the scope where you want to print it:\r\ndo\r\n(**)let n = mySecretNumber\r\n(**)printfn \"%i %x %A\" n n n\r\nI think it is interesting idea (but with a 0 based index and robust compiler checks) but maybe not as useful as string interpolation?"},{"Submitter":"Dave Thomas","Submitted":"2016-04-19T02:34:00","Content":"I currently use a short variable if I can to reduce the annoyance, but forcing myself to use bad variable names is not good practice either. It seems there should be a way to reuse a binding rather than repeating yourself."},{"Submitter":"Gauthier Segay","Submitted":"2016-04-19T06:43:00","Content":"Dave, can you show how mixed of positional and indexed arguments would play together?\r\nShould we reuse string.format notation with braces?"},{"Submitter":"Yemi Bedu","Submitted":"2016-05-27T11:24:00","Content":"Hello,\r\nSo if you have the following (0 indexed):\r\nprintfn \"%A %A[0] %A\" a b c\r\nprintfn \"%A %A[1] %A\" a b c\r\nprintfn \"%A %A %A\" a b c\r\nprintfn \"%A %A %A[1]\" a b c\r\nThe first and fourth would seem to be a compiler error and the second and third should be okay. It seems like subtle errors can easily creep in that may not be obvious with a quick eye scan. How can this be made more clear or is it better to cancel this in favor the following:\r\n[/ideas/suggestion-6002107-add-string-interpolation-to-println-syntax-from-s](/ideas/suggestion-6002107-add-string-interpolation-to-println-syntax-from-s.md)"}],"Status":"","Response":null},"13394442":{"Number":"13394442","Submitter":"Don Syme","Submitted":"2016-04-12T00:00:00","Title":"Optionally specify file order by a fileorder.fsx (or fileorder.txt or fileorder.json) file","Text":"With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to allow the F# compiler to optionally take a special file, tentatively called fileorder.fsx, which specifies the file order E.g.\r\nfileorder.fsx:\r\n#load \"Directory/a.fs\"\r\n#load \"b.fs\"\r\n(We could instead use a fileorder.txt or fileorder.json – discuss).\r\nThis would be given to the F# compiler as a command-line input and otherwise everything would work as it does today.\r\nRules\r\n- File references can be given in any order on the command-line.\r\n- If present, the file order is taken from fileorder.fsx\r\n- Using fileorder.fsx is optional\r\n- fileorder.fsx would be hand-authored by the user\r\n- An error would be given if fileorder.fsx doesn’t list all the files in the compilation.\r\nQuestions:\r\n- Would we use a fileorder.fsx or fileorder.txt\r\n- We need a way to refer to things like “obj/Debug/pars.fs” that are the intermediate outputs of other actions. I suggest wildcards\r\n#load \"obj/*/pars.fs\"\r\nHere the meaning of wildcards is “all the inputs that match” not “all the files on disk that match”.\r\nDisadvantages:\r\n- It’s at least as tasteless than “#load/#require”\r\n- It requires manual editing\r\nAdvantages:\r\n- Single place of reference for file order.\r\n- Requires no changes to F# language, “it just works” with any editor\r\n- We could augment the F# compiler to automatically write out a fileorder.fsx if one doesn’t exist, which would allow the user to gradually switch to this model.\r\nRelated alternative: Allow all declarations to be mutually referential and the compiler takes files in any order [/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an](/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an.md)\r\nRelated alternative: Keep a file order, but infer it from #load/#require declarations. This is covered by [/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files](/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files.md)","Votes":20,"Comments":[{"Submitter":"Kevin Ransom","Submitted":"2016-04-12T12:43:00","Content":"I’m afraid this proposal does not resonate with me. It has a number of deficiencies in my opinion:\r\n1. It repeats information stored elsewhere in every other build system:\r\n• Fake specifies a source file ordering\r\n• Msbuild projects specify source file ordering\r\n• Project.json specifies a source file ordering\r\n2. For a loose collection of F# files in a directory this ordering needs to be specified anyway and so the scenario we are trying to address is not really addressed, I think project.json is as good a way to specify it as an F# file as any\r\n3. I agree with Jared that specifying a source files requirements is a more natural, and source code reuse friendly mechanism for specifying dependencies.\r\n4. A project file can contain a file with the same name in two different directories and so the dependency will need to be path qualified again making the file less friendly in reuse scenarios\r\n5. We already have a model for script files based on #load … this is not aligned with that approach.\r\n• I actually prefer #requires “foo.fs”, and a topological sort, it certainly degenerates in to a form that satisfies this proposal, although there is a preprocessing step that requires opening and reading all of the files which will slow down builds a tad. We can also allow #requires to be a synonym for #load allowing script files to build correctly.\r\n6. I also think that we can probably write a tool that integrates with the dotnet new that reads the source code for loose files and looks at type dependencies and open statements and performs a topological sort that will work. Because it is just a tool, it wouldn’t pollute the compiler and would only run on dotnet new, or when other tooling invoked it.\r\nAnd so …\r\nI think we need to either :\r\n1. Do nothing … require developers to specify file ordering in project.json\r\na. Perhaps write a tool\r\n2. Or add #requires “foo.fs” and do a topologival sort to specify dependencies.\r\nKevin"},{"Submitter":"Gauthier Segay","Submitted":"2016-04-17T20:02:00","Content":"Don, have you considered that fsc now takes a response file?\r\nI think the tooling issue is becoming manageable, for the widespread msbuild project files there is fsprojects/forge tool, and I think support for project.json will be added when it matures.\r\nAs for json file in your suggestion, I really don't think json is a human readable format, it is great when you have javascript on one side but that is about it, writing a json file by hand is tedious compared to a more human friendly format (see the file formats used by paket).\r\nA precompiler directive solution (#require) seems also like a good way to have that made explicit in the source, I think this approach could be studied (with an extra tool as Kevin mentions), but would require some tooling or compiler support (we want error message if a file doesn't exist)."},{"Submitter":"Jared Hester","Submitted":"2016-06-27T23:28:00","Content":"JSON presents several issues for use as a configuration file\r\n- doesn't support comments\r\n- no bare keys\r\n- fussy commas\r\n- the abundance of braces make nesting hard to read at a glance and files tedious to edit\r\n- no multi-line strings\r\n- no literal strings (fully escaped)\r\n- only floats, no integers\r\n- no dateTime standard\r\nA much better choice would be TOML[1] (Rust's choice for Cargo[2]) which addresses all of the issues listed above and every vaild TOML file maps directly to a HashTable.\r\nCSON[3] addresses most of JSON's issues, but it doesn't do it as well as TOML does.\r\nYAML[4] is another option, although it's more sane to read and write than JSON, it's unnecessarily complex and much more than is necessary for a project config. A subset of yaml could be used, but that adds another set of issues, so whether it'd be better than JSON in any form is up for debate.\r\nSo really just use TOML or CSON and please not JSON\r\n[1] https://github.com/toml-lang/toml\r\n[2] http://doc.crates.io/manifest.html#the-project-layout\r\n[3] https://github.com/bevry/cson#what-is-cson\r\n[4] https://en.wikipedia.org/wiki/YAML#Sample_document"},{"Submitter":"Nestor Demeure","Submitted":"2016-07-04T11:51:00","Content":"This post might interest you :\r\nhttp://kcieslak.io/Creating-custom-project-file-for-F\r\nAs far as I know, that tool is currently being design :)"}],"Status":"","Response":null},"13400112":{"Number":"13400112","Submitter":"Gauthier Segay","Submitted":"2016-04-12T00:00:00","Title":"Enable to use open in other scopes","Text":"It would be nice to be able to use open in function scope and maybe other places where it currently is illegal.","Votes":26,"Comments":[{"Submitter":"Richard Minerich","Submitted":"2016-04-12T15:07:00","Content":"I would love to be able to open modules in let scopes, this would be especially useful given the way that things like unchecked arithmetic is done in F#."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-13T01:17:00","Content":"I eagerly support Gauthier and Richard"},{"Submitter":"Loic Denuziere","Submitted":"2016-04-13T03:20:00","Content":"Agreed, this would be great. Just for context, here are the two syntaxes to do this in OCaml:\r\nlet open Module in xyz\r\nModule.(xyz)"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-13T09:07:00","Content":"Loic, I think F# needs and deserves more simple and succinct syntax than that of OCaml; something like this:\r\nlet someWrapperFunction x =\r\n(* .. indentation .. *) open ModuleName\r\n(* .. indentation .. *) y(x) // instead of: ModuleName.y(x)\r\nlet x =\r\n(* .... *) open ModuleName1\r\n(* .... *) open ModuleName2\r\n// instead of: ModuleName1.someConstant1 + ModuleName2.someConstant2\r\n(* .... *) someConstant1 + someConstant2"},{"Submitter":"Gauthier Segay","Submitted":"2016-04-13T09:13:00","Content":"agree with Alexei to have fsharp-y syntax (although I'm not familiar with OCaml, I'm sure there are advantages in the way they open modules), I should have put more details in the suggestion but can't edit it.\r\nI'm also considering if having \"partial\" open (to bring only select symbols in scope) is something which would be valuable."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-13T16:17:00","Content":"As to the partial open syntax.\r\nGauthier, I think it would be nice to use the open keyword not only to open entire modules, namespaces in the let scope, but also to introduce a member of another module or namespace (I mean a type or class and its fields, case identifiers, methods, properties) into the current let block in order to prevent ambiguity in code (if the same identifier is in two different modules and we have an open clause for both), obscurity (you can't find the declaration of an identifier) and possibly a maintenance headache (another module is added which duplicates some identifiers).\r\nThe partial open clause should have the effect that members, properties, fields, case identifiers of the type (class) specified are directly visible from the module, namespace specified within the current let block (of course, if access modifiers of such members, properties, fields etc. allow them to be visible in client code).\r\nFor example,\r\nmodule Zoo =\r\n(* .. *) type Animal =\r\n(* ….... *) | Cat\r\n(* ….... *) | Dog\r\n(* ….... *) | Mouse\r\n(* ….... *) | Hamster\r\n(* ….... *) member this.Age = match this with Dog | Cat -> 2 | _ -> 1\r\n(* ….... *) static member StaticAge (animal : Animal) = animal.Age\r\n// another file and module: client code.\r\nlet myAnimalWithAge =\r\n(* ... *) open Zoo.Animal // introduce the type specified from module Zoo into the let block\r\n(* … *) let animal = Cat // instead of: let animal = Zoo.Animal.Cat\r\n(* … *) let animal = Animal.Dog // intentional shadowing; Animal.Dog and Dog are equally legal\r\n(* … *) let age = StaticAge animal // instead of: Zoo.Animal.StaticAge animal, or: Animal.StaticAge animal\r\n(* … *) (animal, age) // return a tuple\r\nMoreover, I believe that the partial open clause can be widely used not only in the let blocks (definitions of values, functions), but also in the bodies of members, properties of classes and types, in namespaces and modules.\r\nThe syntax suggested would be an equivalent to the using syntax in C++, and the use type, use all type syntax in Ada 2012.\r\nI think the above-mentioned syntax would improve the convenience of writing F# code and boost the F# completive strengths."},{"Submitter":"Alexei Odeychuk","Submitted":"2016-04-20T04:24:00","Content":"I think it would be great to use the open keyword:\r\na) in implicit constructors and explicit constructors, in bodies of methods or properties of classes,\r\nb) in branches of the if expressions (if, elif, else branches),\r\nc) in branches of the match expressions,\r\nd) in the do blocks,\r\ne) in loop bodies\r\nAS WELL in order:\r\na) to open entire modules, namespaces (please see an example of the syntax suggested in my message on April 13, 2016 5:07 PM), or\r\nb) to introduce a member of another module or namespace, namely a type or class and its fields, case identifiers, methods, properties whose access modifiers allow them to be visible in client code (please see an example of the syntax suggested in my message on April 14, 2016 12:17 AM).\r\nc) to refer to a single object or class, type, structure from the same module or namespace so that the expressions can use a simplified syntax when accessing members of the object or structure, class, type (like a With...End With statement in VB.NET), for example:\r\nlet customer = new Customer()\r\nopen customer\r\n// beginning in VB.NET with: .Name\r\n// I think the leading \".\" is unneeded in F#\r\nName <- \"Coho Vineyard\"\r\nCity <- \"Redmond\"\r\nopen customer.Comments\r\nAdd(\"First comment.\") // .Add(\"First comment.\") in VB.NET\r\nAdd(\"Second comment.\")"},{"Submitter":"Paul","Submitted":"2016-09-15T07:53:00","Content":"There is some historic work in this area with a POC implementation here [/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard](/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard.md)\r\nImplementation allowed\r\nlet x = \r\n(* .... *) open ModuleName1 \r\n(* .... *) open ModuleName2 "}],"Status":"","Response":null},"13476465":{"Number":"13476465","Submitter":"Dave Thomas","Submitted":"2016-04-19T00:00:00","Title":"Update records to allow embeddable records","Text":"Update the sytax of records to allow the following:\r\ntype Position = {X : int; Y : int}\r\ntype Sprite = {\r\nPosition\r\nName : string\r\nImage : array byte }\r\nWhich would result in the Position records fields being embedded into Sprite.\r\nThe Go language has such a feature which works quite nicely:\r\nhttps://golang.org/ref/spec#Struct_types","Votes":22,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2016-04-19T02:56:00","Content":"What the construction syntax would look like? In Go it's like this:\r\ntype Base struct {\r\nX int\r\nY int\r\n}\r\ntype Foo struct {\r\nBase\r\nZ int\r\n}\r\nfunc main() {\r\nfoo := Foo { Base { 1, 2 }, 3 }\r\nfmt.Println(foo.X + foo.Y + foo.Z)\r\n}"},{"Submitter":"Don Syme","Submitted":"2016-06-13T05:30:00","Content":"This looks the same as this suggestion: [/ideas/suggestion-12879717-allow-record-inheritance-multiple-inheritance](/ideas/suggestion-12879717-allow-record-inheritance-multiple-inheritance.md)"},{"Submitter":"Don Syme","Submitted":"2016-06-13T05:33:00","Content":"Oh I see, you mean a sort of mixin of Position into Sprite, e.g. \"include Position\"\r\nThere are zillions of issues associated with this - e.g. what about subtyping? what about members on \"Position\"? Would Position have to be a struct?\r\nI'd like to see more examples of the utility of this."}],"Status":"","Response":null},"13554813":{"Number":"13554813","Submitter":"Calogyne","Submitted":"2016-04-23T00:00:00","Title":"Add more split functions to List, Seq, and other collection modules","Text":"Haskell has this Data.List.Split (https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html) library which supports multiple strategies for list splitting. I think those functions can come in handy in some scenarios, plus they cannot be easily made by chaining other existing functions, therefore should be included in the core library?","Votes":3,"Comments":[],"Status":"","Response":null},"13584294":{"Number":"13584294","Submitter":"Reed Adams","Submitted":"2016-04-25T00:00:00","Title":"Allow [<DefaultValue>] on member val auto-properties","Text":"This is specifically motivated by my issues with using Entity Framework and how it initializes DbSet<'T> elements. There might be other applications.\r\nIn order to correctly interact with EF in C# I may use:\r\npublic DbSet<RecType> Records { get; set }\r\nTo accomplish the same thing in F# I must;\r\n[<DefaultValue>]\r\nlet mutable private _Records: DbSet<RecType>\r\nmember x.Records with get() = x._Records and set value = x._Records <- value\r\nNot doing so causes the EF wire-ups to be lost when the regular member init-assign is called.\r\nI believe that it would be beneficial to allow the following:\r\n[<DefaultValue>]\r\nmember val Records: DbSet<RecType> with get, set\r\nThis would remove a good deal of boilerplate code and more expressively describe what's going on.\r\nThank you for your consideration.","Votes":6,"Comments":[{"Submitter":"Daniel Robinson","Submitted":"2016-05-02T09:10:00","Content":"Reed, an equivalent translation of your C# to F# would be:\r\nmember val Records = Unchecked.defaultof<_> with get, set"},{"Submitter":"Reed Adams","Submitted":"2016-05-03T09:33:00","Content":"Unfortunately, this doesn't solve the problem. That changes the type away from the required EF DbSet<> to an IQueryable<QuerySource<,>> as well as not solving the underlying issue of late-assigning the initializer value, which is overwriting property hook wire-ups used by EF.\r\nThe code you posted isn't really equivalent since C# doesn't require property initializers. When the GC allocates memory for the (C#) class it's zero-set for the size of the class and then no further action is taken. F# does this, but then additionally sets the init-value during construction. This is an extra value-set step that C# lacks, and in this case kills the work EF has already done. This is why [<Defaultvalue>] on an F# field prevents the need for an explicit initializer value and prevents the described problem, at the cost of much additional code to facilitate the solution.\r\nI was hopeful for it to work, but it just wasn't so."},{"Submitter":"Don Syme","Submitted":"2016-06-13T05:45:00","Content":"I'm not certain, but does this work?\r\ntype C() =\r\n[<DefaultValue>]\r\nval mutable Records: DbSet<RecType>\r\n??"},{"Submitter":"Reed Adams","Submitted":"2016-06-17T17:05:00","Content":"Hello, Don. Thank you for reviewing my request.\r\nThe suggestion you've given is already among my personal attempts at limiting the verbosity, but this approach too does not solve the issue.\r\nThe problem in your suggested case is that the target is no longer a property (EF uses DbSet<> properties as injection markers) but has been demoted to a regular field, which can be DefaultValue'd, but isn't a property, and so EF ignores this element.\r\nTo date, the only way that I have managed to avoid this problem is with an explicit backing store (your suggestion is suitable for that purpose) that is DefaultValue'd accompanied by the manual property machinery for get and set. It seems that in all cases of F# property use, the value initializer for the property is happening after EF has setup all of its hooks into the object, effectively wiping them out. Bummer :/\r\nIf there is anything else you would like me to test I'm happy to do so.\r\nThank you again for your time."}],"Status":"","Response":null},"13696080":{"Number":"13696080","Submitter":"Rex Ng","Submitted":"2016-05-02T00:00:00","Title":"Add empty value into the String module","Text":"Copied from this GitHub issue: https://github.com/Microsoft/visualfsharp/issues/1139\r\nRight now, if I do not want to use the empty string literal \"\", I have to do something like\r\nprintfn \"%s\" System.String.Empty\r\nin order to reference the public static readonly instance of the empty string in the BCL.\r\nIt would be more convenient if I can just do:\r\n// Referencing the F# String module here instead of System.String\r\nprintfn \"%s\" String.empty\r\nI would imagine String.empty to be an alias to System.String.Empty so there should be just a one-line code change:\r\nmodule String =\r\n[<CompiledName(\"Empty\")>]\r\nlet empty = \"\"\r\n// Other String functions\r\nI think this will be useful because we already have similar empty values from other modules such as Seq, List, and Array.\r\nThis will also make the code more explicit (i.e. convey to others that 'I want an empty string here' instead of 'this can potentially be a typo').","Votes":1,"Comments":[{"Submitter":"Reed Adams","Submitted":"2016-05-03T10:10:00","Content":"While you're waiting for an official library solution, it might be worth noting that you can extend and approximate the desired functionality in your own code for the time being, possibly giving you the expressiveness you're after.\r\nExample at: https://dotnetfiddle.net/rFSPQl\r\nHopefully this gets you closer to where you want to be until a library solution is in place."}],"Status":"","Response":null},"13721676":{"Number":"13721676","Submitter":"James Ashwell","Submitted":"2016-05-03T00:00:00","Title":"Seq.transpose","Text":"It would be nice to have a function that transposes sequences:\r\n[ [ 00; 01; 02;... ]; [ 10; 11; 12;... ]; [ 20; 21; 22;... ];... ]\r\nto\r\n[ [ 00; 10; 20;... ]; [ 01; 11; 21;... ]; [02; 12; 22;... ];... ]\r\nThis is particularly useful when dealing with infinite x infinite sequences, where you want to iterate over the 'outer group' first.","Votes":14,"Comments":[{"Submitter":"Yaar Hever","Submitted":"2016-05-09T07:57:00","Content":"I took a stab at an implementation:\r\nmodule Seq =\r\n(**)\r\n(**)let transpose s =\r\n(****)seq {\r\n(******)let cachedOuter =\r\n(********)s |> Seq.map (fun inner -> (Seq.cast inner).GetEnumerator())\r\n(**********)|> Seq.cache\r\n(**)\r\n(******)let firstInner = Seq.head cachedOuter\r\n(**)\r\n(******)while firstInner.MoveNext() do\r\n(********)yield seq {\r\n(**********)yield firstInner.Current\r\n(**********)yield! cachedOuter\r\n(*****************)|> Seq.skip 1\r\n(*****************)|> Seq.map (fun inner ->\r\n(**********************)inner.MoveNext() |> ignore\r\n(**********************)inner.Current) } }"},{"Submitter":"Reed Adams","Submitted":"2016-06-20T15:56:00","Content":"I'm quite the sucker for code golf. My solution:\r\n// implementation:\r\nlet transposeInfinite seqs = Seq.initInfinite(fun i -> seqs |> Seq.map (Seq.item i))\r\n// verify:\r\n// (inf x inf) set, each starting 10 off\r\nlet orig = Seq.initInfinite(fun i -> Seq.initInfinite((+) (i * 10)))\r\nprintfn \"orig: %A\\n\\ntrans: %A\" orig (transposeInfinite orig)"}],"Status":"","Response":null},"13785189":{"Number":"13785189","Submitter":"Gauthier Segay","Submitted":"2016-05-09T00:00:00","Title":"Support type annotation based on expression's type","Text":"It would be helpful to have type annotation made of the type of another expression:\r\nlet a = 1\r\nlet b : typeofexpr<a> = 2\r\nthis type of type annotation exists in Oracle SQL database (tablename.column_name%type) and is implemented in jai language:\r\nhttps://www.youtube.com/watch?v=iVN3LLf4wMg\r\nI believe it is also possible to do similar thing with C++ templates.","Votes":1,"Comments":[],"Status":"","Response":null},"13887384":{"Number":"13887384","Submitter":"Bartosz Sypytkowski","Submitted":"2016-05-18T00:00:00","Title":"Support for named curried functions","Text":"The idea here is to add support for labeled arguments in curried functions. This could allow to extend things like partial application to depend not only on arguments order, and also to introduce default argument values in curried functions (now it's possible only in F# type methods).\r\nThis feature is supported already in ML languages like OCaml or FB Reason.","Votes":19,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-05-21T05:03:00","Content":"Bartosz, please clarify your suggestion by introducing an example of new syntax in a comment"},{"Submitter":"Richard Minerich","Submitted":"2016-05-27T16:38:00","Content":"This could be neat, but I think it would at the very least require a new non-conflicting operator something like:\r\nlet f x y = x + y\r\nlet f' = f (y ~ 1)\r\nor a whole new spin on partial application, you could make it look kind of like records\r\nlet f' = (f with y = 1)\r\nNot really in love with any of this syntax, just throwing it out there."},{"Submitter":"Jared Hester","Submitted":"2016-06-27T03:56:00","Content":"OCaml does this like\r\n-------\r\nlet rec range ~first:a ~last:b =\r\nif a > b then []\r\nelse a :: range ~last:b ~first:(a+1)\r\n-------\r\nand with the shorthand\r\n-------\r\nlet rec range ~first ~last =\r\nif first > last then []\r\nelse first :: range ~first:(first+1) ~last\r\n-------\r\n~first is short for ~first:first\r\n~last is short for ~last:last\r\nThis is also tied into optional labeled curried args that support default values [1]\r\n------\r\nlet rec range2 ?(step=1) a b =\r\nif a > b then []\r\nelse a :: range ~step (a+step) b\r\n> range2 1 10;;\r\nval it: int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n> range2 1 10 ~step:2;;\r\nval it: int list = [1; 3; 5; 7; 9]\r\n- : int list = [1; 3; 5; 7; 9]\r\n------\r\n?(step=1) means ~step is an optional argument which defaults to 1\r\nalso when a function only has optional args the last arg has to be unit\r\n------\r\nlet open_window ?title ?width ?height ()\r\n------\r\n======\r\nReason's approach is\r\n------\r\nlet add = fun first::f second::s => f + s;\r\nlet result = add second::20 first::10;\r\n------\r\nReason also uses this feature to supply default values to curried functions [2]\r\n------\r\nlet increment = fun by::by=0 num => num + by;\r\nlet two = increment by::1 1;\r\nlet four = increment 4;\r\n------\r\nWhen a curried function takes optional args it's probably best to require the label always\r\nbe used for the optional arg.\r\nIntellisense could also aid in making it clear which argument a value is being used to satisfy\r\n[1] https://ocaml.org/learn/tutorials/labels.html#Usingfooinafunctioncall\r\n[2] https://facebook.github.io/reason/#diving-deeper-curried-functions"}],"Status":"","Response":null},"14277294":{"Number":"14277294","Submitter":"trek42","Submitted":"2016-05-27T00:00:00","Title":"Make module function callable as class extension method","Text":"Sometimes it's more convenient and succint to call a function using dot-notation (i.e., class method) than calling module functions with pipeline, yet module function is easier to be composed. I propose the compiler automatically generate class extension methods from module functions, based on a new attribute \"CallByInstance\" Example:\r\nnamespace Namespace\r\n// .fsi\r\nmodule List =\r\nval map: ('T -> 'U) -> [<CallByInstance>] list<'T> -> list<'U>\r\nCompiler will automatically generate an extension method of list<'U>, in the *containing* namespace, i.e.,\r\nnamespace Namespace\r\nmodule List = ...\r\n// Automatically generated:\r\n[<AutoOpen>]\r\nmodule ListExtension_map =\r\ntype List<'U> with\r\nmember this.map f list = List.map f list this\r\nThis allows the following syntax:\r\n[1;2;3] |> List.map ((+) 1) // as usual\r\n[1;2;3].map ((+) 1) // call the extension method with dot-notation.\r\nNotes:\r\n1. The extension method is a curried member function. (We don't change the curried parameters to tuple).\r\n2. Similarly we don't change the function name (e.g., no \"map\" => \"Map\" thing).\r\n3. We don't need to open module \"List\" for the extension method. Anywhere \"List.map\" is accessible, \"[1;2;3].map\" is also accessible.\r\n4. You can label multiple parameters of a function as [<CallByInstance>], as long as their types are different.\r\n5. Since we require explicitly marking the allowed parameters, there is no compatibility issue. Users can choose to use this feature judiciously.\r\nFinally, this is related to [/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions,](/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions,.md) but in a reverse way (i.e., turn a module function to a method). My personal view is we need both.","Votes":7,"Comments":[{"Submitter":"trek42","Submitted":"2016-05-27T13:31:00","Content":"fix an error: the generated extension method is:\r\ntype List<'U> with\r\n....member this.map f = List.map f this"},{"Submitter":"Don Syme","Submitted":"2016-06-13T05:58:00","Content":"The CallByInstance attribute proposal is very interesting. I've not seen that suggested before. It would, I think, be fairly simple to implement, with many similarities to the existing extension member implementation."},{"Submitter":"Don Syme","Submitted":"2016-06-13T05:59:00","Content":"My intuition would be to make this an F#-specific feature, where the F# compiler inserts the appropriate code at the callsite, and doesn't generate an actual new member in the .NET IL.\r\nThat is, instead of auto-generating the actual extension member."},{"Submitter":"trek42","Submitted":"2016-06-18T22:19:00","Content":"Not knowing much about the F# compiler for judging the way how this would be implemented, but agreed that making this F#-specific feature seems like a good idea. As the feature is proposed, the call-site (call-by-instance) code would still be curried functions, so C# probably won't benefit from it as much as F# code does. A purely F# compiler magic at callsites would definitely work, and probably is more desirable if this simplifies the code and/or reduces the generated assembly."},{"Submitter":"tranquillity","Submitted":"2016-09-17T21:20:00","Content":"This syntax is how Kotlin handles collection functions\r\nval numbers = listOf(1, -1, 2)\r\nnumbers.filter { it > 0 } //== listOf(1, 2)\r\nnumbers.map { it * it } //== listOf(1, 1, 4)\r\nYou can also chain the dot notation together:\r\nnumbers.filter { it > 0 }.map { it * it } //== listOf(1, 4)"}],"Status":"","Response":null},"14411874":{"Number":"14411874","Submitter":"TheInnerLight","Submitted":"2016-05-30T00:00:00","Title":"Add many more string manipulation functions to the Core.String module","Text":"The Core.String module does not provide nearly enough features at present, too often we have to revert to using the the standard .NET string class which both hinders tidy piping and stops us taking advantage of curried args / partial application.\r\nI suggest that at least the following functions be added to the string module:\r\nempty : string\r\nisEmpty : string -> bool\r\nisWhitespace : string -> bool\r\nreplace : string -> string -> string -> string\r\nstartsWith/endsWith : string -> bool\r\nsplit : seq<char> -> string -> seq<string>\r\ntoUpper/toLower(Invariant) : string -> string\r\ntrim : string -> string\r\ntrimStart/trimEnd : string -> string\r\nObviously all of this can easily be achieved by writing simple wrappers to the methods in the .NET string class but if F# is going to have a String module, it ought to be a fully featured one.","Votes":51,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-05-31T15:30:00","Content":"I believe this suggestion is valueable and should be extended. There are three useful functions for string handling in Visual Basic: left, right, mid (please see: String Functions in Visual Basic. https://msdn.microsoft.com/en-us/library/dd789093.aspx).\r\nIt would be nice to add them to String module in F# as follows:\r\nleft: int -> string -> string\r\nright: int -> string -> string\r\nmid: startFrom: int -> int -> string -> string\r\nExample:\r\nlet str = \"123456789\"\r\nlet x = str |> String.mid 2 2 // x = \"23\"\r\nlet y = str |> String.left 4 // y = \"1234\"\r\nlet z = str |> String.right 3 // z = \"789\""},{"Submitter":"Alexei Odeychuk","Submitted":"2016-06-01T06:10:00","Content":"In addition, it would be nice to add several useful functions from Cryptol, a language for programming cryptographic algorithms, to the F# String module:\r\ndrop: int -> string -> string\r\ntail: string -> string // to drop the first symbol from a string\r\ntake: int -> string -> string\r\nsplitBy: int -> string -> string list\r\ngroupBy: int -> string -> string list\r\njoin: string list -> string\r\nExample:\r\nlet str = \"123456789\"\r\nlet x1 = str |> String.drop 5 // x1 = \"6789\"\r\nlet x2 = str |> String.tail // x2 = \"23456789\"\r\nlet x3 = str |> String.take 2 // x3 = \"12\"\r\nlet str2 = \"123456789012\"\r\nlet x4 = str2 |> String.splitBy 3 // x4 = [ \"1234\"; \"5678\"; \"9012\" ]\r\nlet x5 = str2 |> String.groupBy 3 // x5 = [ \"123\"; \"456\"; \"789\"; \"012\" ]\r\nlet str3 = [ \"123\"; \"456\"; \"789\"; \"012\" ]\r\nlet x6 = str3 |> String.join // x6 = \"123456789012\""},{"Submitter":"Bent Tranberg","Submitted":"2016-06-05T14:14:00","Content":"I like the basic philosophy behind string functions in Delphi, and never understood why the same wasn't done in C#.\r\nString functions in C# typically blow up with exceptions, while in Delphi they typically do the best they can, and typically can't blow up. Delphi string functions results in far less coding, because there's no need to check for index out of range or other possible causes of exceptions, and it's usually far easier to comprehend the possible outcomes of an expression.\r\nFor example, SubString in C# will blow up if any index is out of range, which frequently makes it necessary to do a lot of extra checking. Copy in Delphi is basically the same function, but will not blow up, and instead return whatever lies within the given subrange. Safe, logical, easy.\r\nWhen programming in F#, I typically end up implementing a lot of string functions borrowed from Delphi.\r\nOf course I only suggest this as one more source of inspiration, and of course it overlaps heavily with other suggestions."},{"Submitter":"Paul Westcott","Submitted":"2016-06-06T16:06:00","Content":"The following could be used for some inspiration:\r\nhttps://gist.github.com/manofstick/37f243fedaae203104c7dcc81b221d4b\r\nThis is just my string library that I add to as I use different functions. It has some ideas that may be food for thought, such as:\r\n- treating null as String.Empty (it is f# after all, otherwise use string option...)\r\n- Culture stuff is split into submodules\r\n- \"format\" uses statically resolved types to call \"ToString : string->string\" on any object\r\n- silly naming for blank. Not sure what I was thinking. I should probably just rename to the String objects static function names, but without the \"NullOr\", as that is implied by the library.\r\nBut this is far from a complete surface area. as said, only populated as I need things, so should be taken for what it is, a WIP at glacial pace..."}],"Status":"","Response":null},"14558223":{"Number":"14558223","Submitter":"Jason Kleban","Submitted":"2016-06-02T00:00:00","Title":"Support for TypeProvider nested types with static parameters","Text":"Please support TypeProviders providing nested types with static parameters. This would be valuable for metaprogramming similar to how static parameterized method support is valuable compared to the language without them. It would allow a fluent-like construction of types and partially make up for the non-variable length static parameters on a single type. See https://github.com/fsharp/FSharpLangDesign/issues/88","Votes":10,"Comments":[],"Status":"","Response":null},"14595360":{"Number":"14595360","Submitter":"Андрей Чебукин","Submitted":"2016-06-03T00:00:00","Title":"Provide property on base Discriminated Union type if all the case constructors have the same paramater","Text":"If an each case constructor of Discriminated Union has a parameter with the same name and the same type than allow to implement a property on Discriminated Union base type to access to this parameter value.\r\nNow I have to write a match on every case\r\ntype Physical =\r\n| OneToOne of Data : ModuleData * Line : ModuleList\r\n| OneOnOne of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n| OneByOne of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n| Vertical of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n* Line3 : ModuleList * Line4 : ModuleList\r\nmember this.Data : ModuleData = match this with\r\n| OneToOne(data, _) -> data\r\n| OneOnOne(data, _, _) -> data\r\n| OneByOne(data, _, _) -> data\r\n| Vertical(data, _, _, _, _) -> data\r\nImplement this same parameter as a field on base class and allow me to write\r\nmember this.Data : ModuleData = base.Data\r\nOr automatic property implementation would also be a perfect option","Votes":27,"Comments":[{"Submitter":"exercitus vir","Submitted":"2016-07-09T13:53:00","Content":"This is too much magic for my taste. If I saw `base.Data` I would look for such a field or member, but would need to remember that F# magically transforms cases of tuples with common components to this."},{"Submitter":"Abel","Submitted":"2016-09-22T15:55:00","Content":"You can already do generalization:\r\ntype Test =\r\n    | Foo of string\r\n    | Bar of string\r\nstatic member getString x =\r\n    match x with\r\n    | Foo s\r\n    | Bar s -> s // both conditions wrapped in a single continuation\r\nIt would, however, be nice if this is generalized further into something like:\r\nstatic member getString x =\r\n    match x with\r\n    | _ s -> s\r\nBut that doesn't work well with tuples as in your original example. You'd still have to iterate them over, even though you'd need only one continuation."}],"Status":"","Response":null},"14750064":{"Number":"14750064","Submitter":"mk","Submitted":"2016-06-08T00:00:00","Title":"kprintf with delayed string construction","Text":"Currently kprintf and friends take in a continuation function and a StringFormat and return a curried function that when applied builds the string.\r\nIt would be nice for logging frameworks to have an overload where the continuation does not build the string rather provides a delayed function to build the string.\r\nThat way I can do something like:\r\nlet public logWithFormat logLevel logFormat =\r\nkprintf (fun stringBuilder -> if logLevel > currentLoggingLevel then sprintf \"%s\" (stringBuilder())) logFormat","Votes":10,"Comments":[{"Submitter":"mk","Submitted":"2016-06-09T04:31:00","Content":"A related stack overflow thread with the same issue: http://stackoverflow.com/questions/31442608/how-to-wrap-sprintf-conditionally-in-f"},{"Submitter":"Robin Munn","Submitted":"2016-07-13T22:06:00","Content":"If this is implemented, I'd suggest a name incorporating \"d\" for \"delay\", e.g. one of the following naming schemes:\r\ndprintf, dbprintf, dfprintf, dsprintf\r\ndkprintf, dkbprintf, dkfprintf, dksprintf\r\nkdprintf, kdbprintf, kdfprintf, kdsprintf\r\nkprintfd, kbprintfd, kfprintfd, ksprintfd\r\nPersonally, I like the last scheme best, where the \"d\" is appended at the end of the \"normal\" kprintf names. That fits with the printf / printfn function naming, where the two functions do ALMOST the same thing with one minor change (whether a newline is appended or not). Since no kprintf-family functions have an \"n\" overload, there won't be any confusion over whether to put the \"d\" before or after the \"n\", and the parallels to printf / printfn are clear (the \"d\" functions work almost the same as the non-\"d\" functions, but delay calling the continuation)."}],"Status":"","Response":null},"14795655":{"Number":"14795655","Submitter":"zjv","Submitted":"2016-06-13T00:00:00","Title":"Support mixed F# and C# projects in order to extend F# usage","Text":"Support mixing F# and C# source files in the same project in order to support a gradual move to F# for new users/organisations and to support cases where tooling is oriented at C# (F# not supported)\r\nFor instance I could use this feature to slowly move a C# project to F# one class at the time. Another example would be to use C# tooling to generate web infrastructure like ASP.NET 5 controllers (because F# does not currently have templates for this) and then call directly into F# from those.\r\nP.S. Other languages that F# compares to like Scala already supported mixed projects","Votes":118,"Comments":[{"Submitter":"Anonymous","Submitted":"2016-07-05T20:33:00","Content":"Nemerle's support for mixed C# and Nemerle source files was a very appealing feature when I first found it. Although the Nemerle compiler was built as something like a fork of the C# compiler. I would be much more inclined to use F# if I didn't have to 100% commit to it. As functional as C# is getting, it would be nice at times to leave the C behind."},{"Submitter":"Gauthier Segay","Submitted":"2016-07-05T21:31:00","Content":"I think kotlin has such support with java too.\r\nI'd see this idea coming to fruition first in scripting:\r\n#load @\"path/to/file.csx\"\r\nwhere it is easy to figure out the topoligical graph of script files to include, compile in separate assemblies and link.\r\nIf this is made, then work on same feature in project system would be great.\r\nI think that would also give few kicks to Jetbrains to finally start implementing F# support and more importantly, this would restore some trust in having the whole of MS people working on .NET focused on making best platform with highest level of interop among all the languages, having them invest major engineering efforts which benefits all the languages (current and future) to have easy embedding of all IL compilers in a meta compiler.\r\nF# file ordering is also a major aspect making this seem viable."},{"Submitter":"mmc","Submitted":"2016-07-16T11:29:00","Content":"Another valuable usecase for this would be to F# projects that needs to be consumed from other .NET languages like C#. A mixed F# project could have all the private logic as F# files but the main exposed interfaces as C#."},{"Submitter":"Charles Roddie","Submitted":"2016-09-21T08:39:00","Content":"How is this compatible with file order requirements?\r\n1.cs, 2.fs, 3.fs, 4.cs\r\nPresumably the fs files can refer to previous cs files, and the cs files can refer to each other. Then 2.fs can refer to 1.cs which can refer to 4.cs which can refer to 3.fs. So 2.fs can effectively refer to 3.fs and the whole linear order of F# is broken, isn't it?"},{"Submitter":"Gauthier Segay","Submitted":"2016-09-21T14:41:00","Content":"Charles Roddie, this would work with \"islands\" of C# files compiled together and knowing about previous compiled islands, 1.cs can't know about 4.cs in your case."}],"Status":"","Response":null},"14892927":{"Number":"14892927","Submitter":"Pedro Santos","Submitted":"2016-06-21T00:00:00","Title":"Support constant values in Discriminated unions","Text":"Hi,\r\nWhile trying to model a music domain I ended up with this code:\r\ntype Note = | C | CSharp | DFlat | D | DSharp | EFlat | E | F | FSharp\r\n| GFlat | G | GSharp | AFlat | A | ASharp | BFlat | B\r\n\r\nlet noteName note =\r\nmatch note with\r\n| C -> \"C\" | CSharp -> \"C#\" | DFlat -> \"Db\" | D -> \"D\"\r\n| DSharp -> \"D#\" | EFlat -> \"Eb\" | E -> \"E\" | F -> \"F\"\r\n| FSharp -> \"F#\" | GFlat -> \"Gb\" | G -> \"G\" | GSharp -> \"G#\"\r\n| AFlat -> \"Ab\" | A -> \"A\" | ASharp -> \"A#\" | BFlat -> \"Bb\"\r\n| B -> \"B\"\r\n\r\nlet pitch note =\r\nmatch note with\r\n| C -> 0 | CSharp -> 1 | DFlat -> 1 | D -> 2\r\n| DSharp -> 3 | EFlat -> 3 | E -> 4 | F -> 5\r\n| FSharp -> 6 | GFlat -> 6 | G -> 7 | GSharp -> 8\r\n| AFlat -> 8 | A -> 9 | ASharp -> 10 | BFlat -> 10\r\n| B -> 11\r\nThe code I wish I could write looks like this:\r\ntype Note = | C of (\"C\", 0) | CSharp of (\"C#\", 1) and so on\r\nlet name = fst C\r\nlet pitch = sdn C\r\nor\r\ntype Note = | C = {name=\"C\"; pitch=0} | CSharp = {name=\"C#\"; pitch=1} and so on\r\nlet name = C.name\r\nlet pitch = C.pitch\r\nor\r\ntype Note = | C of {name=\"C\"; pitch=0} | CSharp of {name=\"C#\"; pitch=1} and so on\r\nlet name = C.name\r\nlet pitch = C.pitch","Votes":6,"Comments":[{"Submitter":"exercitus vir","Submitted":"2016-07-09T12:59:00","Content":"You could instead just do this:\r\ntype Note = { name: string, pitch : uint }\r\nmodule Note =\r\nlet C = { name = \"C\", pitch = 0 }\r\nlet CSharp = { name = \"C#\", pitch = 1 }\r\n//etc.\r\nlet name = Note.C.name\r\nlet pitch = Note .C.pitch"},{"Submitter":"Isak Sky","Submitted":"2016-07-29T19:56:00","Content":"You can do this:\r\ntype Cond = Foo | Bar | Baz\r\nlet (|SetV|) x _ = x\r\n[<EntryPoint>]\r\nlet main argv =\r\nlet c = Cond.Foo\r\nmatch c with\r\n| Baz ->\r\nprintfn \"Baz\"\r\n| Foo & SetV \"and\" kwd\r\n| Bar & SetV \"or\" kwd ->\r\nprintfn \"Keyword: %s\" kwd\r\n| Baz -> failwith \"wat\"\r\n0 // return an integer exit code\r\nBut note this compiler bug:\r\nhttps://github.com/Microsoft/visualfsharp/issues/1281\r\nCredit @kevin in fp slack."},{"Submitter":"Abel","Submitted":"2016-09-22T15:37:00","Content":"It seems to me to make more sense to change the way you use DU for your problem domain. I am missing CFlat (C♭) and ESharp (E♯) etc, or things like DDoubleSharp (D"}],"Status":"","Response":null},"15133467":{"Number":"15133467","Submitter":"exercitus vir","Submitted":"2016-07-09T00:00:00","Title":"Nominal subtyping of unions","Text":"This is basically a repost of \"subtyping for discriminated unions\" ([/ideas/suggestion-6672490-subtyping-for-discriminated-unions),](/ideas/suggestion-6672490-subtyping-for-discriminated-unions),.md) but with more details and a description of a concrete use case.\r\nI am reposting because I would like more discussion on this and because I think that declined requests are no longer tracked by Don Syme (and others).\r\nDon Syme declined the feature because he likes features to be generic and symmetric for types in F#. This is a good general rule and I trust in Don's good taste, but I think that this feature request is an exception to the rule, so the decline should be reconsidered for the following reasons:\r\nNominal subtyping cannot be implemented for records because records are compiled to sealed classes, which is a good thing and I see no use cases for subtyping of records anyway (there is also already ambiguity for records with the same fields that needs to be resolved manually with type annotations). So far we agree.\r\nBut this is completely different for unions. This feature only makes sense for unions because of the nature of unions (i.e. limited number of cases where subsets of cases can be fully handled by pattern matches of supersets). Unions are not compiled to sealed classes and there are many uses cases for subtype polymorphic unions. Nominal subtyping of unions is different from structural subtyping of unions (e.g. polymorphic variants in OCaml) in that it is completely safe (i.e. the compiler can still check for exhausiveness). There is also no technical reason that I see (other than maybe a more complex parser, which is an acceptable reason for declining this feature).\r\nHere is a concrete example. Let's say you want to model a financial trading domain where a broker connects to multiple exchanges and submits orders to multiple exchanges. Each exchange supports a subset of a fixed number of possible order types (e.g. limit order, market order, stop limit order, stop market order, trailing stop order, fill or kill order, etc. ) and a subset of timing options for the order (Good Till Day, Good Till Cancel, Good Till Date, Immediate or Cancel, etc.).\r\nUnions are perfect for that except that there is no way currently to generically work with order types and timing options from different exchanges (in a clean way). How would you do this right now in F# without lots of boilerlate and really ugly code (i.e. one interface or member constraint per supported case)?. This feature would allow to express the model directly and I am sure there are many more examples where this is really valuable.\r\nWhat I value about F# the most is the expressiveness of it and this is the only feature (and higher-kinded types maybe) that do not let me express something cleanly.What do you think? Any issues with this that I am overlooking?","Votes":8,"Comments":[],"Status":"","Response":null},"15133590":{"Number":"15133590","Submitter":"exercitus vir","Submitted":"2016-07-09T00:00:00","Title":"Multi-case unions compiled to struct","Text":"I am posting this idea to be able to track its status since it is already informally under consideration. Tuples, records, and single-cases unions are have already planned (implementation even nearing completoin) to be compilable to a struct:\r\nstruct tuples: [/ideas/suggestion-6148669-add-support-for-structtuple](/ideas/suggestion-6148669-add-support-for-structtuple.md)\r\nstruct records: [/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu](/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu.md)\r\nstruct single-case unions: [/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs](/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs.md)\r\nThere is also already a proof of concept for unions of \"blittable\" types: [/ideas/suggestion-7072844-utilise-clr-union-types-for-discriminated-unions](/ideas/suggestion-7072844-utilise-clr-union-types-for-discriminated-unions.md)\r\nThere has also been a lot of discussion on the implementation of multi-case unions in the discussion of struct records: https://github.com/Microsoft/visualfsharp/pull/620\r\nOne great use of multi-case unions compiled to struct would be optional computations (e.g. Option<'T>) for value types that don't do heap-allocation at all.","Votes":20,"Comments":[],"Status":"","Response":null},"15202209":{"Number":"15202209","Submitter":"Isak Sky","Submitted":"2016-07-13T00:00:00","Title":"Return untyped syntax tree from ITypeProvider","Text":"Add the ability to *opt in* to send back an untyped syntax tree from ITypeProviders. The current type provider mechanism is good for simple data exploration use cases, but otherwise extremely limited, and will soon allow for less metaprogramming than Roslyn in some ways. Currently, some types of type providers not possible to create, because unbound generics, records, discriminated unions, and other normal language features are not supported.\r\nWith the ability to opt in to just returning an untyped syntax tree, it would enable the creation of just about any type provider. It would also effectively give F# macros, though through an API rather than syntax.\r\nThese new kind of type providers would be hard to create initially, but the community would be empowered to create libraries to wrap the untyped syntax tree to make it easier to use, and it would soon be an extremely effective and powerful way to do metaprogramming.\r\nAnother benefit is that there wouldn't really be much of a design to experiment with to get right - it is just the untyped syntax tree of the language, which we already have a version of.\r\nThe F# community has very limited resources, and this would be an extremely leveraged way to utilize them.","Votes":27,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-07-17T16:15:00","Content":"One of the F# strengths is its strong typing. It is not a dynamic typed language. Strong typing helps spotting bugs in code early and produce safe, secure and high-performance code. Maybe it would be better to address the core problem: to develop support at the compiler level for creating unbound generics, records, discriminated unions, and other normal language features in type providers that lack support as of today, preserving F# as a strongly typed language."},{"Submitter":"Isak Sky","Submitted":"2016-07-18T00:22:00","Content":"Alexei Odeychuk: I agree it would be nice, but we also have to think about how to best utilize our very limited resources. Remember that type providers have been out for many years, and we still don't have anywhere close to full language support. I think we have to be open to the possibility that the current design is too difficult to implement.\r\nThinking of good abstractions for meta programming is incredibly hard, and there are a lot of big issues with the current approach F# takes, as anyone who has written a type provider can tell you. That is why I think it is better to expose a lower level API, and let the community build on this instead."},{"Submitter":"Dave Thomas","Submitted":"2016-07-18T08:11:00","Content":"The big problem with TP's is a lot of errors come during running the second instance of your dev environment during quotation splicing, so they are not well typed enough during development."}],"Status":"","Response":null},"15257796":{"Number":"15257796","Submitter":"Isaac Abraham","Submitted":"2016-07-18T00:00:00","Title":"Remove warning for new keyword on IDisposable","Text":"The only time I ever use the new keyword is on Disposables, and even then only to silence the compiler warnings. I'm not sure what purpose the warning serves either, because you can still forget to bind the disposable with the use keyword instead of with let. What's more annoying is that it prevents you from effective pipelining.\r\nCould this be removed from the next F# release, or perhaps replaced with a warning if you bind a Disposable with let instead of use?","Votes":5,"Comments":[{"Submitter":"Alexei Odeychuk","Submitted":"2016-07-18T06:44:00","Content":"I support Isaac Abraham's suggestion!"},{"Submitter":"Reed Copsey, Jr.","Submitted":"2016-07-18T13:31:00","Content":"Binding a disposable with let is a common requirement if you're authoring libraries.\r\nI find the current warning _very_ valuable. If you never use \"new\", the warning effectively tells you whenever you allocate something that's disposable, and also provides a simple way in your code to see all uses of disposable."},{"Submitter":"Gauthier Segay","Submitted":"2016-07-19T18:00:00","Content":"I agree with Reed and use same convention, and I do benefit from the warning.\r\nTo workaround the fact you can't use the constructor as first class function only takes a single line function while having the warning and convention of using new only for IDisposable could form a nice convention in F# codebases."},{"Submitter":"Reed Copsey, Jr.","Submitted":"2016-07-28T19:20:00","Content":"I just posted an alternative: [/ideas/suggestion-15448122-add-a-warning-for-new-keyword-used-on-types-which](/ideas/suggestion-15448122-add-a-warning-for-new-keyword-used-on-types-which.md)"},{"Submitter":"Jared Hester","Submitted":"2016-08-11T21:24:00","Content":"I also find this warning very useful and it definitely should not be removed. Reed's alternative is a much more useful approach.\r\nIf you forget to bind to `use` with the `new` right there, that's on you ;P\r\nIf the real issue is with how it currently can't be pipelined, why not ask for just that instead?"},{"Submitter":"miegir","Submitted":"2016-08-15T16:44:00","Content":"I agree that this warning can be removed and replaced by the warning that IDisposable object should be either bound using 'use' or returned. And that warning should also be reported on methods that return IDisposable values. And, for completeness, using of the 'new' keyword will suppress that new warning, allowing developer to say 'I know that I do here'."}],"Status":"","Response":null},"15332553":{"Number":"15332553","Submitter":"Steven Taylor","Submitted":"2016-07-22T00:00:00","Title":"allow compiler directive to switch off inlining","Text":"to get around debugging issues with the inline macro device, this pattern creaps into the code base (taken from FsPickler):\r\n#if DEBUG\r\nlet writeBoundedSequence\r\n#else\r\nlet inline writeBoundedSequence\r\n#endif\r\nIt would be nice to be able to turn off the effect of the inline keyword for files and entire projects while compiling for debugging purposes. Also, optionally setting ignore inline for code executed in an interactive session would be useful too.","Votes":8,"Comments":[{"Submitter":"Abel","Submitted":"2016-09-25T07:38:00","Content":"I believe I have seen this request before. The problem is that \"inline\" changes the behavior and is often inevitable to create semi-polymorphic (duck-typed) functions and types. Consider:\r\nlet f a b = a + b // a and b are ints\r\nlet inline f a b = a + b // a and b requires member (+)\r\nOr:\r\nlet f a b = int a * int b // a and b are ints\r\nlet inline f a b = int a * int b // a and b require op_Explicit\r\nIf you call this code:\r\nlet result = f 1.23 4uy // the first will work with both, inferred float -> byte -> int\r\nlet result = f 1.23 4L // works with \"inline\", does not compile without (wrong type)\r\nIf your only requirement is to remove optimization of \"inline\" and the different inference rules have no effect, it would make (some) sense to disallow it, esp. since during debugging it is beneficial to be able to step through the method.\r\nYou can simplify your above code somewhat:\r\nlet\r\n    #if DEBUG\r\n    inline\r\n    #endif\r\n    writeBoundedSequence ....\r\nThough I would suggest you create a new compiler constant, say INLINE:\r\nlet\r\n    #if INLINE\r\n    inline\r\n    #endif\r\n    writeBoundedSequence ....\r\nThat is because you would want to be able to see debug behavior of the inlined version and this way you can better control when and where INLINE is used."}],"Status":"","Response":null},"15448122":{"Number":"15448122","Submitter":"Reed Copsey, Jr.","Submitted":"2016-07-28T00:00:00","Title":"Add a warning for new keyword used on types which are not IDisposable","Text":"This is an alternative to: [/ideas/suggestion-15257796-remove-warning-for-new-keyword-on-idisposable](/ideas/suggestion-15257796-remove-warning-for-new-keyword-on-idisposable.md)\r\nThe idea is that the new keyword provides valuable information, but only if you do not use it on all types.\r\nWhen avoiding its usage, you get a visual clue as to instances of disposable types, as well as warnings if you bind them.\r\nBy making it a warning to use new unnecessarily, the compiler would effectively enforce a \"best practice\" with regards to IDisposable usage. It goes a long way today, but requires discipline to make it useful.\r\nThis would be especially helpful to people coming to F# from C#, as many immediately use new everywhere, and don't see this very nice safety benefit provided by the compiler.","Votes":21,"Comments":[],"Status":"","Response":null},"15462291":{"Number":"15462291","Submitter":"Dmitry Morozov","Submitted":"2016-07-29T00:00:00","Title":"Have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files","Text":"Have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files\r\nThis came up in my work on FSharp.Data.SqlClient library.\r\nUp until version 1.8.2 version of the library SqlCommandProvider provided command types with two constructors of following signatures:\r\nnew: connectionString: string, ?commandTimeout: int\r\nnew: ?connection: SqlConnection, ?transaction: SqlTransactoin, ?commandTimeout: int\r\nKeep in mind that above are not normal F# type signatures but rather signature as suggested by Intellisense otherwise parameters with default values won’t show as optional.\r\nIt allowed to write following code:\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \"Server=.;Integrated Security=true\">()\r\ncmd.Execute()\r\nIt resolves to second constructor invocation where all parameters have default value e.g. optional.\r\nAt runtime this code reuses design time connection string to connect to a database. This is typical coding style for F# scripting (*.fsx + FSI).\r\nFor production-like scenarios connection string is read from some sort of configuration.\r\nOne way to archived that is to use connection string name from config file app.config/web.config. In that case type provider reads connection string from config file both at design time and runtime which allows to have different connection string at runtime by overriding *.config file\r\nPattern #1\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \" name=AdventureWorks\">()\r\ncmd.Execute()\r\napp.config\r\n<configuration>\r\n<connectionStrings>\r\n<add name=\"AdventureWorks\" connectionString=\"Data Source=.;Initial Catalog=AdventureWorks2012;Integrated Security=True\" />\r\n</connectionStrings>\r\n…\r\nPattern #2\r\nThe other way is override connection string or connection object at runtime\r\ntype Get42 = SqlCommandProvider<\"select 42\", \"server=.;trusted_connection=yes\">\r\n…\r\nDo\r\nlet connStr = readConnectionStringFromConfig()\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \"Server=.;Integrated Security=true\">( connStr)\r\ncmd.Execute()\r\nNote that will resolve to invocation of first constructor.\r\nThat how it worked until 1.8.2\r\nI got a complaint from one of the library users - Jet.com. They use pattern #2. They said the biggest source of mistakes is that developers forget to provide runtime override for connection string and it fails at runtime.\r\nAn issue was opened to reflect that\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/issues/195\r\nAnd it was fixed and deployed as part of 1.8.2\r\nTo sum up the change is following: if literal connection string was used at design time, at runtime either connection string or connection object is mandatory parameter. I believe it was right change to support production quality code but it made scripting counterpart ugly and I actually received complaints from customers.\r\n[<Literal>]\r\nlet connection = \"Server=.;Integrated Security=true\"\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", connection>(connection)\r\n//connection mentioned twice. Not elegant\r\ncmd.Execute()\r\nIt would be nice if the type provider can generate slightly different constructor signature for scripting e.g. allowing to create provided command with parameter-less ctor invocation.\r\nI already do something similar in response to\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/issues/185\r\nIt relies on IsHostedExecution property TypeProviderConfig\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/blob/v1.8.1/src/SqlClient/Configuration.fs#L67\r\nBut it works only when a type generated within FSI. This was enough to resolve issue 185 but not sufficient to generated diff ctors signatures.\r\nHere is my proposal:\r\n*.fsx files mostly meant to be executed from FSI. Why not to have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files\r\nSo type provider will able to generate diff types depending on IsHostedExecution value","Votes":7,"Comments":[],"Status":"","Response":null},"15511989":{"Number":"15511989","Submitter":"Loic Denuziere","Submitted":"2016-08-02T00:00:00","Title":"Support isNull when querying the built-in SQL type providers","Text":"Right now the query expression-to-LINQ translation doesn't support queries such as `query { for x in table do where (isNull x.Field) }`. Instead we have to use `where (x.Field = null)`. That's quite inconsistent: in normal (non-query) code, `isNull` is advised, but in query code, we can't use it.","Votes":5,"Comments":[{"Submitter":"Daniel Robinson","Submitted":"2016-08-04T10:28:00","Content":"Even better IMO, optimize comparison operators' handling of null so isNull isn't needed (anywhere)."}],"Status":"","Response":null},"15591624":{"Number":"15591624","Submitter":"Dzmitry Lahoda","Submitted":"2016-08-08T00:00:00","Title":"Literal sprintf","Text":"Allow:\r\n```\r\n[<Literal>]\r\nlet a = sprintf \"%s\" \"string\"\r\n```","Votes":13,"Comments":[],"Status":"","Response":null},"15696774":{"Number":"15696774","Submitter":"Mathias Brandewinder","Submitted":"2016-08-17T00:00:00","Title":"Relax indentation rules on Records","Text":"The current indentation rules around records seem inconsistent, or at least counter-intuitive. Consider for instance:\r\ntype Foo = {\r\n....Foo:int\r\n....}\r\ntype Bar = {\r\n....F:Foo\r\n....}\r\nlet bar = {\r\n....F = {\r\n........Foo = 10\r\n........}\r\n....}\r\nThis is valid. But if you change F in Bar to VeryLongName:\r\ntype Baz = {\r\n....VeryLongName:Foo\r\n....}\r\nlet baz = {\r\n....VeryLongName = {\r\n........Foo = 10\r\n........}\r\n....}\r\nWe now get a warning:\r\nwarning FS0058: Possible incorrect indentation: this token is offside of context started at position (10:20). Try indenting this token further or using standard formatting conventions.\r\nIn a similar fashion, indentation rules around adding members to records seem inconsistent, or at least counter-intuitive.\r\nThe 2 examples below are valid:\r\ntype Foo1 =\r\n....{\r\n........data:int\r\n....}\r\n....member x.Data = x.data\r\ntype Foo2 = {\r\n....data:int\r\n....}\r\n....with member x.Data = x.data\r\n... but this one is not:\r\ntype Foo3 = {\r\n....data:int\r\n....}\r\n....member x.Data = x.data\r\nThere is a workaround - systematically put the opening brace { on the second line - but the \"shorter\" syntax is quite nice, and allows to write compact and readable code. Given what is currently acceptable syntax, relaxing a bit the rules would be quite nice, and follow the principle of 'least surprise'.\r\nNote: this is loosely related to [/ideas/suggestion-9156844-relax-some-of-the-indentation-rules](/ideas/suggestion-9156844-relax-some-of-the-indentation-rules.md) ; that specific problem is brought up in the comments.\r\nNote: sorry about the .... but this is the only way I could find to keep the code indentation preserved.","Votes":9,"Comments":[],"Status":"","Response":null},"15801949":{"Number":"15801949","Submitter":"Alex Corrado","Submitted":"2016-08-24T00:00:00","Title":"Allow lower-case DU cases when [<RequireQualifiedAccess>] is specified","Text":"Currently, it is not allowed to declare DU cases with lower-case letters. For instance, this is not allowed:\r\ntype Foo =\r\n| foo\r\n| bar\r\n| baz\r\n// etc...\r\nThis yields: error FS0053: Discriminated union cases and exception labels must be uppercase identifiers\r\nAs I understand it, this is to prevent ambiguity in pattern matching between matching a union case and binding to an identifier. However, this is not an issue if the [<RequireQualifiedAccess>] attribute is specified on the DU. Therefore, I propose we allow lower-case cases in this case.","Votes":1,"Comments":[],"Status":"","Response":null},"15915547":{"Number":"15915547","Submitter":"Ivan J. Simongauz","Submitted":"2016-09-03T00:00:00","Title":"Implement interface delegating","Text":"Implement interface delegating by next syntax:\r\ntype MyType() =\r\nlet delegator : IAddingService\r\ninterface IAddingService by delegator with\r\nmember this.Add x y = // <- this is override\r\nx + y\r\nSpecial behavior when event in interface - sender substitution","Votes":1,"Comments":[],"Status":"","Response":null},"15915808":{"Number":"15915808","Submitter":"Ivan J. Simongauz","Submitted":"2016-09-03T00:00:00","Title":"Impement auto notification","Text":"Impement auto notification chages for classes and records when implemented INotifyPropertyChanged or custom.\r\ntype A() =\r\nlet achaged name old new =\r\nPropertyChanged(this, name)\r\nmember B : int 3 with get and set and notifyby achanged","Votes":1,"Comments":[],"Status":"","Response":null},"15946864":{"Number":"15946864","Submitter":"Marko Grdinic","Submitted":"2016-09-06T00:00:00","Title":"Automate the need to explicitly write out generic parameter constraints in classes","Text":"Given that F# already automatically tells you what member constraints the classes should have, why not go an extra step and have the compiler write them out implicitly like in normal let statements.\r\nI just recently had a situation where in a class I had to explicitly write a bunch of them all out like in the following:\r\n```\r\ntype FFRec<'state when 'state: (member Tape: Stack<unit -> unit>)\r\nand 'state: (member Mem: ObjectPool)\r\nand 'state: (member Str: CudaStream)\r\nand 'state: (member Workspace: Workspace)\r\nand 'state: (member IsInferenceOnly: bool)> =\r\n```\r\nThis would be bad if I had a bunch of classes where for each one, I had to write out every constraint.\r\nOf course I replaced the above with a single subtyping constraint, but is there any reason why the compiler could not have done this automatically? Also if that is not possible, would it be possible to introduce an abbreviation feature for type constraints instead of just types. They would make structural typing a lot more palatable.\r\nHaving recently been introduced to structural typing in F#, I am quite a fan of it and even the syntax which bothered me at the beginning does not look worse than anything you might find in Scala for example. I think this particular feature of the language could be a great selling point if it was made nicer.","Votes":3,"Comments":[],"Status":"","Response":null},"16092382":{"Number":"16092382","Submitter":"Mark Seemann","Submitted":"2016-09-15T00:00:00","Title":"Add ofObj to Seq and Array","Text":"The Option module defines Option.ofObj which converts a potential nullable value to an option.\r\nCollections (Seq and array) can be null in interop scenarios, but it'd often be natural to interpret a null collection as an empty collection.\r\nIt's possible to compose such behaviour from existing building blocks, e.g. with Option.ofObj >> Option.toArray >> Array.concat\r\nThis seems like quite a roundabout way to do things, so I'd like to propose equivalent functions for Seq and Array:\r\n// seq<'a> -> seq<'a>\r\nSeq.ofObj\r\n// 'a [] -> 'a []\r\nArray.ofObj","Votes":6,"Comments":[{"Submitter":"Loic Denuziere","Submitted":"2016-09-16T08:10:00","Content":"Alternatively for something more general, we could have a null equivalent of `defaultArg`. So if it's called let's say `ifNull` (placeholder name, not actual proposal) then your `Seq.ofObj s` would be `ifNull s Seq.empty`, and `Array.ofObj s` would be `ifNull s [||]`."}],"Status":"","Response":null},"16126906":{"Number":"16126906","Submitter":"Loic Denuziere","Submitted":"2016-09-16T00:00:00","Title":"Allow type annotations at the top level in fsi","Text":"Currently, using a type annotation at the top level in fsi results in a syntax error:\r\n> 1 : int;;\r\n1 : int;;\r\n--^\r\nstdin(1,3): error FS0010: Unexpected symbol ':' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.\r\nThe workaround is to wrap the whole expression in parentheses, but I don't believe there's any reason for it to be necessary. It has misled some people into thinking they need to use another syntax instead (I've seen people try to use :?> for example).","Votes":6,"Comments":[],"Status":"","Response":null},"16308904":{"Number":"16308904","Submitter":"Abel","Submitted":"2016-09-22T00:00:00","Title":"Expand on cardinality functions Seq.exactlyOne, with Seq.tryExactlyOne and add oneOrMore, zeroOrMore","Text":"While it is quite trivial to write these functions, I think they have merit. First of, it is good there's a Seq.exactlyOne, but it throws and if you want a non-throwing version, you'll have to write one your own. It's odd there's a creator function, Seq.singleton, but not a test-function.\r\nSince we have Seq.exactlyOne, it should have its logical cardinality counterparts for zero-or-one and one-or-more to be available too.\r\nI suggest we add:\r\nSeq.tryExactlyOne\r\nSeq.oneOrMore (throws)\r\nSeq.zeroOrMore (throws)\r\nSeq.tryOneOrMore\r\nSeq.tryZeroOrMore\r\nThe reason it is better to have these in FSharp.Core is that, if one implements these by hand, it requires at least two iterations until the 2nd element. An optimized implementation may prevent this.\r\nSee also the discussion here: http://stackoverflow.com/questions/39628567/non-throwing-version-of-seq-exactlyone-to-test-for-a-singleton-sequence","Votes":4,"Comments":[],"Status":"","Response":null},"16402732":{"Number":"16402732","Submitter":"lee","Submitted":"2016-09-28T00:00:00","Title":"Allow static optimization conditionals","Text":"If we write the code as below, we will get a compile error: Static optimization conditionals are only for use within the F# library\r\nlet inline toBytes (x : ^a) : byte[] =\r\n(^a : (static member ToBytes : ^a -> byte[])(x))\r\nwhen ^a : byte = [|retype x : byte|]\r\nwhen ^a : string = System.Text.Encoding.UTF8.GetBytes(retype x : string)\r\n\r\nBut allow \"static optimization conditionals\" is very useful, which allow us avoid to use those tricks like \"Simple typeclass implementation\". http://www.fssnip.net/9B","Votes":3,"Comments":[{"Submitter":"Gusty","Submitted":"2016-10-01T16:33:00","Content":"I'm not sure type inference will work well by only allowing static optimizations outside the F# library.\r\nIf you look at the source code of the F# compiler there are many particular cases introduced in order to get simulated members working and inferred.\r\nIn your example calling toBytes with byte will not type check because byte doesn't have a ToBytes static member.\r\nAnyway there seems to be a better way to implement type classes in .NET http://www.mlworkshop.org/2016-7.pdf?attredirects=0"}],"Status":"","Response":null},"16448692":{"Number":"16448692","Submitter":"Mark Seemann","Submitted":"2016-10-01T00:00:00","Title":"Allow fun arrows to start after a line break","Text":"As described here: https://github.com/Microsoft/visualfsharp/issues/1551","Votes":2,"Comments":[],"Status":"","Response":null},"16476649":{"Number":"16476649","Submitter":"Marko Grdinic","Submitted":"2016-10-03T00:00:00","Title":"Record copy update should be able change the generic type","Text":"type A<'a> =\r\n{\r\nmutable x: 'a\r\n}\r\nlet a = {x = 1}\r\n{a with x=\"Hello\"} // Type error\r\nSince the x field is generic and F# is type safe, it would not be bad if the above was valid.","Votes":1,"Comments":[],"Status":"","Response":null},"16482547":{"Number":"16482547","Submitter":"Matt","Submitted":"2016-10-03T00:00:00","Title":"Provide Intellisense on 'tab' key when creating 'new' classes or types.","Text":"I would like to have the ability to hit the \"tab key\" when creating a new type with a constructor that will list the types available properties.\r\nI C# this is done nicely with classes and as you assign a value the property is no longer available in intellisense when one tabs again to select another property.","Votes":1,"Comments":[],"Status":"","Response":null},"16514236":{"Number":"16514236","Submitter":"Musa","Submitted":"2016-10-05T00:00:00","Title":"1-spit Assembly code (or LLVM code) in Repl on each highlighted code piece, for visibility into debugging eg. tail calls, speed of executioa","Text":"","Votes":1,"Comments":[],"Status":"","Response":null},"16526545":{"Number":"16526545","Submitter":"lr","Submitted":"2016-10-06T00:00:00","Title":"Allow Object Expressions from abstract base classes without members","Text":"http://stackoverflow.com/questions/8154730/object-expression-for-abstract-class-without-abstract-members\r\nObject Expressions are a great feature to create instances of single-use interface / abstract class instances without polluting the namespace.\r\nAt the moment it is impossible to inherit from an abstract class which does not define any members.\r\nIf I have an abstract base class\r\n[<AbstractClass>]\r\ntype Foo(i:int) = class end\r\nthen I would like to be able to exten it like this:\r\nlet foo = { new Foo(1) }\r\nBut this errors out with\r\nInvalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.\r\nThe suggestion obviously doesn't work, since the base type is abstract.\r\nThe workaround is to define it like this:\r\nlet foo = { new Foo(1) with member __.ToString() = base.ToString() }","Votes":1,"Comments":[],"Status":"","Response":null},"16529041":{"Number":"16529041","Submitter":"Krzysztof Cieslak","Submitted":"2016-10-06T00:00:00","Title":"Close User Voice in favor of GitHub issues.","Text":"I really believe we should close UserVoice in favor of using GitHub issues (maybe separate repository for it? ). Here are few reasons for it:\r\n* Bad UX\r\n* Need to monitor and maintain separate communication channel\r\n* No comment editing\r\n* No markup for code samples\r\n* No markdown\r\n* Can't embed images\r\n* No mentions and notifications\r\n* Only 10 votes which reduce people ability to vote (especially in so old project as F# - many people already used all their votes over the years)\r\n* No more fake accounts to workaround votes limit\r\n* God damn this text editor (writing long message [like this] i terrible in editor showing 5 lines)\r\n* GitHub issues can be labeled, milestones can be added, new projects feature can be used\r\nSimilar move was done by VSCode Team - https://code.visualstudio.com/blogs/2016/08/19/goodbyeuservoice - and I strongly believe we should do the same.","Votes":226,"Comments":[{"Submitter":"Anonymous","Submitted":"2016-10-06T15:48:00","Content":"+1M"},{"Submitter":"Don Syme","Submitted":"2016-10-06T15:57:00","Content":"Well, someone would need to move all the items, votes, history, discussion and start to chase down incoming links. I don't think it's simple. Having done it once (when extracting F# User Voice from the Microsoft-specific Visual Studio user voice) I don't fancy doing it again, it was a huge job."},{"Submitter":"Reed Copsey, Jr.","Submitted":"2016-10-06T15:59:00","Content":"Don - I suspect that, with your blessing, we could coordinate that and make most of that happen.\r\nThe largest roadblock would be moving votes, since people can't add votes from other accounts. To be honest, I question the value of the votes on here in general, though, as the way voting works on user voice is incredibly problematic anyways."},{"Submitter":"Krzysztof Cieslak","Submitted":"2016-10-06T16:01:00","Content":"I'm pretty sure we can create script using cannopy or HTML TP to get all info from UserVoice and then add it to GitHub using their API :)"},{"Submitter":"Jared Hester","Submitted":"2016-10-06T16:10:00","Content":"There are literally no advantages (at least from our perspective) to using uservoice over github.\r\nAnother advantage of github that wasn't mentioned is the ability to link directly to a specific comment in the thread.\r\nAnother small github advantage is that the comments are listed oldest -> newest, unlike uservoice where you have to go to the end of the thread and read backwards. If your post ends up exceeding the length limit on uservoice you need to split it up and post it backwards so it reads sensibly to other users.\r\nThis site is a wellspring of frustration; the lengths we need to go through (e.g. using (****) to replace whitespace so code examples can be copied and pasted without tons of tedious indenting) distracts from focusing on the content of posts.\r\nI don't think the suggestions should be moved over to the visualfsharp or the fsharplangdesign repo. A new FSharpLangSuggestions or FSharpLangEvolution repository should be dedicated to this role.\r\nI'll even do the grunt work of copying over all of the planned, under review, and started issues if that makes it easier to switch over."},{"Submitter":"Don Syme","Submitted":"2016-10-06T17:19:00","Content":"@JaredHester - We would use \"FSharpLangSuggestions\" or (\"fsharp-lang-suggestions\" to use more modern repo casing - we should probably rename FSharpLangDesign to fsharp-lang-design assuming the redirects work as expected). This collection is deliberately informal: suggestions, and _not_ actual RFCs. I want that distinction.\r\n@JaredHester Closed suggestions would need to be copied over as well. Also the text giving the resolution.\r\n@ReedCopsey - the vote counts are definitely valuable. The voting is only indicative anyway."},{"Submitter":"Robin Munn","Submitted":"2016-10-07T02:57:00","Content":"A suggestion posted today mentions \"No more fake accounts to workaround votes limit\" and has 142 votes. Nice practical illustration of why UserVoice votes aren't *actually* all that reliable. :-)\r\nAnd I would throw 3 votes at this too, except my 10 votes are all used up -- on features I do care about, so I don't want to move them."},{"Submitter":"Robin Munn","Submitted":"2016-10-07T02:58:00","Content":"And since I can't edit my previous comment to add what I forgot to mention, I'll add a new comment to mention it:\r\nI also am 100% in favor of moving to GitHub, and I don't mind re-creating my votes on the issues I've already voted on."}],"Status":"","Response":null},"5663074":{"Number":"5663074","Submitter":"knocte","Submitted":"2014-03-21T00:00:00","Title":"Enable a compiler-warning when a recursive algorithm is not tail-recursive","Text":"Add an TailRecursiveAttribute to enable a compiler-warning when a recursive algorithm is not tail-recursive. This should ideally also cover recursive seq { .. } and async { ... } expressions.","Votes":308,"Comments":[{"Submitter":"Phillip Trelford","Submitted":"2014-03-21T07:30:00","Content":"A compiler warning/error would be useful when you require your function to be tail recursive but it is not, perhaps a tailrec keyword could be used in this case, i.e.\r\nlet tailrec myfunc = // ..."},{"Submitter":"knocte","Submitted":"2014-03-21T07:42:00","Content":"@Phillip: as far as I understand, it's always desirable to be tail-call-friendly, otherwise you might get StackOverflowExceptions if there are many iterations, right?"},{"Submitter":"Phillip Trelford","Submitted":"2014-03-21T07:46:00","Content":"@Anonymous it's desirable to be tail recursive but not always necessary, a blanket warning on all existing code might be a bit harsh. An attribute or keyword where you explicitly expect tail recursion might be more forgiving."},{"Submitter":"Andrew Khmylov","Submitted":"2014-03-21T09:54:00","Content":"Philip, introducing another `tailrec` keyword doesn't sound like a good idea. It would make the code a lot more verbose IMO. I would rather get rid of `rec` keyword at all. I think the compiler is smart enough to figure out that the function is actually recursive, why should I type it myself?"},{"Submitter":"Jon Harrop","Submitted":"2014-03-21T10:02:00","Content":"@Andrew: \"I think the compiler is smart enough\"\r\nConsider:\r\nlet f n = n+1\r\nlet f n = f(n-1)\r\nis the latter definition of \"f\" recursive? Obviously it is impossible to tell. Hence the existence of the \"rec\" keyword.\r\nThe alternative is to make everything recursive but then you must pollute your namespaces with, for example, \"f1\" and \"f2\" because you cannot supercede previous definitions."},{"Submitter":"Jon Harrop","Submitted":"2014-03-21T10:05:00","Content":"How would we handle mutual recursion or recursion via a function that was passed in?\r\nFor example:\r\nlet rec even n =\r\nodd(n-1)\r\nand odd n =\r\neven(n-1)\r\nor:\r\nlet evenOne odd n = odd(n-1)\r\nlet oddOne even n = even(n-1)\r\nlet rec even n = evenOne (oddOne even) n\r\nCould we put this attribute on an entire module to check that all loops within the module require bounded stack space?"},{"Submitter":"knocte","Submitted":"2014-03-21T14:56:00","Content":"@Philip, aha I understand. But I think if such keyword is proposed, I think it would be better if it's for opting-out the warning than opting-in."},{"Submitter":"Mastr Mastic","Submitted":"2014-03-23T02:46:00","Content":"@Andrew Khmylov I cannot agree because imo `rec` is not for the compiler, it is for us, and to me very necessary.\r\nFor instance when you re-bind a symbol for a function, to a function that uses it, how would you express yourself without using `rec` if you intend to call the previous binding or the new (recursive) one?"},{"Submitter":"Mastr Mastic","Submitted":"2014-03-23T02:50:00","Content":"I agree with Philip on the keyword, it seems much more cleaner than an attribute."},{"Submitter":"Jack Pappas","Submitted":"2014-03-29T09:14:00","Content":"Requiring the compiler to warn you when an entire algorithm is not tail-recursive poses a significant challenge, as Jon and others have pointed out.\r\nIf you relax the definition of this feature request to something like \"emit a compiler warning for non-tail-recursive call sites within a 'rec' function\", this becomes fairly simple to implement. In addition, you don't need additional keywords or functions to implement this -- it could be a standard compiler warning which is on by default, which means it'd be easy to turn off for those who wanted to do so."},{"Submitter":"Jack Pappas","Submitted":"2014-03-29T14:07:00","Content":"I put together a little code sample demonstrating my proposal (see previous comment): https://gist.github.com/jack-pappas/9860949\r\nTo elaborate a bit: the compiler would emit a warning at each call site to a function which shares the same stack frame as the current function -- in other words, when a function is calling itself, or some other function within a group of mutually-recursive functions."},{"Submitter":"knocte","Submitted":"2014-04-03T15:45:00","Content":"@Jack: awesome work!"},{"Submitter":"bleis-tift","Submitted":"2014-04-03T23:42:00","Content":"F# has tailcall keyword as reserved-ident-keyword.\r\nSo I think that the keyword is better than tailrec."},{"Submitter":"Don Syme","Submitted":"2014-06-20T12:18:00","Content":"I am generally in favour of addressing this in F# 4.0. I would want seq { .. } and async { ... } tailcalls to also be addressed.\r\nA more detailed design is needed and some trialling would be great. Jack's work is a great start.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest.\r\nI encourage you to consider continue working towards a detailed proposal and a propopsed implementation. I will gladly help.\r\n\r\nI would tend towards using an attribute rather than a keyword, despite the fact that \"tailcall\" is reserved, simply because that is how things like this are generally added to the F# language since F# 2.0.\r\n[<TailCall>]\r\nlet rec f x = .... f (x-1)\r\n[<TailCall>]\r\nlet rec f x = .seq { ... yield! f (x-1) }\r\n[<TailCall>]\r\nlet rec g x = .async { ... return g (x-1) }\r\nWith regard to Jon's question - the checking would be much as described by Jack - i.e. only w.r.t. the control flow contructs that are syntactically present in the F# expression language (and hot combinator encodings of these).\r\nAll uses of an attributed function within its recursive scope would need to be in tail position. Thus passing the function as a higher-order argument would not be allowed.\r\nThis limts the utility of the method of course but it still remains useful, especially for beginners and teaching purposes."},{"Submitter":"Eriawan Kusumawardhono","Submitted":"2014-09-02T22:29:00","Content":"This tailcall CLR and recursive implementation should be transparent to the language, especially F#.\r\nMeaning that not only adding keywords or IDE realtime warning, but also should be available in other languages other than F# as well to use if there's a need to optimize recursive function calls.\r\nI vote +2 for this!"},{"Submitter":"Alfonso Garcia-Caro","Submitted":"2014-09-07T08:30:00","Content":"I would be in favour of using the keyword, the attribute looks much more verbose..."},{"Submitter":"Eriawan Kusumawardhono","Submitted":"2014-09-25T23:16:00","Content":"I agree to use the attribute. This will give different meaning and also context is more verbose than keyword.\r\nThis will also minimize confusion whether a rec function is actually tailcall optimized or not."},{"Submitter":"James Hugard","Submitted":"2014-11-06T02:09:00","Content":"I'm in agreement with Jack Pappas: use neither a keyword nor attribute; simply always issue a warning. In other words, relax the feature request to be:\r\n\"F# compiler emits a warning at each non-tail recursive call site where a function is calling itself or some other function defined within a group of mutually-recursive functions.\"\r\nIt is obviously bad practice, in general, to make non-tail calls to oneself or one's siblings due to the potential of a stack overflow. Therefore, such usage should be strongly discouraged by default and not only when a specific keyword modifier or attribute is supplied. Doubly so because beginners are more likely to make mistakes here and not even know to use a modifier or attribute as a compiler assist.\r\nFor cases where one accepts the risks, the warning could easily be disabled.\r\nThe documentation for that warning, though, would probably run to the long side; e.g., explaining how one could make the code tailcall friendly."},{"Submitter":"Don Syme","Submitted":"2014-11-06T19:05:00","Content":"James/Jack, there are many cases where non-tail recursive calls are required and normal, for example consider Map.add https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/map.fs#L120\r\nIn this case the depth of recursion is bounded by log(n) on the size of the input."},{"Submitter":"Don Syme","Submitted":"2014-11-11T13:22:00","Content":"I have started prototyping this, https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup?branch=tailcall-warning"},{"Submitter":"exercitus vir","Submitted":"2015-06-19T17:53:00","Content":"I second the the idea of always issuing a warning. You can always disable it with an in-place compiler directive if you really don't require tail-recursion."},{"Submitter":"Anonymous","Submitted":"2016-05-10T16:32:00","Content":"It is really \"#1 must be\" all this recursive stuff got failed on a big data if not optimized, but some times it is nontrivial to check is it ok or not."}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"I am generally in favour of addressing this in F# 4.x+. I would want seq { .. } and async { … } tailcalls to also be addressed.\r\nA more detailed design is needed and some trialling would be great. Jack’s work is a great start. However, this is not an easy piece of work to do in a non-invasive way and my own experiments in this area have not yet led to something I feel confident to include in the F# language design.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nCurrently, initial implementations of approved language design can be submitted as pull requests to the appropriate branch of https://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for info on how to contribute to the F# language/core library design\r\nI encourage you to consider continue working towards a detailed proposal and a proposed implementation. I will gladly help.\r\nDon Syme, F# Language and Core Library Evolution"}},"5663202":{"Number":"5663202","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Allow to define types at expression scopes","Text":"The suggestion is to allow \"type X = ...\" in an expression, e.g.\r\nlet f () =\r\ntype X = A | B\r\nlet x = (A,A)\r\nlet y = (B,B)\r\nif (x=y) then true else false","Votes":36,"Comments":[{"Submitter":"Phillip Trelford","Submitted":"2014-03-21T08:09:00","Content":"At a minimum type aliasing at local scopes as per C++ typedef would be really handy. Nested type declaration would also be nice."},{"Submitter":"Don Syme","Submitted":"2014-03-21T13:12:00","Content":"The technical questions that arise are\r\n(a) can these include full type definitions - including members? If so, can these capture values from scope?\r\n(b) can these types appear in the inferred type of the function?"},{"Submitter":"Gustavo Guerra","Submitted":"2014-10-26T17:24:00","Content":"(b) Should not be possible, as these types should be private to the function, so an error should be issued on that case\r\n(a) Yes, they should be full type definitions. Capturing values from scope would be an added bonus, but would be also ok if that wasn't supported, I guess."},{"Submitter":"Gustavo Guerra","Submitted":"2014-10-26T17:27:00","Content":"Actually, even if members weren't allowed this would be already very useful. On local scope we usually use a lot of tuples, and refactoring to records or DUs is usefull, but it's a bit annoying that you have to do that at global scope"},{"Submitter":"Vasily Kirichenko","Submitted":"2014-10-27T02:46:00","Content":"This is now it's implemented in D https://gist.github.com/vasily-kirichenko/95a2cabfba599884b61d\r\nSo, no-static types can capture local variables and cannot escape the function scope."},{"Submitter":"Don Syme","Submitted":"2016-02-04T13:04:00","Content":"What if only type aliases were allowed?"},{"Submitter":"Gustavo Guerra","Submitted":"2016-07-22T05:38:00","Content":"This was also added to TypeScript: https://www.typescriptlang.org/docs/release-notes/typescript-1.6.html"},{"Submitter":"Gustavo Guerra","Submitted":"2016-07-22T05:38:00","Content":"Type aliases only would help a bit but not really solve the problem completely. Having local records and DUs would be much better"},{"Submitter":"Anonymous","Submitted":"2016-07-24T13:58:00","Content":"I was surprised to find this isn't inherently supported, when I first coded it it seemed quite natural because I can declare an inner function within a parent function and the inner function is known only within that parent, I added a simple enum type - also within some parent function and the compiler complained."}],"Status":"","Response":null},"5663215":{"Number":"5663215","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Optional and named parameters on let bindings on modules","Text":"Optional and named parameters are supported in static methods, but not in let bindings on modules. This many times forces you to use a static class instead of a module, which has some inconvenients. Ocaml has this, so I'm guessing is doable.","Votes":128,"Comments":[{"Submitter":"Gustavo Guerra","Submitted":"2014-03-21T08:26:00","Content":"Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/5592336-optional-parameters-on-let-bindings-on-modules"},{"Submitter":"Andrew Cherry","Submitted":"2014-03-21T09:42:00","Content":"A fairly similar syntax of let functionName ?(parameterName: [type]) () = [...] seems like it would work if parameterName became type option? That would seem like it would fit with defaultArg still, etc..."},{"Submitter":"Jon Harrop","Submitted":"2014-03-21T10:07:00","Content":"OCaml is rather grim in this respect. They got too fancy and let you have optional curried arguments that support partial specialization which leads to all kinds of inconveniences.\r\nI would like optional non-curried arguments to let-bound functions though."},{"Submitter":"Jack Pappas","Submitted":"2014-03-22T08:13:00","Content":"OCaml does have this, so it is possible -- but as Jon H. pointed out, it's very easy to make this feature \"too powerful\" and ultimately cause more problems than it solves.\r\n+1 for Jon's suggestion that if this were implemented, it should only be for let-bound functions using the tupled argument style. I think that would provide a good compromise because you'd be able to write let-bound functions in modules in exactly the same way you're writing methods in static classes now (sans overloading), without introducing the complexity of optional curried arguments or type inference when using named arguments."},{"Submitter":"trek42","Submitted":"2014-09-08T16:44:00","Content":"Does named parameters have similar drawbacks as optional parameters (mentioned by Jon)? If not, would definitely see named parameters supported for curried let-bound functions.\r\nThis would remove a fairly common annoying case in pipelines, where I find myself having to use lambda expression (e.g. \"... |> fun param -> someFunc a b param c) instead of partial application (\"... |> someFunc a b c\"), because the pipelined variable isn't the last argument of the function. With named parameter I can use the parameter name to override the parameter order, at the same time increases clarity of code."},{"Submitter":"Richard Minerich","Submitted":"2015-03-12T16:04:00","Content":"It seems like this might ruin the symmetry between tupled function parameters and actual tuples, unless it could be that when you create tuples you can do the same thing, and that seems to come with a host of other problems. What if you could describe function parameters more like records and extend records to allow optional construction parameters?"},{"Submitter":"Richard Minerich","Submitted":"2015-03-12T16:40:00","Content":"Also, would we allow overloading in the context of these special module functions? If not it's still not a replacement for actual static classes."},{"Submitter":"Eric Stokes","Submitted":"2015-12-24T13:26:00","Content":"Coming from OCaml this is by far the thing I most want in F#. I am often forced into using a static class when what I really want is a module containing a type and some operations on that type. I'm not sure I agree that OCaml's optional/labeled implementation is \"too powerful\", for example curried optional arguments could be very useful in a pipeline, it seemed if we forced them to be tupled we'd mostly lose that."},{"Submitter":"Alfonso Garcia-Caro","Submitted":"2016-05-18T07:38:00","Content":"Having this will be tremendously beneficial when parsing TypeScript files to be used by Fable. Currently an extra type must be created to translate module functions in TypeScript with optional or ParamArray arguments."},{"Submitter":"Dave Thomas","Submitted":"2016-05-27T10:11:00","Content":"This would be an excellent addition to the language, using the tupled argument style."},{"Submitter":"Jared Hester","Submitted":"2016-06-28T00:41:00","Content":"related - [/ideas/suggestion-13887384-support-for-named-curried-functions](/ideas/suggestion-13887384-support-for-named-curried-functions.md)"}],"Status":"under-review","Response":null},"5663267":{"Number":"5663267","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Support Provided Union and Record Types","Text":"","Votes":108,"Comments":[{"Submitter":"Jack Pappas","Submitted":"2014-03-22T08:30:00","Content":"What limits you from generating DUs and Records in type providers now? Is the limitation in the F# compiler itself, or in the ubiquitous ProvidedTypes.fs? If it's the latter, this feature could be implemented through a community effort."},{"Submitter":"Keith Battocchi","Submitted":"2014-04-10T08:21:00","Content":"@Jack - it's a compiler limitation (there's no way to provide the metadata that the F# compiler uses to recognize F#-specific types)."},{"Submitter":"mavnn","Submitted":"2014-05-07T04:45:00","Content":"Yes please for this one; let's allow TPs to create idiomatic F# apis!"},{"Submitter":"Don Syme","Submitted":"2016-02-04T12:35:00","Content":"I plan to mark this feature as \"approved in principle\" (it will show as \"planned\"). It would be great if it were done.\r\nHowever, in reality it is both relatively low priority and relatively hard to implement, so I don't expect this to happen any time soon.\r\nFor example, we would have to reverse-map the metadata associated with F#-specific types. This is already done in F# reflection FSharpType.IsRecord and so on."}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Marking as “approved in principle” (it will show as “planned”).\r\nHowever, in reality it is both relatively low priority and relatively hard to implement, so I don’t expect this to happen any time soon.\r\nFor example, we would have to reverse-map the metadata associated with F#-specific types. This is already done in F# reflection FSharpType.IsRecord and so on."}},"5663288":{"Number":"5663288","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Allow type providers to report warnings to the compiler","Text":"","Votes":11,"Comments":[{"Submitter":"Gustavo Guerra","Submitted":"2014-06-28T13:26:00","Content":"Maybe if the class that implements ITypeProvider has a public event named \"WarningGenerated\" or something like that, the compiler could plug into it and listen. It's a bit hack-y, but as there is a canonical implementation of ITypeProvider in TypeProviderForNameSpaces, we could create a method there called \"EmitWarning\", and hide how it's implemented, so there would not be a requirements for a specific FSharp.Core.\r\nUnfortunately, I'm not remembering the case I was thinking about that I wanted to generate a warning on. I think it was in CsvProvider, but can't remember exactly"},{"Submitter":"exercitus vir","Submitted":"2015-06-19T18:01:00","Content":"I also think that this would allow for many more interesting use cases for type providers."}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"This is approved-in-principle for F# 4.x+\r\nA detailed design is needed. I would prefer one that is idiom-based and doesn’t force type providers to use a later FSharp.Core.dll\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"}},"5663298":{"Number":"5663298","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Improve optional parameter interop between F# and C#","Text":"It would be nice if the F# compiler automatically inserted [<Optional;DefaultParameterValue(null)>] in all optional parameters of methods declared in F# classes, so they would be easier to use from C#\r\nIt would also be nice if the constructors of records also used this for parameters of type Option<_>","Votes":20,"Comments":[{"Submitter":"Gustavo Guerra","Submitted":"2014-03-21T08:26:00","Content":"Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4519990-improve-optional-parameter-interop-between-f-and"}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"This proposal is “approved in principle” for F# 4.x+\r\nIf you would like to submit an implementation and testing, please submit to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details about contributing to the F# language and core library\r\nDon Syme, F# Language and Core Library Evolution"}},"5663302":{"Number":"5663302","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Support 'protected' access modifier for F#","Text":"Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2262739-support-protected-access-modifier-for-f","Votes":98,"Comments":[{"Submitter":"Jack Pappas","Submitted":"2014-03-22T08:40:00","Content":"This is one feature I'd really like to see in F#, and it seems like it should be very simple to implement. If the 'protected' modifier was omitted from the language to nudge developers away from OO-style code, I think that may have been the wrong way to go about it, because it makes it impossible to re-implement OO-heavy C# projects in F# in such a way that the change is transparent to any consumers. Consequently, I've had to pass on using F# to replace some C# projects -- the downside of having to re-architect large parts of an existing codebase because F# classes can't declare 'protected' members is very often going to outweigh any upsides that could be had from re-implementing a single project in F#."},{"Submitter":"Blair Davidson","Submitted":"2014-08-04T07:40:00","Content":"Please do this. It make using OOP facilities such in F#."},{"Submitter":"Gauthier Segay","Submitted":"2015-08-05T07:01:00","Content":"I concur that we need fuller support of .net type system."},{"Submitter":"Troy Robinson","Submitted":"2015-08-11T01:30:00","Content":"Scala has it. C# has it. Let's do it! I can't replicate certain classes in my arsenal without it!"},{"Submitter":"Surya Halim","Submitted":"2015-09-10T13:59:00","Content":"I concur with this suggestion. IIRC, one of the reasons given was the access of protected data member defined in base class inside a closure caused very tricky situation because the closure technically should not be able to access the data member. C# solved this through clever compiler trick. Why can't this clever compiler trick be applied to F#? Will it defeat the type soundness of F# as a programming language?\r\nI love F# for being a non-dogmatic functional-first programming language and this missing feature does indeed dampen the expectation a little."}],"Status":"","Response":null},"5663326":{"Number":"5663326","Submitter":"Gustavo Guerra","Submitted":"2014-03-21T00:00:00","Title":"Syntax for turning properties into functions","Text":"When we have F# records and classes (including the ones generated by type providers), we end up having to write things like this a lot:\r\n(fun x -> x.Name)\r\nIt would be nice to have some shorthand for this, similar to what we can do with static members (but nicer than the Scala syntax please)","Votes":457,"Comments":[{"Submitter":"Jon Harrop","Submitted":"2014-03-21T11:29:00","Content":"Doesn't SML use something like #Name?"},{"Submitter":"Loic Denuziere","Submitted":"2014-03-21T11:42:00","Content":"I think (.Name) (with the parentheses) would be readable and non-ambiguous.\r\nOn the other hand, a syntax that includes the class name would mean not having to reorder code to please the type inference."},{"Submitter":"Richard Minerich","Submitted":"2014-03-21T16:49:00","Content":"I don't think this goes far enough. It would be nice to have some kind of first class typed handle to properties so we could more easily compose lenses for updating records as well."},{"Submitter":"Richard Minerich","Submitted":"2014-03-21T18:29:00","Content":"You know, it might just be ideal to have some kind of auto generated lenses as in http://bugsquash.blogspot.com/2011/11/lenses-in-f.html\r\nAlthough, it would be ideal to be able to compose them in such a way as to avoid having to reallocate for each and every update to the same record."},{"Submitter":"Daniel Fabian","Submitted":"2014-03-21T18:43:00","Content":"I agree, that having auto generated lenses would be very nice. However, when we were generating lenses in our project, the mentioned approach turned out to be too weak to be very useful.\r\nWe ended up using partial lenses instead. The idea is, that with partial lenses you can create lenses for a specific case of a DU, as well as a field of a record, a component of a tuple or even an item in a list."},{"Submitter":"Patrick Q","Submitted":"2014-03-22T00:17:00","Content":"This has been on my wish list for quite some time. I don't think the Scalar syntax is that bad, but I would prefer \" # \", as Jon Harrop suggested."},{"Submitter":"Mauricio Scheffer","Submitted":"2014-03-24T19:16:00","Content":"@Daniel Fabian: I don't think you can compare lenses with partial lenses like that... partial lenses are for sums, \"regular\" lenses are for products. You wouldn't use a partial lens for a record field or a tuple. (the definitions I use are the ones in http://dl.dropboxusercontent.com/u/7810909/media/doc/lenses.pdf )"},{"Submitter":"Daniel Fabian","Submitted":"2014-03-25T03:29:00","Content":"With partial lens, I meant { Get: 'T -> 'U option; Set: 'U -> 'T -> 'T }. And it works out perfectly fine also for tuples or records.\r\nThe idea being, we use the partial lenses for zooming somewhere deep into the object graph and then doing an update. Obviously, if you have a product type, the 'U option is not the preferred signature, because you are always in the Some case.\r\nHowever, since our domain model is always a mix between DUs and records, the total lenses from your blog post or FSharpx were too constrained.\r\nWe just considered the lens to be a partial function that may or may not return a value. And when doing an update, the lens may or may not change something, depending on whether or not the lens triggered.\r\nA typical lens would look like this\r\n{ Get =\r\nfunction\r\n| Locator.Point2D (item1, item2) -> Some (item1, item2)\r\n| _ -> None\r\nSet = fun newValue union ->\r\nmatch union with\r\n| Locator.Point2D _ -> Locator.Point2D newValue\r\n| _ -> union }\r\nwe are using this in production and it works very much as desired. The signatures, I took from https://hackage.haskell.org/package/data-lens-2.10.4/docs/Data-Lens-Partial-Common.html\r\nIf you want make a lens for a product type, you just need to wrap it in an additional Some.\r\nAnd then the lens operators from FSharpx we adjusted to take into account the partial functions, so the compose will use Option.bind rather than function composition to compose two lenses, etc. But it works out nicely.\r\nIf you want to get rid of the 'T option, it could even be done so, that you lift a total lens to being a partial one, when combining it with a partial lens. And then with s some operator overloading this would also work out.\r\nWe didn't do this, though, because we use lenses to \"change\" some pre-existing object graph for the most part. And we felt like the occasional unpacking of the option was a small price to pay when compared to the added complexity of having a lot more overloads, adopting total lenses to make them partial etc.\r\nIf we were to extend the compiler though, I think making a distinction between total and partial lenses and properly lifting them on-demand might make sense."},{"Submitter":"Richard Gibson","Submitted":"2014-03-25T05:42:00","Content":"I have always wanted this since I started using Linq some time ago when I wrote .Select(x => x.Name) for the 1000th time and thought \"There must be a shorthand for this - I'm actually reducing readability by giving this lambda variable a name\". I think that naming the variable in this case is giving completely irrelevant information that is actually detrimental to the readability.\r\nConsidering that this is one of the few times where F# is more verbose that C#, List.map (fun x -> x.Name) is even worse.\r\nMy favourite is the syntax that Livescript uses, where you can wrap a dot-access call in parens like it's an operator. The syntax in a complete example would look like this:\r\nlet lengths = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\r\n|> map (.Length)"},{"Submitter":"Richard Gibson","Submitted":"2014-03-25T05:59:00","Content":"Incidentally, Livescript also allows you to do the equivalent of this:\r\n[\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\r\n|> List.filter (.Length >= 4)"},{"Submitter":"Richard Gibson","Submitted":"2014-03-28T11:16:00","Content":"Another possibility for the syntax is to allow us to access instance methods and properties from a static context by passing in the instance as the last parameter. An existing example of this is the String.length property that is defined in the F# standard library, meaning that (given strings = [\"hello\"; \"world\"]) instead of\r\nstrings |> List.map (fun x -> x.Length)\r\nI can write:\r\nstrings |> List.map String.length\r\nThis would also be okay I think"},{"Submitter":"Daniel Fabian","Submitted":"2014-03-28T12:32:00","Content":"You would have to find a way of avoiding ambiguities, though."},{"Submitter":"Bryan Edds","Submitted":"2014-04-10T20:54:00","Content":"I believe the ideal syntax for this in F# would use precisely Loic's suggestion of -\r\n(.Name)\r\nThis should be usable for all the different types of members including record fields, properties, object members, et al. The alternative of -\r\n#Name\r\n- would be confusingly close to SML's, collide with OCaml's object member syntax, and too far afield from F#'s intended syntax."},{"Submitter":"Bryan Edds","Submitted":"2014-04-17T22:04:00","Content":"After further thought, I want to provide an alternative to this suggestion. While the original proposer suggested turning record fields AND class properties into functions, I think only the former should be suggested due to the weakness of the type inferencer.\r\nConsider this -\r\ntype Record = { Member : int }\r\nfun record -> record.Member // This line compiles fine...\r\n(record.Member) // Therefore this syntax should remain a part of this proposal.\r\ntype Class (aMember : int) = let Member = aMember\r\nfun obj -> obj.Member // This line does NOT compile!...\r\n(obj.Member) // Therefore, this syntax should NOT be a part of this proposal.\r\nI think we should concentrate only on getting the syntax working for record fields, and then once that hurdle is cleared, we should consider making the proposed syntax work for the other things that the inferencer is not so handy with.\r\n* While I say the inferencer is weak in this case, I don't mean that as a critique. In fact, I think the weakness is beneficial and necessary to properly idiomatic programming in F#. A lot of people arbitrarily use classes in F# where a record would be more appropriate due to its functional idomaticy. Doing so confounds their API and pollutes the code of its end-users. Having the inferencer punish such practices by requiring noisy type annotations _is a good thing_. In doing so, we come to understand and respect the power of intelligent limitations."},{"Submitter":"Craig Stuntz","Submitted":"2014-06-25T15:55:00","Content":"Related request: Add Lens focus unfocus [/ideas/suggestion-6098767-add-lens-focus-unfocus](/ideas/suggestion-6098767-add-lens-focus-unfocus.md)"},{"Submitter":"Dave Thomas","Submitted":"2014-07-06T03:57:00","Content":"Like Jon mentioned, first class selectors as described here would be perfect: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#records"},{"Submitter":"Dave Thomas","Submitted":"2014-07-06T04:00:00","Content":"The #3 style tuple selector would also be amazing: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#tuples"},{"Submitter":"Anonymous","Submitted":"2014-07-10T06:22:00","Content":"Great suggestion Gustavo - I like the idea of being able to use this shorthand:\r\ntype Something =\r\n{\r\none: int\r\ntwo: int\r\n}\r\nlet ones = someSetOfSomethings |> List.map (.one)"},{"Submitter":"Vladimir Matveev","Submitted":"2014-07-10T18:52:00","Content":"using # as a marker for selectors does not play nice with compiler directives: #identifier at the beginning of the line is used by them. Alternatively we can try to adopt something Scala like: use _.<name>. I've tried to implement it (http://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary?branch=selectors), looks kinda nice."},{"Submitter":"Alfonso Garcia-Caro","Submitted":"2014-09-07T09:13:00","Content":"I would back the idea of having (.Name) just as syntactic sugar (with Intellisense, please) for (fun x -> x.Name)"},{"Submitter":"exercitus vir","Submitted":"2014-10-13T11:02:00","Content":"Of all the suggestions, I like Gibson's last suggestion the most.\r\nList.map String.length\r\nwhere String.Length is the property and String.length the corresponding function. It looks functional, plays nice with type inference and it's unambiguous (because of the lower case). Parenthesis are already too overloaded in F# for my taste.\r\nTo avoid incompatibilities with existing code, it might even be better to indicate explicitly that this is actually an instance method turned into a static method by prefixing it with ` (accent grave) or ^ (circumflex):\r\nList.map String.`length\r\nor\r\nList.map String.^length\r\nso that these \"virtual\" static methods only appear in Intellisense when you type:\r\nString.`\r\nor\r\nString.^\r\nThese \"virtual\" static methods kind of feel like the inverse of C# extension methods, which turn static methods into \"virtual\" instance methods."},{"Submitter":"exercitus vir","Submitted":"2014-10-13T11:04:00","Content":"(...continuing previous post:) Or maybe even:\r\nList.map String#length"},{"Submitter":"Ovidiu Deac","Submitted":"2014-10-25T17:49:00","Content":"My thoughts:\r\n1. The property functions should be namespaced properly to avoid name collisions. For this reason I'm against the approach .PropertyName suggested below\r\n2. For starters doing it for record getters should be easy enough because one cannot define a record like this:\r\ntype Point =\r\n{\r\nx : int\r\ny : int\r\n}\r\n\r\nstatic member x p = p.x\r\n// Error FS0023: The member 'x' can not be defined because the name 'x' clashes with the field 'x' in this type or module (FS0023)\r\n...so if the above static member Point.x is automatically generated it shouldn't break existing code\r\nAs Bryan Edds suggested below, this should also encourage people to use records more instead of classes.\r\n3. I wouldn't bother with the setters for now. The field updates could be considered as a separate feature and it probably needs more consideration.\r\n4. From the syntax perspective I think Point.x looks the most fsharp-ish.\r\n5. If you want to extend that to classes and other functions I like Python approach that member functions are just static functions which take the self instance as the first parameter. This way I the method calls below are identical in Python:\r\nc = MyClass()\r\nc.memberFunction()\r\nMyClass.memberFunction(c)\r\nFor me that's simple and intuitive.\r\nI also like Robert Gibson's suggestion to put the instance parameter last for currying reasons."},{"Submitter":"Bryan Edds","Submitted":"2014-12-23T15:45:00","Content":"To amend my previous comment, I have to say that I quite urgently would also like this functionality to work for non-record property getters now. This is because I now use type extensions to provide syntactically clean getters to dynamic record-style fields like so -\r\ntype Entity with\r\n____member entity.CharacterType = entity?CharacterType : CharacterType\r\n____static member setCharacterType (value : CharacterType) (entity : Entity) = entity?CharacterType <- value\r\nWith this, I can do this -\r\nlet ct = character.CharacterType\r\nand\r\nlet c = Entity.setCharacterType ct c\r\nI know this contradicts what I said earlier, but I need this functionality very badly. Doubly so in the face of needing first-class lenses in F# (that is, support for lensing with F# syntax rather than with a library - tho that is a different subject for the most part)."},{"Submitter":"Scott Wlaschin","Submitted":"2015-01-01T19:36:00","Content":"+1 to the \"(.identifier)\" syntax. Alternatively, extend the preexisting custom prefix operator syntax with (~identifier). You could even use the same syntax to create infix operators the same way, a la backticks in haskell.\r\nFor tuples you could use (.#1) (.#2) etc or if using tildes, (~1), (~2).\r\nAs to name resolution, surely you could use the same scoping rules as for members. That is, if \"x\" is a valid member name in the scope of Point, then (.x) is also a valid name when applied to Points. I don't know how type inference would work though..."},{"Submitter":"Richard Gibson","Submitted":"2015-01-15T05:42:00","Content":"Nice to see you here, Scott!\r\nThis would be a wonderful addition to the language, and I don't see any problem with type inference. (.name) would work wherever (fun x -> x.name) would, e.g.\r\nSeq.map (.name) people // => Not okay\r\npeople |> Seq.map (.name) // => This is just fine\r\nI also have no problem with the tilde syntax. Perhaps then you could drop the parens? E.g.\r\npeople |> Seq.map ~name"},{"Submitter":"luketopia","Submitted":"2015-02-08T18:45:00","Content":"What if we allowed the underscore to represent missing arguments to a member (including the instance), in which case a function for applying those arguments would be produced? Then we could do the following:\r\ncustomers\r\n|> Seq.map _.Name\r\n|> File.WriteAllLines(@\"C:\\CustomerList.txt\", _)\r\nThis would allow us to partially apply ordinary CLR methods with more than one argument, something I have always wanted.\r\nI do still like the .Name syntax without the underscore, but that could be a special case (allow the underscore for the instance to be dropped).\r\nI also think more complex expressions like _.Address.State could be supported. In this case, the entire expression would become a function. This would be distinct from (_.Address).State which would be a compiler error since (_.Address) is its own function."},{"Submitter":"Greg Rosenbaum","Submitted":"2015-03-14T19:15:00","Content":"I think I prefer the #Property syntax, rather than the (.Property) syntax. This is mainly because I don't like extraneous parentheses. ~Property is also possible, but I tend to associate ~ with other things so it's a bit strange.\r\nIt would be great if it could be extended to instance methods, and not just properties. It would make chaining methods and module functions more convenient. Something like:\r\n\"blah\" |> String.replicate 2 |> #Substring 1"},{"Submitter":"luketopia","Submitted":"2015-03-20T20:57:00","Content":"I don't see why the parentheses would be necessary at all. Elm doesn't need them for its record accessor syntax, for instance: http://elm-lang.org/learn/Records.elm#access"},{"Submitter":"Dmítrij Jevgénijevič Ačkásov","Submitted":"2015-07-19T06:43:00","Content":"Dot is an operator probably?\r\n((.)Name)"},{"Submitter":"Jared Hester","Submitted":"2015-09-27T06:45:00","Content":"This functionality does exist in the form\r\n.... let inline _Data x = ( ^a : ( member Data: 'b ) x )\r\nWhich works in situations like -\r\n.... type Bottom = { Data:string }\r\n.... type Middle = { Data:Bottom }\r\n.... type Top = { Data:Middle }\r\n.... let top = { Data = { Data = { Data = \"bottom\" }}}\r\n.... let inline d3 x = ( _Data >> _Data >> _Data ) x ;;\r\n.... d3 top\r\n.... > val it : string = \"bottom\"\r\nThe suggested `.` notation seems like it might cause issues with partial application unless surrounded by parens, so it's probably better to use a different operator as a unary operator on an identifier to create a function like _Data. Some possibilities are\r\n.... ( @. ) ___( @.Data ) <- my favorite option\r\n.... ( .@ ) ___( .@Data )\r\n.... ( @| ) ___( @|Data )\r\n.... ( |@ ) ___( |@Data )\r\n.... ( =| ) ____( =|Data )\r\n.... ( |= ) ____( |=Data )\r\n.... ( |- ) ____ ( |-Data )\r\n.... ( -| ) ____ ( -|Data )\r\n.... ( ./ ) ____ ( ./Data )\r\n.... ( /. ) ____ ( /.Data )\r\n.... ( |. ) ____ ( |.Data )\r\n.... ( .| ) ____ ( .|Data )\r\n.... ( !. ) ____ ( !.Data )\r\n.... ( *@ ) ___ ( *@Data )\r\n.... ( @* ) ___ ( @*Data )\r\n.... ( -@ ) ___ ( -@Data )\r\n.... ( @- ) ___ ( @-Data )\r\n.... ( |* ) ____ ( |*Data )\r\n.... ( *| ) ____ ( *|Data )\r\n( these are all currently valid operators )"},{"Submitter":"Yaar Hever","Submitted":"2015-10-06T20:50:00","Content":"I like the idea of using a bare dot: List.map (.name),\r\nbut I think a better solution would be to have a fixed keyword for creating a lambda whose first and only argument is replaced by something. I've seen the usage of a keyword \"it\" in some language, but I can't remember which one it was.\r\nThis would allow not only: List.map (it.name)\r\nbut also: List.map (funcWithTupleArguments (arg1, arg2, it))\r\nor even: List.map (sprintf \"the square root of %f is %f\\n\" it (sqrt it))"},{"Submitter":"Varon","Submitted":"2015-10-15T07:37:00","Content":"The concept of 'functional properties' has been thoroughly explored under the name of Lenses in the formal side of the FP world.\r\nThere's an existing library that, if mixed with some code generation would probably perfectly work for this purpose. Don Syme has offered some comments relating to naming and usage in the \"Conventions for Lens declarations\" issue. You can read more about this on the github page at https://github.com/xyncro/aether .\r\nIncidentally, this isn't the first time someone's asked for functional properties in F#. Another attempt is visible in the \"Implement first-class lensing / lenses in F#\". This seems to be a generalization of this suggestion.\r\nYou can view this alternative proposal here: [/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f](/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f.md) .\r\nI would suggest that rather than implementing a less general syntactic workaround, we focus on working towards what we need for functional style properties (aka lenses)."},{"Submitter":"Ibrahim","Submitted":"2016-02-23T13:58:00","Content":"I was thinking about this syntax:\r\nlet f = MyType1.Member1\r\nWhere f is equivalent to Member1 with arguments prefix with the 'this' parameter of type 'MyType1'"},{"Submitter":"George","Submitted":"2016-02-29T21:07:00","Content":"Actually there are already partial solutions...\r\nlet Name a = a.Name\r\nThis is a little more exotic and a better explanation of the principals is in the F# language reference pdf and here: http://stackoverflow.com/questions/33161244/in-f-is-it-possible-to-have-a-tryparse-function-that-infers-the-target-type\r\nlet inline id (a:^a) = (^a : (member Id:'b) (a))\r\nEssentially, static type constraints can be used to not only ensure that the parameter has a desired member (or static member) but also apply that member against the parameter to obtain a result."},{"Submitter":"Dax Fohl","Submitted":"2016-03-25T13:07:00","Content":"Not only properties, but members of any kind. (e.g. I just found out about `Seq.map string` instead of `Seq.map (fun x -> x.ToString())` today.)\r\n[/ideas/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur](/ideas/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur.md) seems to enable this but be even more generic, and I think less ugly syntax memorization than \"(%$#) turns a member into a fn\".\r\nThe only downside of that proposal I can see is that it *only* works in lambdas, but I don't see any reason I'd ever want to call a naked `%$#DoSomething myThing` instead of `myThing.DoSomething()` anyway."},{"Submitter":"Abel","Submitted":"2016-09-25T08:17:00","Content":"Your title \"turning properties into functions\" suggests that F# wouldn't have support for this, but you can already do that (get the function accessor of the property):\r\nlet x = classWithNameProperty()\r\nlet f = x.get_Name // x.Name property as a function, f: unit -> string\r\nBut without the syntax decorations proposed in the comments, I don't see how this can be turned into a function if the object is not known (which is the second part of your request).\r\nUnless you need this for many different properties, you can create your own object-less syntax using ducktyping, but this is \"per property\":\r\ntype MyTest() =\r\n    member __.Name = \"foo\"\r\nlet inline name (x: ^a) = (^a: (member Name: string) x)\r\nlet f() =\r\n    Seq.singleton (MyTest())\r\n    |>Seq.map name                // works on any object in the seq with x.Name property\r\nOf course, it would be much nicer to have standard syntax for this."}],"Status":"under-review","Response":null},"5663470":{"Number":"5663470","Submitter":"Eriawan Kusumawardhono","Submitted":"2014-03-21T00:00:00","Title":"Provide covariance/contravariance language support with syntaxes in F# in sync with covariance/contravariance in C#/VB","Text":"Covariance/contravariance has its beginning in CLR 2.0 and also with the introduction of generics in .NET 2.0 (also in F#, C# and VB)\r\nThen in C# 4.0 and VB 10, we have covariance/contravariance supports in the language itself. Currently we don't have support for these covariance and contravariance in F#.\r\nI know it is a runtime feature of CLR 2.0 and 4.0 and I don't want to play catch up with C# and VB.\r\nBut this covariance/contravariance support in C# and VB are powerful to use and also have proven to provide cleaner and clearer ways to understand the code and variances in the types, especially when using parameterized generic types.\r\nThis is not the same as this feedback:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2363794-ocaml-like-variance-annotations-a-and-a-\r\nbut we can use that OCaml syntax as well for starter.\r\nThis feature should also be constrained to only use covariance/contravariance in interfaces and delegates just like in C# and VB, but F# may provide more supports for other types such as events.\r\nAn example of this is the way F# has provided the capability to create extensions to properties and methods, not just methods only in C# and VB.\r\nNOTE: Moved from http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3942302-provide-covariance-contravariance-language-support as suggested by Don Syme.","Votes":149,"Comments":[{"Submitter":"Jon Harrop","Submitted":"2014-03-21T11:40:00","Content":"FWIW, I used OCaml for many years and never once found a use for co/contravariance in real code. There are some corner cases in F# with interop with OO libs like WPF but these are rare IME.\r\nOn a related note, I would like implicit upcast when creating a literal list or array of subtypes like let myControls : Control list = [Label(); Button()]."},{"Submitter":"Jack Pappas","Submitted":"2014-03-23T07:42:00","Content":"This would be a nice feature to have. Even if it were infrequently used in F#-only code, it would be very handy to have when implementing libraries to be consumed from C#.\r\nBTW, F# already does support a bit of contravariance via \"flexible types\". Flexible types don't seem to be used very often except with the 'seq<_>' type; if co-/contra-variance are properly supported in F# (a la C# 4.0), flexible types could be deprecated in favor of the variance annotations.\r\nIf this feature is implemented, I'd prefer it use the C#-style \"in\" and \"out\" keywords instead of OCaml's +/- syntax; I think the keywords are easier to read, they'll stand out when highlighted in an IDE, and it'll make it easier for C# developers to learn F# (or at least, they'll be able to re-use existing knowledge about the in/out keywords)."},{"Submitter":"Eriawan Kusumawardhono","Submitted":"2014-03-24T00:24:00","Content":"Thanks for your nice comment, Jack!\r\nIMHO, this is not just a nice feature to have, but it should be nice to have.\r\nIt's because the nature of F#'s strong typing, therefore it should span to strict and strong covariance and contravariance type.\r\nThese covariance and contravariance support is already supported deep inside the .NET CLR since .NET 2.0, so there should be a strong reason to leverage and promote this powerful runtime feature into language feature, not just C# 4.0 and VB 10 has done."},{"Submitter":"Eriawan Kusumawardhono","Submitted":"2014-03-24T00:25:00","Content":"Pardon my last comment, it should be must have instead of nice to have :)"},{"Submitter":"Mauricio Scheffer","Submitted":"2014-03-27T11:35:00","Content":"As a workaround, some time ago I wrote a little program to add variance annotations to an interface after compilation, though this is only for interop purposes. Of course it doesn't add proper variance support in F#\r\nhttps://github.com/mausch/VariantInterfaces"},{"Submitter":"Bryan Edds","Submitted":"2014-04-08T08:57:00","Content":"Please don't do this. If you look at how badly variances complicate scala code and it's type system while realizing how surprisingly non-useful the feature is in practice (which is precisely as Jon H says), you realize such a feature is a net loss.\r\nIf you're wanting variance for interop, just remind yourself how much smaller this problem is, and how much easier it is to work around, than all the other problems with writing interop code."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-06T08:46:00","Content":"I have run out of votes but this is a nice feature to have +3"},{"Submitter":"Mauricio Scheffer","Submitted":"2014-07-14T12:19:00","Content":"Tweet from Erik Meijer related to this: https://twitter.com/headinthebox/status/487572643714203648"},{"Submitter":"Mark Laws","Submitted":"2015-05-29T05:50:00","Content":"As the tweet from Erik Meijer linked below would suggest, F# lacks this due to its implications for type inference. Don Syme made a post about this same issue nearly ten years ago: http://osdir.com/ml/lang.fsharp.general/2008-09/msg00043.html\r\nIt would be a shame for F# to suffer for the sake of compatibility with a \"feature\" that's a corner case even in C# and VB."}],"Status":"under-review","Response":null},"5663704":{"Number":"5663704","Submitter":"Don Syme","Submitted":"2014-03-21T00:00:00","Title":"Copy-and-update on class types and on records of different types.","Text":"People sometimes find it hard to transition from records to class types - something which comes up when seeking to encapsulate some of the details of the record type.\r\nOne particular reason for this is because their codebase may uses copy-and-update on record types. One approach to easing the transition would be to support copy-and-update on class types, as long as the class type follows a particular design pattern.\r\nOne pattern-based approach could permit both normal record syntax and copy-and-update syntax, e.g.\r\n[<RecordSyntax>]\r\ntype R(a:int, b:int) =\r\nmember x.A = a\r\nmember x.B = b\r\nmember x.C = f(a,b)\r\nwith\r\n{ a = e1; b = e2 } --> R(a=e1,b=e2}\r\n{ r with a = e1} --> R(a=e1,b=r.B)\r\nWhether there were one or two attributes (one for 'RecordSyntax' and one for 'CopyAndUpdateSyntax') would be up for discussion. Presumably using either attribute would give result in a declaration-time check that members exist to match constructor arguments.\r\nMatching uppercase properties to lowercase argument names is somewhat inelegant but in the balance is likely to be a reasonable price to pay for following .NET and F# design norms.","Votes":25,"Comments":[{"Submitter":"Richard Minerich","Submitted":"2014-03-21T16:53:00","Content":"As you know, I've certainly been bitten by this before. The other option would be to extend the record syntax a bit so that they can do most of the same things classes can already do."},{"Submitter":"Will Smith","Submitted":"2014-03-21T18:10:00","Content":"If it can be extended or tweaked a little, this would be useful for structs as well. I'm currently having to do this: https://github.com/TIHan/FQuake3/blob/f6ad8a5809db7d57961a55ffd93e1ba0de85dde7/lib/FQuake3.Utils/src/FQuake3.Utils/math.fs#L117 to get a similar effect. Though, there are more than one possible constructors, which may throw a wrench in this..."},{"Submitter":"Jon Harrop","Submitted":"2014-03-26T05:24:00","Content":"FWIW, OCaml has functional object update.\r\n@WillSmith: Looking at your code I'm thinking you would want the ability to mark a record type as struct."},{"Submitter":"Will Smith","Submitted":"2014-03-26T10:11:00","Content":"Jon,\r\nI guess that is pretty much what I would want.\r\nThough, I am wondering how multiple constructors would work though in regards to using the record syntax."},{"Submitter":"Don Syme","Submitted":"2016-02-03T13:16:00","Content":"See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6124011-easier-to-copy-data-between-records-of-different-t#comments"},{"Submitter":"Don Syme","Submitted":"2016-02-03T13:16:00","Content":"C# is looking into allowing \"with\" on the proposed C# record types. What ever we do here would best align with that."}],"Status":"","Response":null},"5663709":{"Number":"5663709","Submitter":"Nelak","Submitted":"2014-03-21T00:00:00","Title":"Add support for implicit operators to facilitate language interop","Text":"Add support for implicit operators to facilitate language interop instead of having to write an explicit operator like:\r\nhttp://stackoverflow.com/questions/10719770/is-there-anyway-to-use-c-sharp-implicit-operators-from-f","Votes":15,"Comments":[{"Submitter":"Richard Minerich","Submitted":"2014-03-21T16:51:00","Content":"Please no, I don't want any implicit conversions ruining my type safety."},{"Submitter":"Daniel Fabian","Submitted":"2014-03-22T03:22:00","Content":"I agree, the work-around with a local operator using duck-typing seems like a small cost, when compared to losing the very strong typing we have right now."},{"Submitter":"Nelak","Submitted":"2014-03-22T12:53:00","Content":"I'm not proposing to relax strong typing but to add someway to ease language interop.\r\nI don't see why we can't have something like an [<AllowImplicit>] that would be able to handle implicit operators without sacrificing type safety. In this way you need to opt-in for the desired behaviour\r\ne.g.:\r\n[<AllowNull>]\r\nThe null keyword is a valid keyword in the F# language, and you have to use it when you are working with .NET Framework APIs or other APIs that are written in another .NET language. The two situations in which you might need a null value are when you call a .NET API and pass a null value as an argument, and when you interpret the return value or an output parameter from a .NET method call."}],"Status":"","Response":null},"5663774":{"Number":"5663774","Submitter":"Jorge Fioranelli","Submitted":"2014-03-21T00:00:00","Title":"Remove fun keyword from lambda expressions","Text":"Maybe make it optional?\r\nOtherwise it is more verbose than C#.","Votes":267,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2014-04-04T01:39:00","Content":"I personally like the current syntax."},{"Submitter":"Mastr Mastic","Submitted":"2014-04-09T04:07:00","Content":"Should be optional, not removed (otherwise code will break).\r\nAnd I'm all for it.\r\nIt happens to me countless of times that I forget it because my mind just always expects better."},{"Submitter":"Brian","Submitted":"2014-07-06T08:47:00","Content":"Seems like it would complicate the language a lot to make it optional. If we were starting from scratch though I'd support it. I would like to hear about what the reasoning behind requiring \"fun\" for lambda's. Was it simply because it was in OCAML? or was there other technical reasons?"},{"Submitter":"Tahir Hassan","Submitted":"2014-07-25T05:59:00","Content":"I agree, it looks horrible. C# has a much better lambda syntax, imho.\r\nPotentially we could use Haskell's backslash:\r\n[1;2;3] |> Seq.map (\\x -> x * x)\r\nAlthough it ain't as perfect like C#'s, it would work without making the language ambiguous."},{"Submitter":"Michael","Submitted":"2014-09-07T18:34:00","Content":"I really like the fun keyword."},{"Submitter":"Grant Crofton","Submitted":"2015-02-14T12:09:00","Content":"Would certainly improve our code golf scores a little! :-)"},{"Submitter":"Filip Kopecký","Submitted":"2015-06-20T17:49:00","Content":"I think it would be nice if we could write anonymous functions like expressions. The compiler could tell it is a function based on undeclared variables being used.\r\n(fun x y -> x + y)\r\n(x + y)"},{"Submitter":"Андрей Чебукин","Submitted":"2015-07-19T18:33:00","Content":"I agree that it is too long and actually moving to C# syntax would be reasonable.\r\nHowever current syntax allows to introduce a snippet for lambda that looks natural\r\nType fun, press tab (or just space in case of CodeRush) and fun is almost ready for you."},{"Submitter":"Andreas Vilinski","Submitted":"2015-08-06T00:45:00","Content":"You wanna take the fun out of F#!\r\nIt is not always needed. Often you can write ((+) y) instead of (fun x -> x + y). For other cases I have a R# live template expansion, which just adds me an arrow and braces, defined like here:\r\nfsfun ==> (fun x -> $END$)\r\nHowever it would be nice to map list of pairs like in Scala: List.map (_ + _)"},{"Submitter":"Anonymous","Submitted":"2016-01-16T01:29:00","Content":"I think we should preserve the fun keyword to be backward compatible, however\r\nI really like the Elixir shorthand lambda expressions:\r\n1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum\r\nYou can for example make\r\nfun x y z -> x + y + z\r\ninto\r\n&(&1 + &2 + &3)\r\nit is not that much shorter, but it frees the programmer from thinking about what to name all those pesky variables.. just like the pipeline frees the programmer from making up a lot of variable names..."},{"Submitter":"Maciej J. Bańkowski","Submitted":"2016-01-17T09:42:00","Content":"to some Anonymous: variable names are important\r\nif you are lazy enough to name variables $1 $2 $3 then just name them a b c - it is even shorter.\r\nBesides, names do matter for maintainability. 2-3 months from now, nobody will know what the original programmer indented to do - names help.\r\nOn topic: It would be so cool to get rid of the 'fun' keyword and make lambdas as sexy as those in C#. However, I doubt it is possible due to statement evaluation logic of F# and ambiguity that would arise without some arbitrary discriminator for lambda expression.\r\nIn C# lambdas are clear from the context and I am not sure F# context is rich enough to get by without the 'fun' keyword but maybe it is - would be awesome."},{"Submitter":"Will Smith","Submitted":"2016-02-11T18:46:00","Content":"I like what we currently have. It isn't that much more verbose than C#. In a way, it seems easier to spot out lambdas in a codebase when you see 'fun'."},{"Submitter":"Ideaflare","Submitted":"2016-04-11T14:40:00","Content":"I agree with Mastr Mastic, instead of removing it to make it optional.\r\nSomething else that could also be made optional is the let keyword."},{"Submitter":"Alan Ball","Submitted":"2016-08-08T09:21:00","Content":"In response to those who enjoy typing fun, and seeing fun, I do not think the language maintainers would break existing code. The reasonable way to interpret the requirement is to interpret it as optional. I personally think this might be nice. I'm sure there is a clean way to make this work. I would personally prefer the => syntax if possible, simply because many many languages currently use that, including C#."},{"Submitter":"Mohsin Syed","Submitted":"2016-09-15T14:48:00","Content":"looks verbose. Removing would make lambda looks cleaner."},{"Submitter":"Anonymous","Submitted":"2016-09-27T22:02:00","Content":"I think the optional use of the fun keyword would be the way to go as well. Just like in React in ES6 the function keyword is no longer necessary"}],"Status":"","Response":null},"5664242":{"Number":"5664242","Submitter":"Daniel Fabian","Submitted":"2014-03-21T00:00:00","Title":"Simulate higher-kinded polymorphism","Text":"F# already has to make trade-offs when doing interop, e.g. it is possible to create a null value for a DU from C#, erased type providers don't work from anywhere but F# etc. Maybe F# could allow for higher-kinded polymorphism within F# code and use dynamic casts at runtime or maybe statically resolved inlining to simulate higher-kinded polymorphism.","Votes":490,"Comments":[{"Submitter":"Don Syme","Submitted":"2014-03-21T12:38:00","Content":"I think \"until the CLR finally supports it\" should be deleted from the title. To my knowledge there is no prospect of the CLR supporting HK polymorphism in any timeframe that matters for the purposes of this discussion."},{"Submitter":"Lev Gorodinski","Submitted":"2014-03-24T08:23:00","Content":"This would be very useful for higher-order functional programming, along with, to a lesser extent, something like either Scala implicits or Haskell type classes. This can be a slipper slope though - should higher-kinded currying also be supported (aka partially applied type parameters)? If not part of the type system at the core, should F# resort to Scala type lambdas?"},{"Submitter":"Mauricio Scheffer","Submitted":"2014-03-24T21:24:00","Content":"The best simulation of higher kinds I know is the technique explained in http://www.nut-cracker.com.ar/ . Work on this ended up in two libraries: FsControl ( https://github.com/gmpl/FsControl ) and FSharpPlus ( https://github.com/gmpl/FSharpPlus ), which builds on FsControl.\r\nIt's not perfect by any means (I need to finish a series of posts about it), but I'm already using it in production, and it works just fine (at least the parts I'm using).\r\nOf course, it would be much better if F# had explicit support for this."},{"Submitter":"Hodza Nassredin","Submitted":"2014-06-27T00:28:00","Content":"We can emulate some restricted form of Higher-Rank Polymorphism in c# for single inheritance pattern. For example function with forall https://gist.github.com/hodzanassredin/4de8fc7bbfbf4bb7dfa7 more details and monad and monad transformers are here http://hodzanassredin.github.io/2014/06/21/yet-another-monad-guide.html"},{"Submitter":"Hodza Nassredin","Submitted":"2014-06-27T03:11:00","Content":"Added some example how we can automatically translate code like this into c#:\r\npublic static List<A> Wrap(Func<A, List<A>> f, A val) forall A{\r\nwhere A : IConstraint\r\nreturn f(val);\r\n}\r\nhttps://gist.github.com/hodzanassredin/eb0aa76f48e37cbcc87f"},{"Submitter":"John Azariah","Submitted":"2014-09-07T07:37:00","Content":"1) Even without higher-kinded currying, being able to abstract over Monads and Functors without losing type inference would be pretty helpful. Doing that kind of thing in Scala is pretty painful.\r\n2) I'm not sure we need to include Scala-style implicits! I find them a way to reduce the transparency of the code and severely affect the ability to comprehend the code - although it may simply be my naivete!"},{"Submitter":"Anonymous","Submitted":"2014-11-13T01:04:00","Content":"Since .Net is open-sourced, and they are open to PR, let us all push this request to https://github.com/dotnet/corefx and make this the most important feature for F# be realized."},{"Submitter":"Phylos","Submitted":"2015-01-06T23:32:00","Content":"In a recent Reddit post related to F# adoption, I saw a great comment from \"TarMil\" on higher kinds that I believe is worth repeating to illustrate their usefulness. Here is that comment in full ...\r\n\"Basically higher kinds are a type system for types: just like a value has a type, a type has a kind. And just like a function can take other values as arguments, a type variable can take other types as parameters. So where in F# you can have a parameterized type T<'a>, in Haskell the T part itself can be a type variable.\r\nFor an example of the usefulness, see how in F# we have a whole bunch of similar functions:\r\nList.map : ('a -> 'b) -> list<'a> -> list<'b>\r\nArray.map : ('a -> 'b) -> array<'a> -> array<'b>\r\nSeq.map : ('a -> 'b) -> seq<'a> -> seq<'b>\r\nOption.map : ('a -> 'b) -> option<'a> -> option<'b>\r\nEvent.map : ('a -> 'b) -> Event<'a> -> Event<'b>\r\n// Not in the standard library, but easy to implement:\r\nAsync.map : ('a -> 'b) -> Async<'a> -> Async<'b>\r\n// etc.\r\nIn Haskell, you can have a single function fmap, whose type (with an F#-like syntax) would be:\r\nfmap : ('a -> 'b) -> 'T<'a> -> 'T<'b>\r\nwhere (again in a hypothetic F#-like syntax):\r\n'T : Type -> Type\r\n// 'T takes a type as parameter and returns a type\r\nand this function has different implementations for different 'Ts. You can then use this function to write your own functions that can be called on any \"mappable\" type, and will do the right thing according to the type of the value passed.\r\n(I gave the example in Haskell because the way to do this in OCaml is more convoluted.)\""},{"Submitter":"Greg Rosenbaum","Submitted":"2015-03-14T17:57:00","Content":"This can only be practically implemented using statically resolved inlining (or reflection) because of constraints in the IL type system (this is where reified generics bites you in the ass!). Here is what an fmap function (as described by phylos) might look like:\r\nhttps://gist.github.com/Springwight/0368e8e7d7aec8b77e68\r\nI really don't see it as a technical challenge though, considering how much effort has already gone into the inlining system. It's more like, \"do we need to see this in the language?\" It's something that's very unlikely to be used by anyone except library developers, but it will help those library developers a lot."},{"Submitter":"exercitus vir","Submitted":"2015-06-18T14:43:00","Content":"Any comment from Don Syme or the F# Software Foundation Language Group on the chances of simulating higher-kinded polymorphism in the near future?\r\nI think this is a really important feature. Many expert functional programmers forego F# because they think can't take a language serious that does not have it. The F# community is losing a lot of potential expert functional programmers do to this."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2015-07-13T09:00:00","Content":"Also a feature request with this many votes should not be ignored. Otherwise why go through all this Uservoice exercise."},{"Submitter":"Alexander Sidorenko","Submitted":"2015-08-03T05:44:00","Content":"CoreCLR is open-sourced, someday someone will do PL which adds HKT to CLR :) we just need to wait or do it yourself :)"},{"Submitter":"George","Submitted":"2016-03-01T12:00:00","Content":"This may do the trick...\r\nhttps://github.com/gmpl/FsControl"},{"Submitter":"Tobias Burger","Submitted":"2016-04-12T04:02:00","Content":"For reference here is the discussion of HKP in the roslyn issue tracker: https://github.com/dotnet/roslyn/issues/2212"},{"Submitter":"exercitus vir","Submitted":"2016-07-09T09:47:00","Content":"I just want to repeat my question from about one year ago, because I would really appreciate some comments (concerns, feasibility, effort) from the F# team on this:\r\n\"Any comment from Don Syme or the F# Software Foundation Language Group on the chances of simulating higher-kinded polymorphism in the near future?\r\nI think this is a really important feature. Many expert functional programmers forego F# because they think can't take a language serious that does not have it. The F# community is losing a lot of potential expert functional programmers [because of this].\"\r\nThis issue being more than 2 years old requires some kind of official response. Either decline it or approve it in principle, but not answering just keeps our hopes up and keeps our votes from being used for other feature requests."}],"Status":"","Response":{"Responded":"2014-03-21T00:00:00","Text":"removed “until the CLR fully supports it” from title"}},"5664643":{"Number":"5664643","Submitter":"Richard Minerich","Submitted":"2014-03-21T00:00:00","Title":"Add support for GADTs","Text":"Generalized Algebraic Data Types essentially extend standard union types to allow different generic instantiations when defined recursively.\r\nYou can see a simple explanation of how they work in haskell here: https://en.wikibooks.org/wiki/Haskell/GADT\r\nThey open the door to such fantastic type safe data structures as heterogeneous lists and so can vastly improve type safety within the language.","Votes":219,"Comments":[{"Submitter":"Radek Micek","Submitted":"2014-04-21T15:31:00","Content":"I don't think that benefits of GADTs outweight how they complicate type system and type inference (you may lose principal-type property).\r\nBTW: you can do heterogeneous lists without GADTs.\r\nBTW 2: you may be interested in Guarded Algebraic Data Types - http://gallium.inria.fr/~fpottier/publis/simonet-pottier-hmg-toplas.pdf"},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-06T08:49:00","Content":"Since OCaml has this I don't see why not F#"},{"Submitter":"Don Syme","Submitted":"2014-07-04T06:48:00","Content":"There are some relevant commments here too: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6062821-add-dependent-types"},{"Submitter":"Don Syme","Submitted":"2016-02-03T12:45:00","Content":"A major consideration is that GADTs are difficult to compile to .NET IL efficiently. Specifically, it is not possible to recover an existentially-hidden type variable except via virtual dispatch. For example\r\ntype C\r\ntype D<T> : C\r\nIf we have a C, a GADT implementation may \"know\" that for certain cases T has certain values, or decomposes in certain ways. But you can't implement this in .NET IL generics - you have to use reflection to recover the value of T and instantiate the branch code with a specific value. Russo and Kennedy had a proposal for what to do about this for C#.\r\nThis is a significant blocking factor for adding this to F# - GADT code would need reflection and would be less efficient."}],"Status":"","Response":null},"5664936":{"Number":"5664936","Submitter":"Petr Onderka","Submitted":"2014-03-21T00:00:00","Title":"Implement IReadOnlyCollection<'T> in list<'T>","Text":".Net 4.5 has a new type IReadOnlyCollection<'T> and list<'T> (a.k.a. FSharpList<'T>) fits this interface precisely, so I think it should implement it.\r\nOriginal on VS uservoice: http://visualstudio.uservoice.com/forums/121579/suggestions/2902147","Votes":3,"Comments":[{"Submitter":"Mauricio Scheffer","Submitted":"2014-03-24T19:46:00","Content":"Workaround:\r\nmodule List =\r\nlet asReadOnlyList (this: _ list) =\r\n{ new System.Collections.Generic.IReadOnlyList<_> with\r\nmember x.GetEnumerator() = (this :> _ seq).GetEnumerator()\r\nmember x.GetEnumerator() = (this :> System.Collections.IEnumerable).GetEnumerator()\r\nmember x.Count = this.Length\r\nmember x.Item with get i = this.[i] }"},{"Submitter":"Brandon D'Imperio","Submitted":"2015-04-23T12:39:00","Content":"nice work-around Mauricio"},{"Submitter":"Don Syme","Submitted":"2015-07-18T13:34:00","Content":"This seems entirely reasonable (we really should have done it n the FSharp.Core 4.4.0.0 revision)"}],"Status":"planned","Response":{"Responded":"2015-07-18T00:00:00","Text":"This is approved for inclusion in a future release of the F# core library subject to an implementation.\r\nA pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp.\r\nDiscussion of the particular version where this is included can be started once an implementation is available.\r\nDon Syme, F# Language and Core Library Evolution."}},"5665042":{"Number":"5665042","Submitter":"Ryan Riley","Submitted":"2014-03-21T00:00:00","Title":"Allow extension interfaces","Text":"Rather than just supporting single methods or properties, provide a mechanism by which to implement interfaces on existing types. This could be similar to protocols in Clojure and Elixir.","Votes":92,"Comments":[{"Submitter":"Richard Minerich","Submitted":"2014-03-21T16:54:00","Content":"If only I had more votes to give. This would be interop between various libraries a million times better."},{"Submitter":"Jack Pappas","Submitted":"2014-03-22T09:08:00","Content":"This is an interesting idea, and I can think of some times in the past where it would have been useful.\r\nI could be mistaken, but after thinking it over a bit, it seems like this could only work for non-sealed classes; trying to extend sealed classes or value types would lead to issues when interoperating with non-F# code. Extending base classes or interfaces seems possible but very tricky to get right. For example, if you extended a base class which has some derived types, the F# compiler would have to create backing classes (in the compiled assembly) for the base class and any of the derived classes you used in your F# code, just to make sure the 'derives-from' and 'implements' relationships still hold correctly from the POV of any outside code."},{"Submitter":"Daniel Fabian","Submitted":"2014-03-22T12:47:00","Content":"In all fairness, don't object expressions already face pretty similar problems? This could be some sort of automatic implementation of object expressions using delegation."},{"Submitter":"Daniel Fabian","Submitted":"2014-03-23T03:40:00","Content":"I was thinking more about it a little more and I think, it could be done with some special object expression syntax. Something like\r\nlet myObj = MyClass() // does not implement the interface\r\nlet myAdoptedObj = { new IMyInterface on myObj } // if MyClass already has all the functions needed for the interface\r\nlet myAdoptedObj2 = { new IMyInterface on myObj with member x.MyAdditionalMemberOnlyPresentInTheInterface() = () } // if MyClass maybe implements half of the interface and we would like to add the second half. It is possible to use the existing object's methods as a default, but we can provide custom implementations for methods, that are missing or we can hide / override present methods on the object.\r\nAnd because type inference probably would work (it works for object expressions for the generic argument at least), one might introduce a function\r\nlet adopt x = { new _ on x }\r\nlet result = adopt myObj |> funcThatWantsMyInterface\r\nin this hypothetical syntax, { new IMyInterface on myObj } is a short-hand for\r\n{ new IMyInterface with member x.method1 = myObj.method1; member x.method2 = myObj.method2 }\r\nnot unlike the record copy syntax."},{"Submitter":"Jack Pappas","Submitted":"2014-03-23T12:07:00","Content":"Daniel -- no, object expressions don't face the same problems, because they're only required to implement the interface. The problems with these proposed extension interfaces is that they need to have a type which matches both the class being extended and the interface(s) being added. This is the reason it's impossible for this to work with sealed classes and value types, or unsealed classes which have internal/protected constructors.\r\nThe only way I can think for this to work (unless I've misinterpreted Ryan's intentions) is that by extending existing types with these new interfaces, you'd basically just be making a shortcut for using object expressions somewhere else in your code. In other words, the compiler would not actually create a new type derived from the type being extended and the interfaces, but would in fact create a static method (in some module) which takes an instance of the type being extended and internally uses an object expression to produce an instance of the interface which was \"added\" to the type. It would then need to insert a call to this method into any call sites where instances of the interface were expected and you'd passed an instance of the type being extended."},{"Submitter":"Daniel Fabian","Submitted":"2014-03-23T12:28:00","Content":"Maybe I misunderstand the use-case here then. I thought the issue is, that you have a type that would be structurally compatible with an interface, but does not actually implement the interface.\r\nNow if a function requires an in instance of said interface, you cannot pass the object in question, because it does not implement the interface.\r\nSo you either interface your type with the interface, or you need to create an object expression delegating all the methods to the underlaying object. The first option makes implementing the interface easy, but it has to be done beforehand and cannot be don't when retrofitting existing (library) types. Also in the latter case, you do not need to take into account a lot of complicated inheritance hierarchies, because, you are implementing the interface through delegation instead of inheritance.\r\nIf I misunderstood the use-case, maybe the idea with extending the object expression syntax should be moved into a separate freature request."},{"Submitter":"mavnn","Submitted":"2014-06-03T10:06:00","Content":"I'm out of votes, unfortunately. This would be pretty awesome, however. Alternatively, something similar to member constraints where you could say \"anything that matches the signature of this interface\" as a constraint."},{"Submitter":"Ryan Riley","Submitted":"2014-06-03T10:35:00","Content":"Here's a quick sample of the current problem: https://dotnetfiddle.net/vm2CJ6"},{"Submitter":"Ryan Riley","Submitted":"2014-06-03T10:50:00","Content":"@mvann: Something like assembly neutral interfaces without the need for an actual interface implementation that also accepts type extensions would also satisfy me, though I would much prefer the stronger contract afforded by interfaces."},{"Submitter":"Mauricio Scheffer","Submitted":"2014-06-03T11:04:00","Content":"FsControl ( https://github.com/gmpl/FsControl ) is a workaround that does this *now* with the current F#.\r\n@Ryan for your concrete problem, FsControl has the ToString \"type method\": https://github.com/gmpl/FsControl/blob/master/FsControl.Core/Converter.fs#L98\r\nAnd it even does constraining for parametric types, i.e. like Haskell's Show a => Show (Maybe a)"},{"Submitter":"Ryan Riley","Submitted":"2014-06-24T10:48:00","Content":"Thanks all for your comments. FsControl is pretty great, and I'm using it now. I don't think sealed classes are a complete blocker, though they probably make performance a pain. See https://groups.google.com/d/msg/fsharp-opensource/ar8-lbRlTwQ/JzFakHTt1dgJ for an example. As Paul discovered, you can actually use object expressions to append interfaces, though I'm quite certain this won't last long using persistent data structures without doing something to change the module or type functions of the persistent data structures themselves. Consider, for example, the list type."},{"Submitter":"Phil de Joux","Submitted":"2014-11-09T15:34:00","Content":"Here's a concrete example from https://github.com/ServiceStack/ServiceStack/wiki/Error-Handling\r\n\"In addition to the above options, you can override the serialization of ad-hoc exceptions by implementing the IResponseStatusConvertible.ToResponseStatus() method and have it return your own populated ResponseStatus instance instead.\"\r\ntype StatusResponse =\r\n{mutable Status : ResponseStatus}\r\ninterface IHasResponseStatus with\r\nmember x.ResponseStatus\r\nwith get () = x.Status\r\nand set (v) = x.Status <- v\r\nexception StatusExn of StatusResponse\r\ntype StatusExn with\r\n//interface IResponseStatusConvertible\r\nmember x.ToResponseStatus () : StatusResponse = x.Data0"},{"Submitter":"Phil de Joux","Submitted":"2014-11-09T15:42:00","Content":"Classes derived from Exception declared using \"exception of\" are sealed."},{"Submitter":"exercitus vir","Submitted":"2015-06-13T01:26:00","Content":"Regarding this implementation I'd like to elaborate on what Jack Pappas said: Implementing an extension interface, would generate an adapter type and an adapter function that adapts the extended type to the same extension interface while making it appears identical to the extend type. This means that adapter type would need to inherit the extended type with all its interfaces in addition to implementing the new interface. IComparable must also be implemented to return the same result as the extended type. The only restriction is that this does not work with to-be-extended types that cannot be inherited from."},{"Submitter":"Kurt","Submitted":"2015-07-06T02:39:00","Content":"And now, protocols in Swift. https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html\r\nThey are a tasteful design of retro-active interface implementation in a language that seems to have much the same philosophy as F#.\r\nProtocols are extremely powerful, not so much for apps but in library design I've missed them often."}],"Status":"","Response":null},"5665355":{"Number":"5665355","Submitter":"Khan Thompson","Submitted":"2014-03-21T00:00:00","Title":"Add syntactic sugar for functions ala Scala/Clojure","Text":"Add in shorthand syntax for anonymous functions, even if it is only for single argument functions.\r\nFor example:\r\n[1; 2; 3; 4] |> List.map (_ + 1)\r\nAs opposed to\r\n[1; 2; 3; 4] |> List.map (fun i -> i + 1)\r\nIt would be great to have this shorthand so that our anonymous functions are shorter than the C#ers' :).","Votes":37,"Comments":[{"Submitter":"Gustavo Guerra","Submitted":"2014-03-21T18:13:00","Content":"This is the same as this one: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663326-syntax-for-turning-properties-into-functions\r\n(your tittle is actually better, but there's already a bunch of votes there)"},{"Submitter":"Jon Harrop","Submitted":"2014-03-26T09:50:00","Content":"@Gustavo: I think this is a separate idea. That idea was just a shorthand for a lambda that just invokes a property like (fun foo -> foo.Name) could be #Name. This idea is more general. You could do (_.Name) but with this you can also do (_ + 1) as a shorthand for ((+) 1).\r\nFWIW, Mathematica has the shorthand notation #+1& for this where # is an anonymous argument in an anonymous function that ends with &. The syntax really is quite hideous!"},{"Submitter":"Jon Harrop","Submitted":"2014-03-26T09:52:00","Content":"Mathematica can also do multivariate anonymous parameters in anonymous functions. So (fun (x, y, z) -> x*y+z) can be written #1*#2+#3& in Mathematica."},{"Submitter":"Bryan Edds","Submitted":"2014-03-27T22:03:00","Content":"This is silly. You have many alternative options -\r\n[1; 2; 3; 4] |> List.map ((+) 1)\r\n[1; 2; 3; 4] |> List.map (add 1) // where add = (+)\r\n[1; 2; 3; 4] |> List.map incr // where incr n = n + 1\r\nThese are all equivalent and good enough."}],"Status":"","Response":null},"5665432":{"Number":"5665432","Submitter":"Jon Harrop","Submitted":"2014-03-21T00:00:00","Title":"Make FSharp.Core collection functions for Array.Parallel more regular","Text":"In F# 3.0, lots of standard functions are missing from Array.Parallel including tryFindIndex, exists, forall, filter, tryFind, reduce, minBy, maxBy and tryPick. A mapReduce function would also be useful.\r\nEfficient implementations of all of these have been described in the F# Journal. http://fsharpnews.blogspot.co.uk/2013/01/parallel-aggregates.html","Votes":63,"Comments":[{"Submitter":"Don Syme","Submitted":"2016-02-04T12:41:00","Content":"I am going to mark this as \"approved in principle\". That is, we would accept design additions with well-tested implementations of coherent subsets of these functions.\r\nIf someone would like to submit a PR for these that would be great."}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Approved in principle subject to RFC and well-tested implementation being submitted as PR."}},"5669367":{"Number":"5669367","Submitter":"Mastr Mastic","Submitted":"2014-03-23T00:00:00","Title":"Allow Implicit Interface Implementation","Text":"F# only supports explicit interface implementation with the price of unnecessary and excessive casting (also causes readability issues), potential confusion when working with other languages, and causes limitation with F#'s OOP that could be resolved without any major language change.\r\nTo expand on this, this post by Mauricio Scheffer describes the issue very well: http://bugsquash.blogspot.co.il/2009/01/implementing-interfaces-in-f.html\r\nIn addition, I'm sure I could argue that people would prefer to just write `identifier.Member` rather than `(identifier :> Type).Member` whenever the member is a signature provided by an interface.\r\nThis repeats quite a bit on average and it is messy, to say the least.\r\nIt should also be pointed out that even though F# is primarily functional (and interfaces are less of an issue), F# code is still being used from other languages, and also some domains and tasks could be easier to take on from an OO approach.\r\n(I am also finding very high limitations with using WPF & XAML with some MVVM approaches)\r\nCurrently the workaround would be to copy-paste the signatures for every member of an interface.","Votes":133,"Comments":[{"Submitter":"Jack Pappas","Submitted":"2014-03-23T07:45:00","Content":"I personally prefer the requirement for explicit interface implementation and would like to continue to enforce that requirement in my own codebase, so if this feature were implemented I would like to have a compiler option to disable it (or perhaps, it should be disabled by default and activated by a compiler flag)."},{"Submitter":"Mastr Mastic","Submitted":"2014-03-23T08:20:00","Content":"I'd like to expand a bit further on what I've mentioned about WPF and MVVM.\r\nThis issue makes F# not reliable for your view-models because other than being cumbersome and tedious (`{Binding Property}` becomes {`Binding Path=(namespace:InterfaceType.Property)}` for each property.\r\n(You have to type `Path=` to avoid an exception)) it also introduces limitations.\r\nFor instance, one limitation that shows up frequently is that WPF DataTemplates do not support interfaces, yet passing an interface is your only way to expose your members because they are explicit.\r\n(See: http://stackoverflow.com/a/327993/825637)"},{"Submitter":"Mastr Mastic","Submitted":"2014-03-23T11:17:00","Content":"@Jack Pappas No worries there I think, this pretty much has to stay as default for the language so not to break existing-code (which I'm sure is one primary concern for the F# team).\r\nI do like the idea of the compiler flag very much and also I think attributes, keywords, or different syntax would be required to get more specific from one instance to another within the same compilation.\r\nThanks for your input."},{"Submitter":"Jack Pappas","Submitted":"2014-03-23T11:44:00","Content":"@Mastr Mastic Admittedly, I do very little GUI programming, so I haven't run into the situation you described. The additional explanation you added makes a lot of sense, and I think you've made some good arguments for why this feature *should* be implemented. This would be a big change to the language though, and might also pose some challenges w.r.t. to type inference, so the more examples you can provide where the current behavior (explicit interface implementations only) is holding you back, the better."},{"Submitter":"Reed Copsey, Jr.","Submitted":"2014-08-04T19:30:00","Content":"I'd very much like this - and have run into this issue with WPF myself.\r\nMy preference would to allow this via an attribute like many other features - something like:\r\ninterface [<ImplicitInterface>] ISomeInterface with\r\nmember __.Foo = 42\r\nThis would align with how [<AbstractClass>] and similar are handled."},{"Submitter":"Paul","Submitted":"2014-09-09T17:38:00","Content":"I personally prefer the requirement for explicit interface implementation. But if you’re using WPF and not providing a proxy to allow WPF to access to a chosen interface an attribute like CLIMutableAttribute would be better. This would cause the decorated interface to additionally be compiled to Common Language Infrastructure (CLI) representation implicitly (but not exposed to f# code), allowing WPF binding to work. CLIMutableAttribute was added to F# 3.0 and adding this related attribute (called something like CLIImplicitInterface) to F# 4.0 would be a great addition, which would ease GUI development with F#.\r\nhttp://msdn.microsoft.com/en-us/library/hh289724(v=VS.110).aspx\r\nhttp://blogs.msdn.com/b/fsharpteam/archive/2012/07/19/more-about-fsharp-3.0-language-features.aspx\r\ninterface [<CLIImplicitInterface>] ISomeInterface with\r\nmember __.Foo = 42"},{"Submitter":"Saagar Ahluwalia","Submitted":"2015-06-15T17:36:00","Content":"This is not much of an issue as any methods one needs to expose implicitly can just be redefined outside."},{"Submitter":"Kasey Speakman","Submitted":"2015-09-11T11:28:00","Content":"@Saagar Ahluwalia. This is a large issue, depending on your use. Try creating a class which implements IDictionary<'k,'v>. Maintaining ~15 alias methods on the base class is an issue.\r\nI ran into this when creating a circular dictionary. Things I've tried:\r\n- Inherit Dictionary<'k,'v>. Problem: existing functions like Add and Remove can't be overridden, and using them will circumvent the circular buffer. (You can hide them, but there's no \"new\" keyword in F# to suppress the compiler warning.)\r\n- Implement IDictionary<'k,'v>. Problem: when you new up the class, none of the IDictionary methods are there. It's plain weird/unexpected to new up the class and immediately cast it to IDictionary. A static method could be created to do this for the user, but that suffers the same lack of obvious usage.\r\n- Create alias methods on the class which do the interface cast for the user. Problem: this introduces a lot of superfluous alias methods (15ish for IDictionary) which must be maintained (and tested depending on the strictness of your testing policy).\r\nAll of these alternatives are bad."},{"Submitter":"Alexander Batishchev","Submitted":"2015-10-04T00:31:00","Content":"This is a HUGE ISSUE. The worst thing about F#. Clearly indicates its immaturity."},{"Submitter":"Anonymous","Submitted":"2016-01-16T07:46:00","Content":"Pls allow to use implicit interfaces. It is pain when creating an AST model and working with it."}],"Status":"","Response":null},"5670027":{"Number":"5670027","Submitter":"Jack Pappas","Submitted":"2014-03-23T00:00:00","Title":"Implement try/fault expressions","Text":"I would like F# to have try/fault expressions. It would work along the same lines as the current try/with syntax, although the 'fault' block would be constrained to a return type of 'unit'. I don't expect the usage of this to be terribly common, but it would be very handy to have for logging purposes.\r\nTo answer the inevitable question, \"Why not just use try/with and reraise()?\" -- with try/with you're actually catching the exception; unless you remember to call reraise() to terminate all paths in the control flow within the 'with' block, you'll end up swallowing the exception and not getting the expected behavior. Similarly, if an inexperienced (or perhaps just inattentive) developer re-raises the exception with 'raise' instead of 'reraise', the stack trace information will be lost.\r\nWith try/fault, it'd be easy to log relevant information (e.g., variable values) from functions when unwinding the stack due to an exception being thrown, without the downside of being able to affect the control flow.","Votes":5,"Comments":[{"Submitter":"Jon Harrop","Submitted":"2014-03-26T06:19:00","Content":"Why not use try..finally?"},{"Submitter":"Jack Pappas","Submitted":"2014-03-28T18:33:00","Content":"Jon -- With try/finally, the code in the finally block is always executed, whether an exception is raised within the protected (try) block or not. With try/fault, the code in the fault block is executed *only* when an exception has been raised in the try block.\r\nIt would be possible to emulate try/fault behavior with try/finally by writing something like this:\r\nlet mutable error = true\r\ntry\r\n// code which may or may not raise an exception\r\nerror <- false\r\nfinally\r\nif error then ... // execute the \"fault\" handler\r\nbut it's hacky and I'd prefer just to use a true 'fault' block (which is already a feature supported by the CLR). In addition, the code to implement try/finally in the compiler is basically identical to what's needed for try/fault, so it should be fairly straightforward to implement this. If this language feature were accepted, I'd be happy to contribute an implementation (or attempt to)."},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:39:00","Content":"My inclination is that we won't do this in F#. I can see the use cases though - are there really no other ways to achieve this in .NET, e.g. by calling a library function with two lambdas?"},{"Submitter":"Don Syme","Submitted":"2016-02-10T11:02:00","Content":"One approach to this would be to add an OnException combinatory accepting a pair of functions. Likewise an Async.OnException."}],"Status":"","Response":null},"5670137":{"Number":"5670137","Submitter":"Jack Pappas","Submitted":"2014-03-23T00:00:00","Title":"#package directive to import NuGet packages in F# interactive","Text":"It would be quite useful for F# interactive to support a #package directive to allow NuGet packages to be downloaded from within the REPL. I think it would be best if this directive simply downloaded the package, unpacked it, and automatically included (#I) the correct folder based on the framework version F# interactive is running under (e.g., net45). If a package doesn't include assemblies for the specific framework version F# interactive is using, we'd automatically include the folder for the latest framework version which is compatible; e.g., if running on .NET 4.5 and a package only includes a 'net40' folder, we'd include (#I) that folder. I believe this behavior is consistent with how NuGet currently works when referencing packages from a project, e.g., in Visual Studio.\r\n#package should not, however, automatically reference (#r) the assemblies included in the package, in case you only want to reference some of them.\r\nHere's a usage example:\r\n#package \"ExtCore.0.8.41\"\r\n#r \"ExtCore.dll\";;\r\nlet substr = substring \"Hello World!\"\r\nprintfn \"Value: %O\" substr;;","Votes":248,"Comments":[{"Submitter":"Jon Harrop","Submitted":"2014-03-26T08:46:00","Content":"Yes!"},{"Submitter":"Christoph Rüegg","Submitted":"2014-04-23T12:50:00","Content":"See also: https://visualfsharp.codeplex.com/workitem/42"},{"Submitter":"Greg Chernis","Submitted":"2014-09-15T20:03:00","Content":"Here's a workaround: http://tobivnext.wordpress.com/2014/03/26/import-nuget-packages-to-fs-interactive/"},{"Submitter":"Don Syme","Submitted":"2015-02-14T12:04:00","Content":"You can use the following formula to download both a package-management-client tool (paket.exe) at the start of a script and then use it to then download nuget packages:\r\nhttps://gist.github.com/dsyme/9b18608b78dccf92ba33\r\nIt's really cool and close to what's needed, without building in things into F# Interactive.\r\nAdding #nuget to F# Interactive would be a smoother experience, but also has some risks (e.g. nuget is still an evolving thing in many ways)."},{"Submitter":"exercitus vir","Submitted":"2015-06-19T17:54:00","Content":"I like that this would be independent of the package management client."},{"Submitter":"zjv","Submitted":"2015-12-04T07:18:00","Content":"It would be nice if one could also easily import DLL's from projects in the current solution !"},{"Submitter":"Jared Hester","Submitted":"2016-06-28T00:38:00","Content":"Instead of a specific directive what if we could define a set of preprocessors with custom behaviors in a dll and have fsi automatically reference that assembly at startup."},{"Submitter":"Gauthier Segay","Submitted":"2016-07-28T19:11:00","Content":"issue on github https://github.com/Microsoft/visualfsharp/issues/56"}],"Status":"under-review","Response":null},"5670328":{"Number":"5670328","Submitter":"Jack Pappas","Submitted":"2014-03-23T00:00:00","Title":"Additional intrinsics for the NativePtr module","Text":"When interoperating with native code, it would be handy if the NativePtr module included some additional \"intrinsic\" functions for taking advantage of low-level IL instructions; specifically, I'd like to be able to use 'cpblk', 'initblk', 'initobj', and 'copyobj'.\r\nIt would also be nice to have an easy way of checking for null pointer values.\r\nExample implementation of these functions:\r\n[<RequireQualifiedAccess>]\r\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\r\nmodule NativePtr =\r\n[<GeneralizableValue>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"Zero\")>]\r\nlet inline zero<'T when 'T : unmanaged> : nativeptr<'T> =\r\n(# \"ldnull\" : nativeptr<'T> #)\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"IsNull\")>]\r\nlet inline isNull<'T when 'T : unmanaged> (ptr : nativeptr<'T>) =\r\n(# \"ceq\" zero<'T> ptr : bool #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"InitBlockInlined\")>]\r\nlet inline initBlock (p : nativeptr<'T>) (value : byte) (size : uint32) =\r\n(# \"initblk\" p value size #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"CopyBlockInlined\")>]\r\nlet inline memcpy (destPtr : nativeptr<'T>) (srcPtr : nativeptr<'T>) (count : int) =\r\n(# \"cpblk\" destPtr srcPtr (count * sizeof<'T>) #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"InitPointerInlined\")>]\r\nlet inline clear (p : nativeptr<'T>) =\r\n(# \"initobj !0\" type ('T) p #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"CopyPointerInlined\")>]\r\nlet inline copy (destPtr : nativeptr<'T>) (srcPtr : nativeptr<'T>) =\r\n(# \"copyobj !0\" type ('T) destPtr srcPtr #)","Votes":10,"Comments":[{"Submitter":"Will Smith","Submitted":"2014-03-23T10:50:00","Content":"Definitely agree with this! I've had to create my own naive versions of some of these. https://github.com/TIHan/FQuake3/blob/4d5a5702a6ae06cd8e4b57431e656ab4dfd39ac4/src/FSharp/Engine/NativeInterop.fs#L73\r\nWith your listings, maybe another one that casts a nativeptr to another nativeptr type would be super useful as well, though may not be related to your intrinsics. Perhaps, NativePtr.cast ?"},{"Submitter":"Jack Pappas","Submitted":"2014-03-28T18:19:00","Content":"Will -- nativeptr<'T> is just nativeint with a generic type annotation grafted onto it, and it's erased to nativeint at compile-time. Implementing a cast function like you described should be straightforward if you use the F# proto-compiler. IMO it wouldn't be a good addition to FSharp.Core though, because it would totally bypass any and all type-safety. In any case, the difference between your cast function and the intrinsics I listed above -- you can implement your cast with the current version of F#, but the above intrinsics can't be compiled due to some changes that were made to the ILX layer and metadata picker in F# 3.0."},{"Submitter":"Jack Pappas","Submitted":"2014-03-28T18:21:00","Content":"One other thing to point out -- having these intrinsics available in normal F# code would make it possible to implement high-speed native interop libraries like SharpDX without having to resort to IL-rewriting: https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4334135-extend-c-to-close-gaps-for-high-performance-nativ"},{"Submitter":"Will Smith","Submitted":"2014-04-13T13:55:00","Content":"Yea, it was only recently did I found out that nativeptr<'T> is really just a nativeint. Thanks for giving more info on it.\r\nYou make a good point on the type safety, but as we are already in an unsafe context and potentially messing with unmanaged memory, a NativePtr.cast would only benefit handling memory. Is there a better way of going about it? I would interested in an alternative."},{"Submitter":"Anonymous","Submitted":"2014-06-25T17:46:00","Content":"In this vein, it would be useful to be able to easily use what amounts to a binary cast from a byte array, as in C# (fixed byte* p = &b[offset]) { return *(SomeUsefulStruct*)p; }"},{"Submitter":"Frank Niemeyer","Submitted":"2014-07-02T03:42:00","Content":"@Sebastian: The only thing that F# is missing for this is the \"fixed\" statement (you'd have to pin the byte[] by allocating a GCHandle). The dereferencing (i.e. copy the contents of the byte array to a struct of type T) can achieved today using p |> NativePtr.toNativeInt |> NativePtr.ofNativeInt<'T> |> NativePtr.read."},{"Submitter":"Jack Pappas","Submitted":"2014-07-09T19:00:00","Content":"@Sebastian @FrankNiemeyer I've also suggested 'fixed' be implemented for F# 4.0: [/ideas/suggestion-5663721-add-support-for-fixed](/ideas/suggestion-5663721-add-support-for-fixed.md)"},{"Submitter":"Jack Pappas","Submitted":"2014-07-09T19:01:00","Content":"I've implemented these additional intrinsic functions and will be sending a pull request ASAP: https://visualfsharp.codeplex.com/SourceControl/network/forks/jackpappas/fsharpcontrib?branch=native-interop"}],"Status":"started","Response":{"Responded":"2014-11-08T00:00:00","Text":"I’m marking this as “approved” for F# 4.0+.\r\nA pull request for this feature has been submitted here:\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/jackpappas/fsharpcontrib/contribution/7134\r\nThanks\r\nDon, F# Language Design"}},"5673015":{"Number":"5673015","Submitter":"Howard Mansell","Submitted":"2014-03-24T00:00:00","Title":"Support C#-like Anonymous Types in F#","Text":"Commonly I want to return some named values, or sequence of named values, in some expression. Currently I am forced to either go through the additional effort of defining a type, or use a tuple (with its associated error-proneness if there are multiple values of the same type). Anonymous record types would be very useful and would eliminate one of the areas of additional verbosity compared to C#.","Votes":215,"Comments":[{"Submitter":"Lev Gorodinski","Submitted":"2014-03-24T08:26:00","Content":"An alternative is to use a dynamic operator https://www.nuget.org/packages/FSharp.Dynamic/ which can be useful for constructing values at application boundaries. For calls within an application, I would stick to explicit types though."},{"Submitter":"Joel Mueller","Submitted":"2014-04-22T11:51:00","Content":"You can't use the dynamic operator in a quotation, however. There are some C# libraries (such as Neo4jClient) that expect LINQ expression trees that create anonymous types, and extract property names and data types from the expression tree. An F# equivalent is only possible if the dynamic operator is usable in a quotation, or if F# supports anonymous types."},{"Submitter":"Manuel","Submitted":"2014-06-03T07:43:00","Content":"Swift just introduced that also with named member tuples"},{"Submitter":"Maciej J. Bańkowski","Submitted":"2014-06-05T09:54:00","Content":"@Joel Mueller, I have created a pull request for Neo4jClient that includes support for tuples: https://github.com/Readify/Neo4jClient/pull/56 It is not perfect but works as a workaround for the lack of anonymous types.\r\nBTW I totally agree F# should support something like anonymous record types. I do not know why this comes up so late in the F# dev cycle but the requirement to create one-time-use types to work with data is hard for me to understand. As @Lev Gorodinski noted, dynamic has major drawback in that it relaxes strong typing which is a very important F# feature we should keep.\r\nDoes anyone know if there is any technical issue preventing implementation of anonymous types in F#?"},{"Submitter":"Eamon Nerbonne","Submitted":"2014-06-21T03:01:00","Content":"Swift's solution isn't very good, however, so let's not copy that. in particular, swift's names don't really matter, it's still just a positional tuple, so when you do a destructuring let binding, you bind by position, not name. If you happen to swap the names (or mistype one, or refactor and change a member's name), then swift will still let you destructure by position, ignoring the names."},{"Submitter":"Eamon Nerbonne","Submitted":"2014-06-21T03:22:00","Content":"I think this would go particularly well with destructuring let bindings for records - (http://fslang.uservoice.com/forums/245727-f-language/suggestions/6081483-allow-destructuring-let-bindings-for-records-or-t)."},{"Submitter":"Anonymous","Submitted":"2014-06-21T17:58:00","Content":"For a bit of historical perspective, structural record types were part of Standard ML decades before C#."},{"Submitter":"Christopher Stevenson","Submitted":"2014-07-04T02:43:00","Content":"If the issue with this idea is syntax, here's a thought: \"new with { property1 = value; property2 = value }\". The \"new with\" indicates that this is an anonymous record."},{"Submitter":"Michael","Submitted":"2014-11-12T17:21:00","Content":"What's the benefit here? Creating anonymous types, just to turn around and use reflection on them seems sort of hacky. C# APIs like ASP.NET MVC use this because they don't have any slick way of doing [ \"prop1\", \"val1\"; \"prop2\", \"val2\" ]."},{"Submitter":"Jari Pennanen","Submitted":"2015-06-24T00:54:00","Content":"Anonymous Records (which is a same thing as propsed here) are really neat, they are basically like TypeScript interfaces, allowing structural typing where it makes sens.\r\nScala (library) implementation: http://downloads.typesafe.com/website/presentations/ScalaDaysSF2015/T4_Vogt_Compossible.pdf\r\nAbove Scala implementation has some really great benefits, potentially shortening typesafe SQL syntax a lot.\r\nHaskell (library) implementation https://gist.github.com/nikita-volkov/6977841 not very familiar with this one, but that is where I took the name."},{"Submitter":"Ben Lappin","Submitted":"2015-09-18T11:13:00","Content":"One benefit is that if you're only using a type in one place, somewhere deep inside a let binding, you currently need to define the type prior to the outermost let, which can be inconvenient. Take the following example:\r\ntype Thingy = { Inty: int; Stringy: string }\r\nlet ....\r\nlet ....\r\nlet aThingy = { Inty = 5; Stringy = \"F# is fun\" }\r\nIt would be preferable to be able to write something like:\r\nlet....\r\nlet....\r\nlet aLocalThingy = { Inty: int = 6; Stringy: string = \"Future F# is funner\" }\r\n...and in either case, you could then do what you needed with the record, as long as the flow of code allowed its (anonymous) type to be inferred.\r\nEssentially I would see this as \"syntactic sugar\" over defining a type that will only be used in one place."},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:11:00","Content":"See also this suggestion which is somewhat related http://fslang.uservoice.com/forums/245727-f-language/suggestions/8107647-extend-with-keyword-support-to-record-definition"},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:21:00","Content":"See also this suggestion on StructTuple compatible with C# tuples: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6148669-add-support-for-structtuple"},{"Submitter":"Yemi Bedu","Submitted":"2016-06-01T17:08:00","Content":"What is the expectation for these types to shadow each other?\r\nWould you want the compiler to warn about a named record that matches your anonymous one in certain use cases?\r\nExamples would be anonymous record of { Length:int ; Width:int } that could be in a lot of places.\r\nAnother example is if you describe a Point { X:int ; Y:int } and later the anonymous version gets used in a function.\r\nShould it infer Point or just warn \"a named record of type Point matches\"?\r\nWould we want the allow declaration signatures to be anonymous\r\nlet Girl = {Name: string ; Age: int }\r\nlet Boy = {Name: string; Age: int }\r\nlet greet (child: {Name;Age}) = printfn \"%A\" child.Name\r\ngreet {Name=\"you\";Age=21}"},{"Submitter":"Bruno Bozza","Submitted":"2016-08-15T20:39:00","Content":"This is badly needed for data wrangling over typed datasets. I tried to use F#, which I prefer for everything else, but when every 5 lines of query code induce a new record type, updating the records becomes tedious very quickly, so I am back to C# for this.\r\nC#'s support is not perfect (or new), but it has really convenient record punning. And for the drastic cuts they had to make in the design (i.e.: anonymous types being non-denotable and limited to method scope), my favorite feature of this design is that it allowed the team to ship it, and now I can use it. Yes, I expect more from F#, but I would be happy to give up on structural subtyping, first class labels and even denotability, in order to get C#-style functionality."},{"Submitter":"Tomas Lycken","Submitted":"2016-09-05T09:05:00","Content":"I'd love this! See http://stackoverflow.com/q/39306148/38055 for a use case."}],"Status":"under-review","Response":null},"5674940":{"Number":"5674940","Submitter":"Bryan Edds","Submitted":"2014-03-24T00:00:00","Title":"Implement Syntactic Macros","Text":"At least give it a try in a private branch, and upon success, enable them publicly with a compiler switch initially.","Votes":453,"Comments":[{"Submitter":"Tomas Petricek","Submitted":"2014-03-24T16:03:00","Content":"I would be quite interested in the use cases that you have in mind for this? Restricted macro functionality is already available with quotations, type providers & reflection, so I'd like to know what interesting use cases are left :-)"},{"Submitter":"Bryan Edds","Submitted":"2014-03-24T16:17:00","Content":"Tomas, my friend, you ask for too much! I will attempt to post one use case for F# macros here every business day as long as I can manage :)\r\nFor today, the use case is more-automated generation of lens values. Lenses, both full and partial, are no where near first-class enough in F#. You can't do real FP without them. Macros should bring us closer, and also give a prototype showing how the language implementers might design them in the case they do make them first-class."},{"Submitter":"Giuseppe Maggiore","Submitted":"2014-03-25T09:20:00","Content":"Games would greatly benefit from having macros or other similar, high-performance, portable ways to generate complex code.\r\nSeconded with all my heart :)"},{"Submitter":"Will Smith","Submitted":"2014-03-25T10:05:00","Content":"Gluseppe,\r\nFor games, inlining functions help a lot especially for linear algebra math operations. It's much more idiomatic to use inlined functions than macros for performance. It's not always true, however, that inlining a function will give you better performance, in fact, it can give you worse depending on the function if it's long + complex. A macro would be no better here.\r\nI'm doing this myself now and it works just as good as any macro would; however, there are a few outstanding issues with struct param types with inlined functions, but I have a slightly edited compiler that fixes that."},{"Submitter":"Richard Minerich","Submitted":"2014-03-25T10:27:00","Content":"I could see something similar to template haskell being useful, one example of use would be generating lenses."},{"Submitter":"Bryan Edds","Submitted":"2014-03-25T23:02:00","Content":"Macro use case for the day #2 -\r\nImplement F# features outside the compiler so that even idiomatic F# code can be back-ported to OCaml."},{"Submitter":"Jon Harrop","Submitted":"2014-03-26T05:57:00","Content":"@Tomas: Macros are used to customise syntax. For example, you might want to replace the pattern \"| Add(f, g) -> d f + d g\" with \"| f+g -> d f + d g\"."},{"Submitter":"Bryan Edds","Submitted":"2014-03-27T21:28:00","Content":"Macro use case of the day #3 -\r\nLet the community take more of a role in prototyping new F# language features with macros instead of forcing them to hack their own private compiler branch and thereby losing all portability."},{"Submitter":"Bryan Edds","Submitted":"2014-03-31T10:14:00","Content":"Macro use case of the day -\r\nIf we can allow macros to be imported based on a containing namespace / module, various DSL contexts could be opened separately, without clashing."},{"Submitter":"Mastr Mastic","Submitted":"2014-04-02T11:01:00","Content":"Fully seconded, and Bryan you're a hero for initiating this.\r\nMacros are so underrated and to be fully honest, in my opinion this is a must!\r\nI'll even go as far to say that imo every programming language should have macro support.\r\nFor instance, I can't begin to describe how much I dislike GUI development just because you have to manually raise events and legit repeat yourself again and again and again, which just results in filthy messy code."},{"Submitter":"Mastr Mastic","Submitted":"2014-04-02T11:06:00","Content":"Also if I may add another macro use case:\r\nMore aliasing functionality.\r\nfor instance, I highly dislike having to re-type this again and again:\r\n[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>])\r\nType aliasing can't deal with this since the result is not a type.\r\nInheritance is not an option since the attribute is sealed.\r\nOnly option I can think of to deal with these kind of cases (this is merely an example) is macros."},{"Submitter":"Will Smith","Submitted":"2014-04-03T15:02:00","Content":"If F# has proper macros, this means you would be able to create another language inside F#. Do we really want that?\r\n---\r\n\"Implement F# features outside the compiler so that even idiomatic F# code can be back-ported to OCaml.\"\r\nWhy would you want to use macros as a means of back-porting? Arn't there better ways that don't infect the language itself?\r\n\"Macros are used to customise syntax. For example, you might want to replace the pattern \"| Add(f, g) -> d f + d g\" with \"| f+g -> d f + d g\".\"\r\nCouldn't we find a way to extend the F# language that makes something like this possible without relying on macros?\r\n\"Let the community take more of a role in prototyping new F# language features with macros instead of forcing them to hack their own private compiler branch and thereby losing all portability.\"\r\nA true prototype of a language feature is to have a modified version of the compiler. That is the proper way. Using macros for a prototype do not tell you what is involved in actually implementing a language feature.\r\n\"If we can allow macros to be imported based on a containing namespace / module, various DSL contexts could be opened separately, without clashing\"\r\nHow is this a use case for a need to use macros?\r\n\"I can't begin to describe how much I dislike GUI development just because you have to manually raise events and legit repeat yourself again and again and again, which just results in filthy messy code.\"\r\nYou can create abstractions already, or even use type providers to generate all the mess so you don't have to.\r\n\"for instance, I highly dislike having to re-type this again and again:\r\n[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>])\"\r\nSo we can use macros for anyone to call what this behavior does anything they want? I agree that I dislike typing that again and again; but, I feel like we could figure out a simple language feature that could solve this in an idiomatic way."},{"Submitter":"Mauricio Scheffer","Submitted":"2014-04-04T19:23:00","Content":"Other than lenses, lots of things could be derived for a type with a macro: functor, applicative, monad, a serializer. None of the current metaprogramming facilities can do that as far as I know, and you can't build all of that into the language (for example deriving a serializer depends on a specific serialization library)."},{"Submitter":"Bryan Edds","Submitted":"2014-04-04T19:43:00","Content":"Sorry I haven't been posting the use cases for macros like I promised - I've been in the hospital for 4 days now (obviously unrelated).\r\nWill, if macros are only able to be enabled via a compiler-switch, it will not effectively change the language for the typical user, so there are no direct down sides there.\r\nFor people who need to program at the language level (such as framework developers), macros are a must (at least in a black-box language like F#). For those who have only ever consumed those types of services (as opposed to writing them properly), they will only see macros through the the Blub Paradox - http://paulgraham.com/avg.html .\r\nTherefore, only programmers who write at the language level will ever turn on the feature, but those who blithely consume our work will keep the feature off - if they even know it exists in the first place.\r\n* Yes, F# is a black-box language. Just because the compiler is open source does not mean it is white box. If you want to see a white box language, look at AML here - https://github.com/bryanedds/OmniBlade"},{"Submitter":"Mastr Mastic","Submitted":"2014-04-07T10:35:00","Content":"@Will Smith\r\nThere is mess with abstractions as-well.\r\nAs for the attribute, I'll mention again that this is merely an example.\r\nSure, the F# team could introduce a ModuleSuffixAttribute as a shortcut, and maybe even have an optional Boolean parameter for RequireQualifiedAccess, and I was even about to suggest this but then the idea of macros came up and swiped it away because with macros you could do that + more + a lot more!"},{"Submitter":"Bryan Edds","Submitted":"2014-04-08T08:48:00","Content":"* Just for clarification *\r\nThe compiler switch for enabling macros should allow new macros to be defined. Using existing macros should not require a compiler flag. This way, library developer can opt-in to access macro implementation syntax, and consumers can use library macros more transparently (either as if they were an ambient language feature, or a custom syntax imported from an F# namespace / module)."},{"Submitter":"Will Smith","Submitted":"2014-04-13T13:38:00","Content":"That stinks you were in the hospital Bryan! I hope you are feeling better!\r\nIf macros were going to be implemented, a compiler directive or switch would be the least of all evils. That is my opinion and I could live with it.\r\nThis feature currently has the most votes, so it is clear that a lot of people want this for a good reason.\r\nI want to be convinced that macros would really benefit F#; because I really fear this feature a lot. I'm looking for the bigger picture here, but so far all I see is syntactic sugar. I read there is the framework side, but I don't have a clear understanding of the problems devs are facing when developing a framework.\r\nCould anyone show some example problems that macros would truly help resolve? Syntactic sugar is not one of them."},{"Submitter":"Mastr Mastic","Submitted":"2014-04-14T18:02:00","Content":"Will, personally I can't think of any (at least atm); I also can't think what more they need to do, because after all that is their purpose.\r\nBut how about share your thoughts and let us know what's daunting about macros.\r\nI mean, yeah, it can definitely be misused like any other feature, but the good thing about macros is that you can simply choose not to use them.\r\nThey will not invade your work, but only be there for you to use when the trade-offs worth it in your opinion.\r\nAnd perhaps if macros will be implemented (fingers crossed) they could also be removed from a certain point (very much like #undefine in C & C++).\r\nThat being said, I'd like to point out (to everyone) that all in all, macros allow you to make code more compact, shorter, succinct, readable, simpler, etc.\r\nThat's their point (syntactic sugar).\r\nNow just notice how about any best practice you read in a book, online, hear from a friend will have the same reasons for usage. That's what we need, simple compact code.\r\nSo my viewpoint is: Program with care, play nice, have macro support, and the result is a maintainable code, that is a pleasure for the eyes to see."},{"Submitter":"Mauricio Scheffer","Submitted":"2014-04-14T18:16:00","Content":"Will, a lot of use cases have been mentioned in this thread that are not about syntactic sugar: lenses, serialization, derivation of functor/applicative/monad. Also derive curried constructors for records, which would help a lot with applicative functors.\r\nAll of these are about reducing boilerplate by generating code at compile-time."},{"Submitter":"Bryan Edds","Submitted":"2014-04-15T00:06:00","Content":"I'm starting to wonder if there is a bit of confusion between textual macros (like those found in C and C++) and my suggestion of syntactic macros.\r\nFor surefire clarification, here are links describing each -\r\nTextual Macros - http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Text_substitution_macros\r\nSyntactic Macros - http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Syntactic_macros\r\nThe difference between the two is very big, and I too would object to any suggestion of putting textual macros in F#! :)"},{"Submitter":"Dave Thomas","Submitted":"2014-04-24T03:37:00","Content":"I think I would prefer expanded quotation and Type Provider support. The language is at a very stable base and Im not sure you could convince me that macros are necessary."},{"Submitter":"Bryan Edds","Submitted":"2014-04-24T06:54:00","Content":"Hi Dave!\r\nCould you elaborate on what you mean by 'expanded' in these cases, and perhaps give examples where they would obviate macros?"},{"Submitter":"Bryan Edds","Submitted":"2014-04-24T07:13:00","Content":"Dave and all,\r\nHere's a super nice macro use case; Making FSCL more syntactically elegant. FSCL is amazing, but the amount of attributes and <@code quotation symbols@> flying around in its usage code makes it much harder to read and write than it should be, as well as error prone -\r\n\"Ah, why doesn't this work?! Did I leave out an attribute or parameter again?\"\r\nImagine all that encapsulated behind a DSL that looks like first-class F# syntax - all just by opening the appropriate module.\r\nCould expanded code quotations and / or type providers really obviate macros in cases like this?"},{"Submitter":"mavnn","Submitted":"2014-04-25T10:04:00","Content":"@Bryan I don't know if this is what Dave was thinking, but a lot of type kind like functionality could be implemented by type providers that could be parameterized by type or by quotation.\r\nCombined with better quotation evaluation out of the box, it would cover most of the use cases I've seen so far, especially Mauricio's lens et al."},{"Submitter":"Bryan Edds","Submitted":"2014-04-25T10:25:00","Content":"Hi mavnn!\r\nIt would be interesting to see some explanation of what the semantics of better / expanded type providers and quotations would entail, along with a couple of examples demonstrating how they would obviate macros.\r\nWould you or Dave mind writing something like that up as an F# user voice suggestion so we can study upon and vote for it?"},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-06T08:33:00","Content":"I think the following related concepts might be relevant:\r\n1) Metaprogramming\r\n2) Dilecting - Syntax mutation is dilecting\r\n3) Extensible programming\r\n4) Higher Order Abstract Syntax - http://en.wikipedia.org/wiki/Higher-order_abstract_syntax, http://www.cs.cmu.edu/~fp/papers/pldi88.pdf\r\n5) Staging"},{"Submitter":"mavnn","Submitted":"2014-05-07T04:41:00","Content":"@Bryan sorry for the slow response. Type providers that could take a type would allow you to generate things like lenses on the fly. Having said that...\r\n... I actually very much like the idea of syntactic macros and have voted for this idea. So I'm not going to spend too long disagreeing with you!\r\nIt does have to said that a lot of very similar functionality could be provided by better support for evaluating quotations and that may be the more practical solution in the short term."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-07T22:55:00","Content":"There are 3 ways to do this\r\n1) Quasi Quotes (QQ)\r\n2) Macros\r\n3) GADT\r\nWhy not have all 3. F# is very well capable of doing this. If you use QQ you are dealing with concrete syntax. In other ways you can deal with it at the AST level also."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-07T22:58:00","Content":"MetaOCaml, PPX, Camlp4/5 can be a good starting reference to explore the possibilities. Especially MetaOCaml. Love the concepts in this."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-08T00:07:00","Content":"Also it would be very cool if you can use the meta programming facility to have projectional editors within the language."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-08T03:35:00","Content":"Also MetaML and Template Haskell would be good starting points to flesh out a strawman speck for this feature."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2014-05-10T01:09:00","Content":"Something interesting I stumbled across. Some of this research could be taken into consideration http://ltamer.sourceforge.net/"},{"Submitter":"Kurt","Submitted":"2015-07-06T05:46:00","Content":"Here's how Boo does it: https://github.com/bamboo/boo/wiki/Syntactic-Macros"},{"Submitter":"Yaar Hever","Submitted":"2016-03-13T22:31:00","Content":"I think macros would make it much easier to implement the missing functionalities of type providers (like creating F# specific types) and to have a functional way of writing type providers."},{"Submitter":"Anonymous","Submitted":"2016-03-14T08:08:00","Content":"Having a proper macro system would probably make type providers obsolete, the current mechanism (putting it politely) is a crap fest."},{"Submitter":"Kurren Nischal","Submitted":"2016-03-19T05:02:00","Content":"This would be a dream come true"},{"Submitter":"Yemi Bedu","Submitted":"2016-05-29T04:03:00","Content":"[/ideas/suggestion-5975797-allow-implicit-quotation-of-expressions-used-as-a](/ideas/suggestion-5975797-allow-implicit-quotation-of-expressions-used-as-a.md)\r\nHello,\r\nSo I would recommend that the above be extended to work with general methods (functions)\r\nThe definition of it could look like:\r\ndef nameof (q:'T) = match q with\r\n| Quotations.Patterns.ValueWithName(o, ty, n) -> n\r\n| Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nwhich is shorthand for writing:\r\nlet nameof ([<ReflectedDefinition>] q:Quotations.Expr<'T>) : string = match q with\r\n| Quotations.Patterns.ValueWithName(o, ty, n) -> n\r\n| Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nlet y = 1\r\nprintfn \"%s\" (nameof y)\r\nThank you. Good day."}],"Status":"","Response":null},"5675548":{"Number":"5675548","Submitter":"Anonymous","Submitted":"2014-03-24T00:00:00","Title":"Implement monadic getters and setters","Text":"The get/set syntax for F# is very cool, but it has an issue: sometimes, the property we would like to get and set is only available through a workflow/monad, like the async workflow.\r\nThus, I would like to alter the typechecking rules for getters and setters. This is what they are right now (pseudocode) for the Async monad:\r\nProperty x : Async<'a>\r\nget : unit -> Async<'a>\r\nset : Async<'a> -> unit\r\nIndexedProperty x : 'k -> Async<'v>\r\nget : 'k -> Async<'v>\r\nset : 'k -> Async<'v> -> 'unit\r\nThis is what I would like to see made possible:\r\ntype Id<'a> = 'a\r\nProperty x : Async<'a>\r\nget : unit -> Async<'a>\r\nset : 'a -> Async<unit>\r\nIndexedProperty x : 'k -> Async<'v>\r\nget : 'k -> Async<'v>\r\nset : 'k -> 'v -> Async<unit>","Votes":3,"Comments":[{"Submitter":"Mauricio Scheffer","Submitted":"2014-03-24T18:50:00","Content":"Interesting, could you post a snippet illustrating how the current syntax/typechecking is insufficient, and how this suggestion would make it better?"},{"Submitter":"Don Syme","Submitted":"2016-02-03T14:59:00","Content":"I am very sympathetic to this proposal. However, please note that the items would likely not be \"proper\" .NET properties since those are required to have \"unit\" return type on the setter method."}],"Status":"","Response":null},"5675977":{"Number":"5675977","Submitter":"Tracy","Submitted":"2014-03-24T00:00:00","Title":"Allow type providers to generate types from other types","Text":"There are occasions where it would be extremely useful to generate types from other types.\r\nAs an example, F# interop with NHibernate is very clumsy simply because it's difficult to express types of the sort:\r\n// C# record class\r\npublic class MyRecord\r\n{\r\npublic virtual int Id { get; set; }\r\npublic virtual string Description { get; set; }\r\n// etc...\r\n}\r\nIt would be very compelling to be able to represent these as F# record types, but the CIL code generated for F# records is incompatible with NHibernate.\r\nPerhaps it could be possible, using a type provider, to generate the POCO class above from an F# record type of the sort:\r\ntype MyRecord = { Id : int, Description : string }\r\nThe type could be generated as shown below:\r\ntype MyPocoRecord = PocoTypeProvider<MyRecord>()\r\nI understand the difficulty of doing this at compile type.Tomas P actually explained why in a forum post (that I can't seem to find.) However, this sort of problem is the reason by the CLIMutable attribute was created, which as far as I can tell, was hard-coded directly into the F# compiler.\r\nI can see these interop dilemmas becoming more common as F# adoption increases, especially in the enterprise where tools like NHibernate are in widespread use. There ought to be a way to address them without creating one-off CLIMutable-esque attributes per se.\r\nThe feature itself would open the door to incredibly powerful metaprogramming opportunities.","Votes":116,"Comments":[{"Submitter":"Bryan Edds","Submitted":"2014-03-27T21:42:00","Content":"I think this is very interesting and would love to hear about its advantages and disadvatages from the F# team."},{"Submitter":"Nicolas R","Submitted":"2014-05-14T09:28:00","Content":"This amount to \"staged programming\" no ? You have to resolve all the types you give as parameters, run the higher level program on that input, and use the result of that in the \"normal precedence\" program."},{"Submitter":"trek42","Submitted":"2014-06-25T08:27:00","Content":"We might have a simpler implementation by restricting that the types you give to a type provider must be fully resolved before compiling the current file.\r\nExample:\r\n// in A.fs\r\ntype MyRecord = ... // fully defined.\r\n// in B.fs\r\ntype ProvidedType = TypeProvider<MyRecord>;\r\nB.fs must go after A.fs, but you can still put B.fs and A.fs in one project and compile them together.\r\nI think this should enable most benefits without resorting to staged programming. Actually, this seems to play quite nicely with the current fsharp compilation model, which already requires fully resolving dependencies before compiling the source file.\r\n(currently you can simulate this feature by compiling A.fs in its own assembly, then give the assembly file path to the type provider. But doing so means you need to split things that should naturally go together into multiple projects, and it quickly become very cumbersome.)"},{"Submitter":"Dave Thomas","Submitted":"2014-07-02T04:41:00","Content":"You can already have generative types that inherit from a prescribed type, it would be interesting to extend the syntax so that the prescribed type can be included as a generic argument, or perhaps typeof<'a> in the static arguments."},{"Submitter":"Don Syme","Submitted":"2016-02-04T14:01:00","Content":"I would love to see this feature implemented, it would increase the power of F# type providers immensely.\r\nI will mark this as \"approved in principle\" and we will eventually open an RFC for it. However it will be a difficult feature to land in practice and will be subject to very many caveats and likely limitations."},{"Submitter":"Dave Thomas","Submitted":"2016-04-19T02:40:00","Content":"One thing that heads towards this is getting intrinsic type extensions working with generative providers. So that you can then create a type from a provider and immediately augment it in some way. RE:https://github.com/Microsoft/visualfsharp/pull/882"}],"Status":"planned","Response":{"Responded":"2016-06-24T00:00:00","Text":"Marking this as “approved in principle” per comment below.\r\nHowever it will be a difficult feature to land in practice and will be subject to very many caveats and likely limitations. There’s no certainty that this will make it into F#.\r\nWe will open an RFC for it eventually (it won’t be fast :) )\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme\r\nF# Language Evolution"}},"5676471":{"Number":"5676471","Submitter":"Steven Taylor","Submitted":"2014-03-25T00:00:00","Title":"Allow n partitions for ActivePatterns instead of a max 7","Text":"Active patterns can only have seven partitions (see: http://msdn.microsoft.com/en-us/library/dd233248.aspx)\r\nIt would be good if this was a stylistic constraint that could be overridden if desired.\r\nFor example, if active patterns are getting used to split up XML nodes meaningfully, you aren't in control of how many nodes sensibly fit into the top level.","Votes":23,"Comments":[{"Submitter":"Jack Pappas","Submitted":"2014-03-28T18:05:00","Content":"I have often wished for F# to have this feature. I would be OK if the compiler required active patterns with >7 cases to be inlined -- most of the time I've wanted to use this, the active pattern would only be used in 1 or 2 places in the code, and I've mainly wanted to use an active pattern to take advantage of the exhaustivity checking provided by the compiler."},{"Submitter":"Mickey","Submitted":"2014-11-10T10:42:00","Content":"640K. That'll be enough!"},{"Submitter":"bleis-tift","Submitted":"2015-11-07T20:04:00","Content":"type Choice<'T1> =\r\n| Choice1Of1 of 'T1\r\ntype Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'TRest> =\r\n| Choice1OfN of 'T1\r\n| Choice2OfN of 'T2\r\n| Choice3OfN of 'T3\r\n| Choice4OfN of 'T4\r\n| Choice5OfN of 'T5\r\n| Choice6OfN of 'T6\r\n| Choice7OfN of 'T7\r\n| ChioceRest of 'TRest\r\nlet (|P1|P2|P3|P4|P5|P6|P7|P8|) x =\r\nmatch x with\r\n| 1 -> P1\r\n| 2 -> P2\r\n| 3 -> P3\r\n| 4 -> P4\r\n| 5 -> P5\r\n| 6 -> P6\r\n| 7 -> P7\r\n| _ -> P8\r\n// Chice<unit, unit, unit, unit, unit, unit, unit, Choice<unit>>\r\nThis is the same way as the System.Tuple."},{"Submitter":"Don Syme","Submitted":"2016-02-10T11:06:00","Content":"As an aside, we looked at implementing this in F# 2.0 and it seems that it became surprisingly hard very quickly. I can't quite remember the details though."}],"Status":"","Response":null},"5683698":{"Number":"5683698","Submitter":"Loic Denuziere","Submitted":"2014-03-26T00:00:00","Title":"Make .Tag and .Is* discriminated union properties visible from F#","Text":"The .NET class that encodes a discriminated union has `.Is* : bool` properties, for example this:\r\ntype Foo = A | B\r\nhas the following:\r\nmember IsA : bool\r\nmember IsB : bool\r\nThey are hidden from F#, but they could actually be quite useful. I regularly find myself writing something like this:\r\nList.filter (function A -> true | _ -> false)\r\nwhen I could write:\r\nList.filter (fun x -> x.IsA)","Votes":15,"Comments":[{"Submitter":"Peter Strøiman","Submitted":"2014-05-13T03:32:00","Content":"Or even better, have it exposed as static members, so you can write\r\nList.filter Foo.IsA\r\nThe latter can work better with some cases of type inference, e.g.\r\nlet get<'T> () = instance :?> 'T // instance is declared as an obj\r\nIn that case\r\nget () |> List.filter Foo.IsA\r\nWould automatically type infer 'T to be List<Foo>, where\r\nget () |> List.filter (x -> x.IsA)\r\nwould not, and thus would not compile"},{"Submitter":"Loic Denuziere","Submitted":"2014-05-13T04:40:00","Content":"Peter: The thing is, these methods already exist as instance methods, they're just not exposed in F#. Making them static would break backward compatibility for C# code that uses them.\r\nThere is a discussion about a static syntax for instance methods here: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663326-syntax-for-turning-properties-into-functions which would provide the same advantages as you cite, but for all instance methods."},{"Submitter":"Robert Jeppesen","Submitted":"2014-06-26T16:12:00","Content":"I agree with Peter, it would be nice to have this as part of the static type.\r\nWe should have both: The static `IsA` would call the instance `IsA`."},{"Submitter":"Christopher Atkins","Submitted":"2014-07-17T07:10:00","Content":"There are a few considerations to take into account when tackling this, per Don Syme:\r\n* The problem is that the generated “Is*” and “New*” for unions are inserted very late in the compilation pipeline, in the “ILX” phase, using nasty code that is somewhat ancient. There are lots of corresponding cases in tc.fs and check.fs to check that the user doesn’t define these him/herself.\r\n\r\n* The whole generation of these should probably be lifted up to happen during type checking (the same time we generate compare/equality methods, for example, see augment.fs). Then the “check for duplicates” core would be irrelevant.\r\n\r\n* The messiness is compounded by the fact that there are special cases in ILX generation for lists, options and AllowNullValueAsRepresentation unions."},{"Submitter":"Ovidiu Deac","Submitted":"2014-10-25T20:03:00","Content":"Combined with [/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions](/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions.md) would be even nicer:\r\nThe code would be:\r\nList.filter Foo.isA"}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"This proposal is “approved in principle” for F# 4.0+. It would make a good addition to F#. (I don’t think the loss of purity (e.g. wr.t. ordering of union cases) is a critical problem and I believe you can turn of the DefaultAugmentation in any case)\r\nSome technical issues may need to be ironed out during implementation.\r\nIf this is done, the Tag properties present on these types should also be revealed, that is covered by a separate item.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library..\r\nI’d be glad to help guide people through the implementation process.\r\nIf you strongly think this should not be approved please chime in with your technical feedback.\r\nThanks\r\nDon Syme, F# Language and Core Library Evolution"}},"5688398":{"Number":"5688398","Submitter":"Jerold Haas","Submitted":"2014-03-27T00:00:00","Title":"Allow Unicode symbols to be used as operators","Text":"Suggestion moved from https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2314078-allow-unicode-symbols-to-be-used-as-operators\r\nIt would be great to define mathematical operators (e.g. ∀, ∑, ∩) in F#, and be able to use other Unicode symbols (such as arrows) in operators as well. So instead of saying\r\nlet inline (!++) xs = xs |> Seq.sum\r\nyou could say\r\nlet inline (~∑) xs = xs |> Seq.sum\r\nWriting \"∑myList\" is much, much easier on the eyes and brain than trying to figure out what \"!++myList\" does.","Votes":76,"Comments":[{"Submitter":"Daniel Fabian","Submitted":"2014-03-27T12:19:00","Content":"There used to be an addon like that. http://apollo13cn.blogspot.ch/2012/09/math-unicode-symbol-add-on-for-f.html\r\nAnd what stops you right now from using unicode symbols in source code (apart from being rather exotic, that is)"},{"Submitter":"Jerold Haas","Submitted":"2014-03-27T13:07:00","Content":"That add-on is simply text substitution: There's no actual Unicode characters in the source files using that method:\r\n\"This add-on only changes the visual of the string and the source code is untouched. So if you open it in a notepad, the code won't contain any math (Unicode) symbol.\""},{"Submitter":"Mastr Mastic","Submitted":"2014-03-27T20:33:00","Content":"It makes perfect sense that this should be supported, especially for a functional language."},{"Submitter":"Jack Pappas","Submitted":"2014-03-28T17:58:00","Content":"This is an often-requested feature for F#, usually from people doing heavy mathematical or algorithmic work, and can see how having code which more closely adheres to the underlying math could be helpful.\r\nHowever, I have to say -- I don't think it would be good for F# to add this feature. My chief concern is that you'd be forcing consumers of your code to use these symbols as well. This would be annoying at best (I prefer the identifiers as they are now, and would probably end up implementing my own library instead of one that forced me into using Unicode symbols as operators); at worst, code with Unicode operators is much less approachable for newcomers to F# -- especially those who don't come from a math/science-heavy background -- and I worry it would keep people away from F# who might otherwise be quite happy with the language.\r\nAnother drawback -- a number of mainstream development tools (including parts of VS) weren't designed with Unicode symbols in mind, and won't work properly when code or compiled assemblies use them in type/field/method names. You can make a good argument that these tools should be fixed to properly handle Unicode symbols (and I would agree with you); but if having Unicode operators means that many of the common .NET development tools couldn't be used with F# due to such issues, I think that would be a serious problem. Even well-known C# libraries have removed the uses of Unicode characters from their method names due to this issue: http://rx.codeplex.com/releases/view/114891\r\nWhat's the downside of having an IDE plugin (like F# Power Tools), or the add-on Daniel linked to, that could recognize naming conventions for variables and convert them to Unicode characters in the IDE (but not in the actual code)? Proof General (an Emacs package) does this for Isar (a proof language for the Isabelle theorem prover) and it seems to work quite well: http://proofgeneral.inf.ed.ac.uk/releases/ProofGeneral-3.7/isar/isar-unicode-tokens.el"},{"Submitter":"Steve Gilham","Submitted":"2014-04-06T15:16:00","Content":"As code like `let (<+>) = ...` compiles to an all-ASCII function name `op_LessPlusGreater` I would expect code like `let (∪) = ...` to compile to a similarly all-ASCII function name like `op_U222A` in the IL. And just as one can invoke the <+> function by ASCII name (just not as an infix), so too op_U222A could be invoked by that name if input for the mathematical symbol was difficult.\r\nIdeally, this change would be coupled with a more general facility to define infix operators -- along the lines of ML's `infix` keyword -- but lacking a suitable reserved keyword some other syntax, maybe like `let (Union) = ...` compiling to `op_Union` would be required. Or maybe a compiler directive that when switched on made functions defined as explicitly as `op_<whatever>` invokable as infix `<whatever>`"},{"Submitter":"Robert Nielsen","Submitted":"2014-06-22T11:04:00","Content":"Daniel Fabian the main thing that is stopping us from using unicode in the source code is the need for double-backtick marks (`` ``) to make F# understand the meaning, and even then a lot of the language constructs simply refuse to use non-normal names."},{"Submitter":"Don Syme","Submitted":"2015-07-18T11:22:00","Content":"I tend agree with Jack Pappas that this would not be a good thing for F#, for the reasons he describes."},{"Submitter":"Jared Hester","Submitted":"2015-09-26T15:56:00","Content":"What if it required a `#nowarn` and the Unicode characters supported for operators were limited to specific blocks, e.g. Mathematical Operators[1], Supplemental Mathematical Operators[2], and maybe even some of Miscellaneous Technical[3] ;)\r\n[1] http://www.fileformat.info/info/unicode/block/mathematical_operators/utf8test.htm\r\n[2] http://www.fileformat.info/info/unicode/block/supplemental_mathematical_operators/utf8test.htm\r\n[3] http://www.fileformat.info/info/unicode/block/miscellaneous_technical/utf8test.htm"},{"Submitter":"Jared Hester","Submitted":"2016-01-09T15:36:00","Content":"[ Part 2 of 2 ]\r\n> What's the downside of having an IDE plugin (like F# Power Tools), or the add-on Daniel linked to, that could recognize naming conventions for variables and convert them to Unicode characters in the IDE (but not in the actual code)?\r\nThis downside is that this does nothing for operators. Operators are what are in question, and converting variable names does nothing to help the fact that the set of possible operators that can be created is fairly constricted and most of them are part of the language already. Not to mention between Suave, FParsec, and Freya there aren't many you can define or use without colliding fairly quickly under 3 characters. The built in precedence rules of F# only further compound these issues `^` is going to start any operator that you want to have right associativity. Swift gets this right[1], when declaring a custom operator you declare whether it's prefix, infix, or postfix; you pick whether the associativity is left, right, or none; and you set an associativity level between 0 and 255. And operators can be created from Unicode Math, Symbol, Arrow, Dingbat, line/box drawing and Unicode combining characters.[2] One additional feature that they should have included is the ability to give your operator a named\r\nalias to use during autocomplete.\r\nFurthermore there's not reason to create a naming convention for variables so they can be disguised as Unicode characters while rendered, because we can just use those those characters already.\r\nThese are all valid binding names:\r\nʀ ʁ ʂ ʃ ʄ ʅ ʆ ʇ ʈ ʉ ʊ ʋ ʌ ʍ ʎ ʏ ʐ ʑ ʒ ʓ ʔ ʕ ʖ ʗ ʘ ʙ ʚ ʛ ʜ ʝ ʞ ʟ\r\nɀ Ɂ ɂ Ƀ Ʉ Ʌ Ɇ ɇ Ɉ ɉ Ɋ ɋ Ɍ ɍ Ɏ ɏ ɐ ɑ ɒ ɓ ɔ ɕ ɖ ɗ ɘ ə ɚ ɛ ɜ ɝ ɞ ɟ\r\nɠ ɡ ɢ ɣ ɤ ɥ ɦ ɧ ɨ ɩ ɪ ɫ ɬ ɭ ɮ ɯ ɰ ɱ ɲ ɳ ɴ ɵ ɶ ɷ ɸ ɹ ɺ ɻ ɼ ɽ ɾ ɿ\r\nʀ ʁ ʂ ʃ ʄ ʅ ʆ ʇ ʈ ʉ ʊ ʋ ʌ ʍ ʎ ʏ ʐ ʑ ʒ ʓ ʔ ʕ ʖ ʗ ʘ ʙ ʚ ʛ ʜ ʝ ʞ ʟ\r\nπ ρ ς σ τ υ φ χ ψ ω ϊ ϋ ό ύ ώ Ϗ ϐ ϑ ϒ ϓ ϔ ϕ ϖ ϗ Ϙ ϙ Ϛ ϛ Ϝ ϝ Ϟ ϟ\r\nϠ ϡ Ϣ ϣ Ϥ ϥ Ϧ ϧ Ϩ ϩ Ϫ ϫ Ϭ ϭ Ϯ ϯ ϰ ϱ ϲ ϳ ϴ ϵ\r\nڀ ځ ڂ ڃ ڄ څ چ ڇ ڈ ډ ڊ ڋ ڌ ڍ ڎ ڏ ڐ ڑ ڒ ړ ڔ ڕ ږ ڗ ژ ڙ ښ ڛ ڜ ڝ ڞ ڟ\r\nᐁ ᐂ ᐃ ᐄ ᐅ ᐆ ᐇ ᐈ ᐉ ᐊ ᐋ ᐌ ᐍ ᐎ ᐏ ᐐ ᐑ ᐒ ᐓ ᐔ ᐕ ᐖ ᐗ ᐘ ᐙ ᐚ ᐛ ᐜ ᐝ ᐞ ᐟ\r\nⅠ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ Ⅺ Ⅻ Ⅼ Ⅽ Ⅾ Ⅿ ⅰ ⅱ ⅲ ⅳ ⅴ ⅵ ⅶ ⅷ ⅸ ⅹ ⅺ ⅻ ⅼ ⅽ ⅾ ⅿ\r\nↀ ↁ ↂ Ↄ ↄ ↅ ↆ ↇ ↈ\r\nAnd for the wide swath of glyphs and characters that cause compiler errors due to unrecognized characters if you include them in your source, all you need are some backticks\r\n``∠`` ``∡`` ``∢`` ``∣`` ``∤`` ``∥`` ``∦`` ``∧`` ``∨`` ``∩`` ``∪`` ``∫`` ``∬`` ``∭`` ``∮`` ``∯`` ``∰`` ``∱`` ``∲`` ``∳``\r\nand you're free to use and abuse them as much as you please.\r\nIt's almost as though people fear F# will turn into APL if the operator system is improved, but it won't, because people don't want that. This is a feature that will be very beneficial to some people, and for the most part it'll have little to no effect on everyone else. But there's a still decent chance that most people will reach a point in time, maybe a few times, where having these extra capabilities was essential and incredibly useful, just like with Units Of Measure.\r\nLet me be clear I don't want to use operators all the time, and I think that most of the time it's better and easier to understand code by using well named functions over glyph jumbles. My biggest issue with the current state of F# on this issue is it's very easy to make the worst kind code that fulfills and embodies all of the concerns people have brought up already. But there's no way to make and employ the symbols that would actually be useful.\r\n[1] https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html\r\n[2] https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID418"},{"Submitter":"Jared Hester","Submitted":"2016-01-09T15:37:00","Content":"[ Part 1 of 2 ]\r\nI disagree with the majority of Jack's points.\r\n> My chief concern is that you'd be forcing consumers of your code to use these symbols as well.\r\nThat's the point, it's not a detrimental aspect. When working in a specialized domain the ability to use a common and familiar set of symbols is of great benefit to reducing the overall cognitive load applied to problem solving. If a developer is using these symbols in their code, the intended consumers probably want to use them as well.\r\n> code with Unicode operators is much less approachable for newcomers to F# -- especially those who don't come from a math/science-heavy background -- and I worry it would keep people away from F# who might otherwise be quite happy with the language.\r\nThis is a completely unrealistic fear. The kinds of code it would most likely be used in are for highly domain specific math and science projects. These are not the kind of projects that newcomers to the language would be using in the first place. Even without the Unicode glyphs it'd still be unapproachable to newcomers. But that's fine, because it's not for them. We should want to have features in the language that make it more appealing to a wider group of people than it currently does, if a language as obtuse as Haskell can reach the level of popularity that it already has, I think F# will be fine with a few more options for operators.\r\n> Another drawback -- a number of mainstream development tools (including parts of VS) weren't designed with Unicode symbols in mind, and won't work properly when code or compiled assemblies use them in type/field/method names.\r\nAtom, Kate, Brackets, VsCode, Sublime, Vim, Emacs, XCode, Xamarin, these tools all work fine with Unicode Symbols. I use them all the time. I even added Unicode glyph support to Ionide for Atom to make it even easier to use them. Yes the tools should be fixed to handle them properly, but there's no impetus to do so if no one needs the functionality."},{"Submitter":"Matthew Orlando","Submitted":"2016-01-23T14:49:00","Content":"Everything Jared said. My browser (chrome on windows 10) doesn't even display all the characters he listed as valid binding names and yet... they're valid binding names. There is nothing but the fact that people are mostly sane keeping them from running amok with identifier names already. It's just certain sets of characters that seem arbitrarily excluded and would actually logically make sense in a functional language.\r\nOne of the biggest benefits of FP in general is that it's easy to make DSLs. Why would you want to artificially limit the expressiveness of those DSLs?\r\nThe structure of the arguments against adding math symbols as valid operators is identical to the arguments against allowing gay marriage. \"I'm uncomfortable with it, therefore others shouldn't be allowed.\" \"If we allow some people to start doing this, then everyone will start doing this and humanity (programmerity?) will be doomed\""},{"Submitter":"Alan Ball","Submitted":"2016-07-29T13:04:00","Content":"Let's not forget that the link to this page already had 110 votes."},{"Submitter":"Alan Ball","Submitted":"2016-08-02T12:57:00","Content":"The opponents to this suggestion would have us believe that some random assortment of characters is better than a simple symbol that you can even copy and paste into google to find what it means. The idea of \"substitution\" where you can actually figure out what each thing is supposed to mean predictably ultimately leads to something where you have unicode names as functions, losing operator precedence.\r\nu2211 mylist, or\r\nset1 |> u2229 <| set2\r\nis not easier than\r\n∑mylist\r\nand\r\nset1 ∩ set2"},{"Submitter":"Charles Roddie","Submitted":"2016-09-20T16:50:00","Content":"I think there are a few common operators which should be added to the F# spec.\r\n≤, ≥ and ≠ are very common but quite ugly and hard to understand in F#. <= and >= are familiar to progammers but not to non-programmers, and a <= b looks more like a⇐b than a≤b. <> looks nothing like ≠ and is unintelligible to anyone who has not read the F# spec.\r\nI think it would be close to no effort to include these as alternative syntax, and it would allow quantitative code to look a lot better.\r\n← and → could also be treated as more concise and better looking versions of <- and ->\r\n(Maybe ¬ ∧ ∨ for not, &&, ||, and ○ for <| too but these are less universally understood symbols.)\r\nF# is a very expressive language. You can often write code that is basically intelligible to technical people without specific programming knowledge. For example in teaching/presenting maths you can write F# code that is universally understandable, like pseudocode, except that it actually runs. With some small tweaks to approve attractiveness, readability, and intelligibility it can be even better."}],"Status":"","Response":null},"5690218":{"Number":"5690218","Submitter":"Anonymous","Submitted":"2014-03-27T00:00:00","Title":"Allow open in local declarations like in Standard ML and O'Caml (>= 3.12)","Text":"See e.g. http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#localdecs","Votes":67,"Comments":[{"Submitter":"Bryan Edds","Submitted":"2014-03-27T21:30:00","Content":"I like this, though I don't know what the downsides might be."},{"Submitter":"Anonymous","Submitted":"2014-03-28T19:00:00","Content":"I don't think there are any downsides to this. An \"open Module\" declaration has no run-time effects nor does it generate new types so there are no major semantic issues to worry about. It merely allows finer grained scoping of existing bindings."},{"Submitter":"Paul","Submitted":"2014-11-13T18:36:00","Content":"A prototype is available here.\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowOpenInExpressions/contribution/7691"},{"Submitter":"Don Syme","Submitted":"2015-07-18T06:41:00","Content":"Paul, could you please bring the PR across to http://github.com/Microsoft/visualfsharp? It is of definite interest (though no commitment about including the feature as yet)"}],"Status":"under-review","Response":null},"5695277":{"Number":"5695277","Submitter":"Gustavo Guerra","Submitted":"2014-03-28T00:00:00","Title":"Allow the addition of operators in type extensions, and also operators on internal types","Text":"This is currently not allowed:\r\ntype Foo with\r\nstatic member (+) (foo1, foo2) = foo1.Bar + foo2.Bar","Votes":80,"Comments":[{"Submitter":"Mauricio Scheffer","Submitted":"2014-04-09T22:09:00","Content":"This seems more concrete than http://fslang.uservoice.com/forums/245727-f-language/suggestions/5666323-operator-overloads-problem-in-f but since it can already be done with inline + static type parameters I wonder what would be the benefit of doing it via type extensions."},{"Submitter":"Don Syme","Submitted":"2014-06-20T14:04:00","Content":"See some commentary here that discusses a related problem and the relevant commpiler code: https://visualfsharp.codeplex.com/workitem/2"},{"Submitter":"Anonymous","Submitted":"2014-08-17T13:09:00","Content":"This would help with generic arithmetic on novel types, e.g. http://stackoverflow.com/questions/25346246/why-cant-we-satisfy-f-static-member-constraints-with-type-extensions/25347602#25347602"},{"Submitter":"Bryan Edds","Submitted":"2015-02-25T10:08:00","Content":"Just ran into this problem today, and worked around it with the scary inline workaround :) Would be nice if this worked and didn't cause any problems elsewhere!"},{"Submitter":"exercitus vir","Submitted":"2015-06-12T22:32:00","Content":"Yes, I need this too."}],"Status":"","Response":null},"5716959":{"Number":"5716959","Submitter":"Anonymous","Submitted":"2014-04-02T00:00:00","Title":"Support markdown in documentation comments","Text":"F# currently supports documentation comments with either XML tags or no tags. The no tags format is convenient to write, but does not allow formatting the comments for the VS IDE. Use of XML tags allows formatting the documentation comment, but the act of writing the documentation comment becomes a heavy burden as XML is not a very convenient format for manual editing. I would like to suggest supporting some lighter-weight formatting syntax such as markdown.","Votes":19,"Comments":[{"Submitter":"Tomas Petricek","Submitted":"2014-04-03T10:46:00","Content":"The F# Formatting library (http://tpetricek.github.io/FSharp.Formatting/metadata.html) already partly lets you do this. It is not integrated with the compiler, so it won't work nicely in Visual Studio - but if someone added transformation that generates standard XML comments from the Markdown that we already parse, it would work nicely at least for libraries. There is even an open issue for this: https://github.com/tpetricek/FSharp.Formatting/issues/44\r\nI think this is quite close - and with the transformation, you could document libraries with Markdown perfectly. But further integration with compiler would make it even nicer."},{"Submitter":"Mastr Mastic","Submitted":"2014-04-07T10:48:00","Content":"I would love this, and especially if the VS would support this in the IntelliSense tooltips."}],"Status":"","Response":null},"5762135":{"Number":"5762135","Submitter":"exercitus vir","Submitted":"2014-04-12T00:00:00","Title":"Support for type classes or implicits","Text":"(Updated the suggestion to \"type classes or implicits\", and edited it)\r\nPlease add support for type classes or implicits.\r\nCurrently, it's possible to hack type classes into F# using statically resolved type parameters and operators, but it is really ugly and not easily extensible.\r\nI'd like to see something similar to an interface declaration:\r\nclass Mappable =\r\nabstract map : ('a -> 'b) -> 'm<'a> -> 'm<'b>\r\nExisting types could then be made instances of a type classes by writing them as type extensions:\r\ntype Seq with\r\nclass Mappable with\r\nmember map = Seq.map\r\ntype Option with\r\nclass Mappable with\r\nmember map = Option.map\r\nI know that the 'class' keyword could be confusing for OO-folks but I could not come up with a better keyword for a type class but since 'class' is not used in F# anyway, this is probably less of a problem.","Votes":391,"Comments":[{"Submitter":"Will Smith","Submitted":"2014-04-13T13:13:00","Content":"I wouldn't say it's currently a hack; it's just how it's done. But, I think something like this would have potential if we can figure out what the actual benefits are and how do to design it in a way without confusing anyone.\r\nMore info: http://www.infoq.com/interviews/F-Sharp-Don-Syme\r\nNumber 6 shows Don talking about type classes."},{"Submitter":"exercitus vir","Submitted":"2014-04-15T06:35:00","Content":"Currently, it's definitely a hack. It's not extensible, you need to overload unused operators and F# Interactive has problems with scripts that depend on type classes (requires a restart of the session each time its run). Check this for more information on hacking type classes in F#: http://www.nut-cracker.com.ar/index.php/typeclasses-for-fsharp"},{"Submitter":"Will Smith","Submitted":"2014-04-15T16:07:00","Content":"Really good post about it. Thanks for the link.\r\nIt definitely feels like a hack if you try to make it behave exactly like Haskell."},{"Submitter":"Daniel Fabian","Submitted":"2014-04-18T03:10:00","Content":"Whilst, I would love to see this, I think for it be actually useful, we need higher-kinded polymorphism. As it stands now, even if you were able to define type classes, your Mappable would not compile, because 'm<'a> cannot be expressed with the .net type system.\r\nThe technique to simulate type classes has actually evolved somewhat and is _slightly_ less hacky now. E.g. you no longer need a special operator, etc. https://github.com/gmpl/FsControl"},{"Submitter":"Gusty","Submitted":"2014-05-13T04:43:00","Content":"\"...It's not extensible\" It is extensible, just orphan instances are not supported.\r\n\"...you need to overload unused operators\" this was due to a bug in F# parser, since the introduction of F# 3.0 this is not longer required.\r\nRegarding the script issue, I really don't get it, could you possible open an issue in https://github.com/gmpl/FsControl/issues describing this problem?\r\nI personally think F# can add Typeclass support requiring inline functions instead of support at the CLR Level. The same applies to Higher Kinds.\r\nSo the argument \"this is a suggestion for the CLR team\" is not valid, at least that's not what I'm suggesting.\r\nTo avoid the problem Don Syme mentions in the video, just keep ignoring extensions methods in overload resolution and create a \"prelude\" for existing types (that's the goal of FsControl)."},{"Submitter":"exercitus vir","Submitted":"2014-06-23T10:30:00","Content":"Daniel and Gusty,\r\nI was not talking about FsControl and I have not tried FsControl. The script issue occurs when you use the solution presented in http://www.nut-cracker.com.ar/index.php/typeclasses-for-fsharp\r\nI personally do not care about support at the CLR level. It would already be great if it was an F#-only solution like units of measure and statically resolved type parameters."},{"Submitter":"Craig Stuntz","Submitted":"2014-06-25T12:32:00","Content":"One possible keyword might be\r\ntype class Mappable = ...\r\nThat reads well and doesn't introduce any new reserved words. It does introduce ambiguity into the grammar, though."},{"Submitter":"Don Syme","Submitted":"2014-09-07T06:22:00","Content":"I'd like to point people to the two talks about implicits at the ML workshop to get a feeling for implicits and type classes in a mixed OO/FP language, or in an ML-class language.\r\nAny design for implicits in F# would differ substantially from these though.\r\nhttp://www.youtube.com/watch?v=3wVUXTd4WNc\r\nhttp://www.youtube.com/watch?v=--mrQSd6eas"},{"Submitter":"David Ellis","Submitted":"2014-10-27T16:13:00","Content":"I think this is the biggest missing piece to F#. F# needs some kind of support for ad-hoc polymorphism. Haskell has type classes and clojure has protocols. F# needs type classes. If I could use all my votes on this, I would."},{"Submitter":"exercitus vir","Submitted":"2014-11-07T05:50:00","Content":"I was not asking for implicits originally because I am not a big fan of implicits. Implicits can be abused to make code less type safe (e.g. converting floats to ints). They also feel hacky to me if you only want is type classes. Adapting types (implicits in Skala) is also less efficient that calling the functions directly (type classes in Haskell).\r\nI would prefer pure type classes and you could leverage the member constraints implementation of F# for a clean implementation of type classes in F#."},{"Submitter":"Gusty","Submitted":"2014-11-19T16:26:00","Content":"I know you were not talking about FsControl (http://github.com/gmpl/FsControl) but in the post you mentioned (now moved to http://nut-cracker.azurewebsites.net/typeclasses-for-fsharp) I described a technique which inspired me later to develop FsControl, which runs in F# 3.0 so you don't need to use operators at all. Support for this technique (or similar) at the language level (not CLR) will be nice."},{"Submitter":"Radek Micek","Submitted":"2015-06-07T05:47:00","Content":"What about implementation similar to type providers? For each parameter annotated with [<Witness>] attribute where the argument is not given explicitly in the code the compiler would call all witness providers in the scope to generate the argument. If only single witness is generated then this witness becomes the argument otherwise it's an error.\r\nAdditionally if there is a single value in the scope which can be used as the argument then it is used as the argument and witness providers are not used."},{"Submitter":"Kurt","Submitted":"2015-07-06T02:58:00","Content":"I haven't given this any votes because what I've missed is some sort of retro-active interface implementation, like is possible with protocols in Clojure and recently swift. So I voted for this one instead:\r\n[/ideas/suggestion-5665042-allow-extension-interfaces](/ideas/suggestion-5665042-allow-extension-interfaces.md)\r\nbecause it is more focused.\r\nTypeclasses solve that problem but protocols seems to me like a solution that is closer to the existing design space of F# (i.e. a functional first language with OO concepts like subtyping). Typeclasses have many extensions - functional dependencies, overlapping instances, etc that are essentially research problems. What happens if you use two libraries that each instantiate the same typeclass for the same type in a different way? And how do typeclasses work with subtyping?\r\nFinally proposing an idea for A or B (even if A and B are related) draws votes away from more focused suggestions. (e.g. this suggestion has something for everyone so it's not clear what I'm voting for here. Even the original poster commented they don't really want implicits...)"},{"Submitter":"Radek Micek","Submitted":"2015-10-19T16:15:00","Content":"> What happens if you use two libraries that each instantiate the same typeclass for the same type in a different way?\r\n@Kurt Doesn't this problem exist with protocols too? What should happen when two different assemblies implement the same protocol for the same type in a different way?\r\nAFAIK in Haskell this leads to failure when linking. In Scala this is resolved by scoping rules for implicits (which is IMO better than Haskell).\r\n> And how do typeclasses work with subtyping?\r\nThis could be derived from implicits."},{"Submitter":"Don Syme","Submitted":"2016-02-03T13:45:00","Content":"See also\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/6343928-allow-naming-of-member-constraints\r\nThese various features tug in different incompatible directions."},{"Submitter":"bleis-tift","Submitted":"2016-03-02T18:18:00","Content":"OCaml way: http://www.lpw25.net/ml2014.pdf"}],"Status":"","Response":null},"5823074":{"Number":"5823074","Submitter":"Christoph Rüegg","Submitted":"2014-04-23T00:00:00","Title":"Stronger type directed conversion from functions to .Net delegates","Text":"It seems in some cases type directed conversion from functions to .Net Func<_,_> delegates only works if the called method has overloads. It would be convenient if it worked the same way for methods without overloads as well.\r\nFor example:\r\nopen System.Linq\r\nlet even n = n % 2 = 0\r\nlet seqA = seq { 0..2..10 }\r\nseqA.Where(even) // works\r\nseqA.All(even) // does not work\r\nhttp://stackoverflow.com/questions/23256355/passing-f-function-to-ienumerable-where-vs-ienumerable-all\r\nhttp://stackoverflow.com/questions/12933366/f-func-type-inference-difference-between-seq-and-pseq-todictionary","Votes":25,"Comments":[{"Submitter":"Christoph Rüegg","Submitted":"2014-04-23T18:01:00","Content":"Workarounds:\r\nseqA.All(System.Func<_,_>(even))\r\nseqA.All(fun x -> even x)"},{"Submitter":"Albert-Jan","Submitted":"2014-08-01T13:06:00","Content":"This does work:\r\neven |> seqA.all"},{"Submitter":"Daniel Ferreira Monteiro Alves","Submitted":"2015-04-26T13:31:00","Content":"Why not use the .NET native Action and Func and other delegates unstead of the only F# specific closure? Or at least, allow some implicit convertion here."}],"Status":"under-review","Response":null},"5900625":{"Number":"5900625","Submitter":"amazingant","Submitted":"2014-05-08T00:00:00","Title":"Add NameOf operator to follow C#/VB update","Text":"The Roslyn compiler currently (as of 2014-05-08) has a new NameOf operator listed as \"Planned\" for both C# and VB:\r\n(https://roslyn.codeplex.com/wikipage?title=Language%20Feature%20Status&referringTitle=Documentation)\r\nPending its arrival there, it would be awesome to get something similar in F# as well.","Votes":126,"Comments":[{"Submitter":"Don Syme","Submitted":"2014-11-14T12:35:00","Content":"I agree this should be added to F#.\r\nThe exact design needs nailing down. A special library intrinsic \"val nameof : 'T -> string\" looks appropriate, where \"T\" can be either an expression, a first-class use of a method or a typeof<...> expression may be simplest. The check.fs and opt.fs in the F# compiler would then treat this construct as special, doing a compile-time evaluation.\r\nhttps://gist.github.com/forki/7c8ef4c3126c953630fb shows the kind of place where this is used in C#."},{"Submitter":"Steffen Forkmann","Submitted":"2014-11-15T06:24:00","Content":"I have a prototype implementation. Will send a first pull request for discussion soon."},{"Submitter":"Steffen Forkmann","Submitted":"2014-11-15T13:30:00","Content":"Pull request is at https://visualfsharp.codeplex.com/SourceControl/network/forks/forki/fsharp/contribution/7698"},{"Submitter":"exercitus vir","Submitted":"2015-06-19T18:06:00","Content":"This is adding the name at compile-time right?"},{"Submitter":"zjv","Submitted":"2015-12-01T03:35:00","Content":"Would really like this feature. Currently I have some ugly code with a hardcoded string in F# which I would like to improve. A nameof would make the code much safer against refactorings.\r\n[<ReflectedDefinition(true)>]\r\nlet foo (x) = ...\r\nlet fooType = foo.GetType().DeclaringType.GetMethod(\"foo\")\r\nlet fooExpr = Expr.TryGetReflectedDefinition(fooType)"},{"Submitter":"ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)","Submitted":"2016-02-03T13:55:00","Content":"PR at https://github.com/Microsoft/visualfsharp/pull/908"},{"Submitter":"Yemi Bedu","Submitted":"2016-05-27T10:59:00","Content":"[/ideas/suggestion-5674940-implement-syntactic-macros](/ideas/suggestion-5674940-implement-syntactic-macros.md)\r\nAllowing my suggested function extension or macros would allow this implementation to be trivial. I explain this again below:\r\n-----\r\nSo what would be nice is to extend the resolution of function parameters so that they wrap their parameters to be quotation expressions if it is a macro definition. Otherwise it would pass in the direct object value as normal. We can introduce a new keyword to make the distinction.\r\nThe definition of it could look like:\r\n// def is a let that will pass in arguments as a Quotations.Expr\r\ndef nameof (arg:Quotations.Expr) : string = match arg with | Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nlet y = 1\r\nprintfn \"%s\" (nameof y)\r\nThe boxing will just find the most local definition of parameter if it is a variable or wrap the expression directly as <@ expression @>\r\nThis could allow us to use a lot of existing code and framework already in F#"}],"Status":"started","Response":{"Responded":"2016-06-17T00:00:00","Text":"RFC is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1003-nameof-operator.md"}},"5927125":{"Number":"5927125","Submitter":"Gusty","Submitted":"2014-05-14T00:00:00","Title":"Allow implementation of generic methods with constraints of the form 'T :> 'U","Text":"Currently this is solved as 'a = 'b.\r\nThis limitation does not exists in C# and it makes impossible to interact with some existing libraries, as in this case http://stackoverflow.com/questions/23643989/is-it-possible-to-implement-the-idbsett-interface-in-f\r\nThis will also allow to work around F#'s lack of generic (co/contra)-variance.","Votes":136,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-06-18T14:30:00","Content":"Could Don Syme or someone from the F# team comment on whether this can be realized?"},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2015-07-13T09:05:00","Content":"Maybe you can tweet him with this. But completed features have a very low vote count generally: https://fslang.uservoice.com/forums/245727-f-language/status/1225916. Possibly suggested by the core team."},{"Submitter":"Suminda Sirinath Salpitikorala Dharmasena","Submitted":"2015-07-13T09:05:00","Content":"Twitter link is: https://twitter.com/dsyme"},{"Submitter":"Isaac Abraham","Submitted":"2016-02-11T06:35:00","Content":"What makes you think they were suggested by the core team? You can see the names of people that have raised each of the completed features."},{"Submitter":"Anonymous","Submitted":"2016-05-26T13:35:00","Content":"Yes please"}],"Status":"","Response":null},"5975840":{"Number":"5975840","Submitter":"Tomas Petricek","Submitted":"2014-05-27T00:00:00","Title":"Allow \"params\" dictionaries as method arguments","Text":"When interoperating with languages that are more dynamic than F# (like Python, Matlab or R), we can often get the list of available methods/functions, but we cannot always get the names and types of parameters. For example, in R provider, you sometimes have to write:\r\nnamedParams [ (\"xval\", days), (\"yval\", prices), (\"another\", box 1) ]\r\n|> R.plot\r\nIt would be nice if I could put the \"Params\" attribute on a \"IDictionary<string, 'T>\" and let the compiler provide all additional named parameters as a dictionary:\r\nR.plot(xval=days, yval=prices, another=1)\r\nThis would have other uses - for example, when creating a Deedle data frame, you need to specify names of columns. We have a custom operator and function for that:\r\nframe [ \"prices\" => prices; \"days\" => days ]\r\nBut with the new feature, we could let you write, for example:\r\nFrame.ofColumns(prices = [...], days, = [...])\r\nThis could really be done just by adding [Params] attribute to an IDicitionary parameter. To support the R provider case, this needs to work in type providers too.","Votes":30,"Comments":[{"Submitter":"Tomas Petricek","Submitted":"2014-05-27T12:02:00","Content":"Just for a reference, I imagine that the definition would look like this:\r\ntype R =\r\nstatic member plot([<Params>] args:IDictionary<string, obj>) = (...)\r\nI suppose one subtle thing here is to make sure that the type information propagates correctly through the type inference - so when you define it as taking `obj`, the arguments will need to be boxed, but when you define the dictionary as containing just `float` values, the optional arguments would presumably be restricted to floats."},{"Submitter":"Richard Minerich","Submitted":"2014-05-27T14:12:00","Content":"It also should be noted that IDictionary does not have an ordering while the arguments do. It would be ideal to capture this information."},{"Submitter":"Don Syme","Submitted":"2014-06-20T11:46:00","Content":"I'm generally in favour of addressing this for F# 4.0, if a technically feasible design is proposed, analyzed in detail, and an implementation+testing provided by the F# Community.\r\nTo get more concrete, what's being proposed is presumably a new attribute ParamDictionary used like this:\r\nopen System\r\nopen System.Collections.Generic\r\nopen System.Runtime.CompilerServices\r\ntype C() =\r\nstatic member DoSomething1([<ParamArray>] args: 'T[]) = ()\r\nstatic member DoSomething2([<ParamDictionary>] args: IDictionary<string,obj>) = ()\r\nC.DoSomething2(arg1=1, arg2=3)\r\nIs that correct?\r\nImplementing this is non-trivial (Tomas mentions some reasons why) and libraries would pick up a dependency on the updated FSharp.Core containing the attribute."},{"Submitter":"Jack Pappas","Submitted":"2014-07-06T09:42:00","Content":"I don't know about the user-facing side of things (i.e., how to expose this in the language), but on the compiled side of things, you could represent this using the usual [<ParamArray>] attribute with a KeyValuePair<string,obj>[]-typed parameter. That would avoid the need for consuming code to take a dependency on FSharp.Core and it would preserve parameter ordering (as Rick mentioned). Although this doesn't actually use IDictionary<_,_>, it doesn't seem likely that most real-world uses are going to pass in more than, say, 20-30 arguments, so lookups can use a linear scan of the argument array to find a matching k-v pair without too much performance overhead."},{"Submitter":"Jack Pappas","Submitted":"2014-07-06T09:48:00","Content":"Another way to implement this (besides what I mentioned below) would be to have a [<ParamDictionary>] attribute and have the F# compiler compile that parameter into an ExpandoObject. That would interop a bit more closely with C# dynamic and the DLR, but the price is that it wouldn't work if targeting a .NET Framework earlier than 4.0."}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"Updating to planned to indicate this is approved in general terms. A detailed design and implementation would be needed.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"}},"5980924":{"Number":"5980924","Submitter":"Tomas Petricek","Submitted":"2014-05-28T00:00:00","Title":"Allow specifying subset of type arguments explicitly","Text":"Say we have a generic type Frame<TRow, TColumn>. When using instance methods of the frame, it is possible to write a generic method that takes a single additional type parameter - for example, to get a column as a specific type:\r\nframe.GetColumn<float>(\"Value\")\r\nHowever, doing the same thing using module and function is not possible, because the corresponding `getCol` function requires three type arguments (TRow, TCol and the additional one):\r\nframe |> Frame.getCol<_, _, float> \"Value\"\r\nIt would be nice if F# had some mechanism that would allow specifying only subset of the type parameters. For example:\r\nlet getCol<[<RequiresExplicitTypeArguments>] 'T, 'TCol, 'TRow> frame = (...)\r\nAnd then I could write just:\r\nframe |> Frame.getCol<float> \"Value\"\r\nInterestingly, this is also problem for extension methods. When you define a C#-style extension method for a generic type like frame, it also has three type arguments and it is impossible to call it with just a single type argument.","Votes":7,"Comments":[{"Submitter":"Don Syme","Submitted":"2014-06-20T11:38:00","Content":"Having seen the impact this problem has on Deedle, I'm in favour of addressing it for F# 4.0. I will mark it \"approved\" (using the label \"planned\") as a result, though the details need to be worked out.\r\nAnother possible declaration syntax is this:\r\nlet getCol< 'T, 'TCol, [<OptionalArgument>] 'TRow > frame = ()\r\nor this\r\nlet getCol< 'T, 'TCol, 'TRow? > frame = ()\r\nThe former has the downside that it could only be used with an updated FSharp.Core since the Microsoft.FSharp.Core.OptionalAttribute would need to be updated with a flag to say it's permissible to use the attribute here (or the F# 4.0 compiler would need to be adjusted to allow the use of this attribute even if the flag has not been updated, e.g. when using FSharp.Core 4.3.0.0 with F# 4.0 compiler)\r\nWe should also now consider what the precise language/spec rules should be. Please list questions to be addressed below."},{"Submitter":"Gusty","Submitted":"2015-11-08T02:12:00","Content":"For completeness it will be nice to allow to use the underscores in the declaration as well.\r\nlet func<_> = ()\r\nCurrently this is allowed: let func< 'T, .. > = ()\r\nSo, this should be allowed too: let func< .. > = ()"}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"Updating to planned to indicate this is approved in general terms. A detailed design and implementation would be needed.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"}},"6002107":{"Number":"6002107","Submitter":"Robert Jeppesen","Submitted":"2014-06-02T00:00:00","Title":"Add string interpolation to println syntax (from Swift)","Text":"The new language from Apple, Swift has a really nice syntax for println:\r\nhttp://en.wikipedia.org/wiki/Swift_(programming_language)\r\nlet people = [\"Anna\": 67, \"Beto\": 8, \"Jack\": 33, \"Sam\": 25]\r\nfor (name, age) in people {\r\nprintln(\"\\(name) is \\(age) years old.\")\r\n}\r\nWe could steal the idea but use % instead of \\ for a better fit. It would also be compatible, and combinable (is that a word?) with existing printfn syntax:\r\nlet name = \"Robert\"\r\nprintfn \"Hi %(name), your age is %d\"\r\nprintfn : int -> string\r\nNaturally there would be compiler errors if name does not exist.","Votes":179,"Comments":[{"Submitter":"Jarle Stabell","Submitted":"2014-06-02T17:50:00","Content":"I've \"always\" wanted something like this in F#. It feels very old-fashioned having to manually specify the \"types\" in printf in a language with type inference. Also, it's a totally separate, although simple, \"type language\".\r\n(Scala has a much more generic mechanism, perhaps overkill though)."},{"Submitter":"Mauricio Scheffer","Submitted":"2014-06-02T18:19:00","Content":"Related: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5678806-string-interpolation"},{"Submitter":"Marcin Juraszek","Submitted":"2014-06-02T19:21:00","Content":"There is similar idea for C#: http://roslyn.codeplex.com/discussions/540869"},{"Submitter":"Mauricio Scheffer","Submitted":"2014-06-02T21:45:00","Content":"@Marcin: not really. The Roslyn thread is about general string interpolation. This one is a limited application for printf. See my link above for the F# discussion about general string interpolation."},{"Submitter":"Heather Cynede","Submitted":"2014-06-03T01:55:00","Content":"from Nemerle?\r\nhttp://en.wikipedia.org/wiki/Nemerle#String_formatting"},{"Submitter":"Loic Denuziere","Submitted":"2014-06-03T04:43:00","Content":"General string interpolation exists in many languages, including Nemerle as you noted Heather. A big inconvenient is that it would require yet another string delimiter (we have 3 already...). This is about having it as an extra *printf format character, which is probably a smaller can of worms to open."},{"Submitter":"Robert Jeppesen","Submitted":"2014-06-03T17:57:00","Content":"It's worth noting that in Swift (and Nemerle), these interpolations are expressions, so you can do\r\nprintfn \"The sum is %(a + b)\"\r\nThis would be nice here, but if that raises the amount of work to prohibiting levels, I think it can be skipped."},{"Submitter":"Don Syme","Submitted":"2014-06-20T09:57:00","Content":"I am very positively predisposed to this feature - at least where only a variable name can be interpolated.\r\nQuestions\r\n- Could you use a long identifer %(name1.name2)? I presume not, but it may be a relatively simple extension to allow this.\r\n- What formatting would be used, e.g. for floating point values. Is it %A? Can you modify formatting specifiers?\r\n- Could you use a mix of %d and %(name) specifiers in a single printf format string? My intuition is to allow this, but if the implementation becomes too complex then to disallow it.\r\nDo other people have detailed questions about the specification and scope of this feature?\r\nNote that I have begun labelling some features as \"approved\" (actually the label is currently called \"planned\", though I think of it as \"approved\"), see https://fslang.uservoice.com/forums/245727-f-language/status/1225914.\r\nLabelling something as \"approved\" is not committing to \"doing\" the feature, but it does mean we would in theory accept implementations (with corresponding testing) of these features into the \"fsharp4\" branch at https://visualfsharp.codeplex.com/.\r\nSo we would ask you to consider implementing this feature and submitting it. The implementation would then flow throughout all delivery vehicles for F#. We would provide lots of assistance to those seeking to implement the feature.\r\nI already labelled a couple of printf suggestions as \"approved\".\r\nIf you disagree with labelling a feature as \"approved\", please argue your case through the User Voice comments, at least initially :)\r\nThanks\r\nDon Syme"},{"Submitter":"bleis-tift","Submitted":"2014-06-20T20:00:00","Content":"FYI, scala has similar feature.\r\nhttp://docs.scala-lang.org/overviews/core/string-interpolation.html"},{"Submitter":"Vladimir Matveev","Submitted":"2014-07-01T17:51:00","Content":"ok, I took a stab on this feature and have a working prototype (https://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary?branch=fsharp4)\r\nbriefly: when analyzing format string compiler splits it into chunks: textblocks and embedded expressions (that are denoted by wrapping them in %()).Then final string that will be passed as a parameter to the constructor of PrintFormat is evaluated as ' string.Concat([| textblock1; expr1; textblock2; expr2... |]) '. All logic that manufactures phantom types remains intact. To evaluate expressions typechecker tries to parse it using provided access point to parser and typecheck it.\r\nPros: implementation is relatively simple, supports both %(expr) and %(d) specifiers, embedded expressions are regular F# expressions so long names or operators inside are not problem.\r\nCons: the entire feature is implemented on the semantic level so purely syntax based goodies will require extra effort to work with it, As an example if syntax highlighting is implemented only based on syntactic information then embedded expressions will be highlighted as a string."},{"Submitter":"Nikita Nemkin","Submitted":"2015-06-02T10:09:00","Content":"Rascal (metaprogramming language) has an amazing string interpolation facility: http://tutor.rascal-mpl.org/Rascal/Expressions/Values/String/String.html\r\nIt works for all strings (not only println argument) and interpolates arbitrary expressions and even basic control structures."},{"Submitter":"exercitus vir","Submitted":"2015-06-19T18:05:00","Content":"This is awesome."},{"Submitter":"Don Syme","Submitted":"2015-09-05T06:02:00","Content":"This feature didn't make it for F# 4.0 due to some lingering concerns about the design. The prototype for this feature can be found here: https://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary/contribution/7063. If you would like to pick up the prototype and take it further please rebase it as a fork of \"master\" of http://github.com/Microsoft/visualfsharp"},{"Submitter":"Steffen Forkmann","Submitted":"2016-02-01T08:39:00","Content":"Rebased version can be found at https://github.com/Microsoft/visualfsharp/pull/921"},{"Submitter":"Jon Nyman","Submitted":"2016-02-18T10:42:00","Content":"type Person = {name: string; age: int}\r\nlet person = {name = \"Robert\"; age=5}\r\nprintfn \"Hi %(person, A), your age is %(person.age, 5i) with space or age %(person.age) without.\"\r\nprintfn : int -> unit"},{"Submitter":"Jon Nyman","Submitted":"2016-02-18T10:43:00","Content":"or rather\r\nprintfn : unit -> string"},{"Submitter":"Robert Jeppesen","Submitted":"2016-02-19T05:47:00","Content":"I'd prefer it if this feature isn't limited to printf functions, but applied generally to all string literals, like literals in C# with '$' prefix."}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Approved in principle (and has been for a while), please see RFC FS-1001 https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1001-StringInterpolation.md\r\nDon Syme, F# Language Evolution"}},"6063696":{"Number":"6063696","Submitter":"Goswin","Submitted":"2014-06-17T00:00:00","Title":"Internationalized printf formatting of numbers","Text":"Most non-english speaking countries use \",\" as deciamal separator.\r\nit would be nice if I could write <sprintf \"%,1f\" 2.222> instead of <sprintf \"%.1f\" 2.222> to get a comma as a decimal separator.","Votes":8,"Comments":[{"Submitter":"Don Syme","Submitted":"2014-06-20T06:40:00","Content":"This is a reasonable suggestion. From the point of view of the F# language design, I would be happy to see a well-considered set of practical extensions to printf added to F# 4.0 or later versions. This could be one of them.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly incuding Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest.\r\nIf provided, the design should be\r\n- analyzed and extended with respect to a broader set of potential non-english-speaking numerical formats\r\n- sent for community discussion, for example by adding a link to a more detailed proposal to the end of this post, or by submitting a concrete implementation\r\nThanks\r\nDon Syme, current \"BDFL\" for F# Language Design"},{"Submitter":"Don Syme","Submitted":"2014-06-25T12:04:00","Content":"Adjusted the title to match my earlier comment"},{"Submitter":"Goswin","Submitted":"2014-06-30T03:56:00","Content":"related:\r\nhttp://stackoverflow.com/questions/21462617/how-to-get-culture-aware-output-with-printf-like-functions"}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"This is a reasonable suggestion. From the point of view of the F# language design, I would be happy to see a well-considered set of extensions to printf added to F# 4.x or later versions.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nWe would strongly welcome an implementation proposal and initial testing for this.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library..\r\nThanks\r\nDon Syme, F# Language and Core Library Evolution"}},"6080367":{"Number":"6080367","Submitter":"Gustavo Guerra","Submitted":"2014-06-20T00:00:00","Title":"Support for Generic Provided Type Definitions","Text":"This is needed for TPs that interop with other languages. A good example is the TypeScript type provider in Funscript","Votes":85,"Comments":[],"Status":"","Response":null},"6085086":{"Number":"6085086","Submitter":"Robert Nielsen","Submitted":"2014-06-22T00:00:00","Title":"Nested types for F#","Text":"I don't think F# supports nested type definitions yet.\r\nThe idea was posted here:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2313137-inner-types-for-f\r\nTwo other references on nested types:\r\nhttp://msdn.microsoft.com/en-us/library/ms173120.aspx\r\nhttp://cs.hubfs.net/topic/None/57397","Votes":45,"Comments":[{"Submitter":"James Freiwirth","Submitted":"2014-10-20T15:10:00","Content":"This would be great. Also allowing 'open' statements in the same way that you can with nested modules would help to make large codebases more organised and easier to maintain."},{"Submitter":"Gauthier Segay","Submitted":"2015-08-05T07:01:00","Content":"I concur that we need fuller support of .net type system."}],"Status":"","Response":null},"6085102":{"Number":"6085102","Submitter":"Robert Nielsen","Submitted":"2014-06-22T00:00:00","Title":"Allow F# compiler directives like #nowarn to span less than an entire file.","Text":"Idea posted here:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3338653-allow-f-compiler-directives-like-nowarn-to-span\r\nA possibly related issue / suggestion is listed here:\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/5676502-disable-compiler-warnings-per-line","Votes":7,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-06-19T17:32:00","Content":"You could use #endnowarn \"[number]\" to explicitely end a compiler directive."},{"Submitter":"Mark Seemann","Submitted":"2016-05-29T02:11:00","Content":"In C#, this feature exists, and has the following form:\r\n#pragma warning disable 618\r\ncode...\r\n#pragma warning enable 618\r\nThis enables you to suppress specific compiler warnings locally, which is quite important for evolving APIs: sometimes you need to deprecate a particular API (function, type), but keep it around for backwards compatibility. This means that your own code may still need to use the deprecated code for a while longer (for e.g. unit tests), so it'd be nice to enable that scenario without suppressing all other warnings."}],"Status":"","Response":null},"6108807":{"Number":"6108807","Submitter":"Dave Thomas","Submitted":"2014-06-27T00:00:00","Title":"Allow Object expressions to have attributes applied to them","Text":"In the simplest case something like this would be possible:\r\n[<MyAttribute>]\r\nlet makeResource name =\r\n{ new System.IDisposable\r\nwith member this.Dispose() = printfn \"%s disposed\" name }\r\nAnd then when the code is compiled the expression thats generated would also have the attribute applied to it.\r\nThis would interoperability with frameworks that use declarative attributes which would otherwise require adding a full type","Votes":4,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2014-06-28T01:44:00","Content":"I think it's more logical to place attributes right before object expression itself, like this:\r\nlet makeResource name =\r\n[<MyAttribute>]\r\n{ new System.IDisposable with\r\nmember this.Dispose() = printfn \"%s disposed\" name }\r\nIt's also better since we now can apply attributes not only in bindings, but in any expression:\r\nfunc ([<MyAttribute>]\r\n{ new System.IDisposable with\r\nmember this.Dispose() = printfn \"%s disposed\" name },\r\nanotherArg)"},{"Submitter":"Don Syme","Submitted":"2015-07-18T13:28:00","Content":"I tend to agree that this should be supported (though the location for the attributes would be different to shown above)"},{"Submitter":"zhonglei chen","Submitted":"2016-01-30T12:29:00","Content":"I agree with this suggestion due to performance consideration.\r\nIf we can add attribute to object expression, we can apply the following pattern to improve the performance of algorithms:\r\nlet sort<'a, 'c when 'c :> System.Collection.Generic.IComparer<'a>>( array : 'a[], comparer : 'c ) = ...\r\nlet filter<'a, 'p when 'p :> XXX.Predicate<'a>>( array : seq<'a> , predicate : 'p) = ...\r\n...\r\nnow, users can access these algorithms by passing an object expression:\r\nsort([0..1000000], { new IComparer<int> with member this.Compare(a, b) = a.CompareTo(b) })\r\nfilter([0..1000000], { new Predicate with member this.Filter(a) = a % 2 = 0 })\r\nat this point, it looks like the client code injection mechanism goes back to java, so how can we benifit from this ?\r\nwe can apply the struct attribute to object expression to force the anonymous type to be generated as struct:\r\nsort([0..1000000], [<Struct>] { new IComparer<int> with member this.Compare(a, b) = a.CompareTo(b) })\r\nfilter([0..1000000], [<Struct>] { new Predicate with member this.Filter(a) = a % 2 = 0 })\r\nand then the JIT compiler will generate some individual algorithms for each anonymous type here, and inlining the Compare/Filter method into inner loop of algorithm.\r\nwe can benifit much from this."}],"Status":"","Response":null},"6122717":{"Number":"6122717","Submitter":"Don Syme","Submitted":"2014-07-01T00:00:00","Title":"Allow nested property setters and collection property setters in initializers","Text":"I suggest we consider allowing A.B=expr property setters in initializers, e.g.\r\n\r\nUIButton(UIButtonType.Custom, Layer.BorderWidth = 1.0, Layer.BorderColor=UIColor.Gray.CGColor, Radius = size / 2.0)\r\ncf. https://github.com/dvdsgl/shallow/blob/master/Shallow/RoundButton.fs#L6\r\nAlso, we should consider allowing collection setters, e.g.\r\nC(CollectionProperty = [ 1;2;3 ])\r\nwhere CollectionProperty has the \"Add\" pattern of C#. One design would make it tht any IEnumerable<T> would be assignable, where T corresponds to the type of an Add method, though that may not be fully compatible with the C# mechanism.","Votes":12,"Comments":[{"Submitter":"Dave Thomas","Submitted":"2014-07-06T03:37:00","Content":"Having an IList<_>.Add mechanism as mentioned would make interop with lots of C# more palatable as extra create methods would ordinarily have to be added or assign an intermediate type."},{"Submitter":"Paul","Submitted":"2014-07-21T19:29:00","Content":"It might be more readable to explicitly specify the property setter to distinguish it from a standard setter with something like\r\nlet init values f = values |> Seq.iter f\r\nC(CollectionProperty.Add |> init [1;2;3])\r\nOr use a property setter extension which adds the items to given collection.\r\nC(InitializingCollectionPropertyExtension = [1;2;3])"},{"Submitter":"Paul","Submitted":"2014-10-19T13:52:00","Content":"An initial implementation of this feature has now been submitted here: https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters"},{"Submitter":"Don Syme","Submitted":"2014-10-20T09:35:00","Content":"Hi Paul,\r\nThat's great news! I'll definitely be taking a look at this.\r\nCould you submit a pull request for that branch so we can see the overall changes more easily? (You may need to rebase the branch) Also could you write up a description of what is and isn't allowed (this should also match your testing)\r\nThanks\r\nDon"},{"Submitter":"Don Syme","Submitted":"2014-10-20T10:08:00","Content":"(BTW I now see the implementation in the \"master\" branch of https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters)"},{"Submitter":"Don Syme","Submitted":"2014-10-20T10:09:00","Content":"(Also, for those wondering, the design is summarized in this commit: https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters/changeset/147eff4c8542fd5d5f1e351c831da7d653d679f3)"},{"Submitter":"Don Syme","Submitted":"2014-10-20T10:09:00","Content":"(That's the proposed, experimental design)"},{"Submitter":"Paul","Submitted":"2014-10-21T11:28:00","Content":"A pull request has now been submitted."}],"Status":"","Response":null},"6181848":{"Number":"6181848","Submitter":"Isaac Abraham","Submitted":"2014-07-16T00:00:00","Title":"Provide better support for structural typing","Text":"In F#3 you can declare a function which can operate on e.g. records which has no relation aside from the fact that they share e.g. field name + type. This can occasionally be useful - however, the syntax for achieving this is somewhat awkward e.g. http://codebetter.com/matthewpodwysocki/2009/06/11/f-duck-typing-and-structural-typing/\r\nIf there were a more succinct way to achieve this, it could be a very powerful feature e.g.\r\ndecorating a function with [<StructuralTyping>] to automatically indicate to the compiler to infer the implicit structure of the type, or at least simplifying the syntax to not have to mess around with \"'a member\" etc..","Votes":17,"Comments":[{"Submitter":"trek42","Submitted":"2014-08-27T12:35:00","Content":"structural typing is in general very useful, and can avoid using the OO-style inheritance in many places.\r\nWould be nice if F# supports typeclass, and implements this particular type of structural typing in the framework of typeclass. Something like:\r\ntypeclass ClassName = { property_name: type; ... }\r\nand every record type that has all the listed fields automatically becomes an instance of the typeclass."},{"Submitter":"Richard Gibson","Submitted":"2014-09-12T05:47:00","Content":"I really like the way Typescript does this. You can either use an interface (the object in question does not have to explicitly implement the interface to satisfy it, although it can) or you can declare the 'shape' of the object inline. Such as:\r\nclass Person\r\n{\r\nconstructor(public name : string)\r\n{}\r\n}\r\nvar sayHello = function (named : { name : string })\r\n{\r\nreturn \"Hello \" + named.name;\r\n}\r\nsayHello(new Person(\"John\"));"},{"Submitter":"Tobias Burger","Submitted":"2014-12-12T08:46:00","Content":"Would be cool to have a structural type syntax like in TypeScript. Especially for interop scenarios, where often a type/class is needed for binding.\r\ntype PersonController() =\r\ninherit ApiController()\r\nmember __.GetGreeting(person: { name: string; age: int }) =\r\nsprintf \"hello %s, you are %i years old\" person.name person.age"},{"Submitter":"Don Syme","Submitted":"2016-02-05T06:20:00","Content":"Strucutral subtyping is hard to implement within the constraints of the .NET type system. Any implementation would effectively have to erase to property bags at compile time. See the discussion here for example: http://fslang.uservoice.com/forums/245727-f-language/suggestions/9633858-structural-extensible-records-like-elm-concrete. This representation would also not work particularly well with .NET reflection.\r\nHow bad is this? Well, for normal F# use it is quite bad. But for lower-performance information-representation scenarios it may not too bad.\r\nI'll leave this open as a general placeholder for votes on \"better structural subtyping\""},{"Submitter":"Isaac Abraham","Submitted":"2016-08-12T07:05:00","Content":"Don - I'm not really sure if I'm thinking along the same lines here - I'm thinking for just syntactic sugar for either the duck-typing support that already exists in F#. I don't even know how this works internally (is the structural constraint erased at runtime? what's the signature of the method at runtime?).\r\nThis could even be something that was erased away at compile-time and resorted to something less than that at runtime (in a similar way to units of measure?). I don't know :-)"}],"Status":"","Response":null},"6193110":{"Number":"6193110","Submitter":"Demetrios Obenour","Submitted":"2014-07-19T00:00:00","Title":"Add StructOption<T>","Text":"Currently, whenever a new Option is created, a heap allocation is required. This comes at a performance penalty.\r\nI suggest that a new type StructOption<T> be made available for performance.","Votes":59,"Comments":[{"Submitter":"Arbil","Submitted":"2014-07-20T02:53:00","Content":"This is much needed. For maximum performance, is there a reason why options on reference types cannot be just syntactic sugar on `null`? By that I mean that for both `T` and `T option` the underlying type is just `T`, and matching on option is compiled to `if opt = null then..;else..`."},{"Submitter":"Demetrios Obenour","Submitted":"2014-07-20T12:14:00","Content":"I agree with Arbil. This would have the further advantage that Option<T> could be restricted (as a .NET type in the CIL) to where T is a struct -- so Option<T> would not box the struct.\r\nIf this is not possible, use two types: one where T is a reference type, and one where T is a value type -- it is not acceptable for Option<T> where T is a struct to box the struct."},{"Submitter":"Fraser Waters","Submitted":"2014-07-21T06:03:00","Content":"\"Also, it would be nice if there was a way to create an Option<T> type (where T is a struct) without boxing the struct.\" This is already the case. Option is a proper generic type, when T is a value type the jit will create new instances of Option so that the value stored does not need to be boxed (Same way List<T> doesn't box value types).\r\n\"For maximum performance, is there a reason why options on reference types cannot be just syntactic sugar on `null`?\" I figure generics throw a spanner in the works here, if you have a generic method that takes a generic option that has to be done with the proper option class to support being able to pass both structs and classes in (structs couldn't be passed in as null, and nullable<T> is a totally different type).\r\nIt's probably possible to have an optimization pass that erases instances of Option<class> to just class and replaces matches/instance methods (e.g. opt.IsNone becomes (opt == null)). There's probably some corner cases where you can't erase every instance, and of course if changes your public API which you may or may not be wanted, but it sounds possible.\r\nYou could probably do a similar pass with Option<struct> to Nullable<T>. Nullable is a value type so it could help with performance and GC pressure, but that probably has even more corner cases."},{"Submitter":"Alfonso Garcia-Caro","Submitted":"2014-09-07T10:41:00","Content":"Having a compiler flag to desugar options on reference types as null would increase performance when writing F# to be compiled into other languages like JavaScript."},{"Submitter":"Loic Denuziere","Submitted":"2014-09-21T05:01:00","Content":"This is not purely an optimization though, it changes the semantics of the language. Currently, None and Some null are different, whereas with this proposal they would be equal."},{"Submitter":"Vasily Kirichenko","Submitted":"2014-10-05T09:07:00","Content":"None is represented as null in compiled code due to [<CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)>] applied on Option<'T>. So, only Some<'T> values are heap allocated."},{"Submitter":"Will Smith","Submitted":"2015-05-14T19:12:00","Content":"This is tricky. If Option<'T> can be made into a struct, then discriminated unions should be made into structs."},{"Submitter":"Don Syme","Submitted":"2016-02-04T12:50:00","Content":"I will mark this as approved in principle and we will open an RFC for it. We should add a StructOption<T> type to FSharp.Core.\r\nMore details are needed, but the intent is to augment FSharp.Core with a StructOption<'T> type that can be used as a substitute for the current option type in pattern matching etc. That will require ironing out many details.\r\nThe library functions using Option (e.g. choose) would not initially be redefined, that could be discussed in the RFC\r\nThe type would be opt-in, e.g. by opening a namespace or using a specific type name or StructSome/StructNone etc. Details will be discussed in the RFC"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Approved in principle, per my comment below.\r\nLink to RFC to follow\r\nDon Syme, F# Language and Core Library Evolution"}},"6237585":{"Number":"6237585","Submitter":"Yusuf Motara","Submitted":"2014-07-31T00:00:00","Title":"Allow \"inline\" keyword in the case \"let f = fun a -> ...\"","Text":"Currently, the code \"let inline f = fun a -> ...\" does not compile, but the code \"let inline f a = ...\" does compile. Since the two mean the same thing, \"inline\" should be allowed on both.","Votes":3,"Comments":[{"Submitter":"amazingant","Submitted":"2015-03-21T21:01:00","Content":"Posted an issue on the fsharp/FSharp.Compiler.Service repository over on GitHub here:\r\nhttps://github.com/fsharp/FSharp.Compiler.Service/issues/315\r\nDon Syme suggested either moving it to the Microsoft/VisualFSharp repository as a bug or posting it as a feature request here, and seeing as it's already mentioned here, I'll tag along for the ride.\r\nAdding my +3 for the time-being :)"},{"Submitter":"exercitus vir","Submitted":"2015-05-21T17:09:00","Content":"I have the exact same problem (also inspired by your suggestion in the comments on Haskell-style type annotations).\r\nI feel that this is a bug - not a feature request - because it is valid syntax and compiles to exactly the same code as the more standard 'let inline f a = ...'."},{"Submitter":"exercitus vir","Submitted":"2015-05-21T17:36:00","Content":"I've also posted this as a bug on https://github.com/Microsoft/visualfsharp/issues/467"},{"Submitter":"Don Syme","Submitted":"2015-07-18T13:30:00","Content":"This is not something I see as a priority (because there is an adequate way of working around the problem), but a pull request (with adequate testing etc.) that implements this could well be accepted, assuming no gotchas are found along the way."},{"Submitter":"Don Syme","Submitted":"2016-07-11T08:15:00","Content":"I'm changing this to be marked as \"approved\". This means someone can propose a PR for the issue. PRs should be submitted to http://github.com/Microsoft/visualfsharp."}],"Status":"planned","Response":{"Responded":"2016-07-11T00:00:00","Text":"This is approved for inclusion in a future release of F# subject to completion of an RFC and implementation.\r\nAn RFC can be submitted to https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nA pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp.\r\nDiscussion of the particular version for this to be included in can be made once an implementation is available."}},"6323146":{"Number":"6323146","Submitter":"Daniel Bradley","Submitted":"2014-08-20T00:00:00","Title":"Syntactically describe dependencies between files (by using '#requires', '#load' or extending 'open' syntax)","Text":"With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to use #requrie declarations within files to specify a file order\r\n#require \"Helpers.fs\"\r\nThen, the compiler could automatically infer the dependencies between the files and not require files to be passed in pre-ordered by least dependent first.\r\nRelated alternative #3: Keep a file order, but optionally have it specified by a fileorder.fsx or fileorder.txt or fileorder.json: [/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx](/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx.md)","Votes":7,"Comments":[{"Submitter":"Don Syme","Submitted":"2016-02-03T14:49:00","Content":"Other suggestions have been\r\n#requires \"Helpers.fs\"\r\nor\r\n#load \"Helpers.fs\" (which already describes dependencies in scripts)\r\nSee also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6323146-describe-dependencies-between-files-by-extending"},{"Submitter":"ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)","Submitted":"2016-02-03T14:51:00","Content":"See http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an"},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:29:00","Content":"Closing this in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an"}],"Status":"under-review","Response":null},"6343373":{"Number":"6343373","Submitter":"Kevin Jones","Submitted":"2014-08-25T00:00:00","Title":"Allow defining extern methods in a class","Text":"Currently it appears that extern methods for platform invoke only work properly when used inside of a module (see this discussion: http://stackoverflow.com/questions/22275072/why-does-the-f-compiler-give-an-error-for-one-case-but-not-the-other) this limitation poses problems when organizing your code in an efficient manner and results in having multiple modules defined (for an example, see here: http://stackoverflow.com/questions/25004314/working-with-safehandles-in-f)\r\nIt would be nice if extern methods could be defined in classes (and work correctly) even if the scope of the method is always limited to the type itself.","Votes":3,"Comments":[],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"This is now “approved in principle” for some version of F# 4.x or beyond. It is entirely reasonable to eventually allow this for F#.\r\nHowever, because there is a workaround (using a module), and because the implementation and testing is a little complicated, involving new code paths, it may be that the feature is not seen as high priority. Only a fully implemented and tested feature would be accepted.\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, Current BDFL for F# Language Evolution"}},"6359526":{"Number":"6359526","Submitter":"Eirik George Tsarpalis","Submitted":"2014-08-28T00:00:00","Title":"Add 'serializable' and 'blittable' constraints for types","Text":"I think it would be a good idea to let the F# compiler reason about serializable types. This could be implemented along the lines of the 'comparison' constraint, i.e. based upon an assortment of criteria for deciding when it is satisfied.\r\nFor instance, a type could be statically deemed serializable iff\r\n* it is primitive, string, byte array, etc.\r\n* It is a subtype of System.Exception\r\n* it is a managed class or struct that carries the Serializable attribute.","Votes":3,"Comments":[{"Submitter":"thinkb4coding","Submitted":"2014-08-28T11:07:00","Content":"That could be useful, it would avoid knowing this only at runtime.. But It makes me wonder if it could not be more generic and that you could create your own constraint that would run at design and compile time (like done with Type Providers)..\r\nThis way you could check various things about types used in a function to validate that behavior will be correct then at runtime... thoughts ?"},{"Submitter":"Eirik George Tsarpalis","Submitted":"2014-08-28T11:48:00","Content":"@thinkb4coding you mean having arbitrary pluggable type predicates? I'm not even sure what the consequences would be to that."},{"Submitter":"Don Syme","Submitted":"2016-02-04T18:13:00","Content":"I've combined this with the suggestion for \"blittable\" types: http://fslang.uservoice.com/forums/245727-f-language/suggestions/9989010-add-blittable-type-constraints-in-order-to-support"},{"Submitter":"exercitus vir","Submitted":"2016-07-08T14:12:00","Content":"I think \"serializable\" and \"blittable\" are two completely different issues and should be kept seperate. Serialization is an abstract concept that can apply to any proper data type and \"blittable\" seems to be about unmanaged types (I don't really understand what blittable means).\r\nI find serialization via attributes and Reflection less than ideal (slow and unsafe). The C# team actually wants to get away from serialization via Reflection."}],"Status":"","Response":null},"6475447":{"Number":"6475447","Submitter":"Loic Denuziere","Submitted":"2014-09-23T00:00:00","Title":"Fix ReflectedDefinition for top-level pattern-matched let bindings","Text":"Right now, when you do something like this:\r\n[<ReflectedDefinition>]\r\nlet (a, b) = (1, 2)\r\nThe compiled result is roughly equivalent to:\r\nlet private generatedIdent = (1, 2)\r\n[<ReflectedDefinition>] let a = fst generatedIdent\r\n[<ReflectedDefinition>] let b = snd generatedIdent\r\nAs you can see, the actual expression (1, 2) doesn't get reflected. This makes such definitions unusable for most use cases of ReflectedDefinition. As far as I can tell, this could be fixed by simply adding a ReflectedDefinition of generatedIdent.","Votes":9,"Comments":[],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"I’ve marked this as approved for F# 4.x+.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them). Currently, initial implementations of approved language design can be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"}},"6499392":{"Number":"6499392","Submitter":"Daniel Robinson","Submitted":"2014-09-29T00:00:00","Title":"Wildcard self identifiers","Text":"Two underscores are frequently used in member definitions to denote an ignored \"self\" identifier. This seems like a hack given that the language already provides a wildcard pattern that represents an unused value.","Votes":9,"Comments":[{"Submitter":"Daniel Robinson","Submitted":"2014-09-29T11:16:00","Content":"Forgot the link to the old VS UserVoice item: https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3745318-allow-wildcard-self-identifiers"},{"Submitter":"Alexei Odeychuk","Submitted":"2014-10-10T01:48:00","Content":"I think one underscore is enough to denote an unused \"self\" identifier. The language has to be consistent. One underscore has already been in use to denote an unused value in the match expression."},{"Submitter":"Daniel Robinson","Submitted":"2014-10-15T16:59:00","Content":"Thanks for the invitation. I hope to be able to contribute to the F# tools eventually, but my schedule won't allow it at present. Hopefully someone else will be willing to take this on."},{"Submitter":"Richard Gibson","Submitted":"2014-11-26T06:50:00","Content":"Are self-identifiers actually needed at all? I know they're in there for historical reasons, but I don't see any actual use for them.\r\nConsidering F# still has the \"base\" keyword, I see no reason we can't use the normal \"this\" as well."},{"Submitter":"Daniel Robinson","Submitted":"2014-12-08T10:43:00","Content":"Richard, here's one use: http://stackoverflow.com/a/5356224/162396"},{"Submitter":"exercitus vir","Submitted":"2015-07-20T22:34:00","Content":"Isn't a single underscore just a convention? You can use any other lower-case letter or non-letter-character as a last match to match anything. It seems that the underscore itself has no special meaning in F# other than being allowed as type parameters without leading '."}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"I’m marking this as approved in principle for F# 4.×. you are invited to submit a quality and tested implementation would be needed, to be submitted to http://github.com/Microsoft/visualfsharp.\r\nSee http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details about contributing to the F# language and core library\r\nFWIW I’ve actually taken a look at this once or twice and it was surprisingly invasive to implement. But by all means give it a go and ask if you need help.\r\nDon Syme\r\nBDFL F# Language/Core Library Evolution"}},"6531829":{"Number":"6531829","Submitter":"Robert Jeppesen","Submitted":"2014-10-07T00:00:00","Title":"Allow TypeProviders to supply location with errors","Text":"When a custom type provider fails, the type provider will typically throw, there is not much else to do.\r\nI suggest to add the ability to add an error location when something fails. This would allow to pinpoint with squigglies where the error is in ie json/sql/whatever.\r\nPerhaps the simplest non-breaking implementation would be to add a known exception type that contains a file location and a range. So the TP still just throws, but adds this information where possible.","Votes":6,"Comments":[{"Submitter":"ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)","Submitted":"2014-10-30T06:58:00","Content":"See also this proposal [/ideas/suggestion-5663288-allow-type-providers-to-report-warnings-to-the-com,](/ideas/suggestion-5663288-allow-type-providers-to-report-warnings-to-the-com,.md) these should probably be combined"}],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"Approved in principle for F# 4.0 (or later, depending), along with “allow type providers to report warnings”. subject to a suitable implementation being submitted. Both are entirely reasonable\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language/Library evolution"}},"6536829":{"Number":"6536829","Submitter":"Eirik George Tsarpalis","Submitted":"2014-10-08T00:00:00","Title":"Implement OCaml's new match/exception syntax","Text":"Implement the feature that is nicely described in the following post:\r\nhttps://blogs.janestreet.com/pattern-matching-and-exception-handling-unite/","Votes":42,"Comments":[{"Submitter":"Eirik George Tsarpalis","Submitted":"2014-10-14T06:18:00","Content":"Consider the following hypothetical example:\r\nlet readLines (reader : unit -> string) : string list =\r\nlet rec loop acc =\r\ntry\r\nlet l = reader ()\r\nloop (l :: acc)\r\nwith e ->\r\nList.rev acc\r\nloop []\r\nThis will make successive calls on a reader function until an exception is raised (e.g. IOException), after which the accumulated lines will be returned. The trouble with this example is that it is not tail-recursive, since the recursive call lies inside a try block. Typically, one would have to rewrite the above example like so:\r\nlet readLines (reader : unit -> string) =\r\nlet rec loop acc =\r\nlet result = try reader () |> Choice1Of2 with e -> Choice2Of2 e\r\nmatch result with\r\n| Choice1Of2 l -> loop (l :: acc)\r\n| Choice2Of2 e -> List.rev acc\r\nloop []\r\nThis is an extremely clumsy piece of code which also results in additional allocations. OCaml solves this problem by offering a unifying exception handling with pattern matching:\r\nlet readLines (reader : unit -> string) =\r\nlet rec loop acc =\r\nmatch reader () with\r\n| l -> loop (l :: acc)\r\n| exception e -> List.rev acc\r\nloop []\r\nThe above ensures that the recursive call is tail recursive, eliminates unnecessary allocations and is easy to read."},{"Submitter":"Joerg Beekmann","Submitted":"2014-10-14T06:30:00","Content":"This is a very nice solution; means production code can look just as nice as sample code!"},{"Submitter":"Vasily Kirichenko","Submitted":"2014-10-14T06:47:00","Content":"Looks very nice."},{"Submitter":"Richard Minerich","Submitted":"2014-10-14T13:41:00","Content":"Just be careful, they use exceptions for flow control in OCaml because they're cheap on that runtime. On .NET exceptions are very expensive and should not be used for standard control flow. I would consider that IOException sample to be very bad form on .NET."},{"Submitter":"Eirik George Tsarpalis","Submitted":"2014-10-14T14:42:00","Content":"(Also continuing from https://twitter.com/eiriktsarpalis/status/521968130097049601)\r\nPerhaps the example I gave was a bit unfortunate (I basically just converted it from Yaron's blog post) but the annoyance still exists in F#. Even if exceptions are not intended for control flow, you still have very realistic use cases in which functions are passed lambdas with no particular guarantees on exception safety. In order for your code to be tail recursive, you have to give your code the Choice<_,_> treatment which I agree is more ugly than it is inefficient. A nice example is when implementing the continuation monad with exceptions, e.g.\r\ntype Cont<'T> = ('T -> unit) -> (exn -> unit) -> unit\r\nThe correct monadic bind will have to be implemented like this:\r\nlet bind (f : Cont<'T>) (g : 'T -> Cont<'S>) : Cont<'S> =\r\nfun sc ec -> f (fun t -> let r = try g t |> Choice1Of2 with e -> Choice2Of2 e in match r with Choice1Of2 s -> s sc ec | Choice2Of2 e -> ec e) ec\r\nWhereas with the match/exception syntax it would be like this:\r\nlet bind (f : Cont<'T>) (g : 'T -> Cont<'S>) : Cont<'S> =\r\nfun sc ec -> f (fun t -> let r = match g t with s -> s sc ec | exception e -> ec e) ec\r\nTo give you a bigger perspective, here is a somewhat complete continuation/exception monad implementation:\r\nhttps://github.com/nessos/MBrace.Cloud/blob/master/MBrace.Cloud/CloudBuilder.fs\r\nPerhaps one criticism to this feature would be that it might somehow encourage people to use exceptions as control flow? I don't quite see this, most people out there realise that .NET exceptions are expensive. Other than that, it might not be as common a pattern in F#, but I do come across it quite frequently myself."},{"Submitter":"Greg Chapman","Submitted":"2014-12-03T14:08:00","Content":"If we had something like Scala's Try, we could do the readLines example today.\r\ntype Either<'a,'b> = Left of 'a | Right of 'b\r\nlet Try f = try Right (f()) with e -> Left e\r\n{...}\r\nmatch Try reader with\r\n| Right l -> loop (l::acc)\r\n| Left e -> List.rev acc\r\nI wish F# had either Scala's notion of call-by-name, or (my preference) a nicer syntax for delayed expressions. For some reason, something like:\r\n{| expr |}\r\nreads nicer than:\r\n(fun()-> expr)\r\neven if they compile to exactly the same thing.\r\nIf {| expr |} was a syntax for a delayed expression, you could implement the bind example using:\r\nmatch Try {| g t |} with Right s -> s sc ec | Left e -> ec e) ec"},{"Submitter":"Don Syme","Submitted":"2016-02-04T12:55:00","Content":"Eirik, what would be the desugaring in quotations and computation expressions?\r\nthanks\r\ndon"},{"Submitter":"Eirik George Tsarpalis","Submitted":"2016-06-28T09:01:00","Content":"Hi Don,\r\nI would imagine that desugaring (both in comp exprs and quotations) could take the following form. The code\r\nasync {\r\nmatch expr with\r\n| Pat1 -> cexpr1\r\n| Pat2 -> cexpr2\r\n| exception Pat3 -> cexpr3\r\n| exception Pat4 -> cexpr4\r\n}\r\nwould transform to\r\nasync.Delay(fun () ->\r\nmatch (try Choice1Of2 expr with e -> Choice2Of2 e) with\r\n| Choice1Of2 Pat1 -> cexpr1\r\n| Choice2Of2 Pat2 -> cexpr2\r\n| Choice2Of2 Pat3 -> cexpr3\r\n| Choice3Of3 Pat4 -> cexpr4)\r\nThis should work fine, assuming no match! feature is added to computation expressions in the future. In such a case, a match! implementation would have to manage the exception handling logic explicitly."},{"Submitter":"Eirik George Tsarpalis","Submitted":"2016-06-28T09:10:00","Content":"Similarly, the non-monadic expression\r\nmatch expr with\r\n| Pat1 -> expr1\r\n| Pat2 -> expr2\r\n| exception Pat3 -> expr3\r\n| exception Pat4 -> expr4\r\nwould desugar to\r\nlet mutable exn = Unchecked.defaultof<Exception>\r\nlet mutable result = Unchecked.defaultof<'T>\r\ntry result <- expr with e -> exn <- e\r\nmatch exn with\r\n| null ->\r\nmatch result with\r\n| Pat1 -> expr1\r\n| Pat2 -> expr2\r\n| Pat3 -> expr3\r\n| Pat4 -> expr4"}],"Status":"","Response":null},"6538074":{"Number":"6538074","Submitter":"amazingant","Submitted":"2014-10-08T00:00:00","Title":"Add support for Haskell-style type annotations","Text":"Although it's typically preferred to let the compiler handle types, it is often necessary to provide type annotation. Sometimes this is to help the compiler understand the types a function can take, often it is done to help other developers understand your code, and in my personal use, I frequently add type annotations to ensure the compiler will catch typos I make which change a function's return type.\r\nAlthough not as verbose as other .NET languages, the F# type annotations do add verbosity to a function definition, look cluttered compared to Haskell's syntax (personal opinion), and do not match the type format provided by the compiler or interactive environment.\r\nI propose adding syntax to allow defining a function's type with a syntax closer to Haskell's. Since the :: operator is already in use, my proposal is to create a new operator such as => for these purposes; a new keyword could suffice as well, or simply new use of the val keyword currently used in signature files.\r\nMy initial suggestion is as follows:\r\nlet f => int -> int -> int\r\nlet f x y = x * y\r\nWhile the inclusion of variable names would reduce the terseness of the syntax and would provide little benefit to readability or comprehension, such a change would provide consistency with the format output by fsi.exe and seen in Visual Studio with IntelliSense. An more complex type signature with such a format:\r\nlet f => a:(int -> string -> int) -> x:string list -> y:int -> int list\r\nlet f a x y = List.map (a y) x\r\nIn these examples, neither of the code snippets would typically need type annotations, and the annotations here are much larger than the implementation itself. However, the former syntax (my preference) would greatly reduce the length of function declarations in more complex functions. The latter option, while I would prefer it over the current syntax, would introduce an additional location where variable names would have to be changed during refactoring.\r\nIt is my opinion that were such a syntax to be provided, use of both the new and current syntaxes together should provide a compiler warning to the effect of \"Multiple type annotations provided for function {0}. Consider removing extra type annotations to simplify refactoring of your code.\"","Votes":58,"Comments":[{"Submitter":"Loic Denuziere","Submitted":"2014-10-14T09:42:00","Content":"If we implement this (which I think would be a good idea), we should definitely use the same syntax as .fsi files.\r\nval f : int -> int -> int\r\nlet f x y = x * y"},{"Submitter":"Sergey Yavnyi","Submitted":"2014-10-27T04:47:00","Content":"Nice idea.\r\nAnother (but somewhat clunky) alternative that you can already use is\r\nlet f : int -> int -> int = fun x y -> x * y"},{"Submitter":"exercitus vir","Submitted":"2014-11-06T04:41:00","Content":"Sergey, thanks for pointing that out. Since this is already possible, it does not seem that this suggestion really adds much value."},{"Submitter":"amazingant","Submitted":"2015-01-07T11:17:00","Content":"@Sergey I agree that alternative looks a bit clunky, but it can be rearranged enough that I'm happy with it:\r\nlet f : int -> int -> int =\r\nfun x y -> x * y\r\nIt feels a little odd not adding a full indentation level, but the second line only needs one extra space (or tab, if you're one of those) beyond the indentation for the signature line; with just one space it still feels like the fun line is still part of the function header, without requiring the body of the code to gain another indentation level."},{"Submitter":"exercitus vir","Submitted":"2015-06-19T18:02:00","Content":"This is related: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6237585-allow-inline-keyword-in-the-case-let-f-fun-a"},{"Submitter":"Tobias Burger","Submitted":"2016-01-11T07:55:00","Content":"The more I code in Haskell/Elm/PureScript the more I like the way of how type are declared in this languages.\r\nYou can \"emulate\" this style by using an .fsi file alongside your .fs file, but the declaration and the implementation is physically separated and for scripts there is no way to declare this kind of type annotations.\r\nI'm with Loic: the declaration should be the same as for .fsi files.\r\nI find it easier to read/understand (and implement) the function by looking at the second declaration.\r\nlet map (mapper: 'a -> 'b) (m: M<'a>) : M<'b> = ...\r\nval map : ('a -> 'b) -> M<'a> -> M<'b>\r\nlet map mapper m = ..."},{"Submitter":"Anonymous","Submitted":"2016-01-16T01:39:00","Content":"Never worked with Haskell, but after I've tried Idris I've started to miss having type annotations over my functions, or at least some of them...\r\nDeclaration style should ofc be same as in fsi files..."},{"Submitter":"Don Syme","Submitted":"2016-02-04T14:06:00","Content":"Why not just this syntax?\r\nlet f : int -> int -> int\r\nlet f x y = x * y\r\nAlso what would be the syntax for \"member\" declarations? This?\r\nmember M : int -> int\r\nmember this.M(x) = x + 4\r\nAlso what would be the syntax for \"let rec\" declarations in a mutually recursive group?"},{"Submitter":"Anonymous","Submitted":"2016-02-10T13:42:00","Content":"What about:\r\nf : int -> int -> int\r\nlet f x y = x * y\r\n...and ...\r\nM : int -> int\r\nmember this.M(x) = x + 4\r\nsame for let rec"},{"Submitter":"exercitus vir","Submitted":"2016-07-11T11:55:00","Content":"This is possible using the following (already supported) syntax:\r\nlet add : int -> int -> int =\r\nfun x y -> x * y\r\nThe only restriction is that you currently cannot add \"inline\" to the function value:\r\nlet add : int -> int -> int =\r\ninline fun x y -> x + y\r\nLifting this restriction has been requested and approved by Don Syme here, so someone just needs to propose a tested PR: [/ideas/suggestion-6237585-allow-inline-keyword-in-the-case-let-f-fun-a](/ideas/suggestion-6237585-allow-inline-keyword-in-the-case-let-f-fun-a.md)"}],"Status":"","Response":null},"6672381":{"Number":"6672381","Submitter":"Gustavo Guerra","Submitted":"2014-11-06T00:00:00","Title":"Allow negative indices in indexing and slicing like python","Text":"Example: permit usage of a.[..-2] instead of a.[..a.Length-1]\r\nThe compiler could just do that conversion behind the scenes, so it would work with existing types that have custom indexing and slicing","Votes":33,"Comments":[{"Submitter":"Kit Eason","Submitted":"2014-11-06T06:32:00","Content":"This would be so freakin' useful in the code I am writing right now!"},{"Submitter":"Goswin","Submitted":"2014-11-10T08:46:00","Content":"I am not sure if this schould be default.\r\nI am doing this with an extension member:\r\nlet inline getNegIndex i len =\r\nlet j = if i<0 then len + i else i\r\nif j<0 || j >= len then failwithf \"Cannot get index %d from %d items (for given negative index %d ) \" j len i\r\nelse j\r\ntype ``[]``<'T> with\r\nmember inline arr.GetItemNeg i = arr.[getNegIndex i arr.Length]"},{"Submitter":"Richard Gibson","Submitted":"2014-11-13T05:15:00","Content":"I remember this discussion coming up in CoffeeScript and it's surprisingly hard to do when you involve variables. For example:\r\narr.[..x] // Should the compiler insert a check to see if x is negative?"},{"Submitter":"Brody Berg","Submitted":"2015-02-09T13:13:00","Content":"Here is the CoffeeScript discussion: https://github.com/jashkenas/coffeescript/wiki/FAQ\r\nI don't think the CoffeeScript source-to-source compilation-time constraints apply to the F# compiler in this case."},{"Submitter":"Gusty","Submitted":"2015-09-29T08:28:00","Content":"I like it. FSharpPlus had that feature longtime:(https://github.com/gmpl/FSharpPlus/blob/0f0550000077cb9da3f340612a84911e92c1a790/FSharpPlus/Extensions.fs#L49)\r\nnote that the GetSlice there support also negatives at the beginning of the string.\r\nBut now I see that in F#4.0 it doesn't work anymore since GetSlice was added in the F# core (without the negatives) and shadows the method in F#+ so if this feature is not accepted an option would be to avoid shadowing those functions further defined in Libraries.\r\nThis way everybody is free to decide to use negative indexing by using a library or writing an extension method."}],"Status":"","Response":null},"6672675":{"Number":"6672675","Submitter":"Remko Boschker","Submitted":"2014-11-06T00:00:00","Title":"An CLIVirtual attribute","Text":"Just as you can use CLIMutable to store records using Entity Framework wouldn't is be nice to be able to set an CLIVirtual attribute on a record field of an ICollection type so that Entity Framework can do lazy loading. See also http://stackoverflow.com/questions/26775760/how-to-create-a-virtual-record-field-for-entity-framework-lazy-loading","Votes":22,"Comments":[{"Submitter":"luketopia","Submitted":"2014-11-10T17:40:00","Content":"In addition to making the property virtual, you would also have to make the record type non-sealed since EF creates dynamic proxy types that inherit from the base entity to override the virtual properties. Right now, all record types are sealed."}],"Status":"","Response":null},"6672880":{"Number":"6672880","Submitter":"Gustavo Guerra","Submitted":"2014-11-06T00:00:00","Title":"Add a Option.getOrDefault and other new functions to the Option module","Text":"Like List.nth, defaultArgs has the parameters in the \"wrong order\" to be able to be used in partial application. List.item is solving that problem, we should also do the same for defaultArg","Votes":15,"Comments":[{"Submitter":"Vasily Kirichenko","Submitted":"2014-11-06T07:58:00","Content":"I think a better name is getOrElse (it's also used in Scala). I would also like to add several other functions, like:\r\nofNull\r\nofNullable\r\ntoNullable\r\nattempt\r\norElse\r\ngetOrTry\r\norTry\r\nflatten\r\n(we use all of them in Visual F# Power Tools https://github.com/fsprojects/VisualFSharpPowerTools/blob/3299b8cc99bea9430149df0338304b60c8a6405b/src/FSharpVSPowerTools.Core/Utils.fs#L49-L91)\r\nThere are many others in ExtCore https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Pervasive.fs#L727-L923 and in FSharpx https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/ComputationExpressions/Monad.fs#L86-L285\r\nI think we should collect all of them in a table (like it's with collections on codeplex) and discuss what should be added into FSharp.Core (it'd be fine to do the same with Choice)."},{"Submitter":"Richard Minerich","Submitted":"2014-11-06T08:03:00","Content":"I'm not sure if they've been defined in the 4.0 pull requests but I always define something like:\r\nOption.resolve : 'T -> 'T option -> 'T\r\nOption.resolveBy : (unit -> 'T) -> 'T option -> 'T\r\nOption.tryResolve : 'T option -> 'T option -> 'T option\r\nOption.tryResolveBy (unit -> 'T option) -> 'T option -> 'T option"},{"Submitter":"Mark Seemann","Submitted":"2016-02-23T03:56:00","Content":"Other nice-to-haves:\r\nOption.map2: ('a -> 'b -> 'c) -> 'a option -> 'b option -> 'c option\r\nOption.map3: ('a -> 'b -> 'c -> 'd) -> 'a option -> 'b option -> 'c option -> 'd option\r\nThe List module defines map2 and map3, so it'd be natural to add these to the Option module as well."},{"Submitter":"Mark Seemann","Submitted":"2016-02-23T04:16:00","Content":"It'd also be nice with a built-in computation builder."},{"Submitter":"Mark Seemann","Submitted":"2016-02-23T09:01:00","Content":"Opened a GitHub issue for this: https://github.com/Microsoft/visualfsharp/issues/980"},{"Submitter":"Enrico Sada","Submitted":"2016-03-01T09:10:00","Content":"created RFC https://github.com/fsharp/FSharpLangDesign/issues/60"}],"Status":"planned","Response":{"Responded":"2016-02-29T00:00:00","Text":"Approved-in-principle to make some sensible additions to the Option module\r\nDetails about naming and exact additions will need to be finalized.\r\nWe will create an RFC for this at https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThanks\r\nDon Syme\r\nF# Language Evolution"}},"6690744":{"Number":"6690744","Submitter":"TeaDrivenDev _","Submitted":"2014-11-09T00:00:00","Title":"Properly print 'None' for option types from FSI","Text":"FSI output properly handles 'Some x', but often prints 'None' as 'null', apparently when the value is part of a larger type.\r\nlet x : uint16 option = None\r\ncorrectly results in: val x : uint16 option = None\r\nlet y : string * uint16 option = \"\", None\r\ninstead prints: val y : string * uint16 option = (\"\", null)","Votes":18,"Comments":[{"Submitter":"Grant Crofton","Submitted":"2014-11-13T04:03:00","Content":"Yes please, this can be pretty annoying (especially when trying to show people F#)"},{"Submitter":"FANG Colin","Submitted":"2014-12-07T18:35:00","Content":"> printfn \"%A\" (1, None)\r\nprintfn \"%A\" None\r\nprintfn \"%O\" (1, None)\r\nprintfn \"%O\" None\r\n(1, null)\r\n<null>\r\n(1, )\r\n<null>"}],"Status":"planned","Response":{"Responded":"2016-02-05T00:00:00","Text":"This should certainly be fixed, as much as possible\r\nDon Syme, F# Language Evolution"}},"6723648":{"Number":"6723648","Submitter":"TeaDrivenDev _","Submitted":"2014-11-15T00:00:00","Title":"Display current parameter type in tooltip for generic function","Text":"I posted this on CodePlex (https://visualfsharp.codeplex.com/workitem/172), and Don Syme asked me to put it here as well.\r\nThe C# editor in Visual Studio displays the actual parameter types involved in the tooltips for generic class instances and method invocations. The F# editor only does that for objects and methods, but oddly not for F# types/functions; shouldn't this information be quite readily available?\r\nHaving this kind of information at hand would especially make it quite a bit easier to follow the transformation of data through pipe chains, even more so as this type of display is also completely absent for lambdas at this time.","Votes":11,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-05-21T18:19:00","Content":"I don't understand this feature request. Could you please elaborate or provide a code sample?"},{"Submitter":"Don Syme","Submitted":"2016-02-04T17:55:00","Content":"This should really go in the Visual Studio Tools user voice. But it's important to do, we should just get it done :)"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Not really a language item, but this should be implemented in the Visual F# Tools and the F# COmpiler Service"}},"6752948":{"Number":"6752948","Submitter":"Arash Sahebolamri","Submitted":"2014-11-21T00:00:00","Title":"Support bind (e.g. \"await\") in the middle of expressions, possibly using !! operator","Text":"that does the binding implicitly; so that it wouldn't be necessary to bind every monadic expression to a name. In the case of async workflows, it would behave like the C# await keyword.\r\nWith this operator, instead of this:\r\nlet task= tasync{\r\nlet! response = http.GetAsync(uri)\r\nlet! string = response.Content.ReadAsStringAsync()\r\nlet! res = processAsync(string)\r\nreturn res\r\n}\r\nit would be possible to write code like this:\r\nlet task= tasync{ return !! processAsync(!!(!!http.GetAsync(uri)).Content.ReadAsStringAsync()) }\r\nOr write this:\r\nlet t= opt{ return ((!!x) + !!y) / !!z}\r\ninstead of this:\r\nlet t= opt{\r\nlet! xx = x\r\nlet! yy = y\r\nlet! zz = z\r\nreturn (xx + yy) / zz\r\n}","Votes":10,"Comments":[{"Submitter":"Wallace Kelly","Submitted":"2015-05-28T12:11:00","Content":"In your examples, you have `tasync`. Is that a typo? Or is `tasync` a real thing?"},{"Submitter":"Don Syme","Submitted":"2016-02-04T17:54:00","Content":"Wallace - it's a typo I think."}],"Status":"","Response":null},"6803533":{"Number":"6803533","Submitter":"Ryan Riley","Submitted":"2014-12-04T00:00:00","Title":"Support .NET Core and CoreCLR","Text":".NET Core is the new cloud runtime model for the CLR and used in ASP.NET vNext.","Votes":374,"Comments":[{"Submitter":"Raymen Scholten","Submitted":"2015-02-11T09:46:00","Content":"I think this is becoming more and more important with the latest open sourcing of the CoreCLR"},{"Submitter":"Henrik Feldt","Submitted":"2015-04-03T03:56:00","Content":"I think this is especially important to get to run on small linux distros, like https://github.com/gliderlabs/docker-alpine which I predict will gain a lot of popularity in the docker community."},{"Submitter":"Jarle Stabell","Submitted":"2015-05-28T16:46:00","Content":"With support for this, we would find ourselves having the moral duty of removing all Perl and PHP scripts from this planet. ;)\r\nF# could perhaps also become important in enabling a realistic (and superior) NodeJS alternative.\r\nAnd help those who are trying to tell the world that F# is a great alternative to Python and R."},{"Submitter":"Johann Dirry","Submitted":"2016-02-21T15:03:00","Content":"I find this very important, because some really good libraries are written in F# these days and without F# support I can't use them in UWP projects."},{"Submitter":"Troy Robinson","Submitted":"2016-04-06T18:54:00","Content":"Was this completed? Looks like it may have been with this?\r\nhttps://github.com/Microsoft/visualfsharp/pull/499"}],"Status":"started","Response":{"Responded":"2015-08-03T00:00:00","Text":"Strictly speaking this issue is not meant for https://fslang.uservoice.com, since it is about targeting a particular platform with the tooling, rather than the F# language or core library design itself.\r\nHowever, I’m leaving it open for now since it’s getting so many votes. We may close it sometime soon to release the votes.\r\nIn any case, this work is planned by the Microsoft visualfsharp team and other contributors. Please contribute to the work at the http://github.com/Microsoft/visualfsharp repository and follow that repository for more details and updates.\r\nRelevant issues: https://github.com/Microsoft/visualfsharp/issues/387 and https://github.com/Microsoft/visualfsharp/pull/499\r\nDon Syme, F# Language and Core Library Evolution"}},"6906132":{"Number":"6906132","Submitter":"Bryan Edds","Submitted":"2014-12-31T00:00:00","Title":"Implement first-class lensing / lenses in F#","Text":"When working with complex state structures, functional programming is, without a great deal of additional tooling (tooling that does not satisfactorily exist in F#), highly inconvenient, verbose, and even error-prone. These problems are so pronounced that many cite them as a reason to label functional programming itself as inapplicable to the domains within which complex state structures are inherent!\r\nAs functional programmers, we believe otherwise, and many even believe that it is in the domain of dealing with complex state artifacts that functional programming is especially beneficial and necessary! However, with such weak syntactic constructs such as these -\r\nlet a = { a with B = { a.B with C = c }}}\r\n- we win ourselves no favors.\r\nAnd even in the narrow context of such a small problem, simple and promising solutions abound. For example, why doesn't this syntax have a semantics assigned to it in F#? -\r\nlet a = { a with B.C = c }\r\nOr better, given that we know at compile-time that there is a means of constructing A and B, why we can't assign a semantics to this -\r\nlet a = a.B.C $= c\r\n- and generate all the backing code for such a pure functional update automatically?\r\nAnd why restrict such nice syntax to only record fields? Why not let it be applicable to all members who support the concept of readability and updatability (EG - lensability) such as with here -\r\ntype Entity with\r\n\r\nmember gui.Enabled = gui?Enabled : bool\r\nstatic member setEnabled (value : bool) (gui : Entity) = gui?Enabled <- value\r\nso that we can finally utter -\r\nlet entity = entity.Enabled $= anotherEntity.Enabled\r\nIn other words, why not give the compiler some way of recognizing 'lensability' implicitly for simple cases (and perhaps explicitly with simple declarations in more refined cases such as with Map values), ultimately enabling good syntax to take advantage of it all?\r\nAnd yes, there have been library solutions to the problem of lensing proposed in F#. However, in experience I have found the library solution to be embarrassingly inadequate. This is due to the fact that F# does not provide out-of-the-box (nor shall it in the reasonably near-future) the language constructs necessary to build a sufficiently expressive lens library... and not even for the straight-forward use cases I outlined above! And, even if such language constructs were available, I still doubt that a form of expression as understandable and succinct as the syntax I proposed could be achieved.\r\nFor that reason, I did and still do conclude that it is necessary to build lensing as a first class construct in the language. This is so that instead of attempting to use kindedness to express lensing, the simpler (and admittedly more muscled) approaches of syntactic expansion / IL generation may be used. Thus this user suggestion.\r\n(On a side note, perhaps if we had a sophisticated and general syntactic macro system in F# like I suggested here - [/ideas/suggestion-5674940-implement-syntactic-macros,](/ideas/suggestion-5674940-implement-syntactic-macros,.md) the solution could again be proposed as a library. However, given that such a feature whose design and implementation is daunting and not yet to be even approved in principle, this too is a non-starter for an urgently-needed construct.)\r\nTo expand on the design proposal further, et's look at the subtle distinction I've made in the words I've used above. Specifically, we notice a distinction between -\r\nLensing - viewing or updating a value contained by another functional value\r\nLenses - a general mechanism by which lensing is achieved\r\nWe've already seen the syntax I propose for lensing where the lens itself is contextually implied -\r\nlet a = a.B.C $= c // here a new value of a is constructed and bound to a shadowing binding of a.\r\nNow say we want to pull out the lens itself that it might be passed around for lensing later. Obviously, we will need a syntax for that as well. However, the desired form taken by that syntax is more nebulous, so here are a few options -\r\nlet abcLens = lens <@ A.B.C @> // here's a syntax that utilizes code quotations: verbose but maybe easier to implement in the compiler?\r\nlet abcLens = lensOf A.B.C OR lensOf<A.B.C> // here's lens with a new keyword lensOf: succinct, but not perfect backward compatibility\r\nlet abcLens = {$ A.B.C $} // ugly, but succinct and probably backward compatible (but maybe not as I've yet to study F#'s AST in-depth).\r\n...and there are presumably many more possible forms. After all, for literally ALL the syntax I've proposed in this thread, I've merely been riffing!\r\nAdditionally, there would need to be a syntax for allowing user-defined induction of other things into the category of 'lensability'.\r\nFor example, say we have a type whose members are described at run-time like so -\r\ntype A with\r\n\r\nstatic member getB (a : A) = a?B : bool\r\nstatic member setB (b : bool) (a : A) = a?B <- value\r\nWe should be able to decorate the view and update functions like so -\r\ntype A with\r\n\r\n[<Viewable \"B\">] static member getB (a : A) = a?B : bool\r\n[<Updatable \"B\">] static member setB (b : bool) (a : A) : A = a?B <- value\r\nIn conclusion, F# needs first-class support for lensing / lenses because it current set of language features is inadequate to provide a library solution, and because lensing / lenses is such a fundamental property of functional programming in stateful systems. While my design proposal certainly will have some flaws that need to be smoothed over, I think it is a good enough start to get something in the works!","Votes":165,"Comments":[{"Submitter":"Christopher Stevenson","Submitted":"2015-01-09T22:14:00","Content":"Coming from an object-oriented background, I find it difficult to understand what lenses are, besides 'functional version of properties'. Even though this proposal is rather lengthy, I'm not really understanding what the benefit of this is, besides some vague notion of more concise field setting of copied records.\r\nIf someone could point to a good primer, I'd appreciate it."},{"Submitter":"Fraser Waters","Submitted":"2015-01-12T11:22:00","Content":"Functional properties is a pretty good way of putting it. The one part that Bryan didn't really cover well in this is that the lens is an instance of an object itself. So given his example of \"lens <@ A.B.C @>\" that would create a lense for field C of field B of type A. That lens object is a function that can either get that value from an instance of A, or set that value on an instance of A (returning a new A).\r\neg something like:\r\nlet l = lens <@ A.B.C @>\r\nlet a = // create some A value\r\nlet c = get l a // c is now the same as a.B.C\r\nlet newC = // create some C value\r\nlet newA = set l a newC // newA is now the same as { a with B = { a.B with C = newC } }\r\nLenses themselves aren't massively complex, it's pretty much just:\r\ntype Lense<a', b'> = { getter : a' -> b'; setter : a' -> b' -> a' }\r\nlet get lense obj -> lense.getter obj\r\nlet set lense obj value -> lense.setter obj value\r\nbut with that you can then add composibility and other nice functional things on top. The awkard bit of lenses is constructing those getter/setter functions (more so the setter), but the construction of those functions is also trivial to the compiler."},{"Submitter":"Anonymous","Submitted":"2015-01-19T11:27:00","Content":"I think it is critical to look at the different versions of this concept and how they evolved in Haskell -- my understanding, weak as it may be, is that it took a while to get to ekmett's package and that is the one that you would want to model it after.\r\nOne key thing that you want to preserve would be in addition to a regular getters and setters, you want the ability to set a value with function that uses the original value. For example, if you have a property that is an integer, you should be able to set it with an incrementing function:\r\nf x = x + 1\r\nand all of the variations that you might want with that."},{"Submitter":"Bryan Edds","Submitted":"2015-01-19T11:48:00","Content":"I think those are just a matter of defining the right operators.\r\nI think also there is a marked difference in the scope of what Haskell's lenses accomplishes and what we actually need in F#. The two may differ more than one may initially think. Or not - I too am no expert.\r\nHowever, I think it would be great to ask Edward Kmett himself to take a look at the lens proposal during the design process. Though he is busy as always, and even though he's not an F# user AFAIK, I think he would willing to prioritize some time for it.\r\nI have his contacts, and he spends a good deal of time on #Haskell on Freenode IRC."},{"Submitter":"Andrew Cherry","Submitted":"2015-02-13T06:19:00","Content":"I think I commented a bit on this elsewhere in a discussion, but it came up again just now in another context ( https://github.com/SuaveIO/suave/pull/206#discussion_r24602874 ), and @dsyme thought it might be useful to include here...\r\nI use lenses (Aether library), but they're not the Kmett library style of lens (which, from memory, are van Laarhoven lenses). With our type system as it stands, we're restricted to the more naive style of lens that Aether implements (get, set pairs). I do still find that they're useful however.\r\n(See that linked discussion for a little more detail and some examples).\r\nHowever... I'm not sure I can agree with lenses, as a concept, becoming a language feature. It's overly specific, to my mind. Either we need to be saying something like\r\n\"We need a better way of modifying properties in deeply nested immutable data structures\", which would be reasonable perhaps, or we should be saying \"we need the type system to be a bit different/more to enable us to write some functional techniques which would make, e.g. lenses, possible\". I'm not sure that lenses as a thing though is a language level change."},{"Submitter":"Don Syme","Submitted":"2015-02-14T11:47:00","Content":"On the specific question of \"{ a with B.C = d }\"... One possibility would be to give a semantics to this as follows:\r\n{ a with ...; b.c = d } --> { a with b = { a.b with c = d}; ...}\r\nIn addition, we could also allow \"setting\" properties which are not record-defined properties, e.g.\r\n{ a with ...; b = c } --> { a with ... }._set_b(c)\r\nWith these two rules we would have:\r\n{ a with b.g = c; d = e } --> a._set_b(a.b._set_g(c))._set_d(e)\r\nwhere \"a\" can be any kind of object as long as it has _set_b and _set_b \"functional property setters\". The naming _set_b could be discussed.\r\nThis is a fairly simple language feature which could be of some help, and would also address the \"use record 'with' syntax on non-record types\" request ([/ideas/suggestion-6420709-allow-record-like-obj-with-newvals-syntax-for)](/ideas/suggestion-6420709-allow-record-like-obj-with-newvals-syntax-for).md)"},{"Submitter":"Bryan Edds","Submitted":"2015-02-14T23:46:00","Content":"Hi Don!\r\nI somewhat regret suggesting lensing semantics for -\r\nlet a = { a with B.C = c }\r\nThis is because B is currently used to specify the containing type of C.\r\nInstead, I really do think we want a semantics for this more unique syntax -\r\nlet a = a.B.C $= c\r\nWhy overload existing syntax if we don't have to?"},{"Submitter":"Jack Fox","Submitted":"2015-08-02T19:27:00","Content":"The Microsoft team has published their short-term roadmap https://github.com/Microsoft/visualfsharp/issues/563 and the long-term roadmap is coming. There are limited resources and they are deploying them wisely. What the community can do on the side is improve the documentation and publicize existing projects like http://fsprojects.github.io/FSharpx.Extras/ where lens support (among other overlooked gems) already exists."},{"Submitter":"Giacomo Stelluti Scala","Submitted":"2015-08-03T13:22:00","Content":"I've voted it.\r\nI'm wondering if one day F# will have functors like OCaml, this could be implemented as library but with a deeper and more elegant support."},{"Submitter":"Henrik Feldt","Submitted":"2015-08-10T01:29:00","Content":"I find this proposal overly syntax-oriented: it's supposedly needed because \"lenses are such a fundamental property of functional programming in stateful systems\", but you can in fact easily program in a stateless manner even when using sockets, file handles, semaphores etc.\r\nInstead, add facilities to the language to write higher kinded types, that would enable us to write van Laarhoven (http://twanvl.nl/blog/haskell/cps-functional-references) lenses, or enable us to have an officially supported Applicative namespace, or allow us to export static signatures (or type classes and instances) from modules.\r\nLanguage design should be free from muck; oriented towards creating the language as a total function of its input: code, rather than lots of small partial functions over code."},{"Submitter":"Andrew Cherry","Submitted":"2015-08-10T06:22:00","Content":"I don't think my opinion has changed much from commenting back in February. Aether (disclaimer, i'm the maintainer) provides a reasonable library solution (in my opinion) given the constraints of the language. Even the limited possibilities that Aether provides have proven very useful when writing other libraries and being able to work with complex structures effectively. (See for example the approach that Freya takes to providing lenses in to OWIN state to provide strongly typed, safe access to request/response properties).\r\nA specific extension of the language to support lens functionality (and realistically people only seem to be talking about \"functional properties\" which in my head is a small subset of the usefulness of lenses and related techniques - lenses with prisms, transducers, etc. etc.) seems over specific and maybe a little short sighted in terms of not attacking the problem in a more interesting way.\r\nAs Henrik mentions, an extension of the type system would enable us to write a far more general and useful system as a library, rather than baking specific approaches in to a language core. I'm with Henrik on this one - I would vote for careful selection of a few key extensions to the core of the language and type system which would enable new things to be built as libraries, rather than baking things that seem useful today in to the language itself. That way lies PHP."},{"Submitter":"Don Syme","Submitted":"2016-02-04T13:58:00","Content":"This suggestion was also relevant (and the same idea is mentioned above)\r\n[/ideas/suggestion-5663252-extended-record-with-syntax-to-work-with-nested-pr](/ideas/suggestion-5663252-extended-record-with-syntax-to-work-with-nested-pr.md)"},{"Submitter":"Don Syme","Submitted":"2016-02-05T04:08:00","Content":"See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6906132-implement-first-class-lensing-lenses-in-f"},{"Submitter":"Anonymous","Submitted":"2016-04-20T10:14:00","Content":"It seems that van Laarhoven style lenses allowing polymorphic updates can be encoded in F#: http://fssnip.net/7Pk"},{"Submitter":"Ivan J. Simongauz","Submitted":"2016-09-03T05:19:00","Content":"What about observable lenses, this is almost necessary for WPF and so on.\r\ntype\r\nchange<'t> =\r\n| Intent\r\n| Await\r\n| Change of 't\r\ntype ObservableLense<'t, 'tv> = ('t -> 'tv, 't -> 'tv -> 'tv, IObservable<'tv change>)"}],"Status":"","Response":null},"6923281":{"Number":"6923281","Submitter":"Vladimir","Submitted":"2015-01-05T00:00:00","Title":"Add possibility to use break and continue in f# loops. And do while loop","Text":"It very often looks better than recursion, and it would be wonderful to have this possibility","Votes":12,"Comments":[{"Submitter":"Vladimir","Submitted":"2015-01-05T05:50:00","Content":"And it would be wonderful to add the same things to sequences"},{"Submitter":"Richard Minerich","Submitted":"2015-01-12T12:05:00","Content":"I have mixed feelings about this. On one hand there have been cases where having this would be useful for porting code from other languages, on the other I'd be worried that many would start to use these in cases that are more clearly expressed as recursion and in so doing make the code much more difficult to understand and maintain."},{"Submitter":"Phylos","Submitted":"2015-01-18T00:32:00","Content":"I don't think this is a good idea, as it would encourage perpetuating imperative programming approaches to those new to F#."},{"Submitter":"Vladimir","Submitted":"2015-02-09T04:08:00","Content":"but when we working with arrays, it's not so clear to use recursion. Especially, when we must modify the array. In this case recursion looks very ugly, especially, we must send a lot of arguments there.\r\nP.S. I also like functional style, but in some cases imperative style is much better. And it's very sad when I cant use the best way to resolve some problem in my favorite language, and should use for that, for example, c#"},{"Submitter":"Richard Gibson","Submitted":"2015-02-17T08:39:00","Content":"I'm also not convinced this is a good idea - most of the time when I was learning F# and I wished for break or continue it was because I didn't know how to use the appropriate F# sequence function yet. `Pick` and `find` are two functions that come to mind in helping get out of the imperative way of thinking.\r\nIf you have any examples on where it's truly necessary or preferable to use break / continue I'd love to see them, only because I can't think of any myself."},{"Submitter":"Vladimir","Submitted":"2015-03-06T07:04:00","Content":"Sequences is very slow and there are some situation when performance is required. For example when you work with matrices. Also you can't always use Array module, because its functions always copy array, that is not very well in most cases. So if you can said, how to work with it without recursion, I will be very glad.\r\nI see very often, when some one use \"rec loop\" for making loops functionality. I think it's awful.\r\nI think if you don't need loops (with break and continue) you can don't to use it. I think it's not a big problem to implement this feature and you can decide for yourself, should you use it or not."}],"Status":"","Response":null},"6958404":{"Number":"6958404","Submitter":"Isaac Abraham","Submitted":"2015-01-13T00:00:00","Title":"Allow opening of static classes (matching the C# design)","Text":"You currently can't \"open\" a static class e.g. System.Console - only modules or namespaces. We should be able to also open static classes as well.","Votes":31,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-06-22T15:32:00","Content":"I agree. Modules are compiled down to static classes anyway, so there should be no technical reason for disallowing it."},{"Submitter":"Don Syme","Submitted":"2016-02-04T17:49:00","Content":"Yes, this should I suppose be implemented to match the corresponding C# feature, since static classes will begin to be more common coming from the C# world."},{"Submitter":"Marc Sigrist","Submitted":"2016-02-10T06:15:00","Content":"As in C#, static classes defined in F# will probably become more common. If so, would we still require static classes in F# to be defined via [<AbstractClass; Sealed>]? Or, would it make sense to reuse the static keyword known from 'static member' for 'static type'?"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Thanks for the suggestion. Approved in principle.\r\nWe will open an RFC for this in due course https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs"}},"6987069":{"Number":"6987069","Submitter":"Don Syme","Submitted":"2015-01-20T00:00:00","Title":"Restrict \"private\" for items in namespaces to mean \"private to the namespace declaration group\" #43","Text":"For F# 2.x-4.0, as discussed in thie GitHub thread (https://github.com/Microsoft/visualfsharp/issues/43#issuecomment-70650925), a \"private\" module or type in a namespace is actually accessible from anywhere in that assembly contributing to the same namespace.\r\nThe suggestion is to emit a warning when such an item is accessed from outside the immediate namespace declaration group in which it is declared. For example, we would give a warning if it is accessed from another file in the same namespace in the same assembly.","Votes":4,"Comments":[{"Submitter":"Bryan Edds","Submitted":"2016-02-25T16:43:00","Content":"To help support abstract data types as explained here - https://vimeo.com/128464151 - and as discussed in a bug report here - https://github.com/Microsoft/visualfsharp/issues/984\r\nI propose that we add one exception to the proposed rule, rendering it -\r\n\"Restrict \"private\" for items in namespaces to mean \"private to the namespace declaration group\" [except where functions are defined in a module with the same name as the type and in the same namespace.]\"\r\nWe can create module with the same name as the type in namespace by using the [<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>] attribute on the module, which is a common technique in F#.\r\nThis may seem like a minor exception, but it will keep from breaking code that heavily uses the above abstract data type style, such as here - https://github.com/bryanedds/Prime\r\n- and here - https://github.com/bryanedds/NuGameEngine"}],"Status":"planned","Response":{"Responded":"2015-07-17T00:00:00","Text":"This problem should be fixed via a warning.\r\nThis is approved for inclusion in a future release of the F# language subject to an implementation and detailed design.\r\nDon Syme, F# Language and Core Library Evolution."}},"7017131":{"Number":"7017131","Submitter":"Don Syme","Submitted":"2015-01-27T00:00:00","Title":"Make F# union types like \"list\" that have no subtypes 'sealed'","Text":"The compiled form of the \"list\" type in F# uses a single class. This is also the case for some other F# union types, e.g. ones which are enumerations where no case carries any data. For these types, the compiled representation of the union type should be marked \"sealed\" in F# metadata\r\nThis is a breaking change w.r.t. hypothetical clients in other .NET languages that take advantage of this, though we know of no such instance in practice.","Votes":1,"Comments":[],"Status":"planned","Response":{"Responded":"2015-08-03T00:00:00","Text":"Considering this approved for F# 4.x or the first possible update after this.\r\nDiscussion still very welcome.\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language/Library Evolution"}},"7055281":{"Number":"7055281","Submitter":"Max","Submitted":"2015-02-05T00:00:00","Title":"Add a symbol for FSI to check whether it's in 64 bit or 32 bit","Text":"Often I want to reference different libraries based on whether the FSI is running in 32 bit or 64 bit mode. I often have to test two versions of an assembly, and it's enough of a pain just changing the flag every time, let alone change the references. Being able to do:\r\n#if 64_BIT\r\n#r \"My64BitLib.dll\"\r\n#else\r\n#r \"My32BitLib.dll\"\r\n#endif","Votes":4,"Comments":[{"Submitter":"ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)","Submitted":"2015-07-17T08:32:00","Content":"This seems entirely reasonable for scripting code.\r\nI'll mark it as \"approved in principle\", however the Visual F# Tools team and others may have opinions about how we deal with this kind of configuration parameter. Probably the best thing to do is send a PR to http://github.com/Microsoft/visualfsharp and continue the discussion there, then link back to this discussion."}],"Status":"planned","Response":{"Responded":"2015-07-17T00:00:00","Text":"This is approved for inclusion in a future release of F# subject to an implementation and detailed design. A pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp. Discussion of the particular version for this to be included in can be made once an implementation is available.\r\nDesign detail can also be discussed below.\r\nDon Syme, F# Language and Core Library Evolution."}},"7072844":{"Number":"7072844","Submitter":"Isaac Abraham","Submitted":"2015-02-09T00:00:00","Title":"Utilise CLR union types for discriminated unions","Text":"CLR has native support for union types; these could provide optimization and performance opportunities for F# discriminated unions.","Votes":6,"Comments":[{"Submitter":"David Taylor-Fuller","Submitted":"2015-02-16T17:31:00","Content":"Would love to know why this wasnt done in the initial implementation."},{"Submitter":"exercitus vir","Submitted":"2015-05-21T18:09:00","Content":"Also interested. Does anyone have more information on native union types in the CLR?"},{"Submitter":"Sam Isaacson","Submitted":"2015-07-14T04:58:00","Content":"When you say \"native support for union types\" do you mean the usage of attributes <StructLayout( LayoutKind.Explicit )> or something else?\r\nI currently have a need for a DU type that is not heap allocated - this is causing performance problems via the \"JIT_new\" operation being expensive."},{"Submitter":"Don Syme","Submitted":"2015-07-17T08:24:00","Content":"It would be good to have some mock-up code with performance comparisons for this."},{"Submitter":"Zoltan Podlovics","Submitted":"2015-12-30T07:55:00","Content":"A proof of concept explicit structlayout based demo available at:\r\nhttps://github.com/Microsoft/visualfsharp/pull/620\r\nhttps://gist.github.com/zpodlovics/80e12e2de35cf73e6e03\r\nHowever, it limited only to blittable types. Combine it with blittable type constraint and you can have stack allocated DU."}],"Status":"","Response":null},"7119363":{"Number":"7119363","Submitter":"Gauthier Segay","Submitted":"2015-02-19T00:00:00","Title":"An attribute enforcing usage (in F# code) of named parameters at callsite","Text":"In some code, it's critical to have function/methods called with parameter names at call site, for readability reasons, but also for correctness.\r\nI would like F# to enforce this using an attribute for example: [<EnforceNamedParametersAtCallSite>]\r\nsuppose we have this code (for sake of showing the idea):\r\ntype Foo() =\r\nmember x.Bar(b, a) = (a, b)\r\nlet foo = new Foo()\r\nfoo.Bar(1.00, 0.00)\r\nfoo.Bar(a = 1.00, b = 0.00)\r\nnow suppose we have this slight change in the code (just swapped the parameter names)\r\ntype Foo() =\r\nmember x.Bar(b, a) = (a, b)\r\nthis would not produce the expected result\r\nfoo.Bar(1.00, 0.00)\r\nWith the proposed feature:\r\ntype Foo() =\r\n[<EnforceNamedParametersAtCallSite>]\r\nmember x.Bar(b, a) = (a, b)\r\nfoo.Bar(1.00, 0.00) // doesn't compile, expects usage of parameter names\r\nAnother example is with FSharp.Data.SqlClient's SqlCommandProvider, which defines methods taking parameters based on their order of appearance in the sql code.\r\nsamplesql1.sql\r\n------------------------------------\r\ndeclare @numerator float\r\ndeclare @denominator float\r\nset @numerator = @a\r\nset @denominator = @b\r\nselect @numerator / @denominator\r\nsamplesql2.sql\r\n------------------------------------\r\ndeclare @numerator float\r\ndeclare @denominator float\r\nset @denominator = @b // swapped this line, didn't change anything else\r\nset @numerator = @a\r\nselect @numerator / @denominator\r\nsample1.fsx\r\n------------------------------------\r\n#r @\"..\\tools\\nuget\\packages\\FSharp.Data.SqlClient\\lib\\net40\\FSharp.Data.SqlClient.dll\"\r\nopen FSharp.Data\r\ntype divideInSql = SqlCommandProvider< \"sample1.sql\", YourConnectionString>\r\nlet cmd = new divideInSql()\r\ncmd.Execute(0.0, 1.0) // work but wait bellow (don't want that to compile)\r\ncmd.Execute(a = 0.0, b = 1.0) // works\r\ncmd.Execute(b = 1.0, a = 0.0) // works\r\nsample2.fsx\r\n------------------------------------\r\n#r @\"..\\tools\\nuget\\packages\\FSharp.Data.SqlClient\\lib\\net40\\FSharp.Data.SqlClient.dll\"\r\nopen FSharp.Data\r\ntype divideInSql = SqlCommandProvider< \"sample2.sql\", YourConnectionString>\r\nlet cmd = new divideInSql()\r\ncmd.Execute(0.0, 1.0) // fails divide by 0 (don't want that to compile)\r\ncmd.Execute(a = 0.0, b = 1.0) // works\r\ncmd.Execute(b = 1.0, a = 0.0) // works\r\n------------------------------------\r\nWe have seen by now that change of order in a sql file provokes havoc.\r\nAPI design wise, some people might want to enforce that callsite will use named parameters to avoid those kind of misshaps.\r\nI hope the description is clear enough.","Votes":4,"Comments":[{"Submitter":"Don Syme","Submitted":"2015-07-17T08:04:00","Content":"I can see the rationale.\r\nIt feels uncomfortable to add a bespoke attribute for this though I don't have specific better suggestions as yet. There's nothing quite like this in the F# language design, apart from the requirement to name record fields in the { a=1; b = 2} construction syntax, which is of course a related problem."}],"Status":"","Response":null},"7138324":{"Number":"7138324","Submitter":"Steven Taylor","Submitted":"2015-02-24T00:00:00","Title":"Record type inference suggestion","Text":"Note that if the record {a: int; b: int} is declared last, then type + argument name type inference will not work. Switching the order around resolves the issue. However, this behaviour can be a little mentally jarring.\r\nThe lightweight syntax is very useful. It'd be great to strengthen it up.\r\nmodule Eg1 =\r\ntype AB = {a: int; b: int}\r\ntype A = {a: int}\r\ntype B = {b: int}\r\nlet a = {a=1}\r\nlet b = {b=2}\r\nlet ab = {a=1;b=2}\r\nmodule Eg2 =\r\ntype A = {a: int}\r\ntype B = {b: int}\r\ntype AB = {a: int; b: int} // <- NB. only the order has changed\r\nlet a = {a=1} // fail\r\nlet b = {b=2} // fail\r\n// note that example 3 resolves the ambiguity with the dot syntax on the first named field, but that's not the point.\r\nmodule Eg3 =\r\ntype A = {a: int}\r\ntype B = {b: int}\r\ntype AB = {a: int; b: int}\r\nlet a = {A.a=1}\r\nlet b = {B.b=2}\r\nlet ab = {a=1;b=2}","Votes":1,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2015-02-28T07:19:00","Content":"There was a relevant thread there:\r\nhttps://groups.google.com/forum/#!topic/fsharp-opensource/vb3pTUAcRVs"},{"Submitter":"Don Syme","Submitted":"2016-02-05T05:38:00","Content":"Yes, it looks reasonable to be more flexible here. I will mark this as approved-in-principle"}],"Status":"planned","Response":{"Responded":"2016-02-05T00:00:00","Text":"Marking this as approved-in-principle, per my comment below\r\nWe will open an RFC for this in due course, though the change should not be large\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme, F# Language Evolution"}},"7156040":{"Number":"7156040","Submitter":"Alexei Odeychuk","Submitted":"2015-03-01T00:00:00","Title":"Please make a correct ‘modulus’ for F#","Text":"Please fix a bug in the F# compiler. Everybody needs correct values for negative numbers. The algorithm calculating a modulo should respect the existing math rules. For example, 11 % 5 = 1 (correct), but -11 % 5 is -1 (bug), should be 4 (correct value).\r\nFor instance, m mod n: for integers m and n, m mod n is the integer for which 0 <= r < n and m-r is a multiple of n. For example, 11 mod 5 = 1, and -11 mod 5 = 4.\r\nDetails of discussion and suggested corrections to the algorithm of the % operator are here: 1) http://gettingsharper.de/2012/02/28/how-to-implement-a-mathematically-correct-modulus-operator-in-f/\r\n2) Distinctions between rem and mod: http://mathcentral.uregina.ca/QQ/database/QQ.09.12/h/eric1.html","Votes":13,"Comments":[{"Submitter":"Fraser Waters","Submitted":"2015-03-12T07:11:00","Content":"This matches the behavior of % in C# (and nearly every other language), it would also be a significant breaking change. But adding a new builtin function to do this would be a good idea."},{"Submitter":"Don Syme","Submitted":"2015-06-09T14:06:00","Content":"Just to confirm that our decision in F# 1.0 was to follow C#'s design here.\r\nWe would welcome a PR to github.com/Microsoft/visualfsharp/ to add a new operator."},{"Submitter":"Jared Hester","Submitted":"2015-06-22T23:15:00","Content":"` %. ` should be that operator"},{"Submitter":"Jared Hester","Submitted":"2016-07-03T13:49:00","Content":"Another option would be to move `mod` from the set of keywords in \"mlcompatibility\" mode to the standard language keywords"},{"Submitter":"Alexei Odeychuk","Submitted":"2016-07-05T13:13:00","Content":"I agree with Jared Hester (July 03, 2016 11:49). The \"mod\" operator would be a great addition to the F# language!\r\nFor example, the \"mod\" exists in Object Pascal (Delphi), No. 12 in TIOBE Language Popularity Index.\r\nAs to \"%.\" operator suggested by Jared Hester (June 22, 2015 21:15), I believe it would add nothing to code readability. Programming is a human activitiy. The more readable and correct code, the better for programmers and language popularity.\r\nI am strongly in favor of the \"mod\" operator."}],"Status":"","Response":null},"7184398":{"Number":"7184398","Submitter":"luketopia","Submitted":"2015-03-08T00:00:00","Title":"Cartesian product function for collections","Text":"It's often useful to compute the Cartesian product (cross join) of two collections. I always end up writing something like this:\r\nlet cross xs ys =\r\nseq {\r\nfor x in xs do\r\nfor y in ys ->\r\nx, y\r\n}\r\nI think it would be useful to have this in the standard collection modules.","Votes":7,"Comments":[{"Submitter":"Don Syme","Submitted":"2015-06-09T14:04:00","Content":"The FSharp.Core 4.0.0.0 ship has sailed. It seems reasonable for FSharp.Core vNext, though I'd like to see more input on this., e.g. do other languages have this in core functional collection libraries, ,what naming do they use etc.?"},{"Submitter":"luketopia","Submitted":"2015-08-02T07:59:00","Content":"Python calls it \"product\". https://docs.python.org/2/library/itertools.html#itertools.product"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"I’m marking this approved-in-principle, see RFC FS-1002 https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1002-cartesian-product-for-collections.md\r\nThe function would need to be added to List, Array and Seq. I would prefer a different name – I suggest “allPairs”"}},"7574961":{"Number":"7574961","Submitter":"Vasily Kirichenko","Submitted":"2015-04-15T00:00:00","Title":"Override `ToString` for discriminated unions and records","Text":"It's a pain and dirty to add `override x.ToString() = sprintf \"%A\" x` to every type in order to make `String.Format()` happy:\r\ntype T1 =\r\n{ Id: int\r\nVersion: string }\r\noverride x.ToString() = sprintf \"%A\" x\r\ntype DU =\r\n| C1 of int\r\n| C2\r\noverride x.ToString() = sprintf \"%A\" x\r\nI think it's very easy to teach the compiler generate this override automatically for all user types.","Votes":181,"Comments":[{"Submitter":"Steffen Forkmann","Submitted":"2015-04-15T03:38:00","Content":"This is a real world issue and a problem in projects like paket or https://github.com/adamchester/EaToSql/blob/master/src/EaToSql/Model.fs"},{"Submitter":"Steffen Forkmann","Submitted":"2015-04-15T03:44:00","Content":"Also it's hard to debug such types without the automatic tostring implementation. Debugger just shows the type name."},{"Submitter":"Matthew Peacock","Submitted":"2015-04-21T18:21:00","Content":"However, %A is very very slow, ideally the implementation should not do any reflection at runtime, but be based on code generated at compile time."},{"Submitter":"exercitus vir","Submitted":"2015-06-19T18:00:00","Content":"I am against this. ToString() carries no semantics. To what kind of string? Is it an atomic value or structured value? Is it for logging or display to the user? There is no consistency. The ToString() method should simply be deprecated.\r\nYou can always simply call sprintf \"%A\" any structural type to get a good structured representation even if its very slow."}],"Status":"planned","Response":{"Responded":"2016-06-23T00:00:00","Text":"Marking as planned, though we need to work out the details\r\nDon Syme\r\nF# Language and Core Library Evolution"}},"7640829":{"Number":"7640829","Submitter":"Виктор Милованов","Submitted":"2015-04-21T00:00:00","Title":"Allow access modifies to auto properties getters and setters","Text":"member val Property = 10 with get, private set","Votes":30,"Comments":[{"Submitter":"ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)","Submitted":"2016-02-04T17:39:00","Content":"I'm fine with this suggestion. We considered it for F# 3.0 but cut it, since you can always implement this pattern in a more expanded form using \"let\" and explicit get/set.\r\nIt won't be high priority for myself, but if some one does it, that is great\r\nWill mark this approved-in-principle (will show as \"planned\")"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Marked approved-in-principle, see comments. This won’t be high priority but is we get a quality PR for it we will accept it."}},"7845018":{"Number":"7845018","Submitter":"Richard Minerich","Submitted":"2015-05-06T00:00:00","Title":"Make the result of the dict function implement IDictionary","Text":"The fact that the type returned by dict doesn't implement IDictionary makes reflection difficult and inefficient, it also make this type different than all other .NET Core Dictionary implementations","Votes":21,"Comments":[{"Submitter":"Paul Westcott","Submitted":"2015-05-10T21:49:00","Content":"IReadOnlyDictionary<_,_> as well would be good."},{"Submitter":"Steffen Forkmann","Submitted":"2015-05-11T05:18:00","Content":"I tried to implement this at https://github.com/Microsoft/visualfsharp/pull/436"}],"Status":"planned","Response":{"Responded":"2015-07-17T00:00:00","Text":"This is approved for inclusion in a future release of the F# core library subject to an implementation and detailed design. Completion of the pull request to implement this feature will be necessary, see the link above.\r\nDon Syme, F# Language and Core Library Evolution."}},"7916448":{"Number":"7916448","Submitter":"Dmitry Morozov","Submitted":"2015-05-11T00:00:00","Title":"AddObsoleteAttribute method on ProvidedStaticParameter","Text":"","Votes":3,"Comments":[{"Submitter":"Don Syme","Submitted":"2015-06-09T13:39:00","Content":"This is entirely reasonable and we would accept a PR to implement this.\r\nDon Syme"},{"Submitter":"luketopia","Submitted":"2015-07-31T07:07:00","Content":"I'm confused about what is being suggested here. Are we talking about the ProvidedStaticParameter that's internal to FSharp.Data.TypeProviders.dll? Most type providers I've seen provide their own implementation of ProvidedStaticParameter via their ProvidedTypes.fs. Should an issue be opened on FSharp.TypeProviders.StarterPack instead?"}],"Status":"planned","Response":{"Responded":"2015-07-17T00:00:00","Text":"This is approved for inclusion in a future release of F# subject to an implementation and detailed design. A pull request\r\nto implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and\r\ntesting to http://github.com/Microsoft/visualfsharp. Discussion of the particular version for this to be included in can\r\nbe made once an implementation is available.\r\nDesign detail can also be discussed below.\r\nDon Syme, F# Language and Core Library Evolution."}},"8014059":{"Number":"8014059","Submitter":"Andrzej Kukuła","Submitted":"2015-05-18T00:00:00","Title":"Make call syntax simpler for statically resolved member constraints","Text":"The idea is basically explained by the following code:\r\n// this works as expected\r\ntype Example() =\r\nmember __.F(i) = printfn \"%d\" i\r\nlet inline f (x : ^a) =\r\n(^a : (member F : int -> unit) (x, 1))\r\n(^a : (member F : int -> unit) (x, 2))\r\nf (Example())\r\n// this doesn't work\r\nlet inline f (x : ^a when ^a : (member F : int -> unit)) =\r\n// the compiler knows that there must be member F and its signature\r\n// so the following should be possible\r\nx.F(1)\r\nx.F(2)\r\nYou can also view this code highlighted at http://pastebin.com/CHMj7xQG","Votes":29,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-06-12T18:32:00","Content":"Oh yes, much more readable!\r\nI have incorporated your suggestion in my suggestion for \"Interfaces as simple, reusable and named sets of member constraints on statically resolved type parameters\": http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m"},{"Submitter":"Don Syme","Submitted":"2016-02-04T17:35:00","Content":"I think this is totally reasonable, marking it as approved-in-principle.\r\nNote also that a naked type alias can imply multiple constraints, giving a way to name collections of constraints\r\nhttps://gist.github.com/dsyme/bfed2eed788c7ba58ccc"}],"Status":"planned","Response":{"Responded":"2016-02-04T00:00:00","Text":"Approved in principle. Thanks for the suggestion.\r\nWe will add an RFC for this in due course, see https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs\r\nWe will need to consider whether to simplify calls for static members as well."}},"8140617":{"Number":"8140617","Submitter":"Phillip Trelford","Submitted":"2015-05-27T00:00:00","Title":"Extend custom numeric types to support floating point literals","Text":"Currently you can define custom numeric types for integer values.\r\nIt would be nice to be able to handle floating point values too, e.g.\r\ntype complex = Complex of double * double\r\ntype imaginery = Imaginery of double\r\nwith\r\nstatic member (+) (lhs:double,Imaginery(rhs)) = Complex(lhs,rhs)\r\nmodule NumericLiteralI =\r\nlet FromZero () = Imaginery 0.0\r\nlet FromOne () = Imaginery 1.0\r\nlet FromInt32 (x) = Imaginery (double x)\r\nlet FromInt64 (x:int64) = Imaginery (double x)\r\nlet FromDouble (x:float) = Imaginery x // extension\r\nlet polar = 1.5 + 2.5I","Votes":13,"Comments":[{"Submitter":"trek42","Submitted":"2015-06-06T19:19:00","Content":"This will be a very desired feature now that Xamarin unified API uses 'System.nfloat' to represent native float type and no longer uses either float or double. Because of this, I have to keep writing \"nfloat <float-literal>\" (e.g. \"nfloat 2.0\") for all float literals of nfloat type. It will greatly improve clarity and avoid verbosity if I could just say \"2.0nf\" where 'nf' denotes native float values."},{"Submitter":"Don Syme","Submitted":"2015-07-17T06:45:00","Content":"This is a nice suggestion - the Xamarin use-case below is of particular interest.\r\nI'm not marking it as \"approved\" as yet but I'd be interested in seeing a pull request ironing out any lurking design details."},{"Submitter":"Abel","Submitted":"2016-02-05T08:26:00","Content":"@fsharporg-lang: The link to the suggestion \"in favour of\" is actually *this* suggestion. It seems that you mean to say you are actually going to implement this? Or did you mean to point to another suggestion?"}],"Status":"planned","Response":{"Responded":"2016-03-04T00:00:00","Text":"Now marking as planned, which means we can move to an RFC https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThe details remain to be worked out however\r\nDon Syme\r\nF# Language Evolution"}},"8306538":{"Number":"8306538","Submitter":"thinkb4coding","Submitted":"2015-06-10T00:00:00","Title":"Allow quotations of expressions used as Type Provider arguments","Text":"This would enable scenarios where the type provider can rewrite, or abstract at compile time F# code and emit new one.\r\nIt could replace a macro system without the need for new syntax or tooling.","Votes":30,"Comments":[{"Submitter":"thinkb4coding","Submitted":"2015-06-10T04:20:00","Content":"It could be used by transpilers to check validity and emit code at design/compile time"},{"Submitter":"Don Syme","Submitted":"2015-06-10T07:16:00","Content":"Hi @thinkb4coding\r\nI would very much be in favour of this feature for F# vNext.\r\nSee also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6023655-allow-passing-other-types-of-parameters-to-type-pr"},{"Submitter":"Don Syme","Submitted":"2016-02-04T14:08:00","Content":"Just to note that this would almost certainly require this to have been fully implemented: [/ideas/suggestion-5675977-allow-type-providers-to-generate-types-from-other](/ideas/suggestion-5675977-allow-type-providers-to-generate-types-from-other.md)"}],"Status":"","Response":null},"8401578":{"Number":"8401578","Submitter":"exercitus vir","Submitted":"2015-06-13T00:00:00","Title":"Generic `TypeWithMeasure` and `TypeWithoutMeasure` functions for adding units of measure on any type","Text":"Currently, the Core.LanguagePrimitives module only provides the following functions to add units of measure to decimal, double (= float) and single (=float32), respectively:\r\nDecimalWithMeasure : decimal -> decimal<'u>\r\nFloat32WithMeasure : float -> float<'u>\r\nFloatWithMeasure : float32 -> float32<'u>\r\nand the Core.Operators module overloaded functions for removing units of measure on decimal, double (= float) and single (=float32):\r\ndecimal : ^T -> decimal\r\nfloat : ^T -> float\r\nfloat32 : ^T -> float32\r\nEven though all the other primitive numeric types are also annotated with [<MeasureAnnotatedAbbreviation>], you cannot use them to carry a unit of measure, because the needed conversion functions are missing. And since `MeasureAnnotatedAbbreviation` is a public attribute, we would should be able to add units of measure on *any* type.\r\nSo, I propose to add the following generic functions to the Core.LanguagePrimitives module as follows:\r\nTypeWithMeasure<'T, 'U> : 'T -> 'U\r\nTypeWithoutMeasure<'T, 'U>: 'U -> 'T\r\nwhere 'U is 'T with the measure.\r\nCurrently, DecimalWithMeasure, Float32WithMeasure, FloatWithMeasure are all implemented using the same generic function:\r\nlet inline retype<'T,'U> (x:'T) : 'U = (# \"\" x : 'U #)\r\nSo `TypeWithMeasure` and `TypeWithoutMeasure` could simply reuse this function. I realize that retype might not be entirely safe, but implementors of custom types that can carry units of measure can then implement two type-safe functions:\r\n//custom type\r\ntype SomeType = ...\r\n//custom type that can carry measure\r\n[<MeasureAnnotatedAbbreviation>]\r\ntype SomeType <[<Measure>] 'm> = SomeType\r\n//module with conversion functions for custom type\r\nmodule SomeType =\r\nlet inline SomeTypeWithMeasure (withoutMeasure : SomeType) : SomeType<'m> = TypeWithMeasure withoutMeasure\r\nlet inline SomeWithoutMeasure (withMeasure : SomeType<'m>) : SomeType = TypeWithMeasure withMeasure","Votes":2,"Comments":[{"Submitter":"exercitus vir","Submitted":"2015-06-14T11:31:00","Content":"I just noticed that the following functions also exist, but I still think that we need a generic version:\r\nInt16WithMeasure : int16 -> int16<'u>\r\nInt32WithMeasure : int32 -> int32<'u>\r\nInt64WithMeasure : int64 -> int64<'u>\r\nSByteWithMeasure : sbyte -> sbyte<'u>"},{"Submitter":"exercitus vir","Submitted":"2015-06-14T12:08:00","Content":"You could solve the safety issue by introducing a new attribute similar to `GeneralizableValueAttribute` for value restriction. For example, `TypeWithMeasure` and `TypeWithoutMeasure` should only be callable from functions with an Attribute that might be called `ValueReturnedWithMeasureAttribute` and `ValueReturnedWithoutMeasureAttribute` to prevent accidental usage of `TypeWithMeasure` and `TypeWithoutMeasure`."},{"Submitter":"exercitus vir","Submitted":"2015-06-18T11:49:00","Content":"I also noticed that removing units of measure using functions such as `float` or `double` compiles to (in release mode) for example `(Double) doubleValue` in CIL. Unless this cast is ignored by the CLR if the value is of the same type as the desired cast, this explicit cast should not appear in the CIL produced by F#.\r\nI would be interested to know if currently `(Double) doubleValue` is optimized to simply `double` by the CLR to avoid unnecessary casts."},{"Submitter":"Don Syme","Submitted":"2015-07-18T04:43:00","Content":"Take a look at this gist.\r\nhttps://gist.github.com/dsyme/b80086ce5c5a0dc1a9f7\r\nAlthough there is a change of representation in the conversion for units <-> no units, the effect is still basically as you want it. (if you want to minimize the cost of the representation conversion you could use a struct type)"}],"Status":"","Response":null},"8556646":{"Number":"8556646","Submitter":"mikero","Submitted":"2015-06-26T00:00:00","Title":"Add atom syntax","Text":"Add a syntax for atoms a.k.a. keywords a.k.a. self-evaluating symbols.\r\n:foo (or 'foo, or #foo - whichever causes the least problems)\r\nWhere foo otherwise follows the rules for an identifier, is simply turned into \"foo\" at compile time. (It would also be nice of '-' were also added to the list of allowable characters for the atom.)\r\nE.g.:\r\n(\"fido\", :is-a, :pet) is of type string*string*string","Votes":4,"Comments":[{"Submitter":"Shawn Hoover","Submitted":"2015-10-30T14:10:00","Content":"Is there a particular reason why self-evaluating symbols don't exist in a lot of statically typed languages? I've been wondering about it since hearing Rich Hickey stress in some talks the idea of using generic data (maps, vectors, lists) at subsystem boundaries. Obviously they've been around a long time in Lisp, Erlang, and Ruby, for example. Is it just that generic maps are used less in F# so whatever efficiency or syntactic gains of keywords is less useful?\r\nI see someone bothered to make a library in Haskell: https://hackage.haskell.org/package/hxt-9.3.1.15/docs/Data-Atom.html"},{"Submitter":"Don Syme","Submitted":"2016-02-04T17:31:00","Content":"Why wouldn't it have some new type \"Atom\" (e.g. a single field struct wrapping a string)"},{"Submitter":"mikero","Submitted":"2016-02-04T18:36:00","Content":">Why wouldn't it have some new type \"Atom\" (e.g. a single field struct wrapping a string)\r\nThat's fine too -- I was just trying to create the least amount of friction possible and make the Atom an erased type.\r\nThey should always be interned strings so that they are object.== with an atom or a string with the same chars w/o doing a strcmp. (Wouldn't the wrapping interfere with this?)\r\nAh, the atom could be a global object in the assembly so, :foo would be\r\n\r\nnamespace __atoms {\r\nstatic readonly string __gsym_foo = \"foo\";\r\n}\r\nor, per your comment:\r\nstatic readonly string __gsym_foo = new Atom(\"foo\");\r\nSo we could get pretty-print the right way, or store properties on the atom or whatever.\r\nSo the compiler turns :foo into __atoms.__gsym_foo, and :foo == :foo is always true, at least in the same assembly. (Although getting the symbol from a dynamic string (which is not the normal use case) still requires a lookup.)\r\nIf we had symbols and a lightweight first-class map syntax (please!) then I'd be at least 34.7% happier:\r\nlet map = #{:foo 1 :bar 2; :baz 3} --> map<string,int> or map<Atom,int>\r\nmatch map with #{:foo 1 :bar n :REST more} -> /* n =2, more=[ (:baz,3) ] */\r\n(Of course, reader macros would let us do these things ourselves :) and make me 99 44/100 percent happier. Even w/o homoiconicity, I'd deal that the AST transforms to get macros and reader macros - but I know it's a bit of a sticky wicket as well.)\r\nI'm using Clojure over F# for a current project now for some of these reasons, even though I'd much prefer to stay in the .Net ecosystem, and F# in particular -- I'll end up having to do loosely-coupled Java/.Net interop.\r\nAnother option (or related one) is to improve F#'s default use of \"?\" dynamic access, so that out of the box it does all the fast expando object / call-site caching stuff, etc., but still let it be overridable.\r\nIt seems to be that record/class syntax and map syntax and pattern matching could be merged, so that the same pattern could match any complete or partial sum type, and that this would afford a way to do a sort of \"gradual typing\" in F#. Basically I could use record syntax that was a *partial* specification of the record - the backing store would be a map, not a class, and then the type could \"graduate\" to a fully-specified type at some point backed as a class/struct. Devil is in the details..."}],"Status":"","Response":null},"8909788":{"Number":"8909788","Submitter":"Eirik George Tsarpalis","Submitted":"2015-07-17T00:00:00","Title":"Disable or add a warning to mutable use bindings","Text":"See also https://github.com/Microsoft/visualfsharp/issues/535#issuecomment-122262582","Votes":1,"Comments":[],"Status":"started","Response":{"Responded":"2016-06-22T00:00:00","Text":"This is approved for inclusion in a future release of F#.\r\nPR at https://github.com/Microsoft/visualfsharp/pull/1277\r\nNo RFC is needed for this feature.\r\nDon Syme, F# Language and Core Library Evolution."}},"9156844":{"Number":"9156844","Submitter":"Tomas Petricek","Submitted":"2015-08-03T00:00:00","Title":"Relax some of the indentation rules","Text":"Currently, the general rules for indentation in F# is that the code on the next line should be indented further than the thing that determines its starting point on the previous line.\r\nThere are a number of cases where this quite annoyingly means that you have to indent things very far (or, to avoid that, add lots of unnecessary line breaks). One example is when you have nesting in a method call. For example:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions(Options(colorAxis=ColorAxis(values=[| -100;0;100;200;1000 |], colors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nNow, there is almost no way to make this code snippet look decent. I would want to write something like this:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions(Options(colorAxis=ColorAxis(values=[| -100;0;100;200;1000 |],\r\ncolors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nBut this is not allowed, because \"colors\" should start after the opening parenthesis of ColorAxis, so I would need 50 spaces! To make the number of spaces smaller, you can add additional newline (to get the \"ColorAxis\" more to the left), but this looks pretty bad:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions\r\n(Options\r\n(colorAxis =\r\nColorAxis\r\n(values=[| -100;0;100;200;1000 |],\r\ncolors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nAnother example is very similar, but with list expressions. I want to write:\r\nlet pop2010 = series [ for c in wb.Countries ->\r\nc.Name => c.Indicators.``CO2 emissions (kt)``.[2010]]\r\nThis actually works, but it gives warning. Again, it wants me to indent the second line so that it is after \"for\", but then I'm not saving pretty much anything by the newline. Or, I can introduce lots of additional newlines and write:\r\nlet pop2010 =\r\nseries\r\n[ for c in wb.Countries ->\r\nc.Name => c.Indicators.``CO2 emissions (kt)``.[2010]]\r\nI think that in situations like these, the rules should be relaxed. In particular, we should not require new line to be intended further than the \"starting thing\" on the previous line. Just further than the previous line.","Votes":54,"Comments":[{"Submitter":"Tomas Petricek","Submitted":"2015-08-03T19:09:00","Content":"Posted to F# Snippets, which actually *shows* the indentation! http://fssnip.net/rZ"},{"Submitter":"DK","Submitted":"2015-08-04T06:36:00","Content":"As a matter of fact, I don't find the solution to the problem that you've posted to be that bad. I do however prefer it in a slightly different style: http://fssnip.net/s0\r\nGiven enough complexity even this would start becoming too unwieldy, and would require extracting values out into let bindings. But for this example, I personally think this is more than sufficient."},{"Submitter":"Fredrik Forssen","Submitted":"2015-08-04T08:18:00","Content":"What annoys me most is the records. I would prefer to be able to use something looking like the K&R bracing for records, but the F# compiler wants me to either write oneliners or indenting a lot (or putting the braces on their own lines, heresy!)\r\nI'd love to be able to do this (. instead of space since uservoice hates whitespace)\r\ntype Person = {\r\n....Name : string\r\n....Age : int\r\n}\r\nlet calvin = {\r\n....Name = \"Calvin\r\n....Age = 8\r\n}"},{"Submitter":"Anonymous","Submitted":"2015-08-04T16:17:00","Content":"+1000 if I could. Constantly annoyed by this while writing F#."},{"Submitter":"Alexandre Szymocha","Submitted":"2015-12-07T02:37:00","Content":"I LOVE this proposition!\r\nI’m currently using\r\n#nowarn \"62\"\r\n#light \"off\"\r\nat the top of every file. This removes the pythonic indentation and allows me to write my code shapelessly, but it’s tedious."},{"Submitter":"Don Syme","Submitted":"2016-02-03T13:09:00","Content":"See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/7813977-indentation-of-new-lines-should-be-dependent-on-th"},{"Submitter":"Robin Munn","Submitted":"2016-09-27T23:54:00","Content":"BTW, records have been mentioned in a separate suggestion: [/ideas/suggestion-15696774-relax-indentation-rules-on-records](/ideas/suggestion-15696774-relax-indentation-rules-on-records.md)\r\nI feel the records idea is a subset of this one, which would also cover lists and arrays (and so on). So although I'm 100% in favor of the records suggestion, I've put my limited votes on this one instead.\r\nAlso, I'd like to mention one thing that I haven't seen mentioned yet. I'd like to be able to put the closing delimiter on a line of its own, indented at the same level as the following code. E.g.,\r\nlet myFunction () =\r\n....let someList = [\r\n........\"foo\"\r\n........\"bar\"\r\n........\"baz\"\r\n....]\r\n....let otherList = [1; 2; 3]\r\n....// Other code follows"}],"Status":"","Response":null},"9168976":{"Number":"9168976","Submitter":"Don Syme","Submitted":"2015-08-04T00:00:00","Title":"Add \"complement\" and \"logicalNot\" operators to resolve the confusion with \"~~~\"","Text":"When used on user-defined types, the ~~~ operator resolves to op_LogicalNot rather than the expected op_OnesComplement. See https://github.com/Microsoft/visualfsharp/issues/457#issuecomment-104900399 for a workaround.\r\nThis should be fixed FSharp.Core. An attempt to fix this transparently failed, see https://github.com/Microsoft/visualfsharp/pull/458.\r\nA plan to address this going forward is at https://github.com/Microsoft/visualfsharp/pull/458#issuecomment-127711336 but will require an update to FSharp.Core.","Votes":1,"Comments":[],"Status":"planned","Response":{"Responded":"2015-08-04T00:00:00","Text":"Approved in principle for F# 4.x+ at next FSharp.Core update. See ongoing discussion on github threads as well.\r\nDon Syme, F# Language and Core Library Evolution"}},"9183845":{"Number":"9183845","Submitter":"Eirik George Tsarpalis","Submitted":"2015-08-05T00:00:00","Title":"Add System.Collections.ICollection implementations to F# list/set/map","Text":"ICollection is a useful interface that inherits IEnumerable. Inputs implementing ICollection are utilized by libraries such as LINQ, Nessos.Streams and MBrace in order to optimize partitioning of data. Curiously, none of the F# collections (list/set/map) implement ICollection (however the latter two do implement ICollection<T>, which is a different interface designed for mutable collections). It is currently impossible to extract the length/count of a boxed list/map without performing some sort of reflection, which is not always desirable.\r\nI suggest that future versions of F# core implement this.\r\nSee also https://github.com/Microsoft/visualfsharp/issues/570#issuecomment-128000307","Votes":10,"Comments":[{"Submitter":"Lincoln Atkinson","Submitted":"2015-08-05T11:55:00","Content":"In order to accurately track the length of a list, an additional length field would need to be added to every node. That would be a not insignificant increase the size of lists.\r\nAlso worth noting that the F# runtime is allowed to cheat and mutate lists in the name of performant front-to-back list creation. If length needs to be tracked, some of these implementations will be required to perform a second pass to update the length fields (e.g. List.filter, which builds result list front to back but has no way to know final length ahead of time)"},{"Submitter":"Lincoln Atkinson","Submitted":"2015-08-05T12:07:00","Content":"So while I agree 100% that fast access to .Length would be very useful in a number of situations, it would come at the price of memory and CPU for all users, all the time. That's not to be taken lightly.\r\nAnd in fairness I must also note that some runtime APIs would in fact benefit from this - e.g. List.length (obviously), List.nth/List.take/List.skip (can detect 'index out of range' type errors cheaply)."},{"Submitter":"Eirik George Tsarpalis","Submitted":"2015-08-06T04:03:00","Content":"Good point.\r\nMy thinking in this case was not to make .Length a constant time operation, but rather expose the current .Length implementation for untyped access. Perhaps the ICollection.Count property comes with the implicit assumption that it should be constant time, however in practice the performance of .Length is acceptable and in fact much, much better than running Seq.length.\r\nMy motivation behind this feature request is the following: when writing libraries that consume user-supplied IEnumerables (such as PLINQ) it is often good practice to specialize on the input type. This is particularly true in the case in the case of parallel/distributed computation where proper partitioning of input data is important. If I were to write a partitioning function that accepts IEnumerable<T>, handling lists is no problem (given that my library is F# aware):\r\n```\r\nlet partition (n : int) (ts : seq<'T>) =\r\nmatch ts with\r\n| :? 'T [] as ts -> partitionArray n ts\r\n| :? ('T list) as ts -> partitionList n ts\r\n| :? ICollection<'T> as c -> partitionCollection n c\r\n(* add more cases here *)\r\n| _ -> partitionSeq n c // slowest, most naive approach\r\n```\r\nIf I were to write the same partitioning function for IEnumerable, my options become more limited\r\n```\r\nlet partition (n : int) (e : IEnumerable) =\r\nmatch e with\r\n| :? System.Array as a -> partitionArray n a\r\n| :? ICollection as c -> partitionCollection n c\r\n| _ ->\r\n// no longer possible to identify lists, need to rely on clunky reflection\r\nlet t = e.GetType()\r\nif t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<_ list> then\r\n// etc etc\r\n```"},{"Submitter":"Paul Westcott","Submitted":"2015-08-07T04:57:00","Content":"I always think of properties as O(1) operations. ICollection.Count should thus remain as as O(1) operation. If you want untyped access like it then a sperate interface like IFSharpList should be created that implements Length or named like a function Count() as per the IEnumerable<> extension. (Maybe it could implement other functionality as well; maybe IsEmpty; GetElementtType; maybe it derives from IEnumerable... Maybe I'm just clutching at straws!)"},{"Submitter":"Don Syme","Submitted":"2016-02-04T16:43:00","Content":"Re this:\r\n> Also worth noting that the F# runtime is allowed to cheat and mutate lists ...\r\nFSharp.Core does this but only before list objects escape back to user code. (in any case it's not relevant to the issue under discussion here, just mentioning this in case people were wondering)"},{"Submitter":"Don Syme","Submitted":"2016-02-05T09:18:00","Content":"In balance I think this is a reasonable suggestion and will mark it approved-in-principle\r\nAlternatively we could implement IReadOnlyCollection https://msdn.microsoft.com/en-us/library/hh881542(v=vs.110).aspx now that FSharp.Core 4.4.0.0+ target .NET 4.5 and .NET 4.0 is old history."},{"Submitter":"Marc Sigrist","Submitted":"2016-02-10T04:55:00","Content":"FWIW, I have worked in several larger F#-to-C# projects, and I have used IReadOnlyCollection extensively. So I think implementing IReadOnlyCollection would be a great idea."}],"Status":"planned","Response":{"Responded":"2016-02-05T00:00:00","Text":"Approved in principle, see my comment below\r\nWe will open an RFC for this in due course.\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme, F# Language Evolution"}},"9324276":{"Number":"9324276","Submitter":"Bang Jun-young","Submitted":"2015-08-14T00:00:00","Title":"Have String.ofChars in the standard library","Text":"Wouldn't it be convenient if String.ofChars function was part of the standard library? The implementation is quite straightforward:\r\nmodule String =\r\nlet ofSeq (seq: char seq) =\r\nseq |> (System.Text.StringBuilder() |> Seq.fold (fun sb c -> sb.Append(c))) |> string\r\nCurrently, we have to use an inefficient chaining to convert a seq of characters to a string:\r\n['a'; 'b'; 'c'] |> Array.ofList<char> |> System.String\r\nwhich can be simplified with String.ofChars:\r\n['a'; 'b'; 'c'] |> String.ofChars\r\nString.ofSeq also can be handy for profiles like PCL where the String type is not regarded as seq<char>.","Votes":10,"Comments":[{"Submitter":"Don Syme","Submitted":"2016-02-03T12:06:00","Content":"Given that this would be pretty low-performance in any case, the use of StringBuilder appears adequate to cover this case."}],"Status":"","Response":null},"9679206":{"Number":"9679206","Submitter":"Don Syme","Submitted":"2015-09-08T00:00:00","Title":"DefaultValue attribute should require 'mutable' when used in classes and records","Text":"For structs, adding the DefaultValue attribute to a val declaration (a field) results in a check that the field is mutable, since it doesn't make sense to use an immutable field which only ever has the default value.\r\n[<Struct>]\r\ntype S() =\r\n[<DefaultValue>] val x : C\r\nAssemblyReader.fs(4304,23): error FS0880: Uninitialized 'val' fields must be mutable and marked with the '[<DefaultValue>]' attribute. Consider using a 'let' binding instead of a 'val' field.\r\nFor some reason, this condition is only checked for fields declared in structs. We should likewise give a warning for records and classes:\r\ntype C() =\r\n[<DefaultValue>] val x : C\r\nand\r\ntype R = { [<DefaultValue>] x : C; y : int }","Votes":1,"Comments":[],"Status":"planned","Response":{"Responded":"2015-09-08T00:00:00","Text":"Approved for inclusion in a future release of F#.\r\nPlease consider contributing to F# by providing an implementation, with adequate testing. The code to be adjusted is around here: https://github.com/fsharp/fsharp/blob/212c3359bf6d83e30c12e53fd2ef283d3257b328/src/fsharp/PostInferenceChecks.fs#L1422. For some reason, the code is only activated for struct/enum type definitions, but it should also apply to record and class type definitions.\r\nDon Syme, F# Language Evolution"}},"9688323":{"Number":"9688323","Submitter":"Lev Gorodinski","Submitted":"2015-09-09T00:00:00","Title":"Support custom scheduler in Async","Text":"Some discussion here: https://github.com/Microsoft/visualfsharp/issues/581","Votes":15,"Comments":[{"Submitter":"Ryan Riley","Submitted":"2015-09-09T13:35:00","Content":"Weird, I thought I added this a long time ago. Perhaps it was declined."}],"Status":"","Response":null},"9738327":{"Number":"9738327","Submitter":"Gauthier Segay","Submitted":"2015-09-13T00:00:00","Title":"easier interop with FSharp.Core from other .net languages","Text":"A first example is FSharpOption<T> and it's usage in C#/VB, extend FSharp.Core with this module to make it easier to use:\r\nhttp://fssnip.net/so\r\nThere are other efforts to be made to make FSharp.Core look not too alien in other languages, like being able to await on FSharpAsync.\r\nHaving design guidelines for this type of interop doesn't remove the need for basic F# constructs to be exposed in a convenient way to other dotnet languages.","Votes":11,"Comments":[{"Submitter":"Gauthier Segay","Submitted":"2015-09-13T05:26:00","Content":"For discrimated union, the root type expose get_Is* methods, it should be exposed as Is* methods instead."},{"Submitter":"Dzmitry Lahoda","Submitted":"2015-09-22T12:46:00","Content":"It would be yet another path to introduce F# into C# heavy bureaucratic enterprise. I know that F# Core is part of .NET 4.5. So just add reference from GAC."}],"Status":"","Response":null},"9799014":{"Number":"9799014","Submitter":"Eugene Tolmachev","Submitted":"2015-09-17T00:00:00","Title":"Produce System.Linq.Expressions more efficiently","Text":"Most of .NET query providers are written in C# and use System.Linq.Expressions. While the conversion Expr->Expression is available it introduces significant penalty: http://stackoverflow.com/questions/32592811/why-is-f-expression-tree-generation-is-much-slower-than-c-can-it-be-made-fast","Votes":30,"Comments":[{"Submitter":"Dzmitry Lahoda","Submitted":"2015-09-22T12:44:00","Content":"Also I want want to use API of Elastic NEST or NHibernate I have to map F# Expr to Linq manually losing some readability of queries."},{"Submitter":"Eugene Tolmachev","Submitted":"2015-10-09T12:42:00","Content":"Alternatively, maybe introduce an argument attribute, similar to ReflectedDefinition, something that would tell the compiler to produce C#-compatible tree from a lambda at compile-time, rather than the code to perform the conversion at runtime?"},{"Submitter":"Don Syme","Submitted":"2016-02-03T11:09:00","Content":"I have updated the title to change the suggestion to be about performance."}],"Status":"","Response":null}}