{
    "10011624": {
        "Number": "10011624",
        "Submitter": "Wael",
        "Submitted": "2015-10-01T00:00:00",
        "Title": "Add compiler-warning when using mutable or ref",
        "Text": "add compiler flag: --warn-mutable, --warn-ref which would generate warning when using mutable (either mutable keyword or when using ref).\r\nThis would allow pure modules to be made.\r\nNote that F# doesn't have any \"pure\" tags on member methods like the \"const\" qualifier on C++ methods.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-10-19T14:57:00",
                "Content": "> This would allow pure modules to be made.\r\nI don't see how it helps since you can still use some type from referenced assembly which is equivalent to ref.\r\nBTW this can be implemented in linter (eg. VFPT)."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2016-01-22T04:26:00",
                "Content": "FYI I suggested something similar to this in a comment to this other idea: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5670335-pure-functions-pure-keyword\r\nNOTE: you can still use mutable locals (as oppoosed to fields), in immutable code (because local vars in a method cannot be shared among threads)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-23T11:52:00",
                "Content": "I would prefer if this were implemented in FSharpLint. I will decline this for the core language and please add a suggestion there, if it isn't available already."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "See comment above. Declined since we’d prefer this to be implemented in tools such as FSharpLint.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "10012488": {
        "Number": "10012488",
        "Submitter": "Alex Corrado",
        "Submitted": "2015-10-01T00:00:00",
        "Title": "Add anonymous modules",
        "Text": "Often, I find myself writing little private modules to provide some syntactic sugar for a type that I'm using heavily in a file.\r\nFor instance, take this method for quoting an F# function into a LINQ Expression Tree from http://stackoverflow.com/a/23146624/578190. It would be nice if I could write it like this:\r\nopen System.Linq.Expressions\r\nopen module =\r\ntype Expression with\r\nstatic member Lambda(e:Expression<_>) = e\r\nThe above construct would be equivalent to this:\r\nmodule private SomeGeneratedNameIDontCareAbout =\r\ntype Expression with\r\nstatic member Lambda(e:Expression<_>) = e\r\nopen SomeGeneratedNameIDontCareAbout\r\nNote that the module is implicitly private; it effectively has no name, so there is no way to reference its members outside the scope in which it is open'd.\r\nThe `open module =` syntax is just my random suggestion :)",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Alex Corrado",
                "Submitted": "2015-10-01T13:03:00",
                "Content": "A colleague just pointed out that you can do this:\r\n[<AutoOpen>]\r\nmodule private __ =\r\n...\r\nNot quite as pretty, but adequate. Feeling a little silly, I withdraw my suggestion."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Declined per comment from requestor"
        }
    },
    "10020264": {
        "Number": "10020264",
        "Submitter": "Anonymous",
        "Submitted": "2015-10-01T00:00:00",
        "Title": "implicit upcast of return values",
        "Text": "It gets to be very frustrating when working with many C# libraries from F# because F# lacks implicit upcasting of return values. In some cases, this is just annoying. But it is particularly intractable when dealing with libraries expecting Expressions, because upcasting changes how the expression is evaluated by the library. See this question, where in the comments, the author comes to the conclusion that he can't make it work with F#.\r\nhttp://stackoverflow.com/questions/10647198/how-to-convert-expra-b-to-expressionfunca-obj\r\nThere does exist a work-around, but it is quite horrible.\r\nhttp://www.fssnip.net/c7\r\nAside from this show-stopping issue, there are many other scenarios where libraries expect implicit upcasts and it becomes annoying to have to litter your code with explicit upcasts. Interfaces and System.Object are the usual suspects for upcasting.\r\nRequest implicit upcasting of return values.",
        "Votes": 6,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "10100028": {
        "Number": "10100028",
        "Submitter": "Yaar Hever",
        "Submitted": "2015-10-06T00:00:00",
        "Title": "FSI execute without evaluation by pressing Enter",
        "Text": "The way F# interactive is set now, code is executed when it is evaluated, i.e., when a line ends with a double semicolon and Enter.\r\nEvaluation is indeed important, but FSI can also be used to interact with libraries or to get something from the standard output.\r\nThis feature refers mostly to \"side effects\" and might be seen contrary to the values of functional programming, but those are quite interesting and helpful in a scripting language where you want immediate results. FSI has the advantage of being able to access DLLs and execute functions quickly while still enjoying the power of type inference.\r\nI suggest adding a sort-of \"python\" mode in which every piece of code is executed after pressing Enter, if it is well-formed and doesn't expect further arguments. Double semicolons would still be in use for evaluating. It can be referred to as \"imperative mode\".\r\nThus, typing:\r\n> printfn \"hello world\" [Enter]\r\nwould output:\r\nhello world\r\nand start a new interactive line:\r\n>\r\nBut typing\r\n> printfn [Enter]\r\nwould start a new line and wait for an argument.\r\nThe same goes for bindings and other closures.\r\nThe problem of partial application can be solved by expecting the user to press Enter twice for execution:\r\ntyping:\r\n> let printInt = printfn \"%d\" [Enter]\r\nstill expects another argument and doesn't execute, but pressing Enter again will bind printInt to a function: (int -> unit).\r\nThis means, of course, that a non well-formed piece of code followed by pressing Enter twice will have to fail and start a new line.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2015-10-11T13:53:00",
                "Content": "On second thought, I would like to restrict this suggestion. It doesn't make sense to have this faster evaluation option for bindings, since those could be easily evaluated with ';;' like now.\r\nIn fact, the only kind of expression that could be made faster and more efficient by not requiring the double semicolon in an interesting way are expressions that evaluate to a unit.\r\nSo I withdraw the two-'Enter' suggestion and suggest only that if this option is set, each time the user presses 'Enter', the accumulated buffer would be checked to see if it evaluates properly to a unit. If it does, then the buffer is executed and all of the side-effects take place.\r\nTo run an imperative library function that returns a value (say, a boolean marking success/failure), the use could add \"|> ignore\" which would make it evaluate to a unit."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:45:00",
                "Content": "Given the complexity of implementing this (invoking the type checker) we are unlikely to make specific changes here until a major revamp of F# interactive is done."
            },
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2016-02-25T18:16:00",
                "Content": "Thank you for your response. I hope this could be implemented in the future."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per comment"
        }
    },
    "10256475": {
        "Number": "10256475",
        "Submitter": "William Blum",
        "Submitted": "2015-10-17T00:00:00",
        "Title": "Catch improper use of monadic return in async",
        "Text": "The following code should issue a type checking error since return () should yield an Async<unit> and return 42 should yield an Async<int>.\r\nlet f c =\r\nasync {\r\nreturn ()\r\nprintfn \"You passed %A and I am returning 42\" c\r\nreturn 42\r\n}\r\nAdditionally the following code should issue a warning since the return statement does not actually affect the flow of execution as the name suggests (The printf statement is actually executed).\r\nlet g c =\r\nasync {\r\nreturn ()\r\nprintfn \"You passed %A and I am returning 42\" c\r\nreturn ()\r\n}",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-10-18T15:09:00",
                "Content": "Return in computation expressions is the monodic \"return\" (or \"pure\") and has nothing in common with return in imperative languages like C#. What's more, return usually == yield."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-23T11:50:00",
                "Content": "I do agree that ideally this should be caught, and some kind of warning given.\r\nI don't specifically have a design in mind, but I am going to mark this as \"planned\", though subject to a detailed design, implementation and testing. I don't expect it to be a top-priority, but from the design perspective I'm ok with us looking for a solution to this specific problem."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "See comment\r\nApproved in principle, though definitely subject to a more detailed satisfactory design (not to adhoc,not specific to “async”)\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "10257471": {
        "Number": "10257471",
        "Submitter": "William Blum",
        "Submitted": "2015-10-18T00:00:00",
        "Title": "Match descriminates on both argument evaluation and thrown exception",
        "Text": "As explained in OCaml 4.02 release note: \"The match construct was extended to discriminate not just on the value of its argument expression, but also on exceptions arising out of the evaluation of this expression. This solves an old problem: in a let x = a in b, catch exceptions raised by a but not those raised by b. \"",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-10-19T14:50:00",
                "Content": "Isn't this a duplicate of [/ideas/suggestion-6536829-implement-ocaml-s-new-match-exception-syntax](/ideas/suggestion-6536829-implement-ocaml-s-new-match-exception-syntax.md)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Duplicate as noted in the comments\r\nDon Syme, F# Language Evolution"
        }
    },
    "10276974": {
        "Number": "10276974",
        "Submitter": "Kevin Ransom",
        "Submitted": "2015-10-19T00:00:00",
        "Title": "Allow all declarations to be mutually referential and the compiler takes files in any order",
        "Text": "With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to just change F# to use no file order at all, allowing all declarations in an assembly to be mutually referential with other declarations.\r\nRelated alternative: Keep a file order, but infer it from #load/#require declarations. This is covered by [/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files](/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files.md)\r\nRelated alternative: Keep a file order, but optionally have it specified by a fileorder.fsx or fileorder.txt or fileorder.json: [/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx](/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx.md)",
        "Votes": 39,
        "Comments": [
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2015-10-19T13:55:00",
                "Content": "I'm confused. Isn't being able to view file dependencies at a glance, based on file order, a good thing for the same reason types are required to be defined in order?"
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2015-10-19T13:59:00",
                "Content": "If we go the #include/#load route, I hope VS will still require dependency order. My 2 cents."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2015-10-19T14:00:00",
                "Content": "Like Daniel Robinson, I think that since the order matters, being able to view that order at a glance is valuable.\r\nIf that feature is removed, I suspect we'll see files named 010Foo.fs, 050Bar.fs, etc. That's not a place I'd like to go."
            },
            {
                "Submitter": "Colin Bull",
                "Submitted": "2015-10-19T14:16:00",
                "Content": "Personally, having the enforced order of the files is a big win for me. It allows me to pick up a project and instantly know where to start figuring out how things work. This is especially useful for libraries which do not have such an obvious entry point as is available in console apps; also since the compiler enforces it is the same across all projects, no matter the developer. I realise that this can be somewhat of a hurdle for beginners, but for maintainability of a code base it is invaluable."
            },
            {
                "Submitter": "Onorio Catenacci",
                "Submitted": "2015-10-19T14:16:00",
                "Content": "Can someone vote against an idea? This is a bad idea.\r\nF#'s enforced compilation order is a _good_thing_."
            },
            {
                "Submitter": "DK",
                "Submitted": "2015-10-19T14:22:00",
                "Content": "I think this is a brilliant idea! And the best part is -- it doesn't cancel out the enforced file order.\r\nHaving a tool deduce file order (and for example, update file order in solution explorer automatically) will let us keep the best of both worlds."
            },
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-10-19T14:37:00",
                "Content": "@DK Unfortunately this is not so simple. Different file orders may result in different behaviours (eg. when a type is in referenced assembly and a type with the same name is also in current assembly)."
            },
            {
                "Submitter": "Jack Fox",
                "Submitted": "2015-10-19T15:48:00",
                "Content": "Unless this is a win in some area I do not understand (like tooling) I too would down-vote this idea."
            },
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2015-10-19T15:56:00",
                "Content": "I'm also against it. Letting the compiler figure out the order of dependency only postpones the problem and eventually leads to spaghetti code and cyclic dependencies.\r\nI find that this constraint + the fact that mutually recursive functions and types require the \"let/type ... and ...\" syntax actually help in reasoning about the structure of the code.\r\nSee also this article (and the references at its end): http://fsharpforfunandprofit.com/posts/recipe-part3/"
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2015-10-19T17:08:00",
                "Content": "Kevin, would the files in Solution Explorer re-order automatically based on #load's?"
            },
            {
                "Submitter": "x",
                "Submitted": "2015-10-19T17:19:00",
                "Content": "Do this in external tooling to sort your files in the solution, and not in the compiler! As it is, its a great feature for keeping the architecture clean."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-10-20T03:44:00",
                "Content": "As already commented on Twitter: Please don't break compilation order. It's what makes my code sane."
            },
            {
                "Submitter": "mavnn",
                "Submitted": "2015-10-20T07:57:00",
                "Content": "I'd also like to go on record as not wanting this as a feature; I say this dispite having written build scripts that *do* use #load statements in fsx files to feed the compiler source in the correct order.\r\nIt works, but it's ugly and it's not an improvement; optionally moving this information out of fsproj files might be helpful, but I'd rather see a dedicated file for this (like fsi files for signature information)."
            },
            {
                "Submitter": "Shawn Martin",
                "Submitted": "2015-10-21T12:47:00",
                "Content": "Since there's no downvote button, I guess I'll pile on with many of the other commenters. I like the existing enforcement of an explicit, user-specified order."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-10-21T15:53:00",
                "Content": "If I could spend votes to down vote this suggestion I would.\r\nThis is a feature not a bug. It's a small bit of pain to start with that improves the overall quality / understandability later."
            },
            {
                "Submitter": "Bent Tranberg",
                "Submitted": "2015-10-31T15:01:00",
                "Content": "I'd also like to go on record as not wanting this. Colin Bull and others has already explained why it should stay the way it is."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-11-04T21:43:00",
                "Content": "Please don't do this."
            },
            {
                "Submitter": "Semyon Grigorev",
                "Submitted": "2015-12-08T09:01:00",
                "Content": "Bad idea. Fixed compilation order is a good feature."
            },
            {
                "Submitter": "Siro Mateos",
                "Submitted": "2015-12-11T10:13:00",
                "Content": "Add another \"downvote\", for NOT doing this."
            },
            {
                "Submitter": "Joakim",
                "Submitted": "2015-12-23T18:12:00",
                "Content": "Semantic file order and lack of cyclic dependencies makes it so much easier to figure out what's going on in a project. Consider this a downvote."
            },
            {
                "Submitter": "Harald Steinlechner",
                "Submitted": "2016-02-03T06:20:00",
                "Content": "Another downvote. although it seems nice, we'd increase complexity in f# libraries, .e.g. see http://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild/"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:53:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an which suggests\r\nopen \"Helpers.fs\"\r\nor\r\n#requires \"Helpers.fs\"\r\nor\r\n#load \"Helpers.fs\" (which already describes dependencies in scripts)\r\nNote that F# scripts already have syntactic description of non-cyclic dependencies through #load. So a file ordering inferred from syntax is already part of the F# programming model, at least for scripting."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:32:00",
                "Content": "Jus to mention that I don't see anything fundamentally \"non-F#\" about optionally describing file dependencies explicitly within files - indeed we already do this for F# scripting using ``#load``. The file ordering would still exist.\r\nSee http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an for example"
            },
            {
                "Submitter": "Kurren Nischal",
                "Submitted": "2016-04-14T03:23:00",
                "Content": "Downvote. The ability to open a project and immediately see the dependency hierarchy is a major reason why we use F#."
            },
            {
                "Submitter": "Stefano Pian",
                "Submitted": "2016-04-18T03:37:00",
                "Content": "Downvote. The compilation order has been a huge blessing for me whenever I need to pick up a moderate-sized or bigger F# project.\r\nI agree that the F# compilation should become editor-agnostic, but either of the related alternatives would solve the problem without sacrificing F#'s excellent enforced code structure."
            },
            {
                "Submitter": "Jason Ritchie",
                "Submitted": "2016-06-28T06:49:00",
                "Content": "Downvote. Having circular dependencies be impossible helps me fall into a 'pit of success' in my designs."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-06-28T06:58:00",
                "Content": "It is unfortunate that this suggestion mixes 2 concerns:\r\n* declarations to be mutually referential (which most people don't want as seen in comments)\r\n* have the compiler figure out the order rather than have to specify it manually\r\nI think the later point would be a great thing for end-users, and that doesn't circumvent at all file ordering being there and necessary, only it would be figured out by the compiler."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2016-07-01T08:51:00",
                "Content": "100% agree with Gauthier. It would be quite good if the compiler could figure out the order of the files, but total circular dependency is way too error-prone."
            },
            {
                "Submitter": "Alex Yakunin",
                "Submitted": "2016-09-24T02:09:00",
                "Content": "Upvote.\r\nThere were many points saying that explicit file order is one of core F# features, and it's crucial. It lets you immediately see the order of dependencies, and thus it prevents possible issues with circular / spaghetti dependencies.\r\nI am fully disagree with this:\r\na) Dependencies aren't simply chained in most of projects -- usually there is a good amount of flexibility in how to order them. And it's not fully clear why a specific order is preferable over others.\r\nb) This also means that actually order doesn't show the dependencies: on contrary, it shows which dependencies do not exist. The only relationship it exposes is: \"if A is above B, A definitely does not depend on B\". Though the same doesn't mean \"B definitely depends on A\".\r\nc) Finally, dependency graph is a graph, not a sequence. So I don't understand why it's good to force developers to model it as a sequence. Especially assuming that almost any modern compiler is smart enough to figure out both dependencies and compilation sequence.\r\nd) Nevertheless, I see a value in having an ability to display the dependencies of your F# files. But \"display\" is not what compilers do -- this is what IDEs and other tools do. So I totally support to have this feature in IDE, but I don't see a single reason to have it baked into the compiler -- at least in such a way.\r\nMoreover, if I'd be building a feature allowing me to see these dependencies, I'd prefer to show differently -- one of good ways is to show it as a tree listing the most independent files on the first level, their dependencies -- on the second, and so on. The opposite order (from the mostly dependent components to their deepest dependencies) is totally valid too. Any profiler is capable of showing a similar structure for your call tree.\r\nAnd I don't think I'd prefer this dependency graph to be shown simply as an ordered sequence.\r\nPlease consider all these arguments before downvoting this feature."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "10575069": {
        "Number": "10575069",
        "Submitter": "Steffen Forkmann",
        "Submitted": "2015-11-06T00:00:00",
        "Title": "add Async.Choice to FSharp.Core",
        "Text": "Async.Choice is super useful (e.g. very important in Paket) but hard to implement. There are couple of implementations floating around like http://www.fssnip.net/dO but it's ahrd to decide which one is correct. We should add it to the core.",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2015-11-06T04:38:00",
                "Content": "Btw, the implementation of http://www.fssnip.net/dO is flawed. I would consider using http://www.fssnip.net/dN instead."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2015-11-06T04:41:00",
                "Content": "If I remember correctly that version didn't work in paket since it doesn't cancel running http requests"
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2015-11-28T04:48:00",
                "Content": "PR is at https://github.com/Microsoft/visualfsharp/pull/744"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Approved and completed, though not yet in any specific public release of F#.\r\nPR https://github.com/Microsoft/visualfsharp/pull/744 completed.\r\nDon Syme, F# Language Evolution"
        }
    },
    "10596684": {
        "Number": "10596684",
        "Submitter": "Sehnsucht",
        "Submitted": "2015-11-07T00:00:00",
        "Title": "Allow upcast in type test pattern (inside computation expression)",
        "Text": "See this SO subject along with Tomas response ; that convey pretty well what i mean (as my english is rubbish).\r\nhttp://stackoverflow.com/questions/33585508/why-this-for-type-test-pattern-fails",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-23T11:47:00",
                "Content": "Perhaps I don't fully understand the suggestion. However essentially we decided against this in the design of computation expressions, instead the recommendation is to use \"match\" if doing a runtime type test, and \":>\" if doing a static cast."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "See comment above\r\nDon Syme, F# Language Evolution"
        }
    },
    "10617357": {
        "Number": "10617357",
        "Submitter": "Brandon D'Imperio",
        "Submitted": "2015-11-09T00:00:00",
        "Title": "Lift parameter names from the callee",
        "Text": "if I have a method with parameters, and close one of the params with another method call, I lose all parameter names unless I copy and paste them:\r\n```\r\nlet internal save connection apptId apptPatientId apptPatientInfoId apptProviderScheduledId apptFacilityId apptStartTime apptEndTime apptTypeId apptStatus apptBillingStage apptLoS apptCheckInFlag apptCheckInTime apptCheckOutTime apptForeignEhrId apptAccidentRelated apptAccidentId apptAccidentDate apptAccidentState presentingCondition notesToBiller isChecked apptPrimaryGuarantorType admitStatus (admitFacilityId:int Nullable) referralPcp =\r\nlet admitStatus = if String.IsNullOrEmpty(admitStatus) then null else admitStatus\r\ngetScalar connection false (fun db -> db.UspAppointmentsInsUpd(apptId, apptPatientId, apptPatientInfoId, apptProviderScheduledId, apptFacilityId, apptStartTime, apptEndTime, apptTypeId, apptStatus, apptBillingStage, apptLoS, apptCheckInFlag, apptCheckInTime, apptCheckOutTime, apptForeignEhrId, apptAccidentRelated, apptAccidentId, apptAccidentDate, apptAccidentState, presentingCondition, notesToBiller, isChecked, apptPrimaryGuarantorType,admitStatus=admitStatus,admitFacilityId=admitFacilityId,referralPcp=referralPcp))\r\n```\r\nthen want to close the first parameter with\r\n```\r\nlet SaveConn con = save (SqlConn.Conn con)\r\n```\r\nI lose all the remaining parameter names on the tooltip.\r\nInstead I have to do the following\r\n```\r\nlet Save apptId apptPatientId apptPatientInfoId apptProviderScheduledId apptFacilityId apptStartTime apptEndTime apptTypeId apptStatus apptBillingStage apptLoS apptCheckInFlag apptCheckInTime apptCheckOutTime apptForeignEhrId apptAccidentRelated apptAccidentId apptAccidentDate apptAccidentState presentingCondition notesToBiller isChecked apptPrimaryGuarantorType admitStatus admitFacilityId referralPcp connString =\r\nsave (ConnectionString connString) apptId apptPatientId apptPatientInfoId apptProviderScheduledId apptFacilityId apptStartTime apptEndTime apptTypeId apptStatus apptBillingStage apptLoS apptCheckInFlag apptCheckInTime apptCheckOutTime apptForeignEhrId apptAccidentRelated apptAccidentId apptAccidentDate apptAccidentState presentingCondition notesToBiller isChecked apptPrimaryGuarantorType admitStatus admitFacilityId referralPcp\r\n```\r\nMy suggestion is to lift the remaining parameters needed to finish the method call from the callee",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Sehnsucht",
                "Submitted": "2015-11-10T19:31:00",
                "Content": "Aside the current suggestion ; that's a lot of parameter, maybe all those apptXXX args should be in their own type, a record for example (and that way you can \"dot into\" it and have the field names as a hint when the function is \"lifted\")"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:23:00",
                "Content": "I don't think we will do this suggestion: the better thing is to redesign an API when there are soooo many parameters, per the comment below."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thank you for the suggestion. I have marked it declined per my comment below\r\nBest wishes\r\nDon Syme, F# Core Library and Language Evolution"
        }
    },
    "10690359": {
        "Number": "10690359",
        "Submitter": "Joris Morger",
        "Submitted": "2015-11-13T00:00:00",
        "Title": "Add \"row polymorphism\" aka \"extensible records\"",
        "Text": "In F# there is no way to write a function that can work on similar records.\r\nIf I have two records\r\ntype Organisation = { Name: string, Country: string }\r\ntype User = { Name: string, Profession: Profession }\r\nand would like to write a function that operates on the common (name: string) fields I need to rewrite my records.\r\nWhat I would like is a way to write a function that can work with all records that have a field (Name: string)\r\nHere is an example with pseudocode.\r\nNote: I do not propose this exact syntax.\r\n// Named takes a record with at least a name field\r\n// but can have many more in addition to that, denoted by the 'a\r\ntype 'a Named = { Name: string | 'a }\r\nlet printName (a : 'a Named) : string =\r\nsprintf \"Name: %s\" a.Name\r\nIt's already possible to simulate this, but you'd have to replace your records, see here: http://stackoverflow.com/questions/29531852/does-f-have-row-polymorphism-or-something-similar\r\nThis feature is implemented in PureScript and Elm.\r\nElm uses the Name \"Extensible Records\", see: http://elm-lang.org/docs/records#record-types\r\nPurescript: https://leanpub.com/purescript/read#leanpub-auto-record-patterns-and-row-polymorphism",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-11-15T10:05:00",
                "Content": "Note that this is same as\r\n[/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete](/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete.md)\r\nand similar to\r\n[/ideas/suggestion-6181848-provide-better-support-for-structural-typing](/ideas/suggestion-6181848-provide-better-support-for-structural-typing.md)"
            },
            {
                "Submitter": "Nathan Schultz",
                "Submitted": "2015-11-17T20:59:00",
                "Content": "It might be worth noting that Elm is removing Extensible Record support as of version 0.16.\r\nhttps://github.com/elm-lang/elm-compiler/issues/985"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Duplicate of [/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete](/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete.md)\r\nDon Syme, F# Language Evolution"
        }
    },
    "10701768": {
        "Number": "10701768",
        "Submitter": "ふぇ～はぇ～",
        "Submitted": "2015-11-14T00:00:00",
        "Title": "Add stable sort for Array module",
        "Text": "Seq.sort and List.sort are based on Microsoft.FSharp.Primitives.Basics.Array.stableSortInPlace, so there are stable sort. But Array.sort is unstable. This is confusing.\r\nPlease be public the function Array.stableSortInPlace, etc.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:27:00",
                "Content": "This really depends on .NET providing an efficient stable sort for arrays. It doesn't. Searching for \"stable sort array c#\" gives useful guides about what to do."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined: This is really a .NET thing"
        }
    },
    "10800408": {
        "Number": "10800408",
        "Submitter": "Jerold Haas",
        "Submitted": "2015-11-20T00:00:00",
        "Title": "Add function parameter default value shorthand",
        "Text": "let add (x:int = 0) (y:int = 0) = a + b\r\nor\r\nlet add (?x:int = 0) (?y:int = 0) = a + b",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-01-23T11:35:00",
                "Content": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663215-optional-and-named-parameters-on-let-bindings-on-m"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663215-optional-and-named-parameters-on-let-bindings-on-m\r\nDon Syme, F# Language Evolution"
        }
    },
    "10837866": {
        "Number": "10837866",
        "Submitter": "John Azariah",
        "Submitted": "2015-11-23T00:00:00",
        "Title": "Introduce the ?. operator into F#",
        "Text": "Since we allow the . operator to reference fields and properties of objects in F#, we're faced with the same problem of null checking that plagued C# until C# 5.\r\nThe C# 6 'elvis' operator propagates nulls in a succinct way, and I think that working with objects in F# will be similarly simplified if we introduce it here as well!",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-11-28T06:18:00",
                "Content": "I prefer using None instead of null in F#."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2015-12-01T06:54:00",
                "Content": "@radek, maybe semantics like\r\na.?b\r\n===\r\nif a = null then None else Some (a.b)\r\nAnd chained together so\r\na.?b.?c\r\n===\r\nif a = null then None else (if b = null then None else Some (a.b.c))\r\nWould allow easy matching as well:\r\nmatch a.?b with\r\n| Some b -> printf \"a.b is %A\" b\r\n| None -> printf \"a is null\""
            },
            {
                "Submitter": "Colin Bull",
                "Submitted": "2015-12-01T07:46:00",
                "Content": "There is already an Option.ofObj(F# 4) that can help here\r\nYou can do something like,\r\nlet a = new System.IO.FileInfo(\"Foo\")\r\nlet (<*>) a f = a |> Option.map f\r\nlet ($) a f = (Option.ofObj a) <*> f\r\nlet x =\r\na$(fun x -> x.CreationTime) <*> (fun x -> x.ToShortDateString())\r\nNot quiet as succinct but you can always lift those accessors to functions to make things tidier.\r\nIn general though I'm opposed to using this type of symbolics as it hides meaning, however well documented it is from (C# etc...). I'd prefer to define these locally like this and just use the functions from F# core."
            },
            {
                "Submitter": "Bartosz Sypytkowski",
                "Submitted": "2015-12-04T03:12:00",
                "Content": "\"maybe{}\" is a basic lesson about computation expressions and it already solves problems, that \"elvis operator\" is trying to solve. F# doesn't need to solve monad problems using syntax sugar like C# does. We can use existing tools instead."
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2016-01-15T13:07:00",
                "Content": "I agree with Bartosz. Even though ?. would be more succinct, I would prefer the built-in language symbols remain as few in number as possible."
            },
            {
                "Submitter": "Harald Steinlechner",
                "Submitted": "2016-01-18T12:29:00",
                "Content": "this snippet is a superstrong argument against such a feature ;)\r\nhttp://pastebin.com/Z6kbuTEE\r\n(be proud if you can compute all types of the variables as well as the return value)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "10921911": {
        "Number": "10921911",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2015-12-01T00:00:00",
        "Title": "Allow extension members in namespaces, without requiring an enclosing module",
        "Text": "Now it's impossible to declare extension members directly in namespaces, except in the same file and namespace where the type is defined. Please consider eliminating that limitation of the language on the expression of developer's ideas. That limitation does not serve any reasonable purpose, I think. Nobody needs to create a module with [<AutoOpenAttribute>] to hold declarations of extension members only in order to circumvent that limitation of the language. I believe that if a developer needs to create an extension method for a type, he/she should be able to do it directly in any namespace of the application he/she is developing.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2015-12-01T03:47:00",
                "Content": "If such a wrapper module is needed for compilation reasons, let the compiler create such a module with [<AutoOpenAttribute>] automatically."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:03:00",
                "Content": "Because of a considerable amount of technical detail, and because of how extension members are compiled, this is actually quite difficult. As a result I don't think we are going to make this change."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. I’ve marked it declined, as per the comment below\r\nDon Syme, F# Language Evolution"
        }
    },
    "10922358": {
        "Number": "10922358",
        "Submitter": "zjv",
        "Submitted": "2015-12-01T00:00:00",
        "Title": "Make reflected definitions easy to access",
        "Text": "Given a reflected function like this:\r\n[<ReflectedDefinition(true)>]\r\nlet foo (x) = ...\r\nI would like to be able to get the reflected definition like this:\r\nfoo.TryGetReflectedDefinition()\r\ninstead of ugly code like this (note how I had to write the method name as a string):\r\nlet fooType = foo.GetType().DeclaringType.GetMethod(\"foo\")\r\nlet fooExpr = Expr.TryGetReflectedDefinition(fooType)",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:55:00",
                "Content": "Using a quotation <@ foo @> will make it easier to accurately get the method name.\r\nI will decline this: the existing mechanism seems good enough considering this is relatively rare."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "See comment from Don Syme"
        }
    },
    "10964649": {
        "Number": "10964649",
        "Submitter": "zjv",
        "Submitted": "2015-12-04T00:00:00",
        "Title": "Importing DLL's from projects in current solution into F# interactive",
        "Text": "It is currently a hassle to import references to DLL's from projects in the current solution because full paths has to be given and recursive dependencies have to be handled manually. Why not make it possible to import a \"project\" by name along with all dependencies into F# interactive.",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Eric Stokes",
                "Submitted": "2015-12-31T23:13:00",
                "Content": "Or at least remove the requirement that references be entered in dependency order to fsi. Error FS0074 is a big pain point for me in fsi, and there are numerous confused discussions about it on stackoverflow and github. I realize this may not be that easy, but it would be worth the effort!"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-01-23T11:43:00",
                "Content": "This is implemented as \"Send project references to F# Interactive\" in Visual Studio, and I think may be available similarly in other F# tooling. So I will mark it as completed\r\nIn any case it is more on the tooling side than the language side."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "See comment above"
        }
    },
    "10973943": {
        "Number": "10973943",
        "Submitter": "Jared Hester",
        "Submitted": "2015-12-05T00:00:00",
        "Title": "Char[] Literals",
        "Text": "@\"\\\\server\\share\"B is a byte array\r\n@\"\\\\server\\share\"C could be a char array",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:21:00",
                "Content": "Combining into one suggestion with http://fslang.uservoice.com/forums/245727-f-language/suggestions/11109258-allow-string-literal-formats-for-timespan-datetime"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Combining into one suggestion with http://fslang.uservoice.com/forums/245727-f-language/suggestions/11109258-allow-string-literal-formats-for-timespan-datetime"
        }
    },
    "10999326": {
        "Number": "10999326",
        "Submitter": "Max Malook",
        "Submitted": "2015-12-07T00:00:00",
        "Title": "interpret `do! action` as `let! () = action in zero` when the Builder has no Return defined",
        "Text": "In general there are two types of workflows represented by computation expressions:\r\n1) process (async)\r\n2) sequential (seq)\r\nThe former usually uses return or return!, the later yield and yield!.\r\nWith asyncSeq it's actually a combination of both worlds, but the main purpose is to be sequential, and also allow side effects to happen (do! Async.Sleep 200).\r\nCurrently `do! action` is interpreted as `let! () = action in return ()`, with this the Builder has to provide the Return method. With it in place also return keyword becomes available.\r\nIn case of asyncSeq the result of `return expr` is completely ignored, what can lead to inconvenience for the users of asyncSeq.\r\nThe proposal is to interpret `do! action` as `let! () = action in zero` when the Builder do not provide a Return method.\r\nWith it return keyword would be unavailable to the users of the Builder.\r\nOriginal discussion: https://github.com/fsprojects/FSharp.Control.AsyncSeq/issues/38",
        "Votes": 3,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "This PR has been merged, so this design item is completed, though not yet released in a specific version of F#\r\nThis is approved for F# 4.1+. It’s the right adjustment to the language given the problem discussed in the linked gituhb thread\r\nSee also the proposed implementation here: https://github.com/Microsoft/visualfsharp/pull/773\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "11046804": {
        "Number": "11046804",
        "Submitter": "George",
        "Submitted": "2015-12-10T00:00:00",
        "Title": "respect multi-line triple quoted strings indentation",
        "Text": "It would be useful if the starting position of a multi-line triple quoted string could set the starting position of the content when it is the first non-whitespace character on it's source line. Additionally, when it is followed only by source level whitespace character, then the content is presume to actually start on the next line, indented of course. If non-whitespace characters occur prior to the indent point, then it may be flagged as a syntax error, however, EOL characters would be retained to capture lines.\r\nPerhaps a new symbol could be used other than triple quotes...perhaps quadruple quotes: \"\"\"\"",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-12-15T00:00:00",
            "Text": "This would be a breaking change\r\nA new symbol may be possible.\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "11109258": {
        "Number": "11109258",
        "Submitter": "Tom Rathbone",
        "Submitted": "2015-12-16T00:00:00",
        "Title": "Richer literals: TimeSpan/DateTime/Char array/UTF8",
        "Text": "Combining several suggestions for richer literals\r\n- New literals for TimeSpan and DateTime. e.g.\r\n\"01:02:03\"T --> new TimeSpan(1,2,3)\r\n\"2015-01-02 10:30:00\"D -> new DateTime(2015,01,02,10,30,00)\r\n- Char[] e.g\r\n\"abcd\"C\r\n- UTF8 encoded strings \"abc££def\"U\r\nand indeed perhaps the whole mechanism should be extensible like QZRING literals",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2015-12-20T01:17:00",
                "Content": "F# allow you to define your own behavior for suffixes Q, R, Z, I, N & G - https://sergeytihon.wordpress.com/2014/01/11/f-kung-fu-2-custom-numeric-literals/"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "11125137": {
        "Number": "11125137",
        "Submitter": "Keith Battocchi",
        "Submitted": "2015-12-17T00:00:00",
        "Title": "Expand support for byref to match C# 7",
        "Text": "C# is adding support for byref locals and returns (see https://github.com/dotnet/roslyn/issues/118, slated for milestone 1.3). This will result in many libraries that expose these features (which the CLR already supports), but methods with such return types aren't currently usable from F#. F# already supports byref locals, but doesn't support implementing byref-returning methods nor does it support calling byref-returning methods.\r\nAt a minimum, F# should support calling byref-returning-methods (e.g. SomeRefReturningMethod(x,y,z) <- w), since C# users will be creating methods like these and being unable to call them will limit F#'s reach.\r\nIt would be nice if on top of that base level of support F# also supported declaring such methods, using the same safety rules that C# is using (e.g. the only refs that are safe to return are those that point to values stored on the heap or existing refs that are passed into the method).",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Keith Battocchi",
                "Submitted": "2015-12-17T10:40:00",
                "Content": "Concretely, this code works today:\r\nlet array = [| 1 .. 10 |]\r\nlet r = &array.[0]\r\nr <- -1\r\nBut if you create a method using ildasm that wraps int[]'s Address method (with signature int[] * int -> int&), then this doesn't\r\nlet arr = [| 1 .. 10 |]\r\nlet r = ArrayHelper.GetAddress(arr, 0) // error FS0412: A type instantiation involves a byref type. This is not permitted by the rules of Common IL.\r\nr <- -1"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-02T07:06:00",
                "Content": "Would it be possible to simply return a `byref` type to implement this feature?"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Yes, this should be done, thanks\r\nApproved in primciple subject to a detailed design, resolution of any remaining issues, and an implementation, with testing. Also subject to the feature actually appearing in C# 7 :)\r\nDon Syme, F# Language Evolution"
        }
    },
    "11149770": {
        "Number": "11149770",
        "Submitter": "Anonymous",
        "Submitted": "2015-12-19T00:00:00",
        "Title": "Automatic lazy wrapping of argument",
        "Text": "Add such that arguments are automatically wrapped in the lazy expression, if set as the type.\r\nfor instance:\r\nlet (-->) q (p : Lazy<bool>) = not q || (p.Force())\r\nright now i have to write:\r\nfalse --> lazy (1/0 = 0)\r\nwhy not make lazy automatic so it becomes:\r\nfalse --> 1/0 = 0 : True instead of Divide by Zero exception\r\n(while you are at it add a force operator)",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:17:00",
                "Content": "We considered this for F# 1.0. In the end we decided against it, partly because of code-readability reasons, and partly because \"Lazy\" values are not free in F# - they cost a closure and an allocation.\r\nI don't think we will revisit the decision at this stage."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "11273478": {
        "Number": "11273478",
        "Submitter": "Eric Stokes",
        "Submitted": "2015-12-31T00:00:00",
        "Title": "In a pattern match use the record field name as a default binding if none is provided",
        "Text": "In OCaml we can do,\r\nmatch somrecord with\r\n| {foo; bar; baz} -> foo + bar + baz\r\nIf we don't provide a binding, then the field name is used as the default. In F# we still have to write,\r\nmatch somerecord with\r\n| {foo=foo;bar=bar;baz=baz} -> foo + bar + baz\r\nThis is quite a simple syntactic enhancement, however it's very nice to have. It also pushes us to use the (presumably) well chosen record field names for our variables instead of picking a single letter variable name.\r\nAlso, in OCaml we get a warning if we don't bind all the record fields in a pattern match, unless we include _. e.g. {foo;bar;_}. This would be a nice thing to have as well, because in a pattern match where we DO want to bind all the fields, we are now told when the record type changes that we need to consider the new field. This is very useful for large projects.",
        "Votes": 13,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "11356293": {
        "Number": "11356293",
        "Submitter": "Eric Stokes",
        "Submitted": "2016-01-08T00:00:00",
        "Title": "Allow implementation of abstract slots with generic return type instantiated at type 'unit'",
        "Text": "The behavior described here,\r\nhttp://stackoverflow.com/questions/26296401/why-is-unit-treated-differently-by-the-f-type-system-when-used-as-a-generic-i\r\nis quite surprising to someone coming from other typed FP languages. The fact that a generic type parameter can't be unit makes the whole generics abstraction feel a bit leaky and hacky, which isn't great publicity, as F# actually has a lot of great ideas.\r\nIn practice this comes up when implementing type indexed values of various sorts, as an interface is an ideal and natural way to do that, and of course one often wants to have a sometype<unit> value. The compiler error is rather surprising as well, as it implies the object expression doesn't implement the interface, which of course isn't the case.",
        "Votes": 7,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Approving this in principle, it would be great to fix this behavior.\r\nWe will open an RFC on this in due course, https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThere are reasons for the existing behaviour due to unit v. void, as explained in the various stackoverflow topics on this question, but it should be possible to workaround those.\r\nDon Syme, F# Language Evolution"
        }
    },
    "11356425": {
        "Number": "11356425",
        "Submitter": "Don Syme",
        "Submitted": "2016-01-08T00:00:00",
        "Title": "Optionally relax signatures of -X, sin X, cos X to allow use w.r.t. subtyping",
        "Text": "See https://github.com/Microsoft/visualfsharp/issues/799\r\ntype Base(x : int) =\r\nmember self.X = x\r\nstatic member (~-) (a : Base) = Base(-a.X)\r\nstatic member (+) (a : Base, b : Base) = Base(a.X + b.X)\r\nstatic member Cos(a : Base) = Base(2*a.X)\r\ntype Derived(x : int) =\r\ninherit Base(x)\r\nlet a = Base(1)\r\nlet minusa = -a // OK\r\nlet cosa = cos a // OK\r\nlet twoa = a + a // OK\r\nlet b = Derived(1)\r\nlet minusb = -b // Compile error\r\nlet cosb = cos b // Compile error\r\nlet twob = b + b // OK",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T15:56:00",
                "Content": "This is a reasonable request and we should accommodate this somehow. Unfortunately we will likely only be able to do it by having the user open a new module."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marking as approved-in-principle per my comment below\r\nWe will post an RFC for it in due course.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "11462964": {
        "Number": "11462964",
        "Submitter": "Ryan Riley",
        "Submitted": "2016-01-15T00:00:00",
        "Title": "Introduce array spread operator for pattern matching and [<ParamArray>]",
        "Text": "Several languages have introduced a handy spread operator, ..., that can be used to pick up remaining arguments to a function call or when destructuring values. [1] This would be incredibly helpful in F# to reduce boilerplate in methods accepting a [<ParamArray>] or when trying to pattern match arrays:\r\nmatch [|1;2;3;4|] with\r\n| [||] -> // do stuff with empty array\r\n| [|hd;…tl|] -> // do stuff with hd/tl\r\n[1] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2016-01-15T14:17:00",
                "Content": "Testing hypothesis that broken windows applies equally to comments ... please share comments or alternatives! Craig Stuntz suggested a few things on Twitter which led me to explain further why I think this operator is a somewhat natural fit:\r\nArray slices using a slightly similar operator, ..:\r\n[|1;2;3;4|].[1..] = [|2;3;4|]\r\n[|1;2;3;4|].[..2] = [|1;2;3|]\r\nSuggestion to use [|hd::tl|]:\r\nI _think_ :: is restricted to just lists as it is 1) used in the definition of the 'T list type (iirc) and 2) built into the compiler to expect lists (iirc).\r\nSuggestion to use [|hd;;tl|]:\r\n\"error FS0010: Incomplete structured construct at or before this point in pattern” in FSI"
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2016-01-15T15:33:00",
                "Content": "Instead of hard coding new pattern matches into the language I think it would be better if we could make the implementations of existing active patterns more flexible and require less overhead."
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2016-01-18T11:10:00",
                "Content": "@Rick I'm all for that. How might you amend this proposal to achieve more flexibility?"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-01-23T06:33:00",
                "Content": "As written this would require the allocation of a new array for \"tl\".\r\nIf you want \"tl\" to be a slice into the array, then you're probably better off writing an active pattern for this case."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-23T11:34:00",
                "Content": "This seems fairly corner case since it only works over arrays (and presumably lists too). Given the presence of active patterns in the language I'd like to see a larger set of examples and how they look. For example, would \"tl\" be copy of the tail of the array?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per my comment below. We would not extend pattern matching for this one case, but Rick is right that improvements to active patterns may make sense\r\nDon Syme, F# Language Evolution"
        }
    },
    "11464779": {
        "Number": "11464779",
        "Submitter": "Kevin Rood",
        "Submitted": "2016-01-15T00:00:00",
        "Title": "Introduce a different approach for resolving ambiguity of record types",
        "Text": "See the example here under the \"Conflict Resolution\" heading:\r\nhttp://davefancher.com/2012/11/27/f-record-types/\r\nPrefixing the type on a label seems inconsistent with how types are annotated elsewhere in the language. Perhaps something like this with the type annotation on the end would be more consistent:\r\n\"let myRecord = {} : RecordTypeName\"",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Bill Hally",
                "Submitted": "2016-01-19T06:32:00",
                "Content": "You can already do this as follows:\r\n\"let myRecord : RecordTypeName = {...}\""
            },
            {
                "Submitter": "Kevin Rood",
                "Submitted": "2016-01-23T07:44:00",
                "Content": "Very helpful, thank you. I can't recall seeing that elsewhere."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Yes, as noted in the comments a type annotation can already be used.\r\nDon Syme, F# Language Evolution"
        }
    },
    "11543295": {
        "Number": "11543295",
        "Submitter": "Jared Hester",
        "Submitted": "2016-01-22T00:00:00",
        "Title": "Allow Type Extensions and Extension Methods to Satisfy Constraints",
        "Text": "",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5695277-allow-the-addition-of-operators-in-type-extensions"
        }
    },
    "11543415": {
        "Number": "11543415",
        "Submitter": "knocte",
        "Submitted": "2016-01-22T00:00:00",
        "Title": "Optimize IL for methods to use mutable code for better performance",
        "Text": "It turns out that using immutable algorithm is not always the best thing in regards to performance. An interesting story about this is http://viralfsharp.com/2015/12/27/look-and-say-f/\r\nSo mutable code can actually be better in regards to performance (because it involves less allocations?). So maybe, in the cases in which it can be assured that no race condition can happen (i.e. mutable locals instead of mutable fields, because the former cannot be shared between threads), the F# compiler should try to optimize the IL generated for methods, to mutable-locals-optimized IL.\r\nAn example of how Streams could be optimized: https://github.com/nessos/Streams",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "knocte",
                "Submitted": "2016-01-25T02:57:00",
                "Content": "Thanks for your reply Don, inline:\r\n> What specific design changes are proposed?\r\nMy general wandering here is 'can what Nessos has accomplished, be completely automated at the IL-optimization level?'."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "I’m marking this as declined since the proposal is not concrete enough. What specific design changes are proposed?\r\nThe Streams library is great, but can already be used from F#, as can most other mutable programming techniques.\r\nDon Syme, F# Language Evolution"
        }
    },
    "11544387": {
        "Number": "11544387",
        "Submitter": "Dave Thomas",
        "Submitted": "2016-01-22T00:00:00",
        "Title": "Add filtermap to the standard library",
        "Text": "Add filtermap to the standard library\r\nRust, Elixir and other functional languages have this and it would be nice to have an alternative to the option allocating choose function:\r\nlet filtermap (filter:a->bool) (map: a->b) (xs: a list) -> b list = ...\r\nElixir:http://elixir-lang.org/docs/v1.0/elixir/Enum.html#filter_map/3\r\nRust: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map",
        "Votes": 23,
        "Comments": [
            {
                "Submitter": "NhlCrd",
                "Submitted": "2016-01-25T02:45:00",
                "Content": "Isn't it a one-liner in F#?\r\nlet inline List.filterMap f m l = List.filter f >> List.map m"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-01-25T04:04:00",
                "Content": "You can compose a one liner but that would iterate over elements in the list twice. A standard library function would be optimised."
            },
            {
                "Submitter": "Phil de Joux",
                "Submitted": "2016-01-25T08:11:00",
                "Content": "Elm's got it too ...\r\nhttp://package.elm-lang.org/packages/elm-lang/core/1.0.0/List#filterMap"
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2016-01-25T09:46:00",
                "Content": "Isn't this equivalent to Seq.choose?"
            },
            {
                "Submitter": "NhlCrd",
                "Submitted": "2016-01-26T02:53:00",
                "Content": "@Dave Thomas\r\nRight. Do you know if that would happen with the lazy Seq module as well? In C#/VB, a concatenated LINQ expression like .Where().Select() would be compiled into a single loop, I believe."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T15:53:00",
                "Content": "My problem with this suggestion is that there are many, many other combinations of pairs or triples of functions which could be optimized (fused). Adding just one seems incorrect. Why not filterCollect? filterSum? filterMax? filterMin? filterGroupBy?\r\nI am going to decline this on this basis."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-02-06T17:02:00",
                "Content": "Thats a shame, I have never had need of the other function combination you mentioned but filter-map is something that I use quite often, an alternative would be to optimise Choose so the option allocation goes away."
            },
            {
                "Submitter": "Dzmitry Lahoda",
                "Submitted": "2016-02-09T07:09:00",
                "Content": "Seems BCL LINQ optimizes such case http://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,3df3a8bfcaaa2b6d,references\r\n```\r\nif (predicate == null || predicate(item)) {\r\ncurrent = selector(item);\r\nreturn true;\r\n}\r\n```"
            },
            {
                "Submitter": "Dzmitry Lahoda",
                "Submitted": "2016-02-09T07:27:00",
                "Content": "As I know implementation of LINQ (both IEnumerable and IQueryable) are based on direct casts like next:\r\n```\r\nif (source is Iterator<TSource>) return ((Iterator<TSource>)source).Where(predicate);\r\nif (source is TSource[]) return new WhereArrayIterator<TSource>((TSource[])source, predicate);\r\nif (source is List<TSource>) return new WhereListIterator<TSource>((List<TSource>)source, predicate);\r\n```\r\nE.g. some ORM would have own collection and cast on them.\r\nNot sure, but may be in Scala(Dotty) there is way to achieve such optimizations without coding all casts directly. I.e. compiler somehow identifies concrete types/methods to use and uses more faster methods and reduce casing and intermidiate collections. So that when I implement my collection it can be plugged into collection framework in optimized way without changing collection framework code.\r\nSo if this is case and F# has not such - may be this could be proposal.\r\nhttp://stackoverflow.com/a/1728140/173073"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "11602140": {
        "Number": "11602140",
        "Submitter": "Steffen Forkmann",
        "Submitted": "2016-01-27T00:00:00",
        "Title": "remove Seq.rev from FSharp.Core again",
        "Text": "the collection regularization was a good idea. Unfortunately we introduced Seq.rev which internally converts to array. This working for most real-life sequences, but breaks laziness.\r\nI suggest to mark the function as obsolete and remove it later.\r\nSee also https://github.com/Microsoft/visualfsharp/issues/902",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Andrew Cherry",
                "Submitted": "2016-01-27T06:39:00",
                "Content": "Strongly agree. Having rev breaks an important mental model and is at some point going to be a source of the type of bugs that good type systems are designed to eliminate."
            },
            {
                "Submitter": "Mark Laws",
                "Submitted": "2016-01-27T06:42:00",
                "Content": "The potential implications of strictly evaluating the sequence by converting it to an array are dire--this function is a liability and ought to go."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-01-27T12:03:00",
                "Content": "Strongly agree."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2016-01-27T12:46:00",
                "Content": "There was also the suggestion from Eirik that we change the signature to 'a seq -> 'a array to make the internal transformation more explicit"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-28T06:20:00",
                "Content": "Three somewhat obvious points:\r\n* Several of the F# 2.0 Seq.* functions had the same implicit-loss-of-laziness property, for example Seq.groupBy and Seq.distinct. To be consistent we would also deprecate those. But I don't see us doing that after all this time.\r\n* In general we avoid oscillating between design points: \"which version am I on?\" \"Which functions can I use\"? \"How do I write code that works on all versions\"?\r\n* There are workarounds - e.g. define an obsolete Seq.rev in a common prelude shared by code you want to protect from implicit loss of laziness.\r\nmodule Seq =\r\n[<Obsolete(\"etc\")>]\r\nlet rev xs = ..."
            },
            {
                "Submitter": "NhlCrd",
                "Submitted": "2016-01-31T15:53:00",
                "Content": "+1 to Eirik's idea of making the signature explicit and returning an array.\r\nIt could also be applied to the other eager Seq.* functions that Don mentions. A lot of times you're perfectly OK with losing laziness, but it's best to know when that happens.\r\nAs far as I can't tell it shouldn't even break any existing code, outside of weird reflection corner cases."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2016-01-31T16:02:00",
                "Content": "I think it's a interesting l idea, but it is breaking. And it's hard to make the transition easy with compiler warnings."
            },
            {
                "Submitter": "NhlCrd",
                "Submitted": "2016-02-01T08:39:00",
                "Content": "Since Array implements Seq, what sort of code would be broken by changing the signature?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T10:42:00",
                "Content": "@NhlCrd - in compiled .NET code, the return type is significant in the \"identity\" of a function/method and effectively forms part of the linking data for a function. So changing the return type is a breaking change.\r\nMy inclination is to mark this as declined per my comments below."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marking as declined per my comments below.\r\nThat said, if you encounter situations where having Seq.rev has caused bugs, please contact me or post the details below. I’m still interested to know how often this bites in practice.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "11628951": {
        "Number": "11628951",
        "Submitter": "Jared Hester",
        "Submitted": "2016-01-28T00:00:00",
        "Title": "Allow Attributes to follow the `member` keyword",
        "Text": "instead of just -\r\n[<DebuggerStepThrough>]\r\nmember __.ReturnFrom (value: 'T option) : Async<'T option> = async.Return value\r\nand -\r\n[<DebuggerStepThrough>] member __.ReturnFrom (value: 'T option) : Async<'T option> = async.Return value\r\n^ which causes indentation issues for following definitions without attributes\r\nallow -\r\nmember [<DebuggerStepThrough>] __.Zero () : Async<unit option> = Some () |> async.Return",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T10:36:00",
                "Content": "Thanks for the suggestion\r\nHowever I will decline this: what we have works, and the proposed saving is only one line, and the lines become loooong. In balance I don't see a net benefit."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declines see comment above\r\nDon Syme, F# Language Evolution"
        }
    },
    "11633604": {
        "Number": "11633604",
        "Submitter": "Isaac Abraham",
        "Submitted": "2016-01-29T00:00:00",
        "Title": "Single-use / inline discriminated unions",
        "Text": "I noticed something similar to this in Typescript and it got me thinking - there are occasions when you have a discriminated union that you only want to use as a \"one off\" e.g.\r\ntype WindDirection = N | S | E | W\r\ntype Weather = { WindDirection : WindDirection; IsRaining : bool }\r\nCould this be simplified to something like this: -\r\ntype Weather = { WindDirection : (N | S | E | W); IsRaining : bool }\r\nAlmost like a \"nameless DU\" - similar in a way to active patterns - which might be useful in making code more concise and / or reasoning about.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2016-01-29T15:19:00",
                "Content": "Interesting idea, but it needs to be able to have a type. What would a function signature that returns one of these WindDirections look like?"
            },
            {
                "Submitter": "Maciej J. Bańkowski",
                "Submitted": "2016-02-01T15:01:00",
                "Content": "@Will Smith The background compilation could make up the type on the fly, just like with anonymous types in C#. Unless type with this exact shape already exists the name would be equal to the property name - \"WindDirection\" in this case. Seems like it may be implementable.\r\nThe only question is: is it really worth the effort?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T10:27:00",
                "Content": "The Mercury language has this feature (or had, the last time I used it, a long time ago now). We considered it for F# but decided against.\r\nFor example, the type would need a name in error messages, quickinfo and inferred signatures. Also, union types accept struct, comment and all sorts of other attributes. Finally the type names are used to disambiguate case names (and ambiguity becomes quite likely here)."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined – see my comment above.\r\nIt’s not a bad idea, but I feel the use of type names is too important in the language to justify the feature (which after all only saves a couple of lines in type definitions, which are themselves rare)\r\nDon Syme, F# Language Evolution"
        }
    },
    "11645070": {
        "Number": "11645070",
        "Submitter": "amazingant",
        "Submitted": "2016-01-29T00:00:00",
        "Title": "Exclude mutable fields from GetHashCode in record types",
        "Text": "The current default implementation for GetHashCode on record types includes all fields, including those marked as mutable. While this certainly helps in testing structural equality, this violates the MSDN documentation's recommendations for how to implement the function (seen at https://msdn.microsoft.com/en-us/library/system.object.gethashcode%28v=vs.110%29.aspx under \"Notes to Inheritors\").\r\nWhile this is not typically an issue, as records are normally used as immutable data types, it becomes an issue in cases where the hash codes are relied upon. As an example, if a collection of record values is provided as the ItemsSource for a WPF ListView control (even stored in an ObservableCollection<T>), modifying mutable fields while elements in the list are selected renders those elements impossible to deselect.\r\nThis can currently be worked around by overriding GetHashCode on a record type that needs it, although this means also adding the CustomEquality and CustomComparison attributes, overriding the Equals method, and implementing either IComparable or IStructuralComparable. None of this is terribly difficult, but removes the terseness that I've grown to love when defining record types instead of classes.\r\nOriginally posted on GitHub as an issue, as this behavior breaks a standard WPF control :) https://github.com/Microsoft/visualfsharp/issues/912",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-02-02T04:25:00",
                "Content": "I think implicitly changing the behaviour of GetHashCode etc. simply based on the fact that a field is mutable or not is a little dangerous - I would prefer something explicit e.g. something like marking the field that you want to use for hashcode directly, and / or a compiler warning that says \"you have a record with mutable fields and are using default equality codegen, this is unsafe\""
            },
            {
                "Submitter": "amazingant",
                "Submitted": "2016-02-02T13:54:00",
                "Content": "Since someone somewhere may depend on it behaving contrary to the implementation recommendations, and therefore I can't have nice things that work as advertised... I'd lean towards a compiler warning.\r\nIt would also be nice to get documentation somewhere like the Records page (https://msdn.microsoft.com/en-us/library/dd233184.aspx) documenting the fact that common UI elements (Microsoft-provided ones at that, so no \"some third-party tools may break\" crap) are affected by it. The documentation should really be updated somewhere to indicate this, regardless of what (if any) changes are made to the compiler.\r\nGiven your first suggestion, if one were to explicitly mark fields as being part of the GetHashCode calculation, I'd say it should be possible to apply to multiple fields at once. I'd still suggest a compiler warning though, such that if you added the attribute to a mutable field, you still got some kind of notification that it may cause issues."
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-02-03T10:59:00",
                "Content": "We couldn't accept the change proposed (exclusion) since it would be breaking.\r\nA warning that suggests putting [<NoEquality; NoComparison>] or implement custom comparison might be possible. There is however the question is how to make the warning go away if the default GetHashCode is intended (there are cases where you want mutability during initialization prior to any hashing occuring). If the warning were an off-by-default Level 4 warning it would probably be ok.\r\nI'm going to mark the specific proposal as declined since it would be breaking. However please consider submitting a PR for a level 4 warning along the lines above.\r\nDon Syme, F# Language Evolution"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T15:09:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663332-allow-custom-equality-on-record-types"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per my comment below, though an off-by-default warning PR would be accepted.\r\nDon Syme, F# Language Evolution"
        }
    },
    "11661270": {
        "Number": "11661270",
        "Submitter": "Georg Haaser",
        "Submitted": "2016-01-31T00:00:00",
        "Title": "extend ComputationExpression builders with Map : m<'a> * ('a -> 'b) -> m<'b>",
        "Text": "In many scenarios computation expressions could be executed way more efficiently when having just a little more information.\r\nThe typical use-case for that would be something like\r\nasync {\r\nlet! a = something\r\nreturn 2*a\r\n}\r\nwhich currently gets translated to:\r\nasync.Bind(something, fun a -> async.Return(2*a))\r\nBy monad laws (borrowed from haskell here) this must be equal to:\r\nasync.Map(something, fun a -> 2*a)\r\nIn many scenarios the latter can be implemented with a lot less overhead, so in my opinion it would be profitable to allow users to provide this \"shortcut\".",
        "Votes": 8,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "11699604": {
        "Number": "11699604",
        "Submitter": "Harald Steinlechner",
        "Submitted": "2016-02-03T00:00:00",
        "Title": "Pattern matching on member defintions",
        "Text": "when extending discriminated unions with member implementations we can introduce a fresh name for 'this' (usually this or x). This identifier however is syntactically not a pattern.\r\nIt would be nice (for irrefutable patterns) to match directly on this position, .e.g.:\r\ntype Test2 = Test2 of int * int with\r\nmember (Test(a,b)).Blub() = a + b\r\ninstead of:\r\ntype Test = Test of int * int with\r\nmember x.Blub() = let (Test(a,b)) = x in a + b\r\nThe benefit seems to be minor, but additionally my proposal improves uniformity of the language.\r\nHowever i fear this introduces ambiguities in the parser....",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T10:21:00",
                "Content": "Hi Harald,\r\nThanks for taking the time to write this suggestion.\r\nWe considered this in the F# design, but decided against it since we felt that code became substantially less readable when this formulation was used. I don't think we'll revisit the design decision at this point.\r\nBest\r\nDon Syme, F# Language Evolution"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined – see comment above\r\nDon Syme, F# Language Evolution"
        }
    },
    "11723964": {
        "Number": "11723964",
        "Submitter": "Don Syme",
        "Submitted": "2016-02-04T00:00:00",
        "Title": "Allow types and modules to be mutually referential (not across files, only within a closed scope in a single file)",
        "Text": "Currently types and modules can't be mutually referential - a group of types can be using \"type X = ... and Y = ... \"\r\nI propose we allow a collection of types and modules within a single file to be mutually referential, either by using\r\ntype X = ... and module Y = ...\r\nor by allowing a #mutrec declaration within a module or namespace declaration group that \"turns on\" mutual-reference within that scope (no larger than the file). The latter option is appealing as \"and module\" is not required (no new syntax is required) and the syntax of mutually recursive types becomes more regular\r\nnamespace Foo\r\n#mutrec\r\ntype X = ... refer to Y and Z...\r\ntype Y = .... refer to X and Z...\r\nmodule Z = ... refer to X and Y ...\r\nInference would be as \"one big mutually referential group\", just as \"type Y = ... and Z = ...\" today. Execution of initialization code would be as an initialization graph, just as \"static let\" today.",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-02-07T16:02:00",
                "Content": "What is the motivation behind this idea?\r\nOne of the features of F# that I greatly appreciate is that it prohibits cyclic references. In my experience, it's always possible to design the code so that mutual references aren't necessary. I don't even use the 'and' keyword.\r\nI'd be sad to see this feature eroded."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-08T09:01:00",
                "Content": "The ability to create a closed set of mutually recursive types (including static methods and data) is part of the F# language design: the intent has never been to adopt an extreme position where all mutual recursion is banned.\r\nLike many things in F# (mutable, implementation inheritance, null etc.), mutual reference is relatively de-emphasized and scoped, but not banned. The F# 1.0-4.0 design for mutual recursion is fine for the vast majority of purposes and sets the defaults in the right way. However, it is fair to say that it places an artificial distinction which can be worse than awkward on the occasions that mutual reference is used: it says that a closed set of types (with static methods) can be mutually referential, but modules containing functions may not be included in that. Likewise data-carrying exception declarations may not be included in that. There's no strong reason for those restrictions.\r\nWere a proposal along these lines to be implemented, F# will continue to de-emphasize mutual references by default, and the intent is not to shift the language towards open mutual references across all files in an assembly. The question, as always, is finding the right balance."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2016-03-12T10:08:00",
                "Content": "This is great! Not being able to cross-reference between closely-related (basically, the same) type and module is very annoying, esp. if you are used to define type A for state and module A for APIs that operate on A. Sometimes this can be solved by having \"module A_Helpers ...\" that followed by \"type A\" and \"module A\", but there are cases where this isn't sufficient, and the only way is to use static member in \"type A\" to simulate module functions.\r\nAnother related suggestion: while we are at this, can we fix the issue that [<CompilationRepresentation(ModuleSuffix)>] only works when you have the type with the same name already defined before the module, otherwise there is still a name conflict.\r\nSee: http://stackoverflow.com/questions/24684918/module-and-class-with-same-name\r\n(note: the workaround proposed in the link doesn't work with Record type, and practically Record type with same-named module is much more common then class type)."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-23T00:00:00",
            "Text": "Based on the prototypes and experiments with this feature reported at https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1009-mutually-referential-types-and-modules-single-scope.mds, I’m marking it as “approved in principle”.\r\nThis RFC and its implementation have now been accepted.\r\nDon Syme,\r\nF# Language Evolution"
        }
    },
    "12251217": {
        "Number": "12251217",
        "Submitter": "Anthony Lloyd",
        "Submitted": "2016-02-08T00:00:00",
        "Title": "Add non-empty collection versions (or a generic nonempty type?) to the core library",
        "Text": "A class of empty collection bugs and checking code could be eliminated if there was standard library support for non-empty collections.\r\nIn a similar way to the option type it would make function signatures more explicit.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T10:51:00",
                "Content": "Our approach is that this doesn't need to be in the core library - you can define such a collection yourself. There are a lot of constrained types that could go in the F# core library, adding them to the core library would expand out the library surface area too much."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion! See comment below"
        }
    },
    "12425811": {
        "Number": "12425811",
        "Submitter": "Jared Hester",
        "Submitted": "2016-02-21T00:00:00",
        "Title": "Add Polymorphic Variants (ad-hoc Discriminated Unions)",
        "Text": "Creating strongly typed data constructs with some level of heterogeneity is often accomplished with DUs so lets take the trivial case of wanting\r\nto have lists of floats & ints, ints & strings, and ints & floats & strings\r\nWe'd need the types -\r\ntype IntString =\r\n| Int of int\r\n| String' of string\r\ntype FloatInt =\r\n| Float of int\r\n| Int of int\r\n\r\ntype IntFloatString =\r\n| Float of int\r\n| Int of int\r\n| String' of string\r\nBut in practice using these would require qualified access to make sure you're getting the right case from the right type and as types you\r\nwant to group grow in number there's a combinatory explosion of boilerplate and verbose code necessary to put it to work.\r\nPolymorphic variants cut down the noise and increase the flexibility and expressiveness of your code.\r\nThe declaration of a polymorphic variant in OCaml is not unlike that of the single case DUs that are already commonly found in F# code\r\nInstead of -\r\ntype Int = Int of int;;\r\n> type Int = | Int of int\r\nInt 3;;\r\n> val it : Int = Int 3\r\nOCaml and uses a preceding backtick convention for a simplified syntax-\r\nlet three = `Int 3;;\r\n> val three : [> `Int of int ] = `Int 3\r\nlet four = `Float 4.;;\r\n> val four : [> `Float of float ] = `Float 4.\r\nThe `>` at the beginning of the variant types above marks the types as being open to combination with other variant types.\r\nWhich means a list could be declared as such -\r\nlet ls = [three; four]\r\n> val ls : [> `Int of int | `Float of float]\r\nand the type would be an ad-hoc Discriminated Union where its cases match the polymorphic variants used\r\nthis also applies to function declarations\r\nlet is_positive = function\r\n| `Int x -> x > 0\r\n| `Float x -> x > 0.\r\n;;\r\n> val is_positive : [< `Float of float | `Int of int ] -> bool = <fun>\r\nThe `<` is there because is_positive has no way of dealing with values that have tags other than `Float of float or `Int of int.\r\nThe `<` and `>` markers are indicators of the upper and lower bounds on the tags involved.\r\nIf the same set of tags are both an upper and a lower bound, we end up with an exact polymorphic variant type, which has neither marker\r\nlet exact = List.filter is_positive [three;four];;\r\n> val exact : [ `Float of float | `Int of int ] list = [`Int 3; `Float 4.]\r\n^ summarizing the part of Real World Ocaml on Polymorphic Variants\r\nhttps://realworldocaml.org/v1/en/html/variants.html\r\nfurther reference - http://caml.inria.fr/pub/docs/manual-ocaml-400/manual006.html#toc36",
        "Votes": 36,
        "Comments": [
            {
                "Submitter": "Jack Fox",
                "Submitted": "2016-03-06T11:36:00",
                "Content": "Would there be a single ad-hoc Discriminated Union for all polymorphic variants currently in scope? Then depending on program structure and scope different sets of polymorphic variants would be available.\r\nI think I like this idea..."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12428673": {
        "Number": "12428673",
        "Submitter": "Jan Dryk",
        "Submitted": "2016-02-21T00:00:00",
        "Title": "Linker!",
        "Text": "Heres a controversial idea. It would really help in big projects if the order of files didnt matter, like in most other languages. Not only its way more convenient not having to care, it would also allow for folders in solution explorer which solves the problem of having a 200 .fs files in one folder which could occur in large applications.",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-24T00:00:00",
            "Text": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an"
        }
    },
    "12469410": {
        "Number": "12469410",
        "Submitter": "kusokuzeshiki kusokuzeshiki",
        "Submitted": "2016-02-24T00:00:00",
        "Title": "add DAG like source reference control feature",
        "Text": "F# has source reference limitation feature by source order, but it should be enhanced.\r\nI think source references should be like DAG.\r\nNow upper source code can be referenced by any lower source code, but I wanna control some group can and some not.\r\nThis may be enough if module has access control feature like C++'s friend against module.\r\nThis feature increase limitations but eliminates complex source relationship and make easier to grab source structure if it's used properly.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "kusokuzeshiki kusokuzeshiki",
                "Submitted": "2016-02-25T08:45:00",
                "Content": "It's completely different thing.\r\nThe link one deduce limitation.\r\nThis increse limitation.\r\nStill you think both are same idea?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-25T00:00:00",
            "Text": "Pretty much covered by [/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an](/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an.md)"
        }
    },
    "12488550": {
        "Number": "12488550",
        "Submitter": "mikero",
        "Submitted": "2016-02-26T00:00:00",
        "Title": "Map keys <--> set compatibility",
        "Text": "A map's key collection is a set and should be treatable as such. Currently (AFAIK) you must get the keys from the map like so:\r\nlet keys = Map.toSeq >> Seq.map fst\r\nthen create a set from the (k,v) seq:\r\nlet set1 = keys map1 |> Set.ofSeq\r\nand then perform your set operation:\r\nlet common = Set.intersect set1 set2\r\nThis involves creating a temporary collection and a new set.\r\nThere are several ways to improve things:\r\n(1) Provide a Map.toKeySet & Set.ofMapKeys functions that will directly and efficiently create a new set from the Map's keys. This is straightforward and should be done, but will create a new set, which may not always be warranted.\r\n(2) Provide a functions that treat the Map's key as a set, exposing some/all of the set operations - at least intersect/difference.\r\nFor example: Map.keySetIntersect & Map.keysetDifference, or using a nested name Map.keySet.intersect, etc.\r\n(3) Provide set-like functions that work on Maps and produce new Maps. Map.difference and Map.intersect. (Note map intersect would be Map<k,v> -> Map<k,v> -> Map<k,v*v> )\r\nEach of these has it's own use case.",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12510276": {
        "Number": "12510276",
        "Submitter": "Steven Taylor",
        "Submitted": "2016-02-28T00:00:00",
        "Title": "#r #load via fsi method",
        "Text": "fsi.Load(\"script.fsx\")\r\nfsi.Reference(\"bin/debug/someDllReference.dll\")\r\nIt would be very useful to be able to fsi.Load / fsi.Reference through type providers, for use by those who are designing them.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-29T12:58:00",
                "Content": "While tempting, the problem is that type checking of a script would not detect these and so the static type checking of the script would not be possible."
            },
            {
                "Submitter": "Steven Taylor",
                "Submitted": "2016-03-13T19:00:00",
                "Content": "Is there a way to also dynamically insert into the static type checker?\r\nIn the spirit of exploratory programming, there are a range of useful cross .dll / tool chain workflows that this would enable. This would make it a more fluid experience. It would be quite useful for those who are new to whatever modelling domain it is. I've observed that the extra referencing exercise can be jarring to some programmers. Can provide additional use cases if of interest.\r\ncheers."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12512739": {
        "Number": "12512739",
        "Submitter": "Steven Taylor",
        "Submitted": "2016-02-29T00:00:00",
        "Title": "Improve Discriminated Union Type Inference",
        "Text": "Sometimes the most logical name for an element of a Discriminated Union (DU), is a common concept such as a list\r\n-- something that you've used before elsewhere.\r\nThe only way around the last resolved resolution is either through namespaces, or by adopting a naming convention.\r\nSometimes getting nagged about name overuse can lead to clearer code, but what if our intention is exactly as\r\nwritten? In the below, if we named elements to be ListOfA and ListOfB, then the problem goes away.\r\nSounds and often is simple, but it can lead to additional code noise and moves us away ever so slightly\r\nfrom the problem domain.\r\ntype A =\r\n| Element\r\n| List of A list\r\ntype B =\r\n| ElementB\r\n| List of B list\r\nlet u : B = List([]) // okay : takes last defined\r\nlet v : A = List([]) // fails : last defined is B\r\nlet w = List([]) : A // fails : ignores hint\r\nlet x = A.List([]) // okay : fully qualified\r\nlet y = List([ElementA]) // fails : expects ElementA\r\nnote: this request is similar to this accepted request [/ideas/suggestion-7138324-record-based-improve-type-inference-bug?tracking_code=3364d3565b19a0c518474dccbc2a1ec0](/ideas/suggestion-7138324-record-based-improve-type-inference-bug?tracking_code=3364d3565b19a0c518474dccbc2a1ec0.md)",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12515598": {
        "Number": "12515598",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-02-29T00:00:00",
        "Title": "Improve cloning record syntax",
        "Text": "It would be great and comfortable to write: { Record with field1 = x and field2 = y and field3 = z } instead of {{{ Record with field1 = x } with field2 = y } with field3 = z }.\r\nI suggest to make it possible the alternative syntax { ... with ... and ... and ... and so on } for cloning records with multiple fields updated at once, and mark the current syntax {{{{ ... with ... } with ... } with ...} with ... so on } as obsolete in the language specification, but permissible for backward compatibility with the existing codebase.\r\nI think F# syntax rules shouldn't push developers to use curly brakets (those relics of C# in the language with the indentation-based and depth-colorized syntax) in their code excessively.\r\nSyntax \"with ... and ...\" here is mirroring the existing syntax for class properties: \"...with get() = ... and set x = ... .",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-29T12:55:00",
                "Content": "Use { Record with field1 = x; field2 = y }"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-29T00:00:00",
            "Text": "See reply above – use a semicolon"
        }
    },
    "12529242": {
        "Number": "12529242",
        "Submitter": "Zhen",
        "Submitted": "2016-03-01T00:00:00",
        "Title": "warnon:1182 seems like a good idea, why is it off by default ?",
        "Text": "",
        "Votes": 3,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12533019": {
        "Number": "12533019",
        "Submitter": "Jeff Heon",
        "Submitted": "2016-03-01T00:00:00",
        "Title": "Allow function names to end with a question mark.",
        "Text": "I find it really elegant in some language where predicate functions can end with a question mark.\r\nConsider `odd? 5` vs `isOdd 5` or `areRelated a b` vs `related? a b`\r\nThere might be some reason why it's a terrible idea grammar-wise or something in F#. I'm still very much a newbie I'm afraid. I apologize if it's featured in a FAQ I missed or even here and I search badly.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-03-06T11:53:00",
                "Content": "You can get this to work with backtick declarations which let you put lots of stuff e.g. spaces in the declaration e.g.\r\nlet ``odd?`` a = a % 2 <> 0\r\nIntellisense in e.g. Visual Studio doesn't work for them though, unfortunately."
            },
            {
                "Submitter": "Jeff Heon",
                "Submitted": "2016-03-06T15:53:00",
                "Content": "That's great to know Isaac. Thank you very much for taking the time to educate me 8)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12536532": {
        "Number": "12536532",
        "Submitter": "Brad Collins",
        "Submitted": "2016-03-01T00:00:00",
        "Title": "Add a shorthand/literal syntax for creating Maps",
        "Text": "A shorthand/literal syntax or computation expression for building Maps would be nice—something like the following:\r\nlet m = map [\"a\",97; \"b\",98; \"c\",99]\r\nThe shorthand for dictionaries ...\r\nlet d = dict [\"a\",97; \"b\",98; \"c\",99]\r\n... is nice, but while Maps implement IDictionary, dictionaries do not play well with Map module functions. One must inevitably convert a dictionary to a Map or create a Map with Map.ofArray, .ofList, or .ofSeq.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "amazingant",
                "Submitted": "2016-03-07T06:15:00",
                "Content": "You can add this yourself fairly easily by adding the following anywhere in your code:\r\nlet map = Map.ofList\r\nand then your first code sample works"
            },
            {
                "Submitter": "Brad Collins",
                "Submitted": "2016-03-07T09:08:00",
                "Content": "@amazingant, no argument that it's an easy fix, but its seems like an obvious oversight (and perhaps even that's too strong a word) when we have shorthand for every other built-in F# container: lists, sequences, arrays, and sets. As someone who came to the language just a little over a year ago, I found it incongruous for map shorthand to be missing."
            },
            {
                "Submitter": "AK",
                "Submitted": "2016-03-10T15:41:00",
                "Content": "You can already do this\r\ni.e Map [(\"Key\", \"Value); (\"Key2\", \"Value2\")] works fine in my code. Notice the capital M on Map"
            },
            {
                "Submitter": "Brad Collins",
                "Submitted": "2016-03-10T17:31:00",
                "Content": "@ak, ah, I see! I am embarrassed that I had not explored that option. But I see now that it's merely a call to the Map constructor.\r\nI will quibble that the style is inconsistent. That is, it's set [ ... ] for sets, dict [ ... ] for dictionaries, seq [ ... ] for sequences, but it's Map [ ... ] for maps. That inconsistency is not satisfying.\r\nNevertheless, I concede the point that a shorthand clearly already exists. I just overlooked it."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12546456": {
        "Number": "12546456",
        "Submitter": "George",
        "Submitted": "2016-03-01T00:00:00",
        "Title": "Allow more flexible layout for constraint syntax",
        "Text": "The following layout of constraints for a sample class should be possible.\r\nGroupedFixtures<'A, 'B\r\nwhen\r\n'A :> Remote.RemoteWebDriver and\r\n'A : (new: unit -> 'A) and\r\n'B :> ServerFixture\r\n>() as this =\r\nPresently it almost was but the `new()` constraint use of parenthesis caused problems. currently all the constraints layout forces them on the same line which is not as clear or convenient (note the text, that `>() as this`, is allowed on a separate line):\r\nGroupedFixtures<'A, 'B when 'A :> Remote.RemoteWebDriver and 'A : (new: unit -> 'A) and 'B :> ServerFixture\r\n>() as this =",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12546540": {
        "Number": "12546540",
        "Submitter": "George",
        "Submitted": "2016-03-01T00:00:00",
        "Title": "Allow flexible types in default constructor constraint",
        "Text": "This would permit,\r\nlet ctor<'a when 'a:(new: unit -> #IWebDriver)> : unit -> IWebDriver = ...\r\nversus\r\nlet ctor<'a when 'a:(new: unit- > 'a) and 'a :> IWebDriver> = fun () -> new 'a() :> IWebDriver",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12555765": {
        "Number": "12555765",
        "Submitter": "Jared Hester",
        "Submitted": "2016-03-02T00:00:00",
        "Title": "Inline Record Definition in Discriminated Unions",
        "Text": "type shape =\r\n(**)| Circle of\r\n(*....*) { centerX : float\r\n(*......*) centerY : float\r\n(*......*) radius : float\r\n(*....*) }\r\n| Rect of\r\n(*....*) { x_lo : float\r\n(*......*) y_lo : float\r\n(*......*) x_hi : float\r\n(*......*) y_hi : float\r\n(*....*) }\r\nRecently Added to OCaml\r\nhttps://blogs.janestreet.com/ocaml-4-03-everything-else/",
        "Votes": 30,
        "Comments": [
            {
                "Submitter": "Huw Simpson",
                "Submitted": "2016-03-04T07:29:00",
                "Content": "This feature already exists in the form:\r\ntype Shame =\r\n| Circle of centerX: float * centerY:float * radius:float\r\n| ...\r\nIt supports pattern matching by the order of the field as well as the name."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-06T04:27:00",
                "Content": "I believe that discriminated unions containing inline records in their declarations is a great idea. It would improve the F# expressiveness. It is good that the F# language supports tuples with named items as Huw Simpson mentioned, but inline records in declarations of discriminated union types would be a new way of expressing programmers' ideas in code. F# should remain competitive and be better than OCaml, I think."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-07T14:23:00",
                "Content": "I think inline records can be named as \"record expressions\" or \"records of an anonymous type\" for the sake of terminology consistency in F#. There are object expressions in F# that are useful when there is no need to define a class. I think a situation when a language user needs to use a record expression of a compiler-generated anonymous record type instead of a user-defined record type is quite possible in practice and it will be good if the language has a solution able to meet competition with other programming languages."
            },
            {
                "Submitter": "Bikal Gurung",
                "Submitted": "2016-05-19T05:34:00",
                "Content": "This feature is currently deprecated in F# 3.0 and above. It was available I believe until F# 2.0. Maybe we can change the title to 'Undeprecate inline record in DU'. I have also created a ticket/issue in github visual f# repo. https://github.com/Microsoft/visualfsharp/issues/1196#issuecomment-220172524"
            },
            {
                "Submitter": "Demetrios Obenour",
                "Submitted": "2016-07-07T21:03:00",
                "Content": "For me, the big advantage is that it would allow mutable inline records. This can be huge for performance."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12560184": {
        "Number": "12560184",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-02T00:00:00",
        "Title": "Use the in keyword and \"|\" symbol for membership tests and better readability (from Ada 2012)",
        "Text": "I suggest using the in keyword for membership tests (from Ada 2012).\r\nExample # 1:\r\nif x in 1 .. 100 then ... // the in keyword would be especially useful within the if expressions. That form of the if expression has better readability than: if x >= 1 && x <= 100 then...\r\nExample # 2:\r\nmatch counter with n when n in 1 .. 10 .. 101 -> ... // the when expression here has a succinct form and better readability than the current syntax: match counter with n when [ 1 .. 10 .. 101 ] |> List.exists (fun x -> x = n) -> ...\r\nExample # 3:\r\nlet x = 21\r\nlet testX = x in 1 .. 5 .. 21 // testX = true because 1 .. 5 .. 21 is the sequence of integers: 1; 6; 11; 16; 21.\r\nInterdependent suggestion (from Ada 2012):\r\nI suggest using \"I\" symbol along with the in keyword for membership tests, for example:\r\ntype Animals =\r\n| Dog\r\n| Cat\r\n| Mouse\r\n| Chinchilla\r\nlet mutable pet = Chinchilla\r\nif pet in Dog | Cat then ... // if pet = Dog || pet = Cat then ...\r\nThe same role for \"I\" has already assigned within the match expressions in F#:\r\nmatch pet with\r\n| Dog | Cat -> ...\r\nMoreover, the \"I\" symbol can be used in F#:\r\na) for specifying ranges, generating lists, sequences, arrays etc., for example: let lst = [ 1 .. 2 .. 100 | 200 | 1000 .. 3 .. 5000 ];\r\nb) for membership tests (if n in 1 .. 2 .. 100 | 200 | 1000 .. 3 .. 5000 then ...);\r\nc) and within the for loops (for i in 1 .. 2 .. 100 | 200 | 1000 .. 5000 do ... // i is changed from 1 to 99, then becomes equal to 200, then is changed from 1000 to 5000). It's a succinct and easy-to-read notation.\r\nI think it's a good idea to take this notation from Ada 2012 to bolster competitive strengths and popularity of the F# language.\r\nP.S. Ada 2012 is a statically typed, imperative, object-oriented programming language offering extremely strong typing, explicit concurrency, tasks (named and anonymous task types), synchronous message passing between task entries, protected (armored) objects for mutual exclusion. It designed for code readability, safety and maintainability of large, long-lived, mission-critical, safety-critical and security-critical applications. Ada 2012 is the latest version of the Ada language.",
        "Votes": 6,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12563118": {
        "Number": "12563118",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-02T00:00:00",
        "Title": "Allow enumeration type names and discriminated union type names in a for loop (from Ada 2012)",
        "Text": "I suggest using enumeration type names and discriminated union type names in a for loop meaning to try every value (from Ada 2012).\r\nFor example,\r\na) Enumeration type name in a for loop:\r\ntype Animals =\r\n| Tiger = 1\r\n| Cat = 2\r\n| Lion = 3\r\nfor animal in Animals do printf \"%A\" animal\r\nAs of today, the F# compiler posts a message: error FS0039: The value or constructor 'Animals' is not defined.\r\nb) Discriminated union type name in a for loop (Ada 2012 does not have discriminated union types, but it has record types with a discriminant (parameter) that resemble discriminated union behavior, but they have completely different syntax):\r\ntype Animals = Tiger | Cat | Lion\r\nfor animal in Animals do printf \"%A\" animal\r\nAs of today, the F# compiler posts a message: error FS0693: The type '(unit -> Animals)' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq<_>, IEnumerable<_> or IEnumerable and does not have a GetEnumerator method\r\nc) For loop can be applied to generate a list, sequence etc., for example:\r\ntype Animals = Tiger | Cat | Lion\r\nlet animalSequence =\r\nseq { for animal in Animals -> animal } // seq { Tiger; Cat; Lion }\r\nI think it's a good idea to allow enumeration type names and discriminated union type names in for loops and treat enumeration types and discriminated union types by the F# compiler as types compatible with IEnumerable and having a GetEnumerator method (even if they don't). It will make the F# syntax more expressive and bolster F# competitive strengths.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Jack Fox",
                "Submitted": "2016-03-06T11:13:00",
                "Content": "I see merit in this, but I'm withholding my vote as I would rather see this implemented as the having the standard collection functions (fold, map, etc.) over enumerations and discriminated unions. Then this all becomes composable. For loops are not so composable."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-03-06T21:33:00",
                "Content": "What is expected error message if any of the DU member has data defined for it?"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-10T09:29:00",
                "Content": "Gauthier Segay, I think the situation where a discriminated union case has data associated with it should not stand in the way of the introduction of the syntax allowing the usage of discriminated union type names in a for loop. I think there is no need to raise an exception here. The discriminated union is a foundational type in functional programming. So, I suggest default initializing all data fields associated with the appropriate discriminated union case. There is function Unchecked.defaultof<'T> to generate a default value for any type in F#. The compiler can use it to generate compiled code.\r\nIf a language user wants to change any default initialized data field associated with a particular union case, this can be done by writing the code snippet like this:\r\ntype Animals = Tiger of age : int * name : string | Cat | Lion\r\n[ for animal in Animals ->\r\nmatch animal with\r\n| Tiger(age, name) -> Tiger(2, Kitty) // change the initial\r\n// default value\r\n| predator -> predator ]\r\n|> List.iter (printfn \"%A\")\r\nAs to a comment by Jack Fox: I believe that the syntax suggested can be implemented in the compiler even without standard collection functions (fold, map, etc.) over enumerations and discriminated unions.\r\nThe compiler can obtain information on all union cases defined by a language user for a particular discriminated union type from code (The similar applies to enumeration types). So, the F# compiler can convert the expression \"for animal in Animals\" to \"for animal in seq { yield Tiger(Unchecked.defaultof<int>, Unchecked.defaultof<string>); yield Cat; yield Lion }\" behind the scenes in order to reach the goal of the syntax suggested."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12564057": {
        "Number": "12564057",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-02T00:00:00",
        "Title": "Allow basic integer numeric type names in a for loop (from Ada 2012)",
        "Text": "I suggest using basic integer numeric type names (namely, sbyte, byte, int16, uint16, int (int32), uint32, int64, uint64) in a for loop meaning to try every value of the type (from Ada 2012).\r\nFor example,\r\nlet ourSequence = seq { for i in int -> i } // ourSequence : seq<int>\r\nlet ourList = [ for i in byte -> i ] // ourList : byte list\r\nfor i in sbyte do printf \"%A\" i\r\nI think it's a good idea to allow basic integer numeric type names in for loops just as in Ada 2012 and treat such types by the F# compiler as types compatible with IEnumerable and having a GetEnumerator method (even if they don't). It will make the F# syntax more expressive and bolster F# competitive strengths in writing clear and concise code.",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12564486": {
        "Number": "12564486",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-02T00:00:00",
        "Title": "Types with predicates to create subtypes easily (from Ada 2012)",
        "Text": "I suggest introducing type predicates as an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of creating subtypes easily.\r\nSuppose, we are concerned with animal species and that we have a\r\ntype Animals thus:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\nNow suppose we wish to declare subtypes for predators and prey.\r\nSo we would like to declare a type Predators embracing Tiger, Cat and Lion, and a type Prey embracing Mouse and Hamster.\r\nI suggest two ways to do this:\r\n1) We can do this with an anonymous function performing pattern matching (subtype predicate in Ada 2012) by writing:\r\ntype Prey = Animals with function\r\n| Mouse\r\n| Hamster -> true\r\n| _ -> false\r\ntype Predators = Animals with function Tiger | Cat | Lion -> true\r\n| _ -> false\r\nand then we are assured that objects of type Predators can only be Tiger, Cat or Lion, and objects of type Prey can only be Mouse or Hamster.\r\nAnother example:\r\ntype Even = int with function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nThe aspect should be checked (checks for admissible values should be generated in compiled code by the F# compiler and performed) whenever an object of the type is default initialized, on assignments, on type casts, on parameter passing, in the match expressions and so on.\r\n2) If we want to use a named function performing pattern matching, then we have to write:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\nlet isPredator(animal: Animals): bool =\r\nmatch animal with\r\n| Tiger | Cat | Lion -> true\r\n| _ -> false\r\ntype Predator = Animals with isPredator;\r\nAnd last but not least, types with predicates should be allowed in a for loop meaning to try every value. So F# programmers should be able to write:\r\nfor animal in Predators do ...\r\nfor digit in Even do ...\r\nPlease see my previous suggestions for more details:\r\na) Allow enumeration type names and discriminated union type names in a for loop (from Ada 2012): [/ideas/suggestion-12563118-allow-enumeration-type-names-and-discriminated-uni;](/ideas/suggestion-12563118-allow-enumeration-type-names-and-discriminated-uni;.md)\r\nb) Allow basic integer numeric type names in a for loop (from Ada 2012): [/ideas/suggestion-12564057-allow-basic-integer-numeric-type-names-in-a-for-lo](/ideas/suggestion-12564057-allow-basic-integer-numeric-type-names-in-a-for-lo.md)\r\nThe suggested syntax allows writing clear, concise and easy-to-understand code. It will not affect existing codebase.\r\nI think it will help bolster F# competitive strengths and improve its position in the TIOBE language popularity index.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "NhlCrd",
                "Submitted": "2016-03-14T16:56:00",
                "Content": "It is not obvious to me what advantages this feature would provide over active patterns and partial active patterns.\r\nSyntactically speaking, (P)APs are also more concise:\r\nlet (|Predator|Prey|) = function\r\n|Tiger|Lion -> Predator\r\n|Mouse -> Prey"
            },
            {
                "Submitter": "OneWingedShark",
                "Submitted": "2016-03-14T23:25:00",
                "Content": "Per haps a better demonstration would be user-input or data-validation; here's a couple simple examples using Ada 2012's type-system to ensure formatting/data consistsancy:\r\nhttps://m.reddit.com/r/programming/comments/2770qx/computer_science_and_math/chz389x\r\nhttps://m.reddit.com/r/programming/comments/238v7g/three_flaws_in_software_design_part_1_writing/cgv37g7"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12797964": {
        "Number": "12797964",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Use the \"not in\" keyword combination for membership tests (from Ada 2012)",
        "Text": "I suggest using the \"not in\" keyword combination for membership tests (from Ada 2012).\r\nExample # 1:\r\nif x not in 1 .. 100 then ... // this form of the if expression has better readability than: if x < 1 || x > 100 then..., and you have no need to use the \"x\" value name twice.\r\nExample # 2:\r\nmatch counter with n when n not in 1 .. 10 .. 101 -> ... // the when expression here has a succinct form and better readability than the current syntax: match counter with n when [ 1 .. 10 .. 101 ] |> List.forall (fun x -> x <> n) -> ...\r\nExample # 3:\r\nlet x = 0\r\nlet testX = x not in 1 .. 5 .. 21 // testX = true because 1 .. 5 .. 21 is the sequence of integers: 1; 6; 11; 16; 21.\r\nI think it's a good, easy-to-implement idea to take this notation from Ada 2012 to bolster competitive strengths of the F# language in the context of writing succinct, easy-to-read and easy-to-understand code.\r\nP.S. This suggestion is an extension of my previous suggestion:\r\nUse the in keyword and \"|\" symbol for membership tests and better readability (from Ada 2012).\r\nPlease see it for more details. These suggestions are interdependent: [/ideas/suggestion-12560184-use-the-in-keyword-and-symbol-for-membership-t](/ideas/suggestion-12560184-use-the-in-keyword-and-symbol-for-membership-t.md)",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-03-04T06:55:00",
                "Content": "Even if the other suggestion were accepted we would use \"not (x in 1 .. 21)\" in F#."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-07T14:08:00",
                "Content": "Don, syntax \"not (x in 1 .. 21)\" is even better than in Ada. I think syntax like \"(x in 1 .. 21 | 100 | 200 .. 300)\" and \"not (x in 1 .. 21)\" will be a good contribution to the expressiveness of F#. I am very much looking forward to a change in the status of my other suggestion (Use the in keyword and \"|\" symbol for membership tests and better readability, from Ada 2012) to UNDER REVIEW or PLANNED. Thank you very much for your attention to my suggestions aimed at making F# better."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-03-04T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment. Adding new syntax for “not” is not a good fit for the F# language design\r\nDon Syme, F# Language Evolution"
        }
    },
    "12798519": {
        "Number": "12798519",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Compiler-enforced defensive coding: Parentheses to surround the if or match expression within another expression (from Ada 2012)",
        "Text": "I suggest using the if or match expression immediately surrounded by parentheses (on both sides) so long as it is used as part of another expression:\r\nlet a = b + (if x then y else z) + c // parentheses required\r\nlet a = b + (match x with y -> y | _ -> z) + c // parentheses required\r\nI think the F# compiler should emit a warning (not an error, so it is not a breaking change in the F# language) so long as the if or match expression is not immediately surrounded by parentheses within another expression.\r\nRemark: It's an error preventing code from compiling in Ada 2012, but that language is used for writing hard real-time software that can cause severe loss if its code contains a bug, namely threatening human lives or damaging the surroundings physically, so the Ada compiler is oriented to prevent potential logical errors in code at any cost).\r\nThe if or match expression needs not be surrounded by parentheses so long as it is used alone (just as the current F# syntax allows):\r\nlet a = if x then y else z // parentheses are not required\r\nI think it's a good idea of defensive coding. It can be implemented easily in the F# compiler and allows preventing potential logical errors in F# code and improving code readability.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-03-04T06:53:00",
                "Content": "Like most other style checks like this, we'd prefer this goes into FSharpLint"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-03-04T00:00:00",
            "Text": "Per comment, please add this to FSharpLint.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "12800967": {
        "Number": "12800967",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Types with default initial values specified (from Ada 2012)",
        "Text": "I suggest introducing an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of specifying their default initial values in code easily.\r\nThis suggestion is an extension of my previous suggestion:\r\nTypes with predicates to create subtypes easily (from Ada 2012)\r\nPlease see it for more details:\r\n[/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f](/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f.md)\r\nExample # 1:\r\ntype OK = bool [with] default true // type with true as its default initial value\r\nExample # 2:\r\ntype Animals =\r\n| Tiger\r\n| Lion\r\n| Cat\r\n| Mouse\r\n| Hamster\r\n[with] default Cat\r\ntype Prey = Animals\r\nwith function\r\n| Mouse\r\n| Hamster -> true\r\n| _ -> false\r\n[and] default Hamster\r\nlet a : Prey array = Array.zeroCreate 3 // array of 3 hamsters\r\nRemark: \"[and]\" or \"[with]\" means that the \"and\", \"with\" keywords are optional in the above-mentioned lines of code.\r\nIt's not a breaking change in the language; no new keywords are needed to implement this syntax in the F# language. I think this syntax will help represent a programmer's intent in code and improve the expressiveness of the F# language.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Jack Fox",
                "Submitted": "2016-03-06T11:41:00",
                "Content": "I suggest making the \"and\" and \"with\" keywords mandatory...I think it improves readability."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2016-04-13T09:56:00",
                "Content": "This would be great, especially if the F# library would come with a function similar to `genericOne` and we can use this as a static type constraint.\r\nThat way you could write a generic function that works on any type that defines a default value."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12802701": {
        "Number": "12802701",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Code robustness: Types with ranges of admissible values (from Ada 2012)",
        "Text": "I suggest introducing an aspect that can be applied to declarations of enumeration types, discriminated union types and user-defined numeric types with the aim of specifying the range of admissible values for subtypes derived from base types easily.\r\nThis suggestion is an extension of my previous suggestions:\r\n1) Types with predicates to create subtypes easily (from Ada 2012);\r\n2) Types with default initial values specified (from Ada 2012).\r\nPlease see them for more details:\r\n1) [/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f](/ideas/suggestion-12564486-types-with-predicates-to-create-subtypes-easily-f.md)\r\n2) [/ideas/suggestion-12800967-types-with-default-initial-values-specified-from](/ideas/suggestion-12800967-types-with-default-initial-values-specified-from.md)\r\nExample # 1. Type with range of admissible values specified.\r\ntype scores = int range 1 .. 100 // admissible values: 1, 2, 3 .. 100\r\nThe aspect should be checked (checks for admissible values should be generated in compiled code by the F# compiler and performed) whenever an object of the type is default initialized, on assignments, on type casts, on parameter passing, in the match expressions and so on.\r\nExample # 2: Type with range of admissible values and default initial value.\r\ntype rating =\r\n| A\r\n| B\r\n| C\r\n| D\r\n| E\r\n| F\r\ntype goodRating = rating range A .. C default A\r\nExample # 3: Type with range of admissible values, default initial value and subtype predicate.\r\n// admissible values of the type: 0, 2, 4, 6, 8 .. 100\r\nSyntax version # 1:\r\ntype Even = int range 0 .. 100 default 0 with function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nor\r\nSyntax version # 2 (both versions may be acceptable):\r\ntype Even = int range 0 .. 100 with default 0 and function\r\n| n when n % 2 = 0 -> true\r\n| _ -> false\r\nThis feature would be exceptionally useful when paired with units of measure.\r\nExample # 4: Type with unit of measure, range of admissible values, and default initial value.\r\n[<Measure>]\r\ntype celsius\r\nSyntax version # 1:\r\ntype temperature = float<celsius> range -80.0<_> .. 60.0<_> default 0.0<_>\r\nor\r\nSyntax version # 2 (both versions may be acceptable):\r\ntype temperature = float<celsius> range -80.0<celsius> .. 60.0<celsius> default 0.0<celsius>\r\nThis change in the F# language syntax will not affect existing codebase. It requires introducing a new keyword: range. I think this syntax will help represent a programmer's intents in code and improve code robustness and expressiveness of the F# language.",
        "Votes": 5,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12803943": {
        "Number": "12803943",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Code robustness: Range of admissible values for class fields and record fields (from Ada 2012)",
        "Text": "I suggest introducing an aspect that can be applied to declarations of classes and record types with the aim of specifying ranges of admissible values for class fields and record fields easily.\r\nThis suggestion is an extension of my previous suggestion:\r\nCode robustness: Types with ranges of admissible values (from Ada 2012)\r\nPlease see: [/ideas/suggestion-12802701-code-robustness-types-with-ranges-of-admissible-v](/ideas/suggestion-12802701-code-robustness-types-with-ranges-of-admissible-v.md)\r\nExample # 1: Record type with ranges of admissible values specified for its fields.\r\ntype Location = {\r\nmutable Y: float range –1.0 .. 1.0 = 1.0\r\nmutable X: float range -1.0 .. 1.0 = 0.0 // field X is default initialized to 0.0, its admissible values are in a range from -1.0 to 1.0\r\n}\r\nExample # 2: Class with ranges of admissible values specified for its private fields, and access methods to get and set its fields\r\ntype Location() =\r\nlet mutable x : int range -1.0 .. 1.0 = 1.0\r\nlet mutable y: int range –1.0 .. 1.0 = 0.0\r\nmember this.X with get() = x and set value = x <- value\r\nmember this.Y with get() = y and set value = y <- value\r\nThe aspect should be checked (checks for admissible values should be generated in compiled code by the F# compiler and performed) whenever an object of the type is default initialized, on assignments, on type casts, on parameter passing, in the match expressions and so on.\r\nThis change in the F# language syntax will not affect existing codebase. It requires introducing a new keyword: range. I think it's worth it. This syntax will help represent a programmer's intents in code, improve code robustness, clarity and expressiveness of the F# language.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": null
    },
    "12804867": {
        "Number": "12804867",
        "Submitter": "Huw Simpson",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Allow generic type constraints for union and record",
        "Text": "I suggest that the ability to express the following type constraints be added:\r\nwhen 'T : union\r\nwhen 'T : record\r\nThis would enable apis which use quotations or reflection over the supplied record or union to be safer.\r\nThe constraint could be enforced at runtime if unions or records implemented some sort of marker interface, perhaps there is a better way.",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12805656": {
        "Number": "12805656",
        "Submitter": "Anonymous",
        "Submitted": "2016-03-04T00:00:00",
        "Title": "Code succinctness: Relax syntax rules for the else branch of an if expression (from Ada 2012)",
        "Text": "For the sake of code succinctness, I suggest relaxing syntax rules for the else branch of an if expression in two special cases:\r\n1) When there is no else branch in an if expression and the type of the if expression is inferred to be bool, then the F# compiler should treat the absent else branch as equal to false, type bool (like in Ada 2012 for if expressions).\r\n2) When there is no else branch in an if expression and the type of the if expression is inferred to be option, then the compiler should treat the absent else branch as equal to None, type option.\r\nNow, when there is no else branch written in an if expression, the type of the absent else branch is inferred to be unit, and the F# compiler emits an error: FS0001: This expression was expected to have type unit but here has type... .\r\nNew syntax. Example # 1:\r\n[<Measure>]\r\ntype GBP\r\nlet status = false\r\n// money = None here\r\nlet money = if status then Some(100<GBP>)\r\nExample # 2:\r\nlet cashAvailable = false\r\nlet accountCorrect = true\r\n// status = false here due to cashAvailable = false\r\nlet status = if cashAvailable && accountCorrect then true\r\nelif not accountCorrect then false\r\nThese changes in the F# language syntax will not affect existing codebase. The if constructs with no else branch are allowed in Java, C#, Ada 2012, C++, VB.NET, just to name a few. I think this syntax will help remove an unnecessary burden from F# users (who have to write \"else false\", \"else None\" in their if expressions) and improve succinctness of F# code.",
        "Votes": 0,
        "Comments": [
            {
                "Submitter": "Dominick Joseph",
                "Submitted": "2016-03-04T12:39:00",
                "Content": "I don't think is a bad idea. I do feel it makes the language less safe. The reason it defaults to unit if the if branch returns unit is because the else branch can only return unit. For everything else you need to explicitly state the else branch. This causes you to think about what the else branch needs to return. Having it just return none or false can cause you to miss something.\r\nfor example:\r\ntype person = { ShirtColor : string }\r\nlet maybePerson = Some { ShirtColor = \"blue\" }\r\nlet shirtIsBlue (x:person option) = if x.IsSome then x.Value.ShirtColor = \"blue\"\r\nThis will return false if the person is None. Is that what we want? Do we want to return bool option and return none? Do we want to wrap it in a different success/error type? But with this we will just keep processing as if the shirt is not blue. Obviously we would never write this code but imagine more complex types and expressions that don't necessarily have idiomatic ways of dealing with them.\r\nSo do we want safeness or succinctness?"
            },
            {
                "Submitter": "Charles",
                "Submitted": "2016-03-06T11:41:00",
                "Content": "I like the existing unit default for imperative code.\r\nI don't see the value of defaulting to false for Boolean conditionals. Can't \"if a then b else false\" be rewritten as \"a and b\"?"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-07T13:41:00",
                "Content": "I tried to delete the above-mentioned suggestion shared by me, but failed due to the availability of a comment posted by Dominick Joseph. (Now a comment by Charles was appeared. I would like to thank him for another useful comment). Dominick convinced me that my suggestion is not a good fit for the F# language design due to its potential to undermine code safeness. Now the author of the suggestion is indicated as Anonymous. Dear Admin, please check in the website logs that I (Alexei Odeychuk) posted this suggestion, and delete it along with comments by Dominick Joseph and Charles or mark it as DECLINED. Thank you very much in advance for your rapid response."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12814485": {
        "Number": "12814485",
        "Submitter": "Friedrich von Never",
        "Submitted": "2016-03-05T00:00:00",
        "Title": "Add units of measure for standard type aliases",
        "Text": "Currently there is a support for `float<cm>`, but not `double<cm>`; I should call it `float32<cm>`. Almost in every other position `float` and `double` are completely equivalent (and some programmers prefer `double` over `float`). Shouldn't it be the case for units of measure support?\r\nAlso, it seems that units of measure are not supported for unsigned types at all. Was it a design decision? I suggest adding these.",
        "Votes": 3,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12820011": {
        "Number": "12820011",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-03-05T00:00:00",
        "Title": "Make tuple defined DU cases more consistent with tuple",
        "Text": "It is possible to pattern match tuples in a flexible way:\r\nlet a = 1,2\r\nmatch a with\r\n| 1, _ -> ()\r\n| _ -> ()\r\nbut it's not possible to do this on tuple defined DU cases, one has to write this:\r\nmatch pat with\r\n| SynPat.LongIdent(_, _, _, _, _, _) -> ()\r\n| ...\r\nwhich breaks whenever the case definition change (even at place where we don't care of the contents)\r\nwhile supporting this would be friendlier / more resilient to DU case change:\r\nmatch pat with\r\n| SynPat.LongIdent _ -> ()\r\nor even\r\nmatch pat with\r\n| SynPat.LongIdent foo -> () // can deconstruct foo like a normal tuple",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-03-05T14:38:00",
                "Content": "Actually found out it works with enclosing parens:\r\nmatch pat with\r\n| SynPat.LongIdent(_) -> ()\r\nbut it doesn't work with identifier (case whose utility is close to 0)\r\nmatch pat with\r\n| SynPat.LongIdent(a) -> ()"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-05T15:02:00",
                "Content": "I support the idea shared by Gauthier Segay in respect of \"match pat with\r\n| SynPat.LongIdent foo -> ...\"! When I developed a natural language processing application in F#, I often wrote something like: match arabicLexeme with\r\n| Participle(_, _, _, _, _, _, _) -> ...\r\n| FiniteVerb(_, _, _, _, _, _, _, _, _, _) -> ... Right now, the F# 4.0 compiler emits an error FS0019: This constructor is applied to 1 argument(s) but expects 6 in response to a line of code like \"match pat with SynPat.LongIdent foo -> ...\". There is no doubt, syntax for discriminated union cases is worth to be improved in this context.\r\nP.S. As to \"match pat with SynPat.LongIdent _ ->\" I tested it and found that the compiler (F# 4.0, Visual Studio 2015, Windows 7) accepted it.\r\nMy test code for the F# Interactive was:\r\ntype SynPat =\r\n| LongIdent of int * int * int * int * int * int\r\nlet x : SynPat = LongIdent(1, 2, 3, 4, 5, 6)\r\nlet y = match x with LongIdent _ -> true\r\nThe F# Interactive response was:\r\ntype SynPat = | LongIdent of int * int * int * int * int * int\r\nval x : SynPat = LongIdent (1,2,3,4,5,6)\r\nval y : bool = true\r\nNo warnings or errors from the F# 4.0 compiler.\r\nP.P.S. When I tried to write in the F# Interactive:\r\nlet y = match x with LongIdent foo -> true\r\nI received a compiler error FS0019: This constructor is applied to 1 argument(s) but expects 6."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12826233": {
        "Number": "12826233",
        "Submitter": "Matthias Dittrich",
        "Submitted": "2016-03-06T00:00:00",
        "Title": "Hide Obsolete warnings on record initializer not using the obsolete field.",
        "Text": "Basically the compiler emits a warning even when a obsolete field is not used directly in the source code. Here is a code example showing what I mean:\r\n// def version 1\r\ntype TestRecordV1 =\r\n{ Field1 : string\r\nFeild2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nFeild2 = null }\r\n// usage\r\nlet v1var1 = { TestRecordV1.Emtpy with Field1 = \"field1\" }\r\nlet v1var2 = { TestRecordV1.Emtpy with Feild2 = \"field2\" }\r\nlet v1var3 = { TestRecordV1.Field1 = \"field1\"; Feild2 = \"field2\" }\r\nlet v1access1 = v1var1.Field1\r\nlet v1access2 = v1var1.Feild2\r\n// def version 2\r\ntype TestRecordV2 =\r\n{ Field1 : string\r\n[<Obsolete(\"Use Field2 instead\")>]\r\nFeild2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nFeild2 = null } // can we somehow hide the warning here\r\n// (as it is obvious that we need to address it)\r\n// usage\r\nlet v2var1 = { TestRecordV2.Emtpy with Field1 = \"field1\" } // why?\r\nlet v2var2 = { TestRecordV2.Emtpy with Feild2 = \"field2\" }\r\nlet v2var3 = { TestRecordV2.Field1 = \"field1\"; Feild2 = \"field2\" }\r\nlet v2access1 = v2var1.Field1\r\nlet v2access2 = v2var1.Feild2\r\n// def version 3\r\ntype TestRecordV3 =\r\n{ Field1 : string\r\nField2 : string }\r\nstatic member Emtpy =\r\n{ Field1 = null\r\nField2 = null } // was broken\r\n[<Obsolete(\"Use Field2 instead\")>]\r\nmember x.Feild2 = x.Field2\r\n// usage\r\nlet v3var1 = { TestRecordV3.Emtpy with Field1 = \"field1\" } // not broken (yes, old compiled versions are still broken)\r\n//let v3var2 = { TestRecordV3.Emtpy with Feild2 = \"field2\" } // broken\r\nlet v3var2 = { TestRecordV3.Emtpy with Field2 = \"field2\" }\r\n//let v3var3 = { TestRecordV3.Field1 = \"field1\"; Feild2 = \"field2\" } // broken\r\nlet v3var3 = { TestRecordV3.Field1 = \"field1\"; Field2 = \"field2\" }\r\nlet v3access1 = v3var1.Field1\r\nlet v3access2 = v3var1.Feild2 // obsolete, OK\r\nI'm pretty sure this is because the code will still break (and use the obsolete field behind the scenes). So even if the suggestion can not be accepted in general (but I think still worth the discussion) we should consider this is in scripting contexts (where binary compatibility is not really a problem). Scripting is the place where I realized this, so currently there really is no good way to use Obsolete on records at all (besides using constructor functions, but then I think the compiler should generate them for me behind the scenes).",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Matthias Dittrich",
                "Submitted": "2016-03-06T04:31:00",
                "Content": "As the formatting was completely broken: http://fssnip.net/7OE\r\nThe line with \"// Why?\" is triggering an obsolete compiler warning!"
            },
            {
                "Submitter": "Matthias Dittrich",
                "Submitted": "2016-03-06T04:46:00",
                "Content": "I noticed one more thing: The complete record initializer is triggering the obsolete warning instead of the line accessing the obsoleted field (updated the fssnip version)"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-06T05:47:00",
                "Content": "I support the idea shared by Matthias Dittrich."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12838449": {
        "Number": "12838449",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-03-07T00:00:00",
        "Title": "allow use to not bind the expression to a name",
        "Text": "In C#, one can use using(CreateSomeDisposable()) without binding the expression to a name.\r\nSame construct in F# is not allowed, forcing a workaround such as\r\nuse __ = CreateSomeDisposable()\r\nallow to make it like this:\r\nuse CreateSomeDisposable()",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "lr",
                "Submitted": "2016-10-06T13:22:00",
                "Content": "In my opinion the bigger annoyance is that a use expression can't even be bound to _ (single underscore), so if I want to use multiple uses, I need to write something like\r\nuse _1 = CreateSomeDisposable()\r\nuse _2 = CreateSomeDisposable()\r\nIf I could instead bind it to the wildcard character _, then I would be happy:\r\nuse _ = CreateSomeDisposable()\r\nuse _ = CreateSomeDisposable()"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12838959": {
        "Number": "12838959",
        "Submitter": "Pierre Irrmann",
        "Submitted": "2016-03-07T00:00:00",
        "Title": "Allow record types to implement interfaces just by adding the interface name when compatible",
        "Text": "When a record type already has all the members necessary to impement an interface, it could implement it without having to write the code.\r\nFor instance:\r\ntype IHasAnAge =\r\nabstract member Age: int\r\ntype Person = {\r\nName : string\r\nAge: int\r\n} with interface IHasAnAge",
        "Votes": 32,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12839142": {
        "Number": "12839142",
        "Submitter": "Pierre Irrmann",
        "Submitted": "2016-03-07T00:00:00",
        "Title": "Allow overloads of custom keywords in computation expressions",
        "Text": "I've been using custom keywords in computation expressions to write DSLs, and I would have loved to be able to have several signatures for the same custom keyword, in order to make some arguments optional in the expression.\r\nWhen you try do it today, there is an error message such as \"The custom operation 'myOperation' refers to a method which is overloaded. The implementations of custom operations may not be overloaded\"\r\nI'm aware this is a not-so-used feature, but I'd like to know how hard you think it could be (I would event be willing to have a look at how to implement it).",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-28T00:26:00",
                "Content": "This would be great. If custom operators could take other custom operators as arguments it'd be even better."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12879717": {
        "Number": "12879717",
        "Submitter": "Vasily Kirichenko",
        "Submitted": "2016-03-10T00:00:00",
        "Title": "Allow record inheritance / multiple \"inheritance\"",
        "Text": "I propose to add multiple ***fields*** inheritance into records:\r\ntype Person =\r\n{ First: string\r\nLast: string }\r\ntype Foo = { Bar: int }\r\ntype Student =\r\ninherit Person\r\ninherit Foo\r\n{ GPA: float }\r\nlet student = { First = \"a\"; Last = \"b\"; Bar = 2; GPA = 1.0 }\r\nMaking the same thing with composition results with not such an elegance flat records.\r\nThis approach is used, for example, in Nitra AST DSL, see https://github.com/rsdn/Nitra-Mini-C/blob/master/Nitra-Mini-C/MiniC-ast.nitra#L94",
        "Votes": 17,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12880398": {
        "Number": "12880398",
        "Submitter": "Zhen",
        "Submitted": "2016-03-10T00:00:00",
        "Title": "Add Map.count",
        "Text": "Implement Map.count",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Robert Pickering",
                "Submitted": "2016-03-11T15:43:00",
                "Content": "Sent pull request! https://github.com/Microsoft/visualfsharp/pull/1007"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12880410": {
        "Number": "12880410",
        "Submitter": "Zhen",
        "Submitted": "2016-03-10T00:00:00",
        "Title": "Make Set.count O(1)",
        "Text": "Seems easy to track items when they are added and removed",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Robert Pickering",
                "Submitted": "2016-03-11T15:28:00",
                "Content": "Sadly, not as straight forward as it sounds, since set also support filter and partition as well as add. filter and partition work directly on the SetTree type that represents set internally, so these operation would need to return the new count. It could be done, but the question is should it be done, as the extra over heads may out weight the perf gains from have Set.count O(1). Difficult call to make imho."
            },
            {
                "Submitter": "Jack Fox",
                "Submitted": "2016-03-13T12:08:00",
                "Content": "You are going to incur the cost somewhere. It's usually preferable to incur it when you request count."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12882690": {
        "Number": "12882690",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-10T00:00:00",
        "Title": "Code clarity: To change the default value returned by function Unchecked.defaultof<string> to \"\" from null",
        "Text": "I suggest changing the default value returned by function Unchecked.defaultof<string> to \"\" from null. I think the function should return a value of type string indicating an empty string \"\" as expected by a majority of language users who writes string processing code.\r\nNull indicates that there is no value at all.\r\nI am inclined to think from my own experience that null returned by Unchecked.defaultof<string> leads to unnecessary complications in the code dealing with value names of type string, namely in the form of mandatory checks both for \"\" and null, instead of a check for \"\" only in situations when you expect to encounter an empty string.\r\nThe change suggested in the F# language will allow writing more simple and clear code for string processing.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2016-03-25T12:16:00",
                "Content": "This would be a breaking change and would break the \"principle of least surprise\" for anyone coming from C#. I see the value but don't see this ever happening."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2016-04-13T09:29:00",
                "Content": "Although I get where you're coming from, I don't think that changing what Unchecked.defaultof<> does is a good idea because: (a) it's a breaking change and (b) it's the equivalent of default(T) in other .NET languages.\r\nI'd love for F# to support the idea of types that have a sensible default value (such as \"\" for strings, 0 for ints, [] for lists) but I don't know how you'd do it without support for higher kinds first.\r\nNote: We *sort of* have this with static type member constraints, but unfortunately there's no common member name from .NET type to .NET type. Int defines 'Zero' (through F# extensions), String defines 'Empty', and I'm not sure if Array defines anything at all."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12900021": {
        "Number": "12900021",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-11T00:00:00",
        "Title": "Code clarity: Make syntax for sequence expressions as simple as syntax for lists",
        "Text": "I suggest simplifying syntax for generating sequences. It would be great to make it as simple as syntax for lists in F#.\r\nFor example,\r\nlet lst = [ 1; 2; 3; 4 ] // allowed\r\nlet sq = seq { 1; 2; 3; 4 } // not allowed, why?\r\n// error FS0739: Invalid object, sequence or record expression.\r\nNow, the F# syntax rules allow declaring a simple sequence expression as follows:\r\nlet se = seq { yield 1; yield 2; yield 3 }\r\nI think syntax rules may well be simplified in that case. It would be more comfortable for language users to declare sequences with no need to write the yield keyword each time when they specify a new value for the sequence expression.\r\nP.S. At the same time, there is no need to make any improvements in syntax for generating sequences using ranges specified in the form like 1 .. 10.\r\nlet lst = [ 1 .. 10 ] // allowed\r\nlet sq = seq { 1 .. 10 } // allowed, and that's good!",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-03-13T10:24:00",
                "Content": "You can write\r\nlet sq = seq [ 1; 2; 3 ]"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-14T03:09:00",
                "Content": "Thank you, Vasily. Of course, I can, but let sq = seq { 1; 2; 3 } would be better and consistent with the existing F# syntax rules for sequence expressions, I mean the use of {}."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-28T00:23:00",
                "Content": "However this would not be consistent with the rules for computation expressions.\r\n\"Sequence expressions are an example of a computation expression, as are asynchronous workflows and query expressions.\" [1]\r\nIf you're using a seq expr it should be able to take advantage of complex internal logic, recursive looping, lifting nested sequences with yield!, etc.\r\nVasily is right, if all you want is a simple sequence use\r\nseq [10;55;0] or seq [| 40; 5; 0; 40 |]|\r\nPerhaps that error should be improved to say \"invalid sequence expression ...\" with some more details and a suggestion\r\n[1] https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/computation-expressions-%5Bfsharp%5D"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12902226": {
        "Number": "12902226",
        "Submitter": "Matthew Orlando",
        "Submitted": "2016-03-11T00:00:00",
        "Title": "Support partial record prototypes",
        "Text": "I have a case where I have several related types (categories of parameter sets for an analytics API). I want to create a set of new types such that every category is required in exactly one of the new types, and all of the other categories are optional.\r\nThis is fairly easy to express in a variety of ways in F#, but enforcement becomes difficult. I'd prefer to use record types with a default prototype, but there are no good defaults for the required parameters. I either have to clutter up my types with bona fide classes with constructors, or use a module with a create function (as seems common in cases like this).\r\nSo I propose something like the following:\r\ntype Foo = Foo of string\r\ntype Bar = Bar of int\r\ntype Baz = Baz of Guid\r\ntype Foo' = { Foo : Foo ; Bar : Bar option ; Baz : Baz option }\r\nlet defaultFoo' = { Bar = None; Baz = None } : Foo' partial\r\nAlternatively, I'll accept any comments that help point out something I've missed in F#... I'm still only about knee deep in the waters around here.\r\nNow that I think about it a bit more, I wonder if the way I used \"partial\" in my example can be implemented with reflection... Still, I think language support would give a better developer experience.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12913179": {
        "Number": "12913179",
        "Submitter": "Adnan Gazi",
        "Submitted": "2016-03-12T00:00:00",
        "Title": "add a keyword for module-local construction but public deconstruction of types",
        "Text": "Similar to dependant types, except you wouldn't enforce the predicate on which the type is dependant on to be defined WITH the type.\r\nThis keyword could stop clients of a module from constructing the type, but would allow them to 'see' that it exists, and therefore allow them to deconstruct it for their own use.\r\nFor example, if you want a string constrained to 50 chars, you could have\r\ntype String50 = constrained String50 of string\r\nlet createString50 s = if String.length s <= 50 then Some s else None\r\nwhere 'createString50' is a constructor.\r\nCorrect me if I am mistaken, but it seems to be a lot less complicated than dependant types since the dependancy is implicit, and therefore wouldn't be as difficult for the type inference",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2016-03-17T21:01:00",
                "Content": "I think this is a good idea. Similarly for record types, it would be very useful to restrict record type so that external (outside of the module) user code can use the fields (like A.field), but not construct the record or use the { A with field =... } syntax. Having this restriction for records can make code maintenance a lot easier, especially when adding new fields or new invariants among fields we are sure the invariants are always held.\r\nProbably it's better to use an attribute instead of a keyword. Something like [<PrivateConstructor>] would be good.\r\nA new"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12920034": {
        "Number": "12920034",
        "Submitter": "Matthew Orlando",
        "Submitted": "2016-03-13T00:00:00",
        "Title": "Add constraints to match FSharpType.Is* predicates",
        "Text": "I have a type, CaseSet<'a>, that is only meant to be used with descriminated unions. The only way I've found to enforce this is at runtime using FSharpType.IsUnion. I considered using type providers, but those aren't supported in PCLs.\r\nI propose adding the following constraints based on the corresponding FSharpType reflection functions.\r\nfunction : IsFunction\r\ntuple : IsTuple\r\nunion : IsUnion\r\nrecord : IsRecord\r\nmodule : IsModule\r\nexception : IsExceptionRepresentation\r\n(I'm not really sure about that last one... I included it for completeness but maybe just testing for some subclass is sufficient?)",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12940554": {
        "Number": "12940554",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-03-15T00:00:00",
        "Title": "allow defining function with generic type parameter within another function",
        "Text": "I encounter cases where I'd like to define a function taking a generic type parameter within another functions.\r\ntype Foo = {Bar: int option; Baz: string option}\r\nlet doSomething () =\r\n(**)let writer = Console.Out\r\n(**)let writeOption o =\r\n(* *)match o with\r\n(* *)| Some v -> writer.Write(string v)\r\n(* *)| None -> writer.Write(\"\")\r\n(**)writeOption foo.Bar\r\n(**)writeOption foo.Baz\r\nIt's not possible to do that right now and even if I define the function outside at module level (with extra writer parameter), I can't curry it to avoid passing the context (writer) parameter I'm trying to elide to keep my code concise.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2016-03-21T15:28:00",
                "Content": "If you make writeOption inline then this is currently valid synatx..."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "12951354": {
        "Number": "12951354",
        "Submitter": "Steven Taylor",
        "Submitted": "2016-03-15T00:00:00",
        "Title": "custom set the 'last defined'",
        "Text": "Say we implement something like:\r\ntype BinaryOp =\r\n| And\r\n| Or\r\n| Not\r\n| None\r\nmodule test =\r\nlet aMatchFunction (s:string option) = match s with\r\n| Some s -> printfn \"%s\" s\r\n| None -> printfn \"(none)\"\r\n// Error This expression was expected to\r\n// have type string option but here has\r\n// type BinaryOp\r\nSome of the F# conventions are nice, and it'd be good to be able to stay consistent with them across our code base if we choose. In this case, I feel we shouldn't be forced to adopt the longhand convention of:\r\nOption<string>.None just to get the point across to the compiler. Likewise, pushing the definition up the tree -- ie. in this case (aVarName : BinaryOp option) is not always the sensible thing to do.\r\nThis is just a simple example where it doesn't make much difference one way or the other. I suggest we have more preferences for hints and context. Pithy code probably leads to more name clashes. Sometimes these are acceptable.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "12998517": {
        "Number": "12998517",
        "Submitter": "Vasily Kirichenko",
        "Submitted": "2016-03-17T00:00:00",
        "Title": "Inlined default argument values",
        "Text": "Instead of\r\nmember __.Foo(?a: int) =\r\nlet a = defaultArg a 2\r\nit would be great to write it C#-slyle:\r\nmember __.Foo(?a: int = 2)",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-03-17T12:13:00",
                "Content": "I agree with Vasily, but I think the \"?\" symbol is not necessary at all for the syntax suggested. In my opinion, that symbol has no value added; it worsens the readability of code only.\r\nI think it would be even better to write it in the VB.NET or Ada 2012 style:\r\nmember _.Foo(a : int = 2).\r\nSidenote: the value \"a\" has to belong to type int during all its lifetime (as declared in a member or function).\r\nFor example,\r\nmember ___.Foo(a : int = 2): int =\r\n(*…….……*) if a = 2 then 0 else a\r\nFor the sake of the F# language stability, let the two syntax models co-exist. Let the \"member __.Foo(?a: int)\" syntax remain in the existing codebase, and let's open opportunities for the new syntax \"member _.Foo(a : int = 2)\" to become widely used in new code!"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13056630": {
        "Number": "13056630",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-03-21T00:00:00",
        "Title": "Code clarity: Dot notation for casting objects to interfaces",
        "Text": "I suggest introducing the dot notation syntax for casting an object to an interface.\r\nIt would be great to write, for example:\r\nthis.InterfaceName.methodName(param1, param2, ..., paramN)\r\nmyObject.InterfaceName.methodName(param1, ..., paramN)\r\ninstead of:\r\n(this :> InterfaceName).methodName(param1, param2, ..., paramN)\r\n(myObject :> InterfaceName).methodName(param1, ..., paramN)\r\nI think the use of one symbol \".\" instead of four symbols \"(\", \":\", \">\", \")\" to convey the same idea can improve F# code clarity.\r\nThe syntax suggested would be especially useful in the body of methods of classes that implement multiple interfaces.\r\nP.S. My suggestion does not mean a breaking change in the F# language. I think the existing syntax and the dot notation syntax for casts to interfaces can be used interchangeably.",
        "Votes": 5,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "13133787": {
        "Number": "13133787",
        "Submitter": "Anthony Lloyd",
        "Submitted": "2016-03-25T00:00:00",
        "Title": "Add (binary) search function to Map and Set",
        "Text": "Often in interpolation the nearest collection items to a given value are needed. Map and Set both have a data structure that could be binary searched returning the two nearest neighbours optionally. The function should only be called something like 'nearest' so the implementation isn't exposed.\r\nAt the moment you would have to replicate the collections to be able to do this.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2016-03-28T18:00:00",
                "Content": "Implementing \"nearest\" will require the concept of distance, above and beyond a mere total ordering. OCaml provides a Set.split function that splits a set into two sets at the given element, returning a boolean if that element was present.\r\nI wish there were many more functions in Map and Set. I'd like a subset function for Map where you give it a Set of keys. And a merge function for Map that adds binding from one Map to another efficiently (can be done in sub-linear time with pure collections). FWIW, my preference would be for more jack-of-all-trades-and-master-of-none purely functional collections. Their performance inevitably sucks so their value is really ease of use and clarity."
            },
            {
                "Submitter": "Anthony Lloyd",
                "Submitted": "2016-03-29T03:23:00",
                "Content": "It would only need comparison on the key which it already has. I'm thinking of a function a little like Array.BinarySearch. It should probably be called something like search unless that conflicts with some other use.\r\nA more generic iter or fold function could be a possibility if it would be useful for exposing other functionality based on the fact that the structure is a tree."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13134246": {
        "Number": "13134246",
        "Submitter": "Dax Fohl",
        "Submitted": "2016-03-25T00:00:00",
        "Title": "Add (^%) f = f to core library",
        "Text": "This allows method chaining with sequences etc need no parens:\r\nhttp://stackoverflow.com/questions/36220283/anything-else-similar-to-haskells-in-f-other-than\r\nOptionally call it ^$ for Haskell users, though it's not exactly the same as Haskell's $. ^% is (imo) the nicest on the fingers.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2016-03-25T15:11:00",
                "Content": "In particular note the conversation below Mark's answer."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13218072": {
        "Number": "13218072",
        "Submitter": "Vasily Kirichenko",
        "Submitted": "2016-03-30T00:00:00",
        "Title": "Add a \"with\" syntax for patterns",
        "Text": "See detailed OCaml RFC https://github.com/ocamllabs/compiler-hacking/wiki/Add-a-%22with%22-syntax-for-patterns",
        "Votes": 26,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2016-04-05T18:53:00",
                "Content": "I do like this idea, it would be so nice to be able to combine more active pattern cases like this."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13302753": {
        "Number": "13302753",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-04-04T00:00:00",
        "Title": "Code clarity: Remove Object Pascal-style for ... to|downto ... do ... loops from the language (from Swift)",
        "Text": "The for ... to|downto ... do ... loop appears to be a mechanical carry-over from Object Pascal rather than a genuinely F#-specific construct. The for ...to|downto ... do ... loops do not lend themselves to use with sequences and other core F# types supporting IEnumerable interface. It is rarely if ever used in pro-level apps. More F#-typical construction is already available in the language with the for ... in ... do ... loop that has much better readability and expressiveness.\r\nExample # 1:\r\n// it provides equivalent behavior to: for i = 1 to 100 do ...\r\nfor i in 1 .. 100 do ...\r\n// it provides equivalent behavior to: for i = 100 downto 1 do ...\r\nfor i in 100 .. -1 .. 1 do\r\nExample # 2: Clear advantage in using the for … in … do … loop compared to the for … to|downto … do … loop in expressiveness\r\n// some complicated expression to generate a sequence\r\nlet sq = seq { 1 .. 2 .. 999 }\r\n(*........*)|> Seq.filter (fun item -> item <= 199 || item >= 501)\r\n// simply try each item of the sequence supporting\r\n// IEnumerable interface\r\nfor s in sq do …\r\nRemoving the for .. to|downto ... loops would simplify the language. The value added of this construct is limited and I believe its gradual removal from F# should be seriously considered.\r\nAlternative to be considered:\r\nNot removing the for ... to|downto ... do ... loop from F#, losing the opportunity to streamline the language and discard an unneeded control flow item.\r\nApproach suggested:\r\nI suggest that the for ... to|downto ... do ... loop be deprecated in F# vNext and removed entirely in F# vNext vNext.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-04T05:09:00",
                "Content": "Removing the for .. to|downto ... loops would mean the removal of the unneeded \"to\" and \"downto\" keywords from F#."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-04-10T13:03:00",
                "Content": "Nothing can be removed from the language."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-11T04:16:00",
                "Content": "Vasily, obsolescences and deletions are part of the history of programming languages. Some features are identified as obsolescent; some features are deleted from programming languages in the course of time.\r\nThe languages are rid of rarely used or unsafe features, borrows new features from others in order to survive, boost their competitive strengths, and be modern after all.\r\nFeatures removal occurs not only in old programming languages like Fortran (list of obsolescent and deleted features in Fortran: https://en.wikipedia.org/wiki/Fortran#Obsolescence_and_deletions), but also in new languages that are actively developed, for example, Swift (Remove C-style for-loops with conditions and incrementers. Status: Accepted for Swift 3.0: https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md).\r\nI believe it would be OK to deprecate and then remove the rarely-if-ever-used for ... to|downto ... do ... loop from the language.\r\nI think the list of obsolescent and deleted features has to be an integral, normal part of the F# programming language specification."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13306077": {
        "Number": "13306077",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-04-04T00:00:00",
        "Title": "Add the do .. while loops to the language (from Java, C, C++, C#)",
        "Text": "I suggest adding the do .. while loops to F#. This feature would improve the expressiveness of the language and facilitate the migration of large codebases to F# from imperative languages such as Java, C, C++, C#.\r\nI suggest using time-tested and popular syntax from Java, C, C++, C# (TIOBE TOP 4 languages as of March 2016), but with F#-style indentation instead of {}:\r\ndo\r\n(* indentation to indicate the body of the loop *) body-expression\r\nwhile test-condition\r\nThe difference between the do .. while loop and the already existing in F# while .. do loop is that do .. while evaluates its test expression at the bottom of the loop instead of the top. Therefore, the body of the loop is always evaluated at least once before the condition is tested. If the test condition is true, the flow of control jumps back up to do, and the body of the loop evaluates again. This process repeats until the given test condition becomes false. Indentation indicates which expressions are in the loop, so code is clear and easy-to-understand.\r\nIt's good that F# is not pure functional language. I like that F# is a functional-imperative programming language suitable for writing real-world applications. So, it would be nice if F# would be fully developed language in terms of imperative programming features. It certainly would boost the F# popularity and facilitate the migration of existing code from C, C++, C#, Java.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Bent Tranberg",
                "Submitted": "2016-04-10T01:33:00",
                "Content": "I do not like that existing keywords - do, while - are used for this loop construct, especially since \"while\" is already used for another loop construct. In Pascal syntax this loop construct is called repeat-until. It tells you immediately on top of the loop what this is (\"do\" doesn't since it's used already), and to expect an \"until\" at the bottom."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T19:20:00",
                "Content": "I'm concerned that \"do blocks\" will be difficult to discern from \"do while\" blocks.\r\nI'd appreciate this feature be brought to F# but it needs to not clash with do blocks IMHO."
            },
            {
                "Submitter": "Graham Sharp",
                "Submitted": "2016-05-03T12:55:00",
                "Content": "This can be accomplished with\r\nwhile (\r\nbody-expression\r\ntest-condition\r\n) do ()"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13307676": {
        "Number": "13307676",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-04-04T00:00:00",
        "Title": "Add the (..<), (>..) half-open range operators and (>..<) open range operator (from Swift)",
        "Text": "I suggest adding the (..<) and (>..) half-open range operators and (>..<) open range operator to the language in order to reduce risks of introducing off-by-one errors in code.\r\nThere is the (..) closed range operator in F# to generate ranges of consecutive values, but now the language lacks the (..<) and (>..) half-open range operators to generate ranges of consecutive values without the first or last value specified respectively. Furthermore, there is no open range operator (>..<) to generate a range of consecutive values without both the first and last value.\r\nSyntax suggested:\r\na) from Swift:\r\n1 ..< 10 // means: 1 .. 9 in the already existing F# syntax\r\nb) my suggestions:\r\n0 >.. 5 // means: 1 .. 5, the first value (0) is excluded from the range\r\n// means: 0 .. 3 .. 99; the operators (>..), (..), (..<) can be combined\r\n0 .. 3 ..< 100\r\n// means: 1 .. 9 in the existing F# syntax,\r\n// 0 and 10 are excluded from the range\r\n0 >..< 10\r\nlet lst = [ ... some list comprehension ... ]\r\nfor i in 0 ..< lst.Length do ... // instead of: for i in 0 .. lst.Length - 1 do\r\nAs Edsger W. Dijkstra said, programming is a human activity. The off-by-one errors are often introduced by human programmers because it's easier for them to read and write code like: 0 ..< lst.Length (range from 0 to lst.Length, the last value excluded) instead of: 0 .. lst.Length - 1 (range from 0 to the last value, and the last value is: subtract 1 from lst.Length). We see in life that human programmers often forget to write \"- 1\" in code.\r\nThe syntax suggested helps eliminate off-by-one errors in code.\r\nIt would improve F# code robustness and clarity.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T20:28:00",
                "Content": "Interesting, what about a notation that would bring closer to mathematical notation?\r\n[0..lst.Length[\r\nor\r\n[0..lst.Length)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13308666": {
        "Number": "13308666",
        "Submitter": "Musa",
        "Submitted": "2016-04-04T00:00:00",
        "Title": "Can we build a pre-processor so we don't have to use the word: let ? Makes the function name standout and saves typing similar to R ?",
        "Text": "Makes the function name standout and saves typing similar to R, ofcourse if it can be done without breaking something else ?\r\nf := 3 //or ... rather than\r\nlet f = 3",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2016-04-09T15:26:00",
                "Content": "Admittedly, after using f# for years now I feel 'let' is too noisy/repetitive and wish it's gone. The benefits I can see are:\r\n* Make the language feel lighter-weight and the code more \"direct to the point\", without sacrificing readability. (subjectively, I would say it improves readability, especially so in subareas like math/science/finance).\r\n* It's a huge win when using FSI, where virtually every line starts with a \"let\" which doesn't do much.\r\n* Save 4 characters in each line, the saving is big if your coding style requires a maximum (either it's 80 or 100) line width.\r\nSaying the above, personally I don't think it's possible to do this in F#. There probably isn't a backward-compatibility way to achieve this, and all other approaches (e.g., source code transformation) is effectively forking the language, which isn't a good thing to F# in the large.\r\nThe only way one could imagine is to start a new language with a lighter syntax (yes, even lighter than F#) and incorporate the lessons learned from F#. But a new general-purpose language is a huge endeavor, and it would better bring new ideas rather than just different syntax.\r\n(saying that, in an imaginary world my favorite general-purpose language would change the following syntax aspects in F#:\r\n* no let keyword. Use \"=\" for let-binding and \"==\" for equality. (I think it needs to differentiate name-binding from equality when there is no \"let\"). Also without \"let\" it will be problematic when defining a function and put its parameters in multiple lines, for example:\r\nfunction_name param1\r\n........................param2 = (* fund-body *)\r\nwould not work because the first line can also be interpreted as function application. So some special treatment is needed here, e.g., still use some keyword (e.g., \"def\") to mark the beginning of a function definition, or always use lambda syntax \"f = \\(param1, param2) -> ..\" for function definition.\r\n* also replace \"fun\" keyword to something shorter. Probably \"\\\".\r\n* reverse a few default settings. For example, \"CompilationRepresentation(ModuleSuffix)\" should be the default, so that there isn't a need to mention it unless you really need to NOT have it.\r\n* Have a general solution to convert between module functions and instance methods. Ideally every instance method \"a.Func\" could also be called like a free, curried function using \"A.Func\" (A is the typename), and every module function \"M.func x y z\" could be called as an instance function through \"x.func\" (or maybe z.func?), whenever it makes sense. The first is challenging in .NET/F# because .NET methods have method overloading, among other things. The second is challenging itself because it allows calling a module function without opening the module M, and it's like C++'s argument-dependent lookup, which is a big can of worm with tons of ambiguity issues.\r\n* Make Record syntax terser. e.g., the 'with\" keyword is kind of annoying in { a with x = ..}.\r\n* Unify tuple and records. (get rid of the concept of \"tuple\", which is just record with special field names like _0, _1. Make record types by-default structural instead of nominal)\r\nArguably the last one isn't just a syntax feature. So I'll stop here :-) )."
            },
            {
                "Submitter": "Boris",
                "Submitted": "2016-04-10T13:43:00",
                "Content": "I think it will sacrifice readability very much.\r\nIt's just an ancient C(+ - # ) programmer's mental force overestimation.\r\nSuch a quirks make you constantly analyze complex textual patterns to understand what does\r\none code line exactly mean.\r\nIMHO programming languages are much more about reading(and thinking) then about writing."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T20:43:00",
                "Content": "F# is functional first but has to support quite a bit of imperative style constructs which makes it very practical.\r\nWithout let, it would be difficult to understand the scope of definitions, difficult to catch if I mistyped a symbol name.\r\nI think the list of ambiguity this would create is huge and I'm not in favor of this proposition."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-11T02:14:00",
                "Content": "I agree with Boris and Gauthier Segay.\r\nIt would be really difficult to understand the scope of definitions without let.\r\nAs Edsger W. Dijkstra said, programming is a human activity. It's really much more about reading and thinking then about writing code. Code maintenance takes 50% (pro-level mid-size apps) to 90% (large, long-lived apps containing several million lines of code intended to be in use for 5 to 20 years) of time professional programmers spent on software projects.\r\nFrom code readability and maintenance perspective, I see no value added for dropping the let keyword. I think F# has an excellent syntax in this respect. The let keyword helps writing readable code."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13335678": {
        "Number": "13335678",
        "Submitter": "Lenne",
        "Submitted": "2016-04-06T00:00:00",
        "Title": "Compiler directive for environment variables",
        "Text": "It would be nice to have a compiler directive for environment variables which can be used in string literals.\r\nThis way we can pass different parameters to type providers on a build server.\r\n[<Literal>]\r\nlet ConnectionString = #env \"MY_DB_CONNECTIONSTRING\"\r\nlet cmd = new SqlCommandProvider<\"...\", ConnectionString>()",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-08T01:33:00",
                "Content": "Lenne, what's wrong with already-existing .NET built-in Environment.GetEnvironmentVariable method (from namespace System)?\r\nYou can use a .NET built-in method instead of the #env syntax suggested. The name of the built-in method would make your code more readable.\r\nCode example:\r\nopen System\r\n[<Literal>]\r\nlet ConnectionString = Environment.GetEnvironmentVariable(\"MY_DB_CONNECTIONSTRING\")\r\nlet cmd = new SqlCommandProvider<\"...\", ConnectionString>()\r\nPlease see for more details:\r\nEnvironment.GetEnvironmentVariable Method (String)\r\nhttps://msdn.microsoft.com/en-us/library/77zkk0b6(v=vs.110).aspx\r\nHope it helps."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T20:35:00",
                "Content": "Alexey, your example would cause \"This is not a valid constant expression.\" error.\r\nLenne, do you mean the value to be substituted at compile time? (I guess yes as it is a compiler directive).\r\nI'm not sure I see value in this, is there prior art (any other compiler does that?)\r\nI generally move those type of strings in a separate module, and can consider generating this module file as a preliminary build step.\r\nAlso, I think this can be addressed by a type provider altogether, maybe you should consider this instead?"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13345104": {
        "Number": "13345104",
        "Submitter": "Anonymous",
        "Submitted": "2016-04-07T00:00:00",
        "Title": "Add triple-questionmark not yet implemented operator (???) from Scala",
        "Text": "In Scala, there is an operator `???`, which is used as a \"Convenient as a placeholder for a missing right-hand-side of a method.\"\r\nThis is defined as follows:\r\ndef ??? : Nothing = throw new NotImplementedError\r\nIn F# I would imagine that we'd define it something like:\r\n[<GeneralizableValue>]\r\nlet ???<'a> = raise (NotImplementedException())\r\nUnfortunately, ??? is not a valid name, which is why a library solution won't solve this problem.\r\nThe major merit of including this in F#, is that it provides a standardized way to declare incomplete parts of the code, allowing users and tooling to detect this.\r\nYou can read the original reasoning by Martin Odersky here at http://www.scala-lang.org/old/node/11113.html\r\nFinally, an article offering more explanation as to it's value and usage can be found here:\r\nhttp://alvinalexander.com/scala/what-does-three-question-marks-in-scala-mean",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-08T08:52:00",
                "Content": "Varon, did you consider any other options, for example:\r\n1) Simple comment: // ??? to be done\r\nYou can find an uncompleted code fragment in your source code file using Ctrl+F in the Visual Studio and writing: “??? to be done”.\r\n2) Toggle a breakpoint in the Visual Studio when necessary to mark an uncompleted fragment of your code. So, you can run and test your code before a breakpoint.\r\n3) let valueToBeDeveloped<'a>(param1, param2) = Unchecked.defaultof<'a>\r\n// if your function has to return a value of unit type\r\nor: let valueToBeDeveloped<'a>(param1, param2) = ()\r\ninstead of: let valueToBeDeveloped<'a>(param1, param2) = ???\r\nThe already-existing in F# function Unchecked.defaultof<'a> returns the default value of any type and has a much more readable English name than \"???\". Paired with a comment describing your intent \"to write the body of expression here\", such a fragment of your code would be easy-to-understand.\r\nAs to maintenance of code containing \"???\". Code maintenance takes 50% (pro-level mid-size apps) to 90% (large, long-lived apps containing several million lines of code intended to be in use for 5 to 20 years) of time professional programmers spent on software projects. So, how much would \"???\" say about intents of authors of code to a programmer newly assigned to maintain such a project?\r\nOf course, most of the programming languages borrow new language features from others in order to survive and boost their competitive strengths. But from code readability and maintenance perspective, I see no competitive advantages for F# to borrow this syntax from Scala. I think F# has a better syntax (mentioned in point 3) in this respect as of today."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T19:51:00",
                "Content": "I believe a library solution is good enough:\r\nlet undefined () = raise (System.NotImplementedException())"
            },
            {
                "Submitter": "Dzmitry Lahoda",
                "Submitted": "2016-04-12T06:50:00",
                "Content": "Would be good if F# to support\r\n```\r\nlet undefined () = raise NotImplemented\r\n```\r\nI.e. omit `Exception` after raise like with `Attribute`s and new without `()`"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13361034": {
        "Number": "13361034",
        "Submitter": "Francois Brodeur",
        "Submitted": "2016-04-08T00:00:00",
        "Title": "Implement implicit casts for yield",
        "Text": "As described here: https://github.com/fsharp/fsharp/issues/545#event-620769998",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-10T20:38:00",
                "Content": "It seems there are other areas where this could also take place?\r\nIt is a bit annoying to have to explicitly cast but at least it is consistent wherever expected type is not an exact match.\r\nIntroducing this for yield only would create a special case."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13369500": {
        "Number": "13369500",
        "Submitter": "lr",
        "Submitted": "2016-04-09T00:00:00",
        "Title": "Handle null values in Records gracefully instead of crashing with a NRE",
        "Text": "Please see https://github.com/Microsoft/visualfsharp/issues/1044\r\nCurrently, if a nonnull field in a record (e.g. another record, or FSharpList<'T>, ...) is null, .GetHashCode (and potentially other methods) throw a NullReferenceException.\r\nWhile these objects are obviously invalid and AFAIK can't be easily created in pure F#, this case sometimes happens out of the control of the user.\r\nExamples are DataBinding in WPF and Serialization.\r\nIf the external code ever calls .GetHashCode on an object under construction, it will blow up.\r\nThe suggestion is NOT to change anything semantically but to handle null values gracefully where possible to ease the interop with these external libraries. This is especially important for .GetHashCode, since it is expected that it is always safe to call this method.\r\nIn the case of .GetHashCode, this could be handled backwards-compatible by returning a fixed hash for a null value.",
        "Votes": 0,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "13380336": {
        "Number": "13380336",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2016-04-11T00:00:00",
        "Title": "Code expressiveness: Add loops with test condition in the middle",
        "Text": "Sometimes programmers need to first make a calculation and exit the loop when a certain condition is met. However when the condition is not met there is something else to be done. Hence we need a loop where the test condition is in the middle. That loop was first suggested in 1972 by Ole-Johan Dahl, a Norwegian computer scientist who is deemed to be one of the fathers of object-oriented programming.\r\nI suggest using the syntax for that loop that requires no new keywords:\r\ndo\r\n(* indentation to indicate the first part of the loop body *) body-expression\r\nwhile test-condition (* this line of code has to contain the test condition only for code readability *)\r\n(* indentation to indicate the second part of the loop body *) body-expression\r\ndone\r\nRemark: I think the syntax: “do … while test-condition do … done” containing the do twice would be verbose. We can visually separate the two parts of the loop body by enforcing that the line of code beginning with the while keyword contains the test condition only.\r\nThe do .. while .. done loop evaluates its test expression in the middle of the loop instead of the top or bottom. Therefore, the first part of the loop body is always evaluated at least once before the condition is tested. If the test condition is true, the second part of the loop body evaluates and the flow of control jumps back up to do. This process repeats until the given test condition becomes false. Indentation indicates which expressions are in the first or second part of the loop body; the line of code beginning with the while keyword contains the test condition only, so code is clear and easy-to-understand.\r\nI like that F# is a functional-imperative programming language suitable for writing real-world applications. It would be nice if F# would be a language fully developed in terms of imperative programming features, a language containing loops with the test condition at the beginning, in the middle, and at the end. It would improve the F# popularity and facilitate the migration of imperative code from other mainstream languages.\r\nP.S. This suggestion is an extension of my previous suggestion about introducing loops with the test condition at the end: [/ideas/suggestion-13306077-add-the-do-while-loops-to-the-language-from-ja](/ideas/suggestion-13306077-add-the-do-while-loops-to-the-language-from-ja.md)",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "13393365": {
        "Number": "13393365",
        "Submitter": "Dave Thomas",
        "Submitted": "2016-04-12T00:00:00",
        "Title": "Allow printfn to support repeated arguments",
        "Text": "Rather than:\r\nprintfn \"%i %x %A\" mySecretNumber mySecretNumber mySecretNumber\r\nPerhaps an index argument could be added\r\nprintfn \"%[1]i %[1]x %[1]A\" mySecretNumber",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-17T20:08:00",
                "Content": "Dave, do you think that would still be useful with making your variable name short in the scope where you want to print it:\r\ndo\r\n(**)let n = mySecretNumber\r\n(**)printfn \"%i %x %A\" n n n\r\nI think it is interesting idea (but with a 0 based index and robust compiler checks) but maybe not as useful as string interpolation?"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-04-19T02:34:00",
                "Content": "I currently use a short variable if I can to reduce the annoyance, but forcing myself to use bad variable names is not good practice either. It seems there should be a way to reuse a binding rather than repeating yourself."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-19T06:43:00",
                "Content": "Dave, can you show how mixed of positional and indexed arguments would play together?\r\nShould we reuse string.format notation with braces?"
            },
            {
                "Submitter": "Yemi Bedu",
                "Submitted": "2016-05-27T11:24:00",
                "Content": "Hello,\r\nSo if you have the following (0 indexed):\r\nprintfn \"%A %A[0] %A\" a b c\r\nprintfn \"%A %A[1] %A\" a b c\r\nprintfn \"%A %A %A\" a b c\r\nprintfn \"%A %A %A[1]\" a b c\r\nThe first and fourth would seem to be a compiler error and the second and third should be okay. It seems like subtle errors can easily creep in that may not be obvious with a quick eye scan. How can this be made more clear or is it better to cancel this in favor the following:\r\n[/ideas/suggestion-6002107-add-string-interpolation-to-println-syntax-from-s](/ideas/suggestion-6002107-add-string-interpolation-to-println-syntax-from-s.md)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13394442": {
        "Number": "13394442",
        "Submitter": "Don Syme",
        "Submitted": "2016-04-12T00:00:00",
        "Title": "Optionally specify file order by a fileorder.fsx (or fileorder.txt or fileorder.json) file",
        "Text": "With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to allow the F# compiler to optionally take a special file, tentatively called fileorder.fsx, which specifies the file order E.g.\r\nfileorder.fsx:\r\n#load \"Directory/a.fs\"\r\n#load \"b.fs\"\r\n(We could instead use a fileorder.txt or fileorder.json – discuss).\r\nThis would be given to the F# compiler as a command-line input and otherwise everything would work as it does today.\r\nRules\r\n- File references can be given in any order on the command-line.\r\n- If present, the file order is taken from fileorder.fsx\r\n- Using fileorder.fsx is optional\r\n- fileorder.fsx would be hand-authored by the user\r\n- An error would be given if fileorder.fsx doesn’t list all the files in the compilation.\r\nQuestions:\r\n- Would we use a fileorder.fsx or fileorder.txt\r\n- We need a way to refer to things like “obj/Debug/pars.fs” that are the intermediate outputs of other actions. I suggest wildcards\r\n#load \"obj/*/pars.fs\"\r\nHere the meaning of wildcards is “all the inputs that match” not “all the files on disk that match”.\r\nDisadvantages:\r\n- It’s at least as tasteless than “#load/#require”\r\n- It requires manual editing\r\nAdvantages:\r\n- Single place of reference for file order.\r\n- Requires no changes to F# language, “it just works” with any editor\r\n- We could augment the F# compiler to automatically write out a fileorder.fsx if one doesn’t exist, which would allow the user to gradually switch to this model.\r\nRelated alternative: Allow all declarations to be mutually referential and the compiler takes files in any order [/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an](/ideas/suggestion-10276974-allow-the-compiler-to-take-source-code-files-in-an.md)\r\nRelated alternative: Keep a file order, but infer it from #load/#require declarations. This is covered by [/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files](/ideas/suggestion-6323146-syntactically-describe-dependencies-between-files.md)",
        "Votes": 20,
        "Comments": [
            {
                "Submitter": "Kevin Ransom",
                "Submitted": "2016-04-12T12:43:00",
                "Content": "I’m afraid this proposal does not resonate with me. It has a number of deficiencies in my opinion:\r\n1. It repeats information stored elsewhere in every other build system:\r\n• Fake specifies a source file ordering\r\n• Msbuild projects specify source file ordering\r\n• Project.json specifies a source file ordering\r\n2. For a loose collection of F# files in a directory this ordering needs to be specified anyway and so the scenario we are trying to address is not really addressed, I think project.json is as good a way to specify it as an F# file as any\r\n3. I agree with Jared that specifying a source files requirements is a more natural, and source code reuse friendly mechanism for specifying dependencies.\r\n4. A project file can contain a file with the same name in two different directories and so the dependency will need to be path qualified again making the file less friendly in reuse scenarios\r\n5. We already have a model for script files based on #load … this is not aligned with that approach.\r\n• I actually prefer #requires “foo.fs”, and a topological sort, it certainly degenerates in to a form that satisfies this proposal, although there is a preprocessing step that requires opening and reading all of the files which will slow down builds a tad. We can also allow #requires to be a synonym for #load allowing script files to build correctly.\r\n6. I also think that we can probably write a tool that integrates with the dotnet new that reads the source code for loose files and looks at type dependencies and open statements and performs a topological sort that will work. Because it is just a tool, it wouldn’t pollute the compiler and would only run on dotnet new, or when other tooling invoked it.\r\nAnd so …\r\nI think we need to either :\r\n1. Do nothing … require developers to specify file ordering in project.json\r\na. Perhaps write a tool\r\n2. Or add #requires “foo.fs” and do a topologival sort to specify dependencies.\r\nKevin"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-17T20:02:00",
                "Content": "Don, have you considered that fsc now takes a response file?\r\nI think the tooling issue is becoming manageable, for the widespread msbuild project files there is fsprojects/forge tool, and I think support for project.json will be added when it matures.\r\nAs for json file in your suggestion, I really don't think json is a human readable format, it is great when you have javascript on one side but that is about it, writing a json file by hand is tedious compared to a more human friendly format (see the file formats used by paket).\r\nA precompiler directive solution (#require) seems also like a good way to have that made explicit in the source, I think this approach could be studied (with an extra tool as Kevin mentions), but would require some tooling or compiler support (we want error message if a file doesn't exist)."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-27T23:28:00",
                "Content": "JSON presents several issues for use as a configuration file\r\n- doesn't support comments\r\n- no bare keys\r\n- fussy commas\r\n- the abundance of braces make nesting hard to read at a glance and files tedious to edit\r\n- no multi-line strings\r\n- no literal strings (fully escaped)\r\n- only floats, no integers\r\n- no dateTime standard\r\nA much better choice would be TOML[1] (Rust's choice for Cargo[2]) which addresses all of the issues listed above and every vaild TOML file maps directly to a HashTable.\r\nCSON[3] addresses most of JSON's issues, but it doesn't do it as well as TOML does.\r\nYAML[4] is another option, although it's more sane to read and write than JSON, it's unnecessarily complex and much more than is necessary for a project config. A subset of yaml could be used, but that adds another set of issues, so whether it'd be better than JSON in any form is up for debate.\r\nSo really just use TOML or CSON and please not JSON\r\n[1] https://github.com/toml-lang/toml\r\n[2] http://doc.crates.io/manifest.html#the-project-layout\r\n[3] https://github.com/bevry/cson#what-is-cson\r\n[4] https://en.wikipedia.org/wiki/YAML#Sample_document"
            },
            {
                "Submitter": "Nestor Demeure",
                "Submitted": "2016-07-04T11:51:00",
                "Content": "This post might interest you :\r\nhttp://kcieslak.io/Creating-custom-project-file-for-F\r\nAs far as I know, that tool is currently being design :)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13400112": {
        "Number": "13400112",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-04-12T00:00:00",
        "Title": "Enable to use open in other scopes",
        "Text": "It would be nice to be able to use open in function scope and maybe other places where it currently is illegal.",
        "Votes": 26,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2016-04-12T15:07:00",
                "Content": "I would love to be able to open modules in let scopes, this would be especially useful given the way that things like unchecked arithmetic is done in F#."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-13T01:17:00",
                "Content": "I eagerly support Gauthier and Richard"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2016-04-13T03:20:00",
                "Content": "Agreed, this would be great. Just for context, here are the two syntaxes to do this in OCaml:\r\nlet open Module in xyz\r\nModule.(xyz)"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-13T09:07:00",
                "Content": "Loic, I think F# needs and deserves more simple and succinct syntax than that of OCaml; something like this:\r\nlet someWrapperFunction x =\r\n(* .. indentation .. *) open ModuleName\r\n(* .. indentation .. *) y(x) // instead of: ModuleName.y(x)\r\nlet x =\r\n(* .... *) open ModuleName1\r\n(* .... *) open ModuleName2\r\n// instead of: ModuleName1.someConstant1 + ModuleName2.someConstant2\r\n(* .... *) someConstant1 + someConstant2"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-04-13T09:13:00",
                "Content": "agree with Alexei to have fsharp-y syntax (although I'm not familiar with OCaml, I'm sure there are advantages in the way they open modules), I should have put more details in the suggestion but can't edit it.\r\nI'm also considering if having \"partial\" open (to bring only select symbols in scope) is something which would be valuable."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-13T16:17:00",
                "Content": "As to the partial open syntax.\r\nGauthier, I think it would be nice to use the open keyword not only to open entire modules, namespaces in the let scope, but also to introduce a member of another module or namespace (I mean a type or class and its fields, case identifiers, methods, properties) into the current let block in order to prevent ambiguity in code (if the same identifier is in two different modules and we have an open clause for both), obscurity (you can't find the declaration of an identifier) and possibly a maintenance headache (another module is added which duplicates some identifiers).\r\nThe partial open clause should have the effect that members, properties, fields, case identifiers of the type (class) specified are directly visible from the module, namespace specified within the current let block (of course, if access modifiers of such members, properties, fields etc. allow them to be visible in client code).\r\nFor example,\r\nmodule Zoo =\r\n(* .. *) type Animal =\r\n(* ….... *) | Cat\r\n(* ….... *) | Dog\r\n(* ….... *) | Mouse\r\n(* ….... *) | Hamster\r\n(* ….... *) member this.Age = match this with Dog | Cat -> 2 | _ -> 1\r\n(* ….... *) static member StaticAge (animal : Animal) = animal.Age\r\n// another file and module: client code.\r\nlet myAnimalWithAge =\r\n(* ... *) open Zoo.Animal // introduce the type specified from module Zoo into the let block\r\n(* … *) let animal = Cat // instead of: let animal = Zoo.Animal.Cat\r\n(* … *) let animal = Animal.Dog // intentional shadowing; Animal.Dog and Dog are equally legal\r\n(* … *) let age = StaticAge animal // instead of: Zoo.Animal.StaticAge animal, or: Animal.StaticAge animal\r\n(* … *) (animal, age) // return a tuple\r\nMoreover, I believe that the partial open clause can be widely used not only in the let blocks (definitions of values, functions), but also in the bodies of members, properties of classes and types, in namespaces and modules.\r\nThe syntax suggested would be an equivalent to the using syntax in C++, and the use type, use all type syntax in Ada 2012.\r\nI think the above-mentioned syntax would improve the convenience of writing F# code and boost the F# completive strengths."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-04-20T04:24:00",
                "Content": "I think it would be great to use the open keyword:\r\na) in implicit constructors and explicit constructors, in bodies of methods or properties of classes,\r\nb) in branches of the if expressions (if, elif, else branches),\r\nc) in branches of the match expressions,\r\nd) in the do blocks,\r\ne) in loop bodies\r\nAS WELL in order:\r\na) to open entire modules, namespaces (please see an example of the syntax suggested in my message on April 13, 2016 5:07 PM), or\r\nb) to introduce a member of another module or namespace, namely a type or class and its fields, case identifiers, methods, properties whose access modifiers allow them to be visible in client code (please see an example of the syntax suggested in my message on April 14, 2016 12:17 AM).\r\nc) to refer to a single object or class, type, structure from the same module or namespace so that the expressions can use a simplified syntax when accessing members of the object or structure, class, type (like a With...End With statement in VB.NET), for example:\r\nlet customer = new Customer()\r\nopen customer\r\n// beginning in VB.NET with: .Name\r\n// I think the leading \".\" is unneeded in F#\r\nName <- \"Coho Vineyard\"\r\nCity <- \"Redmond\"\r\nopen customer.Comments\r\nAdd(\"First comment.\") // .Add(\"First comment.\") in VB.NET\r\nAdd(\"Second comment.\")"
            },
            {
                "Submitter": "Paul",
                "Submitted": "2016-09-15T07:53:00",
                "Content": "There is some historic work in this area with a POC implementation here [/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard](/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard.md)\r\nImplementation allowed\r\nlet x = \r\n(* .... *) open ModuleName1 \r\n(* .... *) open ModuleName2 "
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13412529": {
        "Number": "13412529",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-04-13T00:00:00",
        "Title": "support flexible types in type alias",
        "Text": "Ability to define\r\ntype CreateCommand = unit -> #IDbCommand\r\ninstead of\r\ntype CreateCommand<'T when 'T :> IDbCommand> = unit -> 'T\r\nbecause the later forces me to specify the generic type (even with _) at places I'm using it.\r\nI'm not clear if there are cases where it would create issues, but it would be nice to have some explicit ways to tell we are ok with implict polymorphism.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:16:00",
                "Content": "This seems to create too many issues to make it feasible. It's effectively like adding a form of existential type to the language, since you're really defining\r\ntype CreateCommand = EXISTS ('T :> IDbCommand). unit -> 'T\r\nThat's not a trivial thing to add to F#"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-06-13T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "13412670": {
        "Number": "13412670",
        "Submitter": "Jeffrey Pierson",
        "Submitted": "2016-04-13T00:00:00",
        "Title": "Add feature to allow string literals to be separated into text files",
        "Text": "Often in code there is a block of meta language in a string format. Typical examples could be SQL, XML, JSON, MD, or just plain text. The choices a developer normally has is either to embed the text as a string literal or to spearate into a file. Separating into a file normally has some advantages in that the format gets better editing support (ex. MyQuery.sql has a nice editing experience than an embedded string) and it cleans up the related code. The down side is traditionally that now the file is read in at runtime and the tooling support in the code to go to the text file for a given string definition becomes more of a manual process.\r\nWhat I would like to propose is the idea of a string literal where the value can be specified in a referenced text file.\r\nBefore:\r\n_program.fs_\r\nlet myQuery = \"select a, b, c from mytable\"\r\nAfter:\r\n_program.fs_\r\nlet myQuery = @mytable_query.sql\r\n_mytable_query.sql_\r\nselect a, b, c\r\nfrom mytable",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2016-04-16T09:05:00",
                "Content": "You can do that with type providers."
            },
            {
                "Submitter": "Jeffrey Pierson",
                "Submitted": "2016-04-27T12:29:00",
                "Content": "Radek Micek - care to share how? I haven't found any available type provider for string literals and looking into how to create a custom type provider has led me into what seems to be a deep rabbit hole."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:20:00",
                "Content": "This is possible with F# type providers, but the functionality needs to be implemented. I tweeted a request for someone to help with this here: https://twitter.com/dsyme/status/742300239739166720"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-06-21T08:39:00",
                "Content": "Jeffrey Pierson, please look at this type provider I created to read a .csv file, parse values from a single column, and generate distinct string literals from those:\r\nhttps://gist.github.com/smoothdeveloper/94332dbd7b894d2dc45cbc1f47a75ac5\r\nI think your feature request is \"as simple as you could get\" exercise to write your first type provider :)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-06-13T00:00:00",
            "Text": "Having a type provider to read string literals from files is entirely reasonable.\r\nI am marking this as declined for the F# language itself because the functionality can be implemented using F# type providers. My suggestion is to open an issue at https://github.com/fsprojects/FSharp.Management/issues\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "13419354": {
        "Number": "13419354",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-04-13T00:00:00",
        "Title": "add isNotNull to FSharp.Core",
        "Text": "Using \"not (isNull a)\" in conditions forces usage of parens or pipe operator and is not optimal readability compared to \"a |> isNotNull\" or \"isNotNull a\"\r\nlet inline isNotNull a = not (isNull a)\r\nin absence of this function, people often take the shortcut of \"a <> null\" which according to lint is not optimal.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Martin Schinz",
                "Submitted": "2016-04-18T02:48:00",
                "Content": "Why not Option.fromNullable and check isNone?"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-04-18T03:30:00",
                "Content": "@Martin because it would cause an unnecessary memory allocation (in case it returns Some)\r\nI don't see why notNull was added. I strongly believe `=` operator should be fixed instead."
            },
            {
                "Submitter": "Carl Patenaude Poulin",
                "Submitted": "2016-04-19T12:02:00",
                "Content": "I just do (not << isNull)..."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:28:00",
                "Content": "The design principle here is that we don't add negations of operators in FSharp.Core. For example we don't add ``List.notContains`` or ``map.Doesn'tContainKey``. We just have to write ``not (List.contains x l`` or ``x |> List.contains x |> not``\r\nI think it's best that we don't start making individual exceptions to this rule."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2016-09-13T09:08:00",
                "Content": "Did I miss something? It looks like this was added to FSharp.Core -\r\nhttps://github.com/Microsoft/visualfsharp/blob/36050db52bc4d4876b16b7f62b5e67cdee34f2aa/src/fsharp/FSharp.Core/prim-types.fsi#L2157-L2158"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-09-13T12:53:00",
                "Content": "Daniel, you are right, it was added recently because, I guess, it is useful even in the compiler itself (to replace non optimal comparison operators)."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-06-13T00:00:00",
            "Text": "Declining per my comment below.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "13476465": {
        "Number": "13476465",
        "Submitter": "Dave Thomas",
        "Submitted": "2016-04-19T00:00:00",
        "Title": "Update records to allow embeddable records",
        "Text": "Update the sytax of records to allow the following:\r\ntype Position = {X : int; Y : int}\r\ntype Sprite = {\r\nPosition\r\nName : string\r\nImage : array byte }\r\nWhich would result in the Position records fields being embedded into Sprite.\r\nThe Go language has such a feature which works quite nicely:\r\nhttps://golang.org/ref/spec#Struct_types",
        "Votes": 22,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-04-19T02:56:00",
                "Content": "What the construction syntax would look like? In Go it's like this:\r\ntype Base struct {\r\nX int\r\nY int\r\n}\r\ntype Foo struct {\r\nBase\r\nZ int\r\n}\r\nfunc main() {\r\nfoo := Foo { Base { 1, 2 }, 3 }\r\nfmt.Println(foo.X + foo.Y + foo.Z)\r\n}"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:30:00",
                "Content": "This looks the same as this suggestion: [/ideas/suggestion-12879717-allow-record-inheritance-multiple-inheritance](/ideas/suggestion-12879717-allow-record-inheritance-multiple-inheritance.md)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:33:00",
                "Content": "Oh I see, you mean a sort of mixin of Position into Sprite, e.g. \"include Position\"\r\nThere are zillions of issues associated with this - e.g. what about subtyping? what about members on \"Position\"? Would Position have to be a struct?\r\nI'd like to see more examples of the utility of this."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13499082": {
        "Number": "13499082",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2016-04-20T00:00:00",
        "Title": "Add support for symbolic stacktraces in computation expressions",
        "Text": "One of the biggest problem in async or computation expressions in general is lack of proper stacktraces when exceptions are raised. This is a major annoyance when debugging in the large, often leading to errors whose origin cannot be traced.\r\nI recently made a blog post arguing for the addition of language features that would make symbolic stacktraces possible for computation expression authors: https://eiriktsarpalis.wordpress.com/2015/12/27/reconciling-stacktraces-with-computation-expressions/\r\nSymbolic stacktraces is a feature that has already appeared in languages like C# (https://github.com/ljw1004/async-exception-stacktrace) and JavaScript (http://www.html5rocks.com/en/tutorials/developertools/async-call-stack/)",
        "Votes": 59,
        "Comments": [
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2016-06-13T07:32:00",
                "Content": "From a compiler perspective, I believe that the issue has been covered by RFC FS-1012..\r\nC.f.\r\n[/ideas/suggestion-8899330-f-compiler-should-support-callerlinenumber-calle](/ideas/suggestion-8899330-f-compiler-should-support-callerlinenumber-calle.md)\r\nhttps://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1012-caller-info-attributes.md\r\nhttps://github.com/Microsoft/visualfsharp/pull/1114"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "See Eirik’s comment below"
        }
    },
    "13554813": {
        "Number": "13554813",
        "Submitter": "Calogyne",
        "Submitted": "2016-04-23T00:00:00",
        "Title": "Add more split functions to List, Seq, and other collection modules",
        "Text": "Haskell has this Data.List.Split (https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html) library which supports multiple strategies for list splitting. I think those functions can come in handy in some scenarios, plus they cannot be easily made by chaining other existing functions, therefore should be included in the core library?",
        "Votes": 3,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "13584294": {
        "Number": "13584294",
        "Submitter": "Reed Adams",
        "Submitted": "2016-04-25T00:00:00",
        "Title": "Allow [<DefaultValue>] on member val auto-properties",
        "Text": "This is specifically motivated by my issues with using Entity Framework and how it initializes DbSet<'T> elements. There might be other applications.\r\nIn order to correctly interact with EF in C# I may use:\r\npublic DbSet<RecType> Records { get; set }\r\nTo accomplish the same thing in F# I must;\r\n[<DefaultValue>]\r\nlet mutable private _Records: DbSet<RecType>\r\nmember x.Records with get() = x._Records and set value = x._Records <- value\r\nNot doing so causes the EF wire-ups to be lost when the regular member init-assign is called.\r\nI believe that it would be beneficial to allow the following:\r\n[<DefaultValue>]\r\nmember val Records: DbSet<RecType> with get, set\r\nThis would remove a good deal of boilerplate code and more expressively describe what's going on.\r\nThank you for your consideration.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2016-05-02T09:10:00",
                "Content": "Reed, an equivalent translation of your C# to F# would be:\r\nmember val Records = Unchecked.defaultof<_> with get, set"
            },
            {
                "Submitter": "Reed Adams",
                "Submitted": "2016-05-03T09:33:00",
                "Content": "Unfortunately, this doesn't solve the problem. That changes the type away from the required EF DbSet<> to an IQueryable<QuerySource<,>> as well as not solving the underlying issue of late-assigning the initializer value, which is overwriting property hook wire-ups used by EF.\r\nThe code you posted isn't really equivalent since C# doesn't require property initializers. When the GC allocates memory for the (C#) class it's zero-set for the size of the class and then no further action is taken. F# does this, but then additionally sets the init-value during construction. This is an extra value-set step that C# lacks, and in this case kills the work EF has already done. This is why [<Defaultvalue>] on an F# field prevents the need for an explicit initializer value and prevents the described problem, at the cost of much additional code to facilitate the solution.\r\nI was hopeful for it to work, but it just wasn't so."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:45:00",
                "Content": "I'm not certain, but does this work?\r\ntype C() =\r\n[<DefaultValue>]\r\nval mutable Records: DbSet<RecType>\r\n??"
            },
            {
                "Submitter": "Reed Adams",
                "Submitted": "2016-06-17T17:05:00",
                "Content": "Hello, Don. Thank you for reviewing my request.\r\nThe suggestion you've given is already among my personal attempts at limiting the verbosity, but this approach too does not solve the issue.\r\nThe problem in your suggested case is that the target is no longer a property (EF uses DbSet<> properties as injection markers) but has been demoted to a regular field, which can be DefaultValue'd, but isn't a property, and so EF ignores this element.\r\nTo date, the only way that I have managed to avoid this problem is with an explicit backing store (your suggestion is suitable for that purpose) that is DefaultValue'd accompanied by the manual property machinery for get and set. It seems that in all cases of F# property use, the value initializer for the property is happening after EF has setup all of its hooks into the object, effectively wiping them out. Bummer :/\r\nIf there is anything else you would like me to test I'm happy to do so.\r\nThank you again for your time."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13660647": {
        "Number": "13660647",
        "Submitter": "Anonymous",
        "Submitted": "2016-04-29T00:00:00",
        "Title": "Support Tabs",
        "Text": "Don't force a code style upon users. Tabs can work perfectly well in whitespace-sensitive languages - see python or haskell - and many people prefer them.\r\nForcing users to use your style just comes across as petty and picky: not the impression you should be giving. Disappointing to see a promising language hamstrung by narrow-minded design decisions.",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-05-08T10:53:00",
                "Content": "Can I downvote this suggestion?"
            },
            {
                "Submitter": "Me",
                "Submitted": "2016-05-08T15:19:00",
                "Content": "Have you ever kissed a girl?"
            },
            {
                "Submitter": "TeaDrivenDev _",
                "Submitted": "2016-05-08T15:27:00",
                "Content": "The language once and for all deciding that for all F# code is a *good* thing. The indentation is part of the syntax, not a question of style."
            },
            {
                "Submitter": "Jerold Haas",
                "Submitted": "2016-05-08T15:40:00",
                "Content": "There are far more important things to concern over rather than whitespace.\r\nIf you'd like a history lesson on F#'s rules on white space I suggest you look at: https://www.seas.upenn.edu/~cis341/current/programming_style.shtml#3"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-05-10T07:13:00",
                "Content": "If you use Visual Studio, may be TabSanity is what you need: https://visualstudiogallery.msdn.microsoft.com/ac4d4d6b-b017-4a42-8f72-55f0ffe850d7"
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-05-17T23:34:00",
                "Content": "If the UserVoice system allowed downvotes, I would spend 2 votes on downvoting this suggestion.\r\nTabs for indentation work well when used consistently, e.g. when you will ALWAYS indent by some multiple of N (where N varies according to your preference: 4, or 2, or 8...). However, if you EVER want to line up an indented line with something on the previous line (e.g., lining up |> operators), then tabs will cause you problems. The example given at https://msdn.microsoft.com/visualfsharpdocs/conceptual/code-formatting-guidelines-%5bfsharp%5d is a simple case that would cause tab problems:\r\nlet function1 arg1 arg2 arg3 arg4 =\r\n....arg1 + arg2\r\n..+ arg3 + arg4\r\n(Here a . represents a space). If you are coding with tabs for indentation, and use 4-space tabs (the most common setting, and IMHO the most sensible one for coding), then that would become:\r\nlet function1 arg1 arg2 arg3 arg4 =\r\n>---arg1 + arg2\r\n..+ arg3 + arg4\r\n(Here >--- represents a 4-space tab). Now the main benefit of tabs (that other coders can adjust them to their preferred indentation level) has been lost! A coder who works with 8-space tabs will see:\r\nlet function1 arg1 arg2 arg3 arg4 =\r\n>-------arg1 + arg2\r\n..+ arg3 + arg4\r\nAnd that doesn't line up at all.\r\nNo. Tabs can be nice when your indentation will always be a multiple of N (whatever N may be). But because F# lets you adjust indentation by the width of an operator (plus one space), and that width may vary, tabs are unsuitable for this language."
            },
            {
                "Submitter": "Stefano Pian",
                "Submitted": "2016-05-24T07:17:00",
                "Content": "I agree that the suggestion is bad, or at best an inefficient use of contributors' efforts.\r\nHowever, I want to disagree with Robin Munn's objection. There *is* one straightforward and well-known solution to the problems he presents:\r\nUse tabs for semantic indentation, and then if necessary add spaces for visual alignment.\r\nIn this style, the provided example should be typed as:\r\nlet function1 arg1 arg2 arg3 arg4 =\r\n>---..arg1 + arg2\r\n>---+ arg3 + arg4\r\nYou can now add as many tabs as you like (if you need to change the semantic indentation of the function) and the alignment will be preserved."
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-05-25T09:25:00",
                "Content": "Stefano Pian's comment is entirely correct in that this is the one and only correct way to mix tabs and spaces -- tabs for indendation and spaces for alignment. And good editors do support this, sometimes with a little help:\r\nEmacs: https://www.emacswiki.org/emacs/TabsAreEvil#SmartTabs\r\nVim: http://www.vim.org/scripts/script.php?script_id=231\r\nResharper: https://www.jetbrains.com/help/resharper/2016.1/Reference__Options__General_Formatter_Style.html\r\nHowever, there are plenty of \"dumb\" editors out there that will ruin that perfect mix of tabs and spaces, and turn >---......foo (one tab plus six spaces) into >--->---..foo (two tabs plus two spaces). And that brings me to my main objection to tabs, which is that:\r\n**I shouldn't have to care about the whitespace in my code!**\r\nMixing tabs and spaces *makes* me care about the whitespace in my code, because I usually can't trust the editor to get it right. And the time and mental energy I have to spend turning on \"Show Invisibles\" and peering at whitespace, to make sure that the tabs and spaces in my whitespace are being mixed correctly, is time and mental energy that I could have been spending on actual, productive improvements to my code.\r\nSo while Stefano's suggestion is entirely correct as far as it goes, it does not change my firm belief that worrying about whitespace is unproductive. And since tab characters in code *unavoidably* leads to worrying about whitespace, I much prefer to avoid them entirely."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-02T13:52:00",
                "Content": "It's fair to say we're not planning to support TABs. After 8 years since F# 1.0 this is, AFAICR, the first time I've heard this suggestion, and there are lots of downvotes for it."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-06-02T00:00:00",
            "Text": "Declined, per comments below. F# is a whitespace sensitive language and the general consensus is that TABs are not a good iddea in whitespace sensitive languages given the current status of editors\r\nDon Syme, F# Language Evolution"
        }
    },
    "13696080": {
        "Number": "13696080",
        "Submitter": "Rex Ng",
        "Submitted": "2016-05-02T00:00:00",
        "Title": "Add empty value into the String module",
        "Text": "Copied from this GitHub issue: https://github.com/Microsoft/visualfsharp/issues/1139\r\nRight now, if I do not want to use the empty string literal \"\", I have to do something like\r\nprintfn \"%s\" System.String.Empty\r\nin order to reference the public static readonly instance of the empty string in the BCL.\r\nIt would be more convenient if I can just do:\r\n// Referencing the F# String module here instead of System.String\r\nprintfn \"%s\" String.empty\r\nI would imagine String.empty to be an alias to System.String.Empty so there should be just a one-line code change:\r\nmodule String =\r\n[<CompiledName(\"Empty\")>]\r\nlet empty = \"\"\r\n// Other String functions\r\nI think this will be useful because we already have similar empty values from other modules such as Seq, List, and Array.\r\nThis will also make the code more explicit (i.e. convey to others that 'I want an empty string here' instead of 'this can potentially be a typo').",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Reed Adams",
                "Submitted": "2016-05-03T10:10:00",
                "Content": "While you're waiting for an official library solution, it might be worth noting that you can extend and approximate the desired functionality in your own code for the time being, possibly giving you the expressiveness you're after.\r\nExample at: https://dotnetfiddle.net/rFSPQl\r\nHopefully this gets you closer to where you want to be until a library solution is in place."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13721676": {
        "Number": "13721676",
        "Submitter": "James Ashwell",
        "Submitted": "2016-05-03T00:00:00",
        "Title": "Seq.transpose",
        "Text": "It would be nice to have a function that transposes sequences:\r\n[ [ 00; 01; 02;... ]; [ 10; 11; 12;... ]; [ 20; 21; 22;... ];... ]\r\nto\r\n[ [ 00; 10; 20;... ]; [ 01; 11; 21;... ]; [02; 12; 22;... ];... ]\r\nThis is particularly useful when dealing with infinite x infinite sequences, where you want to iterate over the 'outer group' first.",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2016-05-09T07:57:00",
                "Content": "I took a stab at an implementation:\r\nmodule Seq =\r\n(**)\r\n(**)let transpose s =\r\n(****)seq {\r\n(******)let cachedOuter =\r\n(********)s |> Seq.map (fun inner -> (Seq.cast inner).GetEnumerator())\r\n(**********)|> Seq.cache\r\n(**)\r\n(******)let firstInner = Seq.head cachedOuter\r\n(**)\r\n(******)while firstInner.MoveNext() do\r\n(********)yield seq {\r\n(**********)yield firstInner.Current\r\n(**********)yield! cachedOuter\r\n(*****************)|> Seq.skip 1\r\n(*****************)|> Seq.map (fun inner ->\r\n(**********************)inner.MoveNext() |> ignore\r\n(**********************)inner.Current) } }"
            },
            {
                "Submitter": "Reed Adams",
                "Submitted": "2016-06-20T15:56:00",
                "Content": "I'm quite the sucker for code golf. My solution:\r\n// implementation:\r\nlet transposeInfinite seqs = Seq.initInfinite(fun i -> seqs |> Seq.map (Seq.item i))\r\n// verify:\r\n// (inf x inf) set, each starting 10 off\r\nlet orig = Seq.initInfinite(fun i -> Seq.initInfinite((+) (i * 10)))\r\nprintfn \"orig: %A\\n\\ntrans: %A\" orig (transposeInfinite orig)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "13785189": {
        "Number": "13785189",
        "Submitter": "Gauthier Segay",
        "Submitted": "2016-05-09T00:00:00",
        "Title": "Support type annotation based on expression's type",
        "Text": "It would be helpful to have type annotation made of the type of another expression:\r\nlet a = 1\r\nlet b : typeofexpr<a> = 2\r\nthis type of type annotation exists in Oracle SQL database (tablename.column_name%type) and is implemented in jai language:\r\nhttps://www.youtube.com/watch?v=iVN3LLf4wMg\r\nI believe it is also possible to do similar thing with C++ templates.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "13887384": {
        "Number": "13887384",
        "Submitter": "Bartosz Sypytkowski",
        "Submitted": "2016-05-18T00:00:00",
        "Title": "Support for named curried functions",
        "Text": "The idea here is to add support for labeled arguments in curried functions. This could allow to extend things like partial application to depend not only on arguments order, and also to introduce default argument values in curried functions (now it's possible only in F# type methods).\r\nThis feature is supported already in ML languages like OCaml or FB Reason.",
        "Votes": 19,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-05-21T05:03:00",
                "Content": "Bartosz, please clarify your suggestion by introducing an example of new syntax in a comment"
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2016-05-27T16:38:00",
                "Content": "This could be neat, but I think it would at the very least require a new non-conflicting operator something like:\r\nlet f x y = x + y\r\nlet f' = f (y ~ 1)\r\nor a whole new spin on partial application, you could make it look kind of like records\r\nlet f' = (f with y = 1)\r\nNot really in love with any of this syntax, just throwing it out there."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-27T03:56:00",
                "Content": "OCaml does this like\r\n-------\r\nlet rec range ~first:a ~last:b =\r\nif a > b then []\r\nelse a :: range ~last:b ~first:(a+1)\r\n-------\r\nand with the shorthand\r\n-------\r\nlet rec range ~first ~last =\r\nif first > last then []\r\nelse first :: range ~first:(first+1) ~last\r\n-------\r\n~first is short for ~first:first\r\n~last is short for ~last:last\r\nThis is also tied into optional labeled curried args that support default values [1]\r\n------\r\nlet rec range2 ?(step=1) a b =\r\nif a > b then []\r\nelse a :: range ~step (a+step) b\r\n> range2 1 10;;\r\nval it: int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n> range2 1 10 ~step:2;;\r\nval it: int list = [1; 3; 5; 7; 9]\r\n- : int list = [1; 3; 5; 7; 9]\r\n------\r\n?(step=1) means ~step is an optional argument which defaults to 1\r\nalso when a function only has optional args the last arg has to be unit\r\n------\r\nlet open_window ?title ?width ?height ()\r\n------\r\n======\r\nReason's approach is\r\n------\r\nlet add = fun first::f second::s => f + s;\r\nlet result = add second::20 first::10;\r\n------\r\nReason also uses this feature to supply default values to curried functions [2]\r\n------\r\nlet increment = fun by::by=0 num => num + by;\r\nlet two = increment by::1 1;\r\nlet four = increment 4;\r\n------\r\nWhen a curried function takes optional args it's probably best to require the label always\r\nbe used for the optional arg.\r\nIntellisense could also aid in making it clear which argument a value is being used to satisfy\r\n[1] https://ocaml.org/learn/tutorials/labels.html#Usingfooinafunctioncall\r\n[2] https://facebook.github.io/reason/#diving-deeper-curried-functions"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14264544": {
        "Number": "14264544",
        "Submitter": "Don Syme",
        "Submitted": "2016-05-27T00:00:00",
        "Title": "Support FSharpType and FSharpValue methods on all profiles",
        "Text": "The following functions are missing from FSharp.Core reflection support for Profile78, 259 and .NET Core. This is because the “BindingFlags” type is not available in those profiles.\r\ntype FSharpValue =\r\nstatic member MakeRecord: recordType:Type * values:obj [] * ?bindingFlags:BindingFlags -> obj\r\nstatic member GetRecordFields: record:obj * ?bindingFlags:BindingFlags -> obj[]\r\nstatic member PreComputeRecordReader : recordType:Type * ?bindingFlags:BindingFlags -> (obj -> obj[])\r\nstatic member PreComputeRecordConstructor : recordType:Type * ?bindingFlags:BindingFlags -> (obj[] -> obj)\r\nstatic member PreComputeRecordConstructorInfo: recordType:Type * ?bindingFlags:BindingFlags -> ConstructorInfo\r\nstatic member MakeUnion: unionCase:UnionCaseInfo * args:obj [] * ?bindingFlags:BindingFlags -> obj\r\nstatic member GetUnionFields: value:obj * unionType:Type * ?bindingFlags:BindingFlags -> UnionCaseInfo * obj []\r\nstatic member PreComputeUnionTagReader : unionType:Type * ?bindingFlags:BindingFlags -> (obj -> int)\r\nstatic member PreComputeUnionTagMemberInfo : unionType:Type * ?bindingFlags:BindingFlags -> MemberInfo\r\nstatic member PreComputeUnionReader : unionCase:UnionCaseInfo * ?bindingFlags:BindingFlags -> (obj -> obj[])\r\nstatic member PreComputeUnionConstructor : unionCase:UnionCaseInfo * ?bindingFlags:BindingFlags -> (obj[] -> obj)\r\nstatic member PreComputeUnionConstructorInfo: unionCase:UnionCaseInfo * ?bindingFlags:BindingFlags -> MethodInfo\r\nstatic member GetExceptionFields: exn:obj * ?bindingFlags:BindingFlags -> obj[]\r\ntype FSharpType =\r\nstatic member GetRecordFields: recordType:Type * ?bindingFlags:BindingFlags -> PropertyInfo[]\r\nstatic member GetUnionCases: unionType:Type * ?bindingFlags:BindingFlags -> UnionCaseInfo[]\r\nstatic member IsRecord: typ:Type * ?bindingFlags:BindingFlags -> bool\r\nstatic member IsUnion: typ:Type * ?bindingFlags:BindingFlags -> bool\r\nstatic member GetExceptionFields: exceptionType:Type * ?bindingFlags:BindingFlags -> PropertyInfo[]\r\nstatic member IsExceptionRepresentation: exceptionType:Type * ?bindingFlags:BindingFlags -> bool\r\nThese functions are really part of the basic F# programming model. This is a frustrating problem because the “BindingFlags” is really only used to supportBindingFlags.NonPublic, and could always just as well have been a Boolean flag.\r\nI believe we should really make alternative versions of these available, especially on .NET Core but also on the portable profiles.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:48:00",
                "Content": "This has actually already been done as part of F# portable profile work https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1013-enable-reflection-functionality-on-portable-profiles.md"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-13T00:00:00",
            "Text": "Completed per comment\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "14266899": {
        "Number": "14266899",
        "Submitter": "Mikkel Christensen",
        "Submitted": "2016-05-27T00:00:00",
        "Title": "Revert the access modifier on FSharpFunc<T, TResult> constructor to be protected again.",
        "Text": "It has been changed to public in 4.4, which is a rather odd construct for an abstract class.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:50:00",
                "Content": "I don't particularly recall why this change was made, but I don't think we'll change it back now for the sake of stability."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-06-13T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "14277294": {
        "Number": "14277294",
        "Submitter": "trek42",
        "Submitted": "2016-05-27T00:00:00",
        "Title": "Make module function callable as class extension method",
        "Text": "Sometimes it's more convenient and succint to call a function using dot-notation (i.e., class method) than calling module functions with pipeline, yet module function is easier to be composed. I propose the compiler automatically generate class extension methods from module functions, based on a new attribute \"CallByInstance\" Example:\r\nnamespace Namespace\r\n// .fsi\r\nmodule List =\r\nval map: ('T -> 'U) -> [<CallByInstance>] list<'T> -> list<'U>\r\nCompiler will automatically generate an extension method of list<'U>, in the *containing* namespace, i.e.,\r\nnamespace Namespace\r\nmodule List = ...\r\n// Automatically generated:\r\n[<AutoOpen>]\r\nmodule ListExtension_map =\r\ntype List<'U> with\r\nmember this.map f list = List.map f list this\r\nThis allows the following syntax:\r\n[1;2;3] |> List.map ((+) 1) // as usual\r\n[1;2;3].map ((+) 1) // call the extension method with dot-notation.\r\nNotes:\r\n1. The extension method is a curried member function. (We don't change the curried parameters to tuple).\r\n2. Similarly we don't change the function name (e.g., no \"map\" => \"Map\" thing).\r\n3. We don't need to open module \"List\" for the extension method. Anywhere \"List.map\" is accessible, \"[1;2;3].map\" is also accessible.\r\n4. You can label multiple parameters of a function as [<CallByInstance>], as long as their types are different.\r\n5. Since we require explicitly marking the allowed parameters, there is no compatibility issue. Users can choose to use this feature judiciously.\r\nFinally, this is related to [/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions,](/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions,.md) but in a reverse way (i.e., turn a module function to a method). My personal view is we need both.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2016-05-27T13:31:00",
                "Content": "fix an error: the generated extension method is:\r\ntype List<'U> with\r\n....member this.map f = List.map f this"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:58:00",
                "Content": "The CallByInstance attribute proposal is very interesting. I've not seen that suggested before. It would, I think, be fairly simple to implement, with many similarities to the existing extension member implementation."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-06-13T05:59:00",
                "Content": "My intuition would be to make this an F#-specific feature, where the F# compiler inserts the appropriate code at the callsite, and doesn't generate an actual new member in the .NET IL.\r\nThat is, instead of auto-generating the actual extension member."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2016-06-18T22:19:00",
                "Content": "Not knowing much about the F# compiler for judging the way how this would be implemented, but agreed that making this F#-specific feature seems like a good idea. As the feature is proposed, the call-site (call-by-instance) code would still be curried functions, so C# probably won't benefit from it as much as F# code does. A purely F# compiler magic at callsites would definitely work, and probably is more desirable if this simplifies the code and/or reduces the generated assembly."
            },
            {
                "Submitter": "tranquillity",
                "Submitted": "2016-09-17T21:20:00",
                "Content": "This syntax is how Kotlin handles collection functions\r\nval numbers = listOf(1, -1, 2)\r\nnumbers.filter { it > 0 } //== listOf(1, 2)\r\nnumbers.map { it * it } //== listOf(1, 1, 4)\r\nYou can also chain the dot notation together:\r\nnumbers.filter { it > 0 }.map { it * it } //== listOf(1, 4)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14411874": {
        "Number": "14411874",
        "Submitter": "TheInnerLight",
        "Submitted": "2016-05-30T00:00:00",
        "Title": "Add many more string manipulation functions to the Core.String module",
        "Text": "The Core.String module does not provide nearly enough features at present, too often we have to revert to using the the standard .NET string class which both hinders tidy piping and stops us taking advantage of curried args / partial application.\r\nI suggest that at least the following functions be added to the string module:\r\nempty : string\r\nisEmpty : string -> bool\r\nisWhitespace : string -> bool\r\nreplace : string -> string -> string -> string\r\nstartsWith/endsWith : string -> bool\r\nsplit : seq<char> -> string -> seq<string>\r\ntoUpper/toLower(Invariant) : string -> string\r\ntrim : string -> string\r\ntrimStart/trimEnd : string -> string\r\nObviously all of this can easily be achieved by writing simple wrappers to the methods in the .NET string class but if F# is going to have a String module, it ought to be a fully featured one.",
        "Votes": 51,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-05-31T15:30:00",
                "Content": "I believe this suggestion is valueable and should be extended. There are three useful functions for string handling in Visual Basic: left, right, mid (please see: String Functions in Visual Basic. https://msdn.microsoft.com/en-us/library/dd789093.aspx).\r\nIt would be nice to add them to String module in F# as follows:\r\nleft: int -> string -> string\r\nright: int -> string -> string\r\nmid: startFrom: int -> int -> string -> string\r\nExample:\r\nlet str = \"123456789\"\r\nlet x = str |> String.mid 2 2 // x = \"23\"\r\nlet y = str |> String.left 4 // y = \"1234\"\r\nlet z = str |> String.right 3 // z = \"789\""
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-06-01T06:10:00",
                "Content": "In addition, it would be nice to add several useful functions from Cryptol, a language for programming cryptographic algorithms, to the F# String module:\r\ndrop: int -> string -> string\r\ntail: string -> string // to drop the first symbol from a string\r\ntake: int -> string -> string\r\nsplitBy: int -> string -> string list\r\ngroupBy: int -> string -> string list\r\njoin: string list -> string\r\nExample:\r\nlet str = \"123456789\"\r\nlet x1 = str |> String.drop 5 // x1 = \"6789\"\r\nlet x2 = str |> String.tail // x2 = \"23456789\"\r\nlet x3 = str |> String.take 2 // x3 = \"12\"\r\nlet str2 = \"123456789012\"\r\nlet x4 = str2 |> String.splitBy 3 // x4 = [ \"1234\"; \"5678\"; \"9012\" ]\r\nlet x5 = str2 |> String.groupBy 3 // x5 = [ \"123\"; \"456\"; \"789\"; \"012\" ]\r\nlet str3 = [ \"123\"; \"456\"; \"789\"; \"012\" ]\r\nlet x6 = str3 |> String.join // x6 = \"123456789012\""
            },
            {
                "Submitter": "Bent Tranberg",
                "Submitted": "2016-06-05T14:14:00",
                "Content": "I like the basic philosophy behind string functions in Delphi, and never understood why the same wasn't done in C#.\r\nString functions in C# typically blow up with exceptions, while in Delphi they typically do the best they can, and typically can't blow up. Delphi string functions results in far less coding, because there's no need to check for index out of range or other possible causes of exceptions, and it's usually far easier to comprehend the possible outcomes of an expression.\r\nFor example, SubString in C# will blow up if any index is out of range, which frequently makes it necessary to do a lot of extra checking. Copy in Delphi is basically the same function, but will not blow up, and instead return whatever lies within the given subrange. Safe, logical, easy.\r\nWhen programming in F#, I typically end up implementing a lot of string functions borrowed from Delphi.\r\nOf course I only suggest this as one more source of inspiration, and of course it overlaps heavily with other suggestions."
            },
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2016-06-06T16:06:00",
                "Content": "The following could be used for some inspiration:\r\nhttps://gist.github.com/manofstick/37f243fedaae203104c7dcc81b221d4b\r\nThis is just my string library that I add to as I use different functions. It has some ideas that may be food for thought, such as:\r\n- treating null as String.Empty (it is f# after all, otherwise use string option...)\r\n- Culture stuff is split into submodules\r\n- \"format\" uses statically resolved types to call \"ToString : string->string\" on any object\r\n- silly naming for blank. Not sure what I was thinking. I should probably just rename to the String objects static function names, but without the \"NullOr\", as that is implied by the library.\r\nBut this is far from a complete surface area. as said, only populated as I need things, so should be taken for what it is, a WIP at glacial pace..."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14533251": {
        "Number": "14533251",
        "Submitter": "Onur",
        "Submitted": "2016-06-02T00:00:00",
        "Title": "Make \"ModuleSuffix\" the default if a type has the same name",
        "Text": "[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix )>]\r\nThis attribute is so commonly used on top of modules. But it is a bit verbose and tedious. I suggest offer an alternative shortcut like [<ModuleSuffix>] or achieve the same effect by a compiler switch.\r\nUpdate: the proposal has been adjusted to say that ModuleSuffix is implied if a type and a module have the same name within the same namespace declaration group",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2016-06-02T16:22:00",
                "Content": "agreed, actually modulesuffix should have been the default setting IMO...but it's not feasible to change the default."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "This has been completed, see RFC at https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1019-implicitly-add-the-module-suffix.md"
        }
    },
    "14558223": {
        "Number": "14558223",
        "Submitter": "Jason Kleban",
        "Submitted": "2016-06-02T00:00:00",
        "Title": "Support for TypeProvider nested types with static parameters",
        "Text": "Please support TypeProviders providing nested types with static parameters. This would be valuable for metaprogramming similar to how static parameterized method support is valuable compared to the language without them. It would allow a fluent-like construction of types and partially make up for the non-variable length static parameters on a single type. See https://github.com/fsharp/FSharpLangDesign/issues/88",
        "Votes": 10,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "14595360": {
        "Number": "14595360",
        "Submitter": "Андрей Чебукин",
        "Submitted": "2016-06-03T00:00:00",
        "Title": "Provide property on base Discriminated Union type if all the case constructors have the same paramater",
        "Text": "If an each case constructor of Discriminated Union has a parameter with the same name and the same type than allow to implement a property on Discriminated Union base type to access to this parameter value.\r\nNow I have to write a match on every case\r\ntype Physical =\r\n| OneToOne of Data : ModuleData * Line : ModuleList\r\n| OneOnOne of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n| OneByOne of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n| Vertical of Data : ModuleData * Line1 : ModuleList * Line2 : ModuleList\r\n* Line3 : ModuleList * Line4 : ModuleList\r\nmember this.Data : ModuleData = match this with\r\n| OneToOne(data, _) -> data\r\n| OneOnOne(data, _, _) -> data\r\n| OneByOne(data, _, _) -> data\r\n| Vertical(data, _, _, _, _) -> data\r\nImplement this same parameter as a field on base class and allow me to write\r\nmember this.Data : ModuleData = base.Data\r\nOr automatic property implementation would also be a perfect option",
        "Votes": 27,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-09T13:53:00",
                "Content": "This is too much magic for my taste. If I saw `base.Data` I would look for such a field or member, but would need to remember that F# magically transforms cases of tuples with common components to this."
            },
            {
                "Submitter": "Abel",
                "Submitted": "2016-09-22T15:55:00",
                "Content": "You can already do generalization:\r\ntype Test =\r\n    | Foo of string\r\n    | Bar of string\r\nstatic member getString x =\r\n    match x with\r\n    | Foo s\r\n    | Bar s -> s // both conditions wrapped in a single continuation\r\nIt would, however, be nice if this is generalized further into something like:\r\nstatic member getString x =\r\n    match x with\r\n    | _ s -> s\r\nBut that doesn't work well with tuples as in your original example. You'd still have to iterate them over, even though you'd need only one continuation."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14750064": {
        "Number": "14750064",
        "Submitter": "mk",
        "Submitted": "2016-06-08T00:00:00",
        "Title": "kprintf with delayed string construction",
        "Text": "Currently kprintf and friends take in a continuation function and a StringFormat and return a curried function that when applied builds the string.\r\nIt would be nice for logging frameworks to have an overload where the continuation does not build the string rather provides a delayed function to build the string.\r\nThat way I can do something like:\r\nlet public logWithFormat logLevel logFormat =\r\nkprintf (fun stringBuilder -> if logLevel > currentLoggingLevel then sprintf \"%s\" (stringBuilder())) logFormat",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "mk",
                "Submitted": "2016-06-09T04:31:00",
                "Content": "A related stack overflow thread with the same issue: http://stackoverflow.com/questions/31442608/how-to-wrap-sprintf-conditionally-in-f"
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-07-13T22:06:00",
                "Content": "If this is implemented, I'd suggest a name incorporating \"d\" for \"delay\", e.g. one of the following naming schemes:\r\ndprintf, dbprintf, dfprintf, dsprintf\r\ndkprintf, dkbprintf, dkfprintf, dksprintf\r\nkdprintf, kdbprintf, kdfprintf, kdsprintf\r\nkprintfd, kbprintfd, kfprintfd, ksprintfd\r\nPersonally, I like the last scheme best, where the \"d\" is appended at the end of the \"normal\" kprintf names. That fits with the printf / printfn function naming, where the two functions do ALMOST the same thing with one minor change (whether a newline is appended or not). Since no kprintf-family functions have an \"n\" overload, there won't be any confusion over whether to put the \"d\" before or after the \"n\", and the parallels to printf / printfn are clear (the \"d\" functions work almost the same as the non-\"d\" functions, but delay calling the continuation)."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14795655": {
        "Number": "14795655",
        "Submitter": "zjv",
        "Submitted": "2016-06-13T00:00:00",
        "Title": "Support mixed F# and C# projects in order to extend F# usage",
        "Text": "Support mixing F# and C# source files in the same project in order to support a gradual move to F# for new users/organisations and to support cases where tooling is oriented at C# (F# not supported)\r\nFor instance I could use this feature to slowly move a C# project to F# one class at the time. Another example would be to use C# tooling to generate web infrastructure like ASP.NET 5 controllers (because F# does not currently have templates for this) and then call directly into F# from those.\r\nP.S. Other languages that F# compares to like Scala already supported mixed projects",
        "Votes": 118,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-07-05T20:33:00",
                "Content": "Nemerle's support for mixed C# and Nemerle source files was a very appealing feature when I first found it. Although the Nemerle compiler was built as something like a fork of the C# compiler. I would be much more inclined to use F# if I didn't have to 100% commit to it. As functional as C# is getting, it would be nice at times to leave the C behind."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-07-05T21:31:00",
                "Content": "I think kotlin has such support with java too.\r\nI'd see this idea coming to fruition first in scripting:\r\n#load @\"path/to/file.csx\"\r\nwhere it is easy to figure out the topoligical graph of script files to include, compile in separate assemblies and link.\r\nIf this is made, then work on same feature in project system would be great.\r\nI think that would also give few kicks to Jetbrains to finally start implementing F# support and more importantly, this would restore some trust in having the whole of MS people working on .NET focused on making best platform with highest level of interop among all the languages, having them invest major engineering efforts which benefits all the languages (current and future) to have easy embedding of all IL compilers in a meta compiler.\r\nF# file ordering is also a major aspect making this seem viable."
            },
            {
                "Submitter": "mmc",
                "Submitted": "2016-07-16T11:29:00",
                "Content": "Another valuable usecase for this would be to F# projects that needs to be consumed from other .NET languages like C#. A mixed F# project could have all the private logic as F# files but the main exposed interfaces as C#."
            },
            {
                "Submitter": "Charles Roddie",
                "Submitted": "2016-09-21T08:39:00",
                "Content": "How is this compatible with file order requirements?\r\n1.cs, 2.fs, 3.fs, 4.cs\r\nPresumably the fs files can refer to previous cs files, and the cs files can refer to each other. Then 2.fs can refer to 1.cs which can refer to 4.cs which can refer to 3.fs. So 2.fs can effectively refer to 3.fs and the whole linear order of F# is broken, isn't it?"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-09-21T14:41:00",
                "Content": "Charles Roddie, this would work with \"islands\" of C# files compiled together and knowing about previous compiled islands, 1.cs can't know about 4.cs in your case."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "14892927": {
        "Number": "14892927",
        "Submitter": "Pedro Santos",
        "Submitted": "2016-06-21T00:00:00",
        "Title": "Support constant values in Discriminated unions",
        "Text": "Hi,\r\nWhile trying to model a music domain I ended up with this code:\r\ntype Note = | C | CSharp | DFlat | D | DSharp | EFlat | E | F | FSharp\r\n| GFlat | G | GSharp | AFlat | A | ASharp | BFlat | B\r\n\r\nlet noteName note =\r\nmatch note with\r\n| C -> \"C\" | CSharp -> \"C#\" | DFlat -> \"Db\" | D -> \"D\"\r\n| DSharp -> \"D#\" | EFlat -> \"Eb\" | E -> \"E\" | F -> \"F\"\r\n| FSharp -> \"F#\" | GFlat -> \"Gb\" | G -> \"G\" | GSharp -> \"G#\"\r\n| AFlat -> \"Ab\" | A -> \"A\" | ASharp -> \"A#\" | BFlat -> \"Bb\"\r\n| B -> \"B\"\r\n\r\nlet pitch note =\r\nmatch note with\r\n| C -> 0 | CSharp -> 1 | DFlat -> 1 | D -> 2\r\n| DSharp -> 3 | EFlat -> 3 | E -> 4 | F -> 5\r\n| FSharp -> 6 | GFlat -> 6 | G -> 7 | GSharp -> 8\r\n| AFlat -> 8 | A -> 9 | ASharp -> 10 | BFlat -> 10\r\n| B -> 11\r\nThe code I wish I could write looks like this:\r\ntype Note = | C of (\"C\", 0) | CSharp of (\"C#\", 1) and so on\r\nlet name = fst C\r\nlet pitch = sdn C\r\nor\r\ntype Note = | C = {name=\"C\"; pitch=0} | CSharp = {name=\"C#\"; pitch=1} and so on\r\nlet name = C.name\r\nlet pitch = C.pitch\r\nor\r\ntype Note = | C of {name=\"C\"; pitch=0} | CSharp of {name=\"C#\"; pitch=1} and so on\r\nlet name = C.name\r\nlet pitch = C.pitch",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-09T12:59:00",
                "Content": "You could instead just do this:\r\ntype Note = { name: string, pitch : uint }\r\nmodule Note =\r\nlet C = { name = \"C\", pitch = 0 }\r\nlet CSharp = { name = \"C#\", pitch = 1 }\r\n//etc.\r\nlet name = Note.C.name\r\nlet pitch = Note .C.pitch"
            },
            {
                "Submitter": "Isak Sky",
                "Submitted": "2016-07-29T19:56:00",
                "Content": "You can do this:\r\ntype Cond = Foo | Bar | Baz\r\nlet (|SetV|) x _ = x\r\n[<EntryPoint>]\r\nlet main argv =\r\nlet c = Cond.Foo\r\nmatch c with\r\n| Baz ->\r\nprintfn \"Baz\"\r\n| Foo & SetV \"and\" kwd\r\n| Bar & SetV \"or\" kwd ->\r\nprintfn \"Keyword: %s\" kwd\r\n| Baz -> failwith \"wat\"\r\n0 // return an integer exit code\r\nBut note this compiler bug:\r\nhttps://github.com/Microsoft/visualfsharp/issues/1281\r\nCredit @kevin in fp slack."
            },
            {
                "Submitter": "Abel",
                "Submitted": "2016-09-22T15:37:00",
                "Content": "It seems to me to make more sense to change the way you use DU for your problem domain. I am missing CFlat (C♭) and ESharp (E♯) etc, or things like DDoubleSharp (D"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "15001293": {
        "Number": "15001293",
        "Submitter": "DonO",
        "Submitted": "2016-06-27T00:00:00",
        "Title": "Naming convention improvements",
        "Text": "I don't think the language benefits from the use of abbreviations especially when they are not consistent. For example\r\ntype ResizeArray<'T> = System.Collections.Generic.List<'T>\r\nI would say that should be named ResizableArray. The current naming sounds like a function. There are more examples of this type of abbreviation that I will try to add when I am reminded of them.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-27T19:57:00",
                "Content": "It the context of all the other collections it doesn't sound like a function. Modules requiring qualified access with the same name as the data structure they're operating over contain functions that are typically verbs.\r\nMap.partition\r\nSeq.filter\r\nArray.iter\r\nList.fold\r\nFurthermore the purpose of the abbreviation is to prevent collisions with the List implemented in FSharp.Core\r\nOther abbreviations used in core are:\r\nunit, ref, list, obj, exn, nativeint, unativeint, string, float32, float, single, double, sbyte, byte, int8, uint8, int16, uint16, int32, int64, uint64, char, bool, decimal, int, array, option, seq\r\n@Dono you haven't stated what is inconsistent about this abbreviation"
            },
            {
                "Submitter": "DonO",
                "Submitted": "2016-06-28T08:21:00",
                "Content": "What's inconsistent in this example is that array is not abbreviated to Arr. \"ResizeArr\" You either abbreviate or don't you don't just pick words randomly to abbreviate and leave others."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-07-05T00:00:00",
            "Text": "While the suggestion is reasonable, this decision was made as part of the F# 2.0, and the slight improvement isn’t sufficient to justify the breaking change renaming at this point\r\nDon Syme, F# Language Evolution"
        }
    },
    "15010572": {
        "Number": "15010572",
        "Submitter": "Dave Thomas",
        "Submitted": "2016-06-28T00:00:00",
        "Title": "Modify open so that it can explicitly only open certain parts",
        "Text": "e.g. open System.Reflection (Assembly)",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Spencer Williams",
                "Submitted": "2016-06-29T09:09:00",
                "Content": "Clarifying: this sounds basically like Python's\r\nimport Foo, Bar from MyModule"
            },
            {
                "Submitter": "Chet Husk",
                "Submitted": "2016-06-29T10:23:00",
                "Content": "Also sounds like Haskell and ES6 Javascript.\r\nHow would extension members in a namespace/module be imported in this syntax?"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-07-05T08:05:00",
                "Content": "Duplicate of [/ideas/suggestion-9987774-allow-finer-grained-control-of-open-like-haskel](/ideas/suggestion-9987774-allow-finer-grained-control-of-open-like-haskel.md)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-07-05T00:00:00",
            "Text": "Duplicate of [/ideas/suggestion-9987774-allow-finer-grained-control-of-open-like-haskel](/ideas/suggestion-9987774-allow-finer-grained-control-of-open-like-haskel.md)"
        }
    },
    "15133467": {
        "Number": "15133467",
        "Submitter": "exercitus vir",
        "Submitted": "2016-07-09T00:00:00",
        "Title": "Nominal subtyping of unions",
        "Text": "This is basically a repost of \"subtyping for discriminated unions\" ([/ideas/suggestion-6672490-subtyping-for-discriminated-unions),](/ideas/suggestion-6672490-subtyping-for-discriminated-unions),.md) but with more details and a description of a concrete use case.\r\nI am reposting because I would like more discussion on this and because I think that declined requests are no longer tracked by Don Syme (and others).\r\nDon Syme declined the feature because he likes features to be generic and symmetric for types in F#. This is a good general rule and I trust in Don's good taste, but I think that this feature request is an exception to the rule, so the decline should be reconsidered for the following reasons:\r\nNominal subtyping cannot be implemented for records because records are compiled to sealed classes, which is a good thing and I see no use cases for subtyping of records anyway (there is also already ambiguity for records with the same fields that needs to be resolved manually with type annotations). So far we agree.\r\nBut this is completely different for unions. This feature only makes sense for unions because of the nature of unions (i.e. limited number of cases where subsets of cases can be fully handled by pattern matches of supersets). Unions are not compiled to sealed classes and there are many uses cases for subtype polymorphic unions. Nominal subtyping of unions is different from structural subtyping of unions (e.g. polymorphic variants in OCaml) in that it is completely safe (i.e. the compiler can still check for exhausiveness). There is also no technical reason that I see (other than maybe a more complex parser, which is an acceptable reason for declining this feature).\r\nHere is a concrete example. Let's say you want to model a financial trading domain where a broker connects to multiple exchanges and submits orders to multiple exchanges. Each exchange supports a subset of a fixed number of possible order types (e.g. limit order, market order, stop limit order, stop market order, trailing stop order, fill or kill order, etc. ) and a subset of timing options for the order (Good Till Day, Good Till Cancel, Good Till Date, Immediate or Cancel, etc.).\r\nUnions are perfect for that except that there is no way currently to generically work with order types and timing options from different exchanges (in a clean way). How would you do this right now in F# without lots of boilerlate and really ugly code (i.e. one interface or member constraint per supported case)?. This feature would allow to express the model directly and I am sure there are many more examples where this is really valuable.\r\nWhat I value about F# the most is the expressiveness of it and this is the only feature (and higher-kinded types maybe) that do not let me express something cleanly.What do you think? Any issues with this that I am overlooking?",
        "Votes": 8,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15133590": {
        "Number": "15133590",
        "Submitter": "exercitus vir",
        "Submitted": "2016-07-09T00:00:00",
        "Title": "Multi-case unions compiled to struct",
        "Text": "I am posting this idea to be able to track its status since it is already informally under consideration. Tuples, records, and single-cases unions are have already planned (implementation even nearing completoin) to be compilable to a struct:\r\nstruct tuples: [/ideas/suggestion-6148669-add-support-for-structtuple](/ideas/suggestion-6148669-add-support-for-structtuple.md)\r\nstruct records: [/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu](/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu.md)\r\nstruct single-case unions: [/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs](/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs.md)\r\nThere is also already a proof of concept for unions of \"blittable\" types: [/ideas/suggestion-7072844-utilise-clr-union-types-for-discriminated-unions](/ideas/suggestion-7072844-utilise-clr-union-types-for-discriminated-unions.md)\r\nThere has also been a lot of discussion on the implementation of multi-case unions in the discussion of struct records: https://github.com/Microsoft/visualfsharp/pull/620\r\nOne great use of multi-case unions compiled to struct would be optional computations (e.g. Option<'T>) for value types that don't do heap-allocation at all.",
        "Votes": 20,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15202209": {
        "Number": "15202209",
        "Submitter": "Isak Sky",
        "Submitted": "2016-07-13T00:00:00",
        "Title": "Return untyped syntax tree from ITypeProvider",
        "Text": "Add the ability to *opt in* to send back an untyped syntax tree from ITypeProviders. The current type provider mechanism is good for simple data exploration use cases, but otherwise extremely limited, and will soon allow for less metaprogramming than Roslyn in some ways. Currently, some types of type providers not possible to create, because unbound generics, records, discriminated unions, and other normal language features are not supported.\r\nWith the ability to opt in to just returning an untyped syntax tree, it would enable the creation of just about any type provider. It would also effectively give F# macros, though through an API rather than syntax.\r\nThese new kind of type providers would be hard to create initially, but the community would be empowered to create libraries to wrap the untyped syntax tree to make it easier to use, and it would soon be an extremely effective and powerful way to do metaprogramming.\r\nAnother benefit is that there wouldn't really be much of a design to experiment with to get right - it is just the untyped syntax tree of the language, which we already have a version of.\r\nThe F# community has very limited resources, and this would be an extremely leveraged way to utilize them.",
        "Votes": 27,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-07-17T16:15:00",
                "Content": "One of the F# strengths is its strong typing. It is not a dynamic typed language. Strong typing helps spotting bugs in code early and produce safe, secure and high-performance code. Maybe it would be better to address the core problem: to develop support at the compiler level for creating unbound generics, records, discriminated unions, and other normal language features in type providers that lack support as of today, preserving F# as a strongly typed language."
            },
            {
                "Submitter": "Isak Sky",
                "Submitted": "2016-07-18T00:22:00",
                "Content": "Alexei Odeychuk: I agree it would be nice, but we also have to think about how to best utilize our very limited resources. Remember that type providers have been out for many years, and we still don't have anywhere close to full language support. I think we have to be open to the possibility that the current design is too difficult to implement.\r\nThinking of good abstractions for meta programming is incredibly hard, and there are a lot of big issues with the current approach F# takes, as anyone who has written a type provider can tell you. That is why I think it is better to expose a lower level API, and let the community build on this instead."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-07-18T08:11:00",
                "Content": "The big problem with TP's is a lot of errors come during running the second instance of your dev environment during quotation splicing, so they are not well typed enough during development."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "15257796": {
        "Number": "15257796",
        "Submitter": "Isaac Abraham",
        "Submitted": "2016-07-18T00:00:00",
        "Title": "Remove warning for new keyword on IDisposable",
        "Text": "The only time I ever use the new keyword is on Disposables, and even then only to silence the compiler warnings. I'm not sure what purpose the warning serves either, because you can still forget to bind the disposable with the use keyword instead of with let. What's more annoying is that it prevents you from effective pipelining.\r\nCould this be removed from the next F# release, or perhaps replaced with a warning if you bind a Disposable with let instead of use?",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-07-18T06:44:00",
                "Content": "I support Isaac Abraham's suggestion!"
            },
            {
                "Submitter": "Reed Copsey, Jr.",
                "Submitted": "2016-07-18T13:31:00",
                "Content": "Binding a disposable with let is a common requirement if you're authoring libraries.\r\nI find the current warning _very_ valuable. If you never use \"new\", the warning effectively tells you whenever you allocate something that's disposable, and also provides a simple way in your code to see all uses of disposable."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-07-19T18:00:00",
                "Content": "I agree with Reed and use same convention, and I do benefit from the warning.\r\nTo workaround the fact you can't use the constructor as first class function only takes a single line function while having the warning and convention of using new only for IDisposable could form a nice convention in F# codebases."
            },
            {
                "Submitter": "Reed Copsey, Jr.",
                "Submitted": "2016-07-28T19:20:00",
                "Content": "I just posted an alternative: [/ideas/suggestion-15448122-add-a-warning-for-new-keyword-used-on-types-which](/ideas/suggestion-15448122-add-a-warning-for-new-keyword-used-on-types-which.md)"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-08-11T21:24:00",
                "Content": "I also find this warning very useful and it definitely should not be removed. Reed's alternative is a much more useful approach.\r\nIf you forget to bind to `use` with the `new` right there, that's on you ;P\r\nIf the real issue is with how it currently can't be pipelined, why not ask for just that instead?"
            },
            {
                "Submitter": "miegir",
                "Submitted": "2016-08-15T16:44:00",
                "Content": "I agree that this warning can be removed and replaced by the warning that IDisposable object should be either bound using 'use' or returned. And that warning should also be reported on methods that return IDisposable values. And, for completeness, using of the 'new' keyword will suppress that new warning, allowing developer to say 'I know that I do here'."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "15332553": {
        "Number": "15332553",
        "Submitter": "Steven Taylor",
        "Submitted": "2016-07-22T00:00:00",
        "Title": "allow compiler directive to switch off inlining",
        "Text": "to get around debugging issues with the inline macro device, this pattern creaps into the code base (taken from FsPickler):\r\n#if DEBUG\r\nlet writeBoundedSequence\r\n#else\r\nlet inline writeBoundedSequence\r\n#endif\r\nIt would be nice to be able to turn off the effect of the inline keyword for files and entire projects while compiling for debugging purposes. Also, optionally setting ignore inline for code executed in an interactive session would be useful too.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Abel",
                "Submitted": "2016-09-25T07:38:00",
                "Content": "I believe I have seen this request before. The problem is that \"inline\" changes the behavior and is often inevitable to create semi-polymorphic (duck-typed) functions and types. Consider:\r\nlet f a b = a + b // a and b are ints\r\nlet inline f a b = a + b // a and b requires member (+)\r\nOr:\r\nlet f a b = int a * int b // a and b are ints\r\nlet inline f a b = int a * int b // a and b require op_Explicit\r\nIf you call this code:\r\nlet result = f 1.23 4uy // the first will work with both, inferred float -> byte -> int\r\nlet result = f 1.23 4L // works with \"inline\", does not compile without (wrong type)\r\nIf your only requirement is to remove optimization of \"inline\" and the different inference rules have no effect, it would make (some) sense to disallow it, esp. since during debugging it is beneficial to be able to step through the method.\r\nYou can simplify your above code somewhat:\r\nlet\r\n    #if DEBUG\r\n    inline\r\n    #endif\r\n    writeBoundedSequence ....\r\nThough I would suggest you create a new compiler constant, say INLINE:\r\nlet\r\n    #if INLINE\r\n    inline\r\n    #endif\r\n    writeBoundedSequence ....\r\nThat is because you would want to be able to see debug behavior of the inlined version and this way you can better control when and where INLINE is used."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "15448122": {
        "Number": "15448122",
        "Submitter": "Reed Copsey, Jr.",
        "Submitted": "2016-07-28T00:00:00",
        "Title": "Add a warning for new keyword used on types which are not IDisposable",
        "Text": "This is an alternative to: [/ideas/suggestion-15257796-remove-warning-for-new-keyword-on-idisposable](/ideas/suggestion-15257796-remove-warning-for-new-keyword-on-idisposable.md)\r\nThe idea is that the new keyword provides valuable information, but only if you do not use it on all types.\r\nWhen avoiding its usage, you get a visual clue as to instances of disposable types, as well as warnings if you bind them.\r\nBy making it a warning to use new unnecessarily, the compiler would effectively enforce a \"best practice\" with regards to IDisposable usage. It goes a long way today, but requires discipline to make it useful.\r\nThis would be especially helpful to people coming to F# from C#, as many immediately use new everywhere, and don't see this very nice safety benefit provided by the compiler.",
        "Votes": 21,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15462291": {
        "Number": "15462291",
        "Submitter": "Dmitry Morozov",
        "Submitted": "2016-07-29T00:00:00",
        "Title": "Have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files",
        "Text": "Have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files\r\nThis came up in my work on FSharp.Data.SqlClient library.\r\nUp until version 1.8.2 version of the library SqlCommandProvider provided command types with two constructors of following signatures:\r\nnew: connectionString: string, ?commandTimeout: int\r\nnew: ?connection: SqlConnection, ?transaction: SqlTransactoin, ?commandTimeout: int\r\nKeep in mind that above are not normal F# type signatures but rather signature as suggested by Intellisense otherwise parameters with default values won’t show as optional.\r\nIt allowed to write following code:\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \"Server=.;Integrated Security=true\">()\r\ncmd.Execute()\r\nIt resolves to second constructor invocation where all parameters have default value e.g. optional.\r\nAt runtime this code reuses design time connection string to connect to a database. This is typical coding style for F# scripting (*.fsx + FSI).\r\nFor production-like scenarios connection string is read from some sort of configuration.\r\nOne way to archived that is to use connection string name from config file app.config/web.config. In that case type provider reads connection string from config file both at design time and runtime which allows to have different connection string at runtime by overriding *.config file\r\nPattern #1\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \" name=AdventureWorks\">()\r\ncmd.Execute()\r\napp.config\r\n<configuration>\r\n<connectionStrings>\r\n<add name=\"AdventureWorks\" connectionString=\"Data Source=.;Initial Catalog=AdventureWorks2012;Integrated Security=True\" />\r\n</connectionStrings>\r\n…\r\nPattern #2\r\nThe other way is override connection string or connection object at runtime\r\ntype Get42 = SqlCommandProvider<\"select 42\", \"server=.;trusted_connection=yes\">\r\n…\r\nDo\r\nlet connStr = readConnectionStringFromConfig()\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", \"Server=.;Integrated Security=true\">( connStr)\r\ncmd.Execute()\r\nNote that will resolve to invocation of first constructor.\r\nThat how it worked until 1.8.2\r\nI got a complaint from one of the library users - Jet.com. They use pattern #2. They said the biggest source of mistakes is that developers forget to provide runtime override for connection string and it fails at runtime.\r\nAn issue was opened to reflect that\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/issues/195\r\nAnd it was fixed and deployed as part of 1.8.2\r\nTo sum up the change is following: if literal connection string was used at design time, at runtime either connection string or connection object is mandatory parameter. I believe it was right change to support production quality code but it made scripting counterpart ugly and I actually received complaints from customers.\r\n[<Literal>]\r\nlet connection = \"Server=.;Integrated Security=true\"\r\ndo\r\nuse cmd = new SqlCommandProvider<\"SELECT 42\", connection>(connection)\r\n//connection mentioned twice. Not elegant\r\ncmd.Execute()\r\nIt would be nice if the type provider can generate slightly different constructor signature for scripting e.g. allowing to create provided command with parameter-less ctor invocation.\r\nI already do something similar in response to\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/issues/185\r\nIt relies on IsHostedExecution property TypeProviderConfig\r\nhttps://github.com/fsprojects/FSharp.Data.SqlClient/blob/v1.8.1/src/SqlClient/Configuration.fs#L67\r\nBut it works only when a type generated within FSI. This was enough to resolve issue 185 but not sufficient to generated diff ctors signatures.\r\nHere is my proposal:\r\n*.fsx files mostly meant to be executed from FSI. Why not to have TypeProviderConfig.IsHostedExecution = true for type providers instantiated in *.fsx files\r\nSo type provider will able to generate diff types depending on IsHostedExecution value",
        "Votes": 7,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15511989": {
        "Number": "15511989",
        "Submitter": "Loic Denuziere",
        "Submitted": "2016-08-02T00:00:00",
        "Title": "Support isNull when querying the built-in SQL type providers",
        "Text": "Right now the query expression-to-LINQ translation doesn't support queries such as `query { for x in table do where (isNull x.Field) }`. Instead we have to use `where (x.Field = null)`. That's quite inconsistent: in normal (non-query) code, `isNull` is advised, but in query code, we can't use it.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2016-08-04T10:28:00",
                "Content": "Even better IMO, optimize comparison operators' handling of null so isNull isn't needed (anywhere)."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "15591624": {
        "Number": "15591624",
        "Submitter": "Dzmitry Lahoda",
        "Submitted": "2016-08-08T00:00:00",
        "Title": "Literal sprintf",
        "Text": "Allow:\r\n```\r\n[<Literal>]\r\nlet a = sprintf \"%s\" \"string\"\r\n```",
        "Votes": 13,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15696774": {
        "Number": "15696774",
        "Submitter": "Mathias Brandewinder",
        "Submitted": "2016-08-17T00:00:00",
        "Title": "Relax indentation rules on Records",
        "Text": "The current indentation rules around records seem inconsistent, or at least counter-intuitive. Consider for instance:\r\ntype Foo = {\r\n....Foo:int\r\n....}\r\ntype Bar = {\r\n....F:Foo\r\n....}\r\nlet bar = {\r\n....F = {\r\n........Foo = 10\r\n........}\r\n....}\r\nThis is valid. But if you change F in Bar to VeryLongName:\r\ntype Baz = {\r\n....VeryLongName:Foo\r\n....}\r\nlet baz = {\r\n....VeryLongName = {\r\n........Foo = 10\r\n........}\r\n....}\r\nWe now get a warning:\r\nwarning FS0058: Possible incorrect indentation: this token is offside of context started at position (10:20). Try indenting this token further or using standard formatting conventions.\r\nIn a similar fashion, indentation rules around adding members to records seem inconsistent, or at least counter-intuitive.\r\nThe 2 examples below are valid:\r\ntype Foo1 =\r\n....{\r\n........data:int\r\n....}\r\n....member x.Data = x.data\r\ntype Foo2 = {\r\n....data:int\r\n....}\r\n....with member x.Data = x.data\r\n... but this one is not:\r\ntype Foo3 = {\r\n....data:int\r\n....}\r\n....member x.Data = x.data\r\nThere is a workaround - systematically put the opening brace { on the second line - but the \"shorter\" syntax is quite nice, and allows to write compact and readable code. Given what is currently acceptable syntax, relaxing a bit the rules would be quite nice, and follow the principle of 'least surprise'.\r\nNote: this is loosely related to [/ideas/suggestion-9156844-relax-some-of-the-indentation-rules](/ideas/suggestion-9156844-relax-some-of-the-indentation-rules.md) ; that specific problem is brought up in the comments.\r\nNote: sorry about the .... but this is the only way I could find to keep the code indentation preserved.",
        "Votes": 9,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15801949": {
        "Number": "15801949",
        "Submitter": "Alex Corrado",
        "Submitted": "2016-08-24T00:00:00",
        "Title": "Allow lower-case DU cases when [<RequireQualifiedAccess>] is specified",
        "Text": "Currently, it is not allowed to declare DU cases with lower-case letters. For instance, this is not allowed:\r\ntype Foo =\r\n| foo\r\n| bar\r\n| baz\r\n// etc...\r\nThis yields: error FS0053: Discriminated union cases and exception labels must be uppercase identifiers\r\nAs I understand it, this is to prevent ambiguity in pattern matching between matching a union case and binding to an identifier. However, this is not an issue if the [<RequireQualifiedAccess>] attribute is specified on the DU. Therefore, I propose we allow lower-case cases in this case.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15915547": {
        "Number": "15915547",
        "Submitter": "Ivan J. Simongauz",
        "Submitted": "2016-09-03T00:00:00",
        "Title": "Implement interface delegating",
        "Text": "Implement interface delegating by next syntax:\r\ntype MyType() =\r\nlet delegator : IAddingService\r\ninterface IAddingService by delegator with\r\nmember this.Add x y = // <- this is override\r\nx + y\r\nSpecial behavior when event in interface - sender substitution",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15915808": {
        "Number": "15915808",
        "Submitter": "Ivan J. Simongauz",
        "Submitted": "2016-09-03T00:00:00",
        "Title": "Impement auto notification",
        "Text": "Impement auto notification chages for classes and records when implemented INotifyPropertyChanged or custom.\r\ntype A() =\r\nlet achaged name old new =\r\nPropertyChanged(this, name)\r\nmember B : int 3 with get and set and notifyby achanged",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "15946864": {
        "Number": "15946864",
        "Submitter": "Marko Grdinic",
        "Submitted": "2016-09-06T00:00:00",
        "Title": "Automate the need to explicitly write out generic parameter constraints in classes",
        "Text": "Given that F# already automatically tells you what member constraints the classes should have, why not go an extra step and have the compiler write them out implicitly like in normal let statements.\r\nI just recently had a situation where in a class I had to explicitly write a bunch of them all out like in the following:\r\n```\r\ntype FFRec<'state when 'state: (member Tape: Stack<unit -> unit>)\r\nand 'state: (member Mem: ObjectPool)\r\nand 'state: (member Str: CudaStream)\r\nand 'state: (member Workspace: Workspace)\r\nand 'state: (member IsInferenceOnly: bool)> =\r\n```\r\nThis would be bad if I had a bunch of classes where for each one, I had to write out every constraint.\r\nOf course I replaced the above with a single subtyping constraint, but is there any reason why the compiler could not have done this automatically? Also if that is not possible, would it be possible to introduce an abbreviation feature for type constraints instead of just types. They would make structural typing a lot more palatable.\r\nHaving recently been introduced to structural typing in F#, I am quite a fan of it and even the syntax which bothered me at the beginning does not look worse than anything you might find in Scala for example. I think this particular feature of the language could be a great selling point if it was made nicer.",
        "Votes": 3,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16092382": {
        "Number": "16092382",
        "Submitter": "Mark Seemann",
        "Submitted": "2016-09-15T00:00:00",
        "Title": "Add ofObj to Seq and Array",
        "Text": "The Option module defines Option.ofObj which converts a potential nullable value to an option.\r\nCollections (Seq and array) can be null in interop scenarios, but it'd often be natural to interpret a null collection as an empty collection.\r\nIt's possible to compose such behaviour from existing building blocks, e.g. with Option.ofObj >> Option.toArray >> Array.concat\r\nThis seems like quite a roundabout way to do things, so I'd like to propose equivalent functions for Seq and Array:\r\n// seq<'a> -> seq<'a>\r\nSeq.ofObj\r\n// 'a [] -> 'a []\r\nArray.ofObj",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2016-09-16T08:10:00",
                "Content": "Alternatively for something more general, we could have a null equivalent of `defaultArg`. So if it's called let's say `ifNull` (placeholder name, not actual proposal) then your `Seq.ofObj s` would be `ifNull s Seq.empty`, and `Array.ofObj s` would be `ifNull s [||]`."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "16126906": {
        "Number": "16126906",
        "Submitter": "Loic Denuziere",
        "Submitted": "2016-09-16T00:00:00",
        "Title": "Allow type annotations at the top level in fsi",
        "Text": "Currently, using a type annotation at the top level in fsi results in a syntax error:\r\n> 1 : int;;\r\n1 : int;;\r\n--^\r\nstdin(1,3): error FS0010: Unexpected symbol ':' in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.\r\nThe workaround is to wrap the whole expression in parentheses, but I don't believe there's any reason for it to be necessary. It has misled some people into thinking they need to use another syntax instead (I've seen people try to use :?> for example).",
        "Votes": 6,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16308904": {
        "Number": "16308904",
        "Submitter": "Abel",
        "Submitted": "2016-09-22T00:00:00",
        "Title": "Expand on cardinality functions Seq.exactlyOne, with Seq.tryExactlyOne and add oneOrMore, zeroOrMore",
        "Text": "While it is quite trivial to write these functions, I think they have merit. First of, it is good there's a Seq.exactlyOne, but it throws and if you want a non-throwing version, you'll have to write one your own. It's odd there's a creator function, Seq.singleton, but not a test-function.\r\nSince we have Seq.exactlyOne, it should have its logical cardinality counterparts for zero-or-one and one-or-more to be available too.\r\nI suggest we add:\r\nSeq.tryExactlyOne\r\nSeq.oneOrMore (throws)\r\nSeq.zeroOrMore (throws)\r\nSeq.tryOneOrMore\r\nSeq.tryZeroOrMore\r\nThe reason it is better to have these in FSharp.Core is that, if one implements these by hand, it requires at least two iterations until the 2nd element. An optimized implementation may prevent this.\r\nSee also the discussion here: http://stackoverflow.com/questions/39628567/non-throwing-version-of-seq-exactlyone-to-test-for-a-singleton-sequence",
        "Votes": 4,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16402732": {
        "Number": "16402732",
        "Submitter": "lee",
        "Submitted": "2016-09-28T00:00:00",
        "Title": "Allow static optimization conditionals",
        "Text": "If we write the code as below, we will get a compile error: Static optimization conditionals are only for use within the F# library\r\nlet inline toBytes (x : ^a) : byte[] =\r\n(^a : (static member ToBytes : ^a -> byte[])(x))\r\nwhen ^a : byte = [|retype x : byte|]\r\nwhen ^a : string = System.Text.Encoding.UTF8.GetBytes(retype x : string)\r\n\r\nBut allow \"static optimization conditionals\" is very useful, which allow us avoid to use those tricks like \"Simple typeclass implementation\". http://www.fssnip.net/9B",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Gusty",
                "Submitted": "2016-10-01T16:33:00",
                "Content": "I'm not sure type inference will work well by only allowing static optimizations outside the F# library.\r\nIf you look at the source code of the F# compiler there are many particular cases introduced in order to get simulated members working and inferred.\r\nIn your example calling toBytes with byte will not type check because byte doesn't have a ToBytes static member.\r\nAnyway there seems to be a better way to implement type classes in .NET http://www.mlworkshop.org/2016-7.pdf?attredirects=0"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "16448692": {
        "Number": "16448692",
        "Submitter": "Mark Seemann",
        "Submitted": "2016-10-01T00:00:00",
        "Title": "Allow fun arrows to start after a line break",
        "Text": "As described here: https://github.com/Microsoft/visualfsharp/issues/1551",
        "Votes": 2,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16476649": {
        "Number": "16476649",
        "Submitter": "Marko Grdinic",
        "Submitted": "2016-10-03T00:00:00",
        "Title": "Record copy update should be able change the generic type",
        "Text": "type A<'a> =\r\n{\r\nmutable x: 'a\r\n}\r\nlet a = {x = 1}\r\n{a with x=\"Hello\"} // Type error\r\nSince the x field is generic and F# is type safe, it would not be bad if the above was valid.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16482547": {
        "Number": "16482547",
        "Submitter": "Matt",
        "Submitted": "2016-10-03T00:00:00",
        "Title": "Provide Intellisense on 'tab' key when creating 'new' classes or types.",
        "Text": "I would like to have the ability to hit the \"tab key\" when creating a new type with a constructor that will list the types available properties.\r\nI C# this is done nicely with classes and as you assign a value the property is no longer available in intellisense when one tabs again to select another property.",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16514236": {
        "Number": "16514236",
        "Submitter": "Musa",
        "Submitted": "2016-10-05T00:00:00",
        "Title": "1-spit Assembly code (or LLVM code) in Repl on each highlighted code piece, for visibility into debugging eg. tail calls, speed of executioa",
        "Text": "",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16526545": {
        "Number": "16526545",
        "Submitter": "lr",
        "Submitted": "2016-10-06T00:00:00",
        "Title": "Allow Object Expressions from abstract base classes without members",
        "Text": "http://stackoverflow.com/questions/8154730/object-expression-for-abstract-class-without-abstract-members\r\nObject Expressions are a great feature to create instances of single-use interface / abstract class instances without polluting the namespace.\r\nAt the moment it is impossible to inherit from an abstract class which does not define any members.\r\nIf I have an abstract base class\r\n[<AbstractClass>]\r\ntype Foo(i:int) = class end\r\nthen I would like to be able to exten it like this:\r\nlet foo = { new Foo(1) }\r\nBut this errors out with\r\nInvalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces.\r\nThe suggestion obviously doesn't work, since the base type is abstract.\r\nThe workaround is to define it like this:\r\nlet foo = { new Foo(1) with member __.ToString() = base.ToString() }",
        "Votes": 1,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "16529041": {
        "Number": "16529041",
        "Submitter": "Krzysztof Cieslak",
        "Submitted": "2016-10-06T00:00:00",
        "Title": "Close User Voice in favor of GitHub issues.",
        "Text": "I really believe we should close UserVoice in favor of using GitHub issues (maybe separate repository for it? ). Here are few reasons for it:\r\n* Bad UX\r\n* Need to monitor and maintain separate communication channel\r\n* No comment editing\r\n* No markup for code samples\r\n* No markdown\r\n* Can't embed images\r\n* No mentions and notifications\r\n* Only 10 votes which reduce people ability to vote (especially in so old project as F# - many people already used all their votes over the years)\r\n* No more fake accounts to workaround votes limit\r\n* God damn this text editor (writing long message [like this] i terrible in editor showing 5 lines)\r\n* GitHub issues can be labeled, milestones can be added, new projects feature can be used\r\nSimilar move was done by VSCode Team - https://code.visualstudio.com/blogs/2016/08/19/goodbyeuservoice - and I strongly believe we should do the same.",
        "Votes": 226,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-10-06T15:48:00",
                "Content": "+1M"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-10-06T15:57:00",
                "Content": "Well, someone would need to move all the items, votes, history, discussion and start to chase down incoming links. I don't think it's simple. Having done it once (when extracting F# User Voice from the Microsoft-specific Visual Studio user voice) I don't fancy doing it again, it was a huge job."
            },
            {
                "Submitter": "Reed Copsey, Jr.",
                "Submitted": "2016-10-06T15:59:00",
                "Content": "Don - I suspect that, with your blessing, we could coordinate that and make most of that happen.\r\nThe largest roadblock would be moving votes, since people can't add votes from other accounts. To be honest, I question the value of the votes on here in general, though, as the way voting works on user voice is incredibly problematic anyways."
            },
            {
                "Submitter": "Krzysztof Cieslak",
                "Submitted": "2016-10-06T16:01:00",
                "Content": "I'm pretty sure we can create script using cannopy or HTML TP to get all info from UserVoice and then add it to GitHub using their API :)"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-10-06T16:10:00",
                "Content": "There are literally no advantages (at least from our perspective) to using uservoice over github.\r\nAnother advantage of github that wasn't mentioned is the ability to link directly to a specific comment in the thread.\r\nAnother small github advantage is that the comments are listed oldest -> newest, unlike uservoice where you have to go to the end of the thread and read backwards. If your post ends up exceeding the length limit on uservoice you need to split it up and post it backwards so it reads sensibly to other users.\r\nThis site is a wellspring of frustration; the lengths we need to go through (e.g. using (****) to replace whitespace so code examples can be copied and pasted without tons of tedious indenting) distracts from focusing on the content of posts.\r\nI don't think the suggestions should be moved over to the visualfsharp or the fsharplangdesign repo. A new FSharpLangSuggestions or FSharpLangEvolution repository should be dedicated to this role.\r\nI'll even do the grunt work of copying over all of the planned, under review, and started issues if that makes it easier to switch over."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-10-06T17:19:00",
                "Content": "@JaredHester - We would use \"FSharpLangSuggestions\" or (\"fsharp-lang-suggestions\" to use more modern repo casing - we should probably rename FSharpLangDesign to fsharp-lang-design assuming the redirects work as expected). This collection is deliberately informal: suggestions, and _not_ actual RFCs. I want that distinction.\r\n@JaredHester Closed suggestions would need to be copied over as well. Also the text giving the resolution.\r\n@ReedCopsey - the vote counts are definitely valuable. The voting is only indicative anyway."
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-10-07T02:57:00",
                "Content": "A suggestion posted today mentions \"No more fake accounts to workaround votes limit\" and has 142 votes. Nice practical illustration of why UserVoice votes aren't *actually* all that reliable. :-)\r\nAnd I would throw 3 votes at this too, except my 10 votes are all used up -- on features I do care about, so I don't want to move them."
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-10-07T02:58:00",
                "Content": "And since I can't edit my previous comment to add what I forgot to mention, I'll add a new comment to mention it:\r\nI also am 100% in favor of moving to GitHub, and I don't mind re-creating my votes on the issues I've already voted on."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663042": {
        "Number": "5663042",
        "Submitter": "UserVoice Team",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Seed this forum with your ideas",
        "Text": "UserVoice pro tip #1:\r\nYour customers are full of ideas, but people are more likely to contribute if they're not among the first. Add your own ideas now!",
        "Votes": 3,
        "Comments": [],
        "Status": "completed",
        "Response": null
    },
    "5663074": {
        "Number": "5663074",
        "Submitter": "knocte",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Enable a compiler-warning when a recursive algorithm is not tail-recursive",
        "Text": "Add an TailRecursiveAttribute to enable a compiler-warning when a recursive algorithm is not tail-recursive. This should ideally also cover recursive seq { .. } and async { ... } expressions.",
        "Votes": 308,
        "Comments": [
            {
                "Submitter": "Phillip Trelford",
                "Submitted": "2014-03-21T07:30:00",
                "Content": "A compiler warning/error would be useful when you require your function to be tail recursive but it is not, perhaps a tailrec keyword could be used in this case, i.e.\r\nlet tailrec myfunc = // ..."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2014-03-21T07:42:00",
                "Content": "@Phillip: as far as I understand, it's always desirable to be tail-call-friendly, otherwise you might get StackOverflowExceptions if there are many iterations, right?"
            },
            {
                "Submitter": "Phillip Trelford",
                "Submitted": "2014-03-21T07:46:00",
                "Content": "@Anonymous it's desirable to be tail recursive but not always necessary, a blanket warning on all existing code might be a bit harsh. An attribute or keyword where you explicitly expect tail recursion might be more forgiving."
            },
            {
                "Submitter": "Andrew Khmylov",
                "Submitted": "2014-03-21T09:54:00",
                "Content": "Philip, introducing another `tailrec` keyword doesn't sound like a good idea. It would make the code a lot more verbose IMO. I would rather get rid of `rec` keyword at all. I think the compiler is smart enough to figure out that the function is actually recursive, why should I type it myself?"
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T10:02:00",
                "Content": "@Andrew: \"I think the compiler is smart enough\"\r\nConsider:\r\nlet f n = n+1\r\nlet f n = f(n-1)\r\nis the latter definition of \"f\" recursive? Obviously it is impossible to tell. Hence the existence of the \"rec\" keyword.\r\nThe alternative is to make everything recursive but then you must pollute your namespaces with, for example, \"f1\" and \"f2\" because you cannot supercede previous definitions."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T10:05:00",
                "Content": "How would we handle mutual recursion or recursion via a function that was passed in?\r\nFor example:\r\nlet rec even n =\r\nodd(n-1)\r\nand odd n =\r\neven(n-1)\r\nor:\r\nlet evenOne odd n = odd(n-1)\r\nlet oddOne even n = even(n-1)\r\nlet rec even n = evenOne (oddOne even) n\r\nCould we put this attribute on an entire module to check that all loops within the module require bounded stack space?"
            },
            {
                "Submitter": "knocte",
                "Submitted": "2014-03-21T14:56:00",
                "Content": "@Philip, aha I understand. But I think if such keyword is proposed, I think it would be better if it's for opting-out the warning than opting-in."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-03-23T02:46:00",
                "Content": "@Andrew Khmylov I cannot agree because imo `rec` is not for the compiler, it is for us, and to me very necessary.\r\nFor instance when you re-bind a symbol for a function, to a function that uses it, how would you express yourself without using `rec` if you intend to call the previous binding or the new (recursive) one?"
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-03-23T02:50:00",
                "Content": "I agree with Philip on the keyword, it seems much more cleaner than an attribute."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-29T09:14:00",
                "Content": "Requiring the compiler to warn you when an entire algorithm is not tail-recursive poses a significant challenge, as Jon and others have pointed out.\r\nIf you relax the definition of this feature request to something like \"emit a compiler warning for non-tail-recursive call sites within a 'rec' function\", this becomes fairly simple to implement. In addition, you don't need additional keywords or functions to implement this -- it could be a standard compiler warning which is on by default, which means it'd be easy to turn off for those who wanted to do so."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-29T14:07:00",
                "Content": "I put together a little code sample demonstrating my proposal (see previous comment): https://gist.github.com/jack-pappas/9860949\r\nTo elaborate a bit: the compiler would emit a warning at each call site to a function which shares the same stack frame as the current function -- in other words, when a function is calling itself, or some other function within a group of mutually-recursive functions."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2014-04-03T15:45:00",
                "Content": "@Jack: awesome work!"
            },
            {
                "Submitter": "bleis-tift",
                "Submitted": "2014-04-03T23:42:00",
                "Content": "F# has tailcall keyword as reserved-ident-keyword.\r\nSo I think that the keyword is better than tailrec."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T12:18:00",
                "Content": "I am generally in favour of addressing this in F# 4.0. I would want seq { .. } and async { ... } tailcalls to also be addressed.\r\nA more detailed design is needed and some trialling would be great. Jack's work is a great start.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest.\r\nI encourage you to consider continue working towards a detailed proposal and a propopsed implementation. I will gladly help.\r\n\r\nI would tend towards using an attribute rather than a keyword, despite the fact that \"tailcall\" is reserved, simply because that is how things like this are generally added to the F# language since F# 2.0.\r\n[<TailCall>]\r\nlet rec f x = .... f (x-1)\r\n[<TailCall>]\r\nlet rec f x = .seq { ... yield! f (x-1) }\r\n[<TailCall>]\r\nlet rec g x = .async { ... return g (x-1) }\r\nWith regard to Jon's question - the checking would be much as described by Jack - i.e. only w.r.t. the control flow contructs that are syntactically present in the F# expression language (and hot combinator encodings of these).\r\nAll uses of an attributed function within its recursive scope would need to be in tail position. Thus passing the function as a higher-order argument would not be allowed.\r\nThis limts the utility of the method of course but it still remains useful, especially for beginners and teaching purposes."
            },
            {
                "Submitter": "Eriawan Kusumawardhono",
                "Submitted": "2014-09-02T22:29:00",
                "Content": "This tailcall CLR and recursive implementation should be transparent to the language, especially F#.\r\nMeaning that not only adding keywords or IDE realtime warning, but also should be available in other languages other than F# as well to use if there's a need to optimize recursive function calls.\r\nI vote +2 for this!"
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T08:30:00",
                "Content": "I would be in favour of using the keyword, the attribute looks much more verbose..."
            },
            {
                "Submitter": "Eriawan Kusumawardhono",
                "Submitted": "2014-09-25T23:16:00",
                "Content": "I agree to use the attribute. This will give different meaning and also context is more verbose than keyword.\r\nThis will also minimize confusion whether a rec function is actually tailcall optimized or not."
            },
            {
                "Submitter": "James Hugard",
                "Submitted": "2014-11-06T02:09:00",
                "Content": "I'm in agreement with Jack Pappas: use neither a keyword nor attribute; simply always issue a warning. In other words, relax the feature request to be:\r\n\"F# compiler emits a warning at each non-tail recursive call site where a function is calling itself or some other function defined within a group of mutually-recursive functions.\"\r\nIt is obviously bad practice, in general, to make non-tail calls to oneself or one's siblings due to the potential of a stack overflow. Therefore, such usage should be strongly discouraged by default and not only when a specific keyword modifier or attribute is supplied. Doubly so because beginners are more likely to make mistakes here and not even know to use a modifier or attribute as a compiler assist.\r\nFor cases where one accepts the risks, the warning could easily be disabled.\r\nThe documentation for that warning, though, would probably run to the long side; e.g., explaining how one could make the code tailcall friendly."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-06T19:05:00",
                "Content": "James/Jack, there are many cases where non-tail recursive calls are required and normal, for example consider Map.add https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/map.fs#L120\r\nIn this case the depth of recursion is bounded by log(n) on the size of the input."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-11T13:22:00",
                "Content": "I have started prototyping this, https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup?branch=tailcall-warning"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T17:53:00",
                "Content": "I second the the idea of always issuing a warning. You can always disable it with an in-place compiler directive if you really don't require tail-recursion."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-05-10T16:32:00",
                "Content": "It is really \"#1 must be\" all this recursive stuff got failed on a big data if not optimized, but some times it is nontrivial to check is it ok or not."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "I am generally in favour of addressing this in F# 4.x+. I would want seq { .. } and async { … } tailcalls to also be addressed.\r\nA more detailed design is needed and some trialling would be great. Jack’s work is a great start. However, this is not an easy piece of work to do in a non-invasive way and my own experiments in this area have not yet led to something I feel confident to include in the F# language design.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nCurrently, initial implementations of approved language design can be submitted as pull requests to the appropriate branch of https://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for info on how to contribute to the F# language/core library design\r\nI encourage you to consider continue working towards a detailed proposal and a proposed implementation. I will gladly help.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5663116": {
        "Number": "5663116",
        "Submitter": "Alex Rønne Petersen",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Featurize static optimization literals",
        "Text": "I understand that the inline IL feature is discouraged because it depends on compiler implementation details, but it seems like static optimization literals would be genuinely useful and also portable across (potential) compilers, yet they are currently disallowed outside of the core library.\r\nWould it make sense to featurize them so they're usable everywhere?",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-21T17:53:00",
                "Content": "Inline IL is interesting, but it should always be discouraged because we don't need a habit of using it. If we use F#, it should be just F#. The kind of optimizations that you would want to gain from inline IL, the F# compiler optimizer should give you that. If it can't, then a change to the optimizer would be needed."
            },
            {
                "Submitter": "Alex Rønne Petersen",
                "Submitted": "2014-09-27T03:31:00",
                "Content": "Just to be clear, inline IL is a separate thing from static optimization literals. What I meant is that while inline IL should not be featurized, static optimization literals are perfectly useful and portable - I see no reason that those should be disallowed outside FSharp.Core.\r\nI worded it that way originally because FSharp.Core tends to use inline IL alongside static optimization literals, but static optimization literals are useful in more general situations too."
            },
            {
                "Submitter": "Michael",
                "Submitted": "2014-11-12T17:34:00",
                "Content": "Yes and they should have the syntax streamlined, too. I should be able to write:\r\nlet inline foo f (x: ^a) = x.Foo f\r\nAnd have it \"just work\" and infer the syntax. Versus having to use the strange member-accessing syntax for every member used.\r\nAlso, lambdas should be inlineable. I should be able to do \"xs |> iter (fun x -> x + 1)\" and have it compile to equivalent code as if I just did a loop."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:08:00",
                "Content": "I agree that lamdas should be inlined."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T11:21:00",
                "Content": "This feature is unsafe to use and can interact badly with type inference and generalization if used incorrectly. For this reason we definitely decided to keep it to be FSharp.Core-only in F# 1.0 onwards.\r\nMy inclination is to stick with this decision since there's been no specific change of circumstance."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663194": {
        "Number": "5663194",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Extend named DUs syntax to allow to use multiple names in a name match",
        "Text": "Currently when I have a DU like this:\r\ntype DU =\r\n| Case1 of prop1:string * prop2:ing * prop3:bool\r\n...\r\nI can pattern match like this:\r\n| Case1(prop1 = \"foo\")\r\nbut I can't like this:\r\n| Case1(prop1 = \"foo\", prop3 = false)",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T09:54:00",
                "Content": "Note you can do this via a semi-colon\r\n| Case1(prop1 = \"foo\"; prop3 = false)\r\nBut I agree, this would be better allowed using a comma. The use of semicolon was a design oversight during the implementation of F# 3.1"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T10:10:00",
                "Content": "Ah, didn't know about that, both the F# 3.1 announcement post (http://blogs.msdn.com/b/fsharpteam/archive/2013/06/27/announcing-a-pre-release-of-f-3-1-and-the-visual-f-tools-in-visual-studio-2013.aspx) and the msdn docs (http://msdn.microsoft.com/en-us/library/dd233226.aspx) don't mention that\r\nI'm happy with the semicolon, it just needs to be better documented as I doubt many people know about it"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T11:41:00",
                "Content": "I've updated the blog post with a note about this. Please add feedback to the MSDN docs."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-03-21T00:00:00",
            "Text": "This is already in F# 3.1, as noted, closing to recycle votes"
        }
    },
    "5663202": {
        "Number": "5663202",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow to define types at expression scopes",
        "Text": "The suggestion is to allow \"type X = ...\" in an expression, e.g.\r\nlet f () =\r\ntype X = A | B\r\nlet x = (A,A)\r\nlet y = (B,B)\r\nif (x=y) then true else false",
        "Votes": 36,
        "Comments": [
            {
                "Submitter": "Phillip Trelford",
                "Submitted": "2014-03-21T08:09:00",
                "Content": "At a minimum type aliasing at local scopes as per C++ typedef would be really handy. Nested type declaration would also be nice."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T13:12:00",
                "Content": "The technical questions that arise are\r\n(a) can these include full type definitions - including members? If so, can these capture values from scope?\r\n(b) can these types appear in the inferred type of the function?"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-10-26T17:24:00",
                "Content": "(b) Should not be possible, as these types should be private to the function, so an error should be issued on that case\r\n(a) Yes, they should be full type definitions. Capturing values from scope would be an added bonus, but would be also ok if that wasn't supported, I guess."
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-10-26T17:27:00",
                "Content": "Actually, even if members weren't allowed this would be already very useful. On local scope we usually use a lot of tuples, and refactoring to records or DUs is usefull, but it's a bit annoying that you have to do that at global scope"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-27T02:46:00",
                "Content": "This is now it's implemented in D https://gist.github.com/vasily-kirichenko/95a2cabfba599884b61d\r\nSo, no-static types can capture local variables and cannot escape the function scope."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:04:00",
                "Content": "What if only type aliases were allowed?"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2016-07-22T05:38:00",
                "Content": "This was also added to TypeScript: https://www.typescriptlang.org/docs/release-notes/typescript-1.6.html"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2016-07-22T05:38:00",
                "Content": "Type aliases only would help a bit but not really solve the problem completely. Having local records and DUs would be much better"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-07-24T13:58:00",
                "Content": "I was surprised to find this isn't inherently supported, when I first coded it it seemed quite natural because I can declare an inner function within a parent function and the inner function is known only within that parent, I added a simple enum type - also within some parent function and the compiler complained."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663215": {
        "Number": "5663215",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Optional and named parameters on let bindings on modules",
        "Text": "Optional and named parameters are supported in static methods, but not in let bindings on modules. This many times forces you to use a static class instead of a module, which has some inconvenients. Ocaml has this, so I'm guessing is doable.",
        "Votes": 128,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T08:26:00",
                "Content": "Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/5592336-optional-parameters-on-let-bindings-on-modules"
            },
            {
                "Submitter": "Andrew Cherry",
                "Submitted": "2014-03-21T09:42:00",
                "Content": "A fairly similar syntax of let functionName ?(parameterName: [type]) () = [...] seems like it would work if parameterName became type option? That would seem like it would fit with defaultArg still, etc..."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T10:07:00",
                "Content": "OCaml is rather grim in this respect. They got too fancy and let you have optional curried arguments that support partial specialization which leads to all kinds of inconveniences.\r\nI would like optional non-curried arguments to let-bound functions though."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T08:13:00",
                "Content": "OCaml does have this, so it is possible -- but as Jon H. pointed out, it's very easy to make this feature \"too powerful\" and ultimately cause more problems than it solves.\r\n+1 for Jon's suggestion that if this were implemented, it should only be for let-bound functions using the tupled argument style. I think that would provide a good compromise because you'd be able to write let-bound functions in modules in exactly the same way you're writing methods in static classes now (sans overloading), without introducing the complexity of optional curried arguments or type inference when using named arguments."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2014-09-08T16:44:00",
                "Content": "Does named parameters have similar drawbacks as optional parameters (mentioned by Jon)? If not, would definitely see named parameters supported for curried let-bound functions.\r\nThis would remove a fairly common annoying case in pipelines, where I find myself having to use lambda expression (e.g. \"... |> fun param -> someFunc a b param c) instead of partial application (\"... |> someFunc a b c\"), because the pipelined variable isn't the last argument of the function. With named parameter I can use the parameter name to override the parameter order, at the same time increases clarity of code."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2015-03-12T16:04:00",
                "Content": "It seems like this might ruin the symmetry between tupled function parameters and actual tuples, unless it could be that when you create tuples you can do the same thing, and that seems to come with a host of other problems. What if you could describe function parameters more like records and extend records to allow optional construction parameters?"
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2015-03-12T16:40:00",
                "Content": "Also, would we allow overloading in the context of these special module functions? If not it's still not a replacement for actual static classes."
            },
            {
                "Submitter": "Eric Stokes",
                "Submitted": "2015-12-24T13:26:00",
                "Content": "Coming from OCaml this is by far the thing I most want in F#. I am often forced into using a static class when what I really want is a module containing a type and some operations on that type. I'm not sure I agree that OCaml's optional/labeled implementation is \"too powerful\", for example curried optional arguments could be very useful in a pipeline, it seemed if we forced them to be tupled we'd mostly lose that."
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2016-05-18T07:38:00",
                "Content": "Having this will be tremendously beneficial when parsing TypeScript files to be used by Fable. Currently an extra type must be created to translate module functions in TypeScript with optional or ParamArray arguments."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-05-27T10:11:00",
                "Content": "This would be an excellent addition to the language, using the tupled argument style."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-28T00:41:00",
                "Content": "related - [/ideas/suggestion-13887384-support-for-named-curried-functions](/ideas/suggestion-13887384-support-for-named-curried-functions.md)"
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5663252": {
        "Number": "5663252",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Extended record with syntax to work with nested properties",
        "Text": "let's say we have the following:\r\ntype RecordA =\r\n{ A : int\r\nB : string }\r\ntype RecordB =\r\n{ A : bool\r\nB : RecordA }\r\nlet a = { A = false\r\nB = { A = 2\r\nB = \"foo\" } }\r\nand want to update that 2 to a 3.\r\nCurrently, we need to do this:\r\nlet a' = { a with B = { a.B with A = 3 } }\r\nwhich doesn't scale to more complex types\r\nIt would be nice to have something like\r\nlet a' = { a with B.A = 3 }\r\nor something similar\r\nIt would also be nice to be able to have something similar with DUs:\r\ntype DU =\r\n| Case of p1:int * p2:string\r\nlet a = Case(1, \"foo\")\r\nlet a' = { a with p1 = 2 }",
        "Votes": 35,
        "Comments": [
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2014-03-22T03:40:00",
                "Content": "This sounds like a good idea.\r\nApologies if I don't understand this well enough, but isn't this really asking for Lenses in F#? http://bugsquash.blogspot.dk/2011/11/lenses-in-f.html"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:56:00",
                "Content": "I am going to close this in favour of [/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f](/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f.md)\r\nThat doesn't mean we would implement first-class lensing. But I think the linked issue opens up several important parts of the design discussion, for example how would this work on class types that are not record types (and also how would this work for collection types). At least we should look at the topic of functional update a bit more holistically than this specific request, even if in the end this is all we do."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Closed in favour of [/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f](/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f.md) per comment below\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663255": {
        "Number": "5663255",
        "Submitter": "Colin Bull",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow infix notation on functions",
        "Text": "",
        "Votes": 32,
        "Comments": [
            {
                "Submitter": "Steve Gilham",
                "Submitted": "2014-04-10T04:11:00",
                "Content": "This is an ML feature, so is not something new to the language familty\r\nWhether this is done by something like an #infix pragma (there being no suitable reserved keyword), or by a compiler flag that allows functions named `op_<whatever>` to be invoked as infix operators `<whatever>` (inverting the current behaviour where operators compile to functions `op_<something>` which can be invoked by that mangled name in prefix -- or even allows things like `let (myOperator) = ...` compile to infixable `myOperator` and prefixable `op_myOperator` for arbitrary identifier `myOperator`."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:59:00",
                "Content": "We decided in F# 1.0 not to allow fixity to depend on scope, and that like OCaml we would have a fixed set of precedences. This simplifies the implementation and also means that parsing is independent of the set of files referenced or namespaces opened.\r\nMy inclination is to apply the rule that nothing specific has changed that would lead us to revisit this decision, so we should stick with it."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marking as declined per my comment below"
        }
    },
    "5663267": {
        "Number": "5663267",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Support Provided Union and Record Types",
        "Text": "",
        "Votes": 108,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T08:30:00",
                "Content": "What limits you from generating DUs and Records in type providers now? Is the limitation in the F# compiler itself, or in the ubiquitous ProvidedTypes.fs? If it's the latter, this feature could be implemented through a community effort."
            },
            {
                "Submitter": "Keith Battocchi",
                "Submitted": "2014-04-10T08:21:00",
                "Content": "@Jack - it's a compiler limitation (there's no way to provide the metadata that the F# compiler uses to recognize F#-specific types)."
            },
            {
                "Submitter": "mavnn",
                "Submitted": "2014-05-07T04:45:00",
                "Content": "Yes please for this one; let's allow TPs to create idiomatic F# apis!"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:35:00",
                "Content": "I plan to mark this feature as \"approved in principle\" (it will show as \"planned\"). It would be great if it were done.\r\nHowever, in reality it is both relatively low priority and relatively hard to implement, so I don't expect this to happen any time soon.\r\nFor example, we would have to reverse-map the metadata associated with F#-specific types. This is already done in F# reflection FSharpType.IsRecord and so on."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marking as “approved in principle” (it will show as “planned”).\r\nHowever, in reality it is both relatively low priority and relatively hard to implement, so I don’t expect this to happen any time soon.\r\nFor example, we would have to reverse-map the metadata associated with F#-specific types. This is already done in F# reflection FSharpType.IsRecord and so on."
        }
    },
    "5663288": {
        "Number": "5663288",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow type providers to report warnings to the compiler",
        "Text": "",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-06-28T13:26:00",
                "Content": "Maybe if the class that implements ITypeProvider has a public event named \"WarningGenerated\" or something like that, the compiler could plug into it and listen. It's a bit hack-y, but as there is a canonical implementation of ITypeProvider in TypeProviderForNameSpaces, we could create a method there called \"EmitWarning\", and hide how it's implemented, so there would not be a requirements for a specific FSharp.Core.\r\nUnfortunately, I'm not remembering the case I was thinking about that I wanted to generate a warning on. I think it was in CsvProvider, but can't remember exactly"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:01:00",
                "Content": "I also think that this would allow for many more interesting use cases for type providers."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "This is approved-in-principle for F# 4.x+\r\nA detailed design is needed. I would prefer one that is idiom-based and doesn’t force type providers to use a later FSharp.Core.dll\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5663298": {
        "Number": "5663298",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Improve optional parameter interop between F# and C#",
        "Text": "It would be nice if the F# compiler automatically inserted [<Optional;DefaultParameterValue(null)>] in all optional parameters of methods declared in F# classes, so they would be easier to use from C#\r\nIt would also be nice if the constructors of records also used this for parameters of type Option<_>",
        "Votes": 20,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T08:26:00",
                "Content": "Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4519990-improve-optional-parameter-interop-between-f-and"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "This proposal is “approved in principle” for F# 4.x+\r\nIf you would like to submit an implementation and testing, please submit to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details about contributing to the F# language and core library\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5663302": {
        "Number": "5663302",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Support 'protected' access modifier for F#",
        "Text": "Original item: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2262739-support-protected-access-modifier-for-f",
        "Votes": 98,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T08:40:00",
                "Content": "This is one feature I'd really like to see in F#, and it seems like it should be very simple to implement. If the 'protected' modifier was omitted from the language to nudge developers away from OO-style code, I think that may have been the wrong way to go about it, because it makes it impossible to re-implement OO-heavy C# projects in F# in such a way that the change is transparent to any consumers. Consequently, I've had to pass on using F# to replace some C# projects -- the downside of having to re-architect large parts of an existing codebase because F# classes can't declare 'protected' members is very often going to outweigh any upsides that could be had from re-implementing a single project in F#."
            },
            {
                "Submitter": "Blair Davidson",
                "Submitted": "2014-08-04T07:40:00",
                "Content": "Please do this. It make using OOP facilities such in F#."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-08-05T07:01:00",
                "Content": "I concur that we need fuller support of .net type system."
            },
            {
                "Submitter": "Troy Robinson",
                "Submitted": "2015-08-11T01:30:00",
                "Content": "Scala has it. C# has it. Let's do it! I can't replicate certain classes in my arsenal without it!"
            },
            {
                "Submitter": "Surya Halim",
                "Submitted": "2015-09-10T13:59:00",
                "Content": "I concur with this suggestion. IIRC, one of the reasons given was the access of protected data member defined in base class inside a closure caused very tricky situation because the closure technically should not be able to access the data member. C# solved this through clever compiler trick. Why can't this clever compiler trick be applied to F#? Will it defeat the type soundness of F# as a programming language?\r\nI love F# for being a non-dogmatic functional-first programming language and this missing feature does indeed dampen the expectation a little."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663317": {
        "Number": "5663317",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow to use class constructors as functions",
        "Text": "DU case constructors can be used as standalone functions, which means I can use them in partial application:\r\nx |> List.map Some\r\nThe same isn't currently allowed on class constructors:\r\nx |> List.map Uri\r\nFor this examples is not a problem, but in some real life scenarios is annoying to have to create wrapper functions",
        "Votes": 124,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T09:42:00",
                "Content": "Yes, this would be very useful. Strange that you can \"|> set\" for a set but you have to do \"|> fun kvs -> Map kvs\" for a Map."
            },
            {
                "Submitter": "David Grenier",
                "Submitted": "2014-06-25T08:51:00",
                "Content": "Curious to know how difficult it would be to extend efforts in this area to allow DUs with \"multiple argument\" work like Haskell and spare us the need for a tuple? I feel this latter feature is even more useful than the former, esp. with respect to pattern matching."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-06-27T13:46:00",
                "Content": "I think this is a reasonable idea, one thing I've done in the past is to make a factory function with the same name as the class in the same module. This seems to work fairly well (if my memory serves)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-10T10:05:00",
                "Content": "An implementation of this feature has now been submitted here: https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7104"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-10T10:11:00",
                "Content": "Note that after this change, the names \"Set\" and \"Map can be used, since they are type names in an auto-opened part of the FSharp.Core library, for example:\r\nlet f3() = [\"a\"] |> Set\r\nlet f4() = [(\"a\", 4); (\"b\", 5) ] |> Map\r\nThis is quite regular.\r\nHowever this does raise the question as to whether the pervasive function \"set\" (lower case) should be deprecated: it's precisely the same as the above. It is better to have only one way to do things."
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-07-10T10:41:00",
                "Content": "Will it also work when there's more than one param and/or multiple overloads?\r\nThe lower case set (and possible other similar functions) will become redundant, but that shouldn't be a big deal IMHO. There's other things that are way more annoying (like partial application unfriendly param order on Array.get, defaultArg and others because of ocaml compat).\r\nI wouldn't deprecate as it's probably used a lot"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-12T00:00:00",
            "Text": "This is now completed and available in preview releases of F# 4.0.\r\nFor an early Visual Studio preview release see here (cross platform releases will follow) – http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663326": {
        "Number": "5663326",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Syntax for turning properties into functions",
        "Text": "When we have F# records and classes (including the ones generated by type providers), we end up having to write things like this a lot:\r\n(fun x -> x.Name)\r\nIt would be nice to have some shorthand for this, similar to what we can do with static members (but nicer than the Scala syntax please)",
        "Votes": 457,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T11:29:00",
                "Content": "Doesn't SML use something like #Name?"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-03-21T11:42:00",
                "Content": "I think (.Name) (with the parentheses) would be readable and non-ambiguous.\r\nOn the other hand, a syntax that includes the class name would mean not having to reorder code to please the type inference."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:49:00",
                "Content": "I don't think this goes far enough. It would be nice to have some kind of first class typed handle to properties so we could more easily compose lenses for updating records as well."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T18:29:00",
                "Content": "You know, it might just be ideal to have some kind of auto generated lenses as in http://bugsquash.blogspot.com/2011/11/lenses-in-f.html\r\nAlthough, it would be ideal to be able to compose them in such a way as to avoid having to reallocate for each and every update to the same record."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-21T18:43:00",
                "Content": "I agree, that having auto generated lenses would be very nice. However, when we were generating lenses in our project, the mentioned approach turned out to be too weak to be very useful.\r\nWe ended up using partial lenses instead. The idea is, that with partial lenses you can create lenses for a specific case of a DU, as well as a field of a record, a component of a tuple or even an item in a list."
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-03-22T00:17:00",
                "Content": "This has been on my wish list for quite some time. I don't think the Scalar syntax is that bad, but I would prefer \" # \", as Jon Harrop suggested."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T19:16:00",
                "Content": "@Daniel Fabian: I don't think you can compare lenses with partial lenses like that... partial lenses are for sums, \"regular\" lenses are for products. You wouldn't use a partial lens for a record field or a tuple. (the definitions I use are the ones in http://dl.dropboxusercontent.com/u/7810909/media/doc/lenses.pdf )"
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-25T03:29:00",
                "Content": "With partial lens, I meant { Get: 'T -> 'U option; Set: 'U -> 'T -> 'T }. And it works out perfectly fine also for tuples or records.\r\nThe idea being, we use the partial lenses for zooming somewhere deep into the object graph and then doing an update. Obviously, if you have a product type, the 'U option is not the preferred signature, because you are always in the Some case.\r\nHowever, since our domain model is always a mix between DUs and records, the total lenses from your blog post or FSharpx were too constrained.\r\nWe just considered the lens to be a partial function that may or may not return a value. And when doing an update, the lens may or may not change something, depending on whether or not the lens triggered.\r\nA typical lens would look like this\r\n{ Get =\r\nfunction\r\n| Locator.Point2D (item1, item2) -> Some (item1, item2)\r\n| _ -> None\r\nSet = fun newValue union ->\r\nmatch union with\r\n| Locator.Point2D _ -> Locator.Point2D newValue\r\n| _ -> union }\r\nwe are using this in production and it works very much as desired. The signatures, I took from https://hackage.haskell.org/package/data-lens-2.10.4/docs/Data-Lens-Partial-Common.html\r\nIf you want make a lens for a product type, you just need to wrap it in an additional Some.\r\nAnd then the lens operators from FSharpx we adjusted to take into account the partial functions, so the compose will use Option.bind rather than function composition to compose two lenses, etc. But it works out nicely.\r\nIf you want to get rid of the 'T option, it could even be done so, that you lift a total lens to being a partial one, when combining it with a partial lens. And then with s some operator overloading this would also work out.\r\nWe didn't do this, though, because we use lenses to \"change\" some pre-existing object graph for the most part. And we felt like the occasional unpacking of the option was a small price to pay when compared to the added complexity of having a lot more overloads, adopting total lenses to make them partial etc.\r\nIf we were to extend the compiler though, I think making a distinction between total and partial lenses and properly lifting them on-demand might make sense."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-25T05:42:00",
                "Content": "I have always wanted this since I started using Linq some time ago when I wrote .Select(x => x.Name) for the 1000th time and thought \"There must be a shorthand for this - I'm actually reducing readability by giving this lambda variable a name\". I think that naming the variable in this case is giving completely irrelevant information that is actually detrimental to the readability.\r\nConsidering that this is one of the few times where F# is more verbose that C#, List.map (fun x -> x.Name) is even worse.\r\nMy favourite is the syntax that Livescript uses, where you can wrap a dot-access call in parens like it's an operator. The syntax in a complete example would look like this:\r\nlet lengths = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\r\n|> map (.Length)"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-25T05:59:00",
                "Content": "Incidentally, Livescript also allows you to do the equivalent of this:\r\n[\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\r\n|> List.filter (.Length >= 4)"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-28T11:16:00",
                "Content": "Another possibility for the syntax is to allow us to access instance methods and properties from a static context by passing in the instance as the last parameter. An existing example of this is the String.length property that is defined in the F# standard library, meaning that (given strings = [\"hello\"; \"world\"]) instead of\r\nstrings |> List.map (fun x -> x.Length)\r\nI can write:\r\nstrings |> List.map String.length\r\nThis would also be okay I think"
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-28T12:32:00",
                "Content": "You would have to find a way of avoiding ambiguities, though."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-10T20:54:00",
                "Content": "I believe the ideal syntax for this in F# would use precisely Loic's suggestion of -\r\n(.Name)\r\nThis should be usable for all the different types of members including record fields, properties, object members, et al. The alternative of -\r\n#Name\r\n- would be confusingly close to SML's, collide with OCaml's object member syntax, and too far afield from F#'s intended syntax."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-17T22:04:00",
                "Content": "After further thought, I want to provide an alternative to this suggestion. While the original proposer suggested turning record fields AND class properties into functions, I think only the former should be suggested due to the weakness of the type inferencer.\r\nConsider this -\r\ntype Record = { Member : int }\r\nfun record -> record.Member // This line compiles fine...\r\n(record.Member) // Therefore this syntax should remain a part of this proposal.\r\ntype Class (aMember : int) = let Member = aMember\r\nfun obj -> obj.Member // This line does NOT compile!...\r\n(obj.Member) // Therefore, this syntax should NOT be a part of this proposal.\r\nI think we should concentrate only on getting the syntax working for record fields, and then once that hurdle is cleared, we should consider making the proposed syntax work for the other things that the inferencer is not so handy with.\r\n* While I say the inferencer is weak in this case, I don't mean that as a critique. In fact, I think the weakness is beneficial and necessary to properly idiomatic programming in F#. A lot of people arbitrarily use classes in F# where a record would be more appropriate due to its functional idomaticy. Doing so confounds their API and pollutes the code of its end-users. Having the inferencer punish such practices by requiring noisy type annotations _is a good thing_. In doing so, we come to understand and respect the power of intelligent limitations."
            },
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2014-06-25T15:55:00",
                "Content": "Related request: Add Lens focus unfocus [/ideas/suggestion-6098767-add-lens-focus-unfocus](/ideas/suggestion-6098767-add-lens-focus-unfocus.md)"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-06T03:57:00",
                "Content": "Like Jon mentioned, first class selectors as described here would be perfect: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#records"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-06T04:00:00",
                "Content": "The #3 style tuple selector would also be amazing: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#tuples"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-07-10T06:22:00",
                "Content": "Great suggestion Gustavo - I like the idea of being able to use this shorthand:\r\ntype Something =\r\n{\r\none: int\r\ntwo: int\r\n}\r\nlet ones = someSetOfSomethings |> List.map (.one)"
            },
            {
                "Submitter": "Vladimir Matveev",
                "Submitted": "2014-07-10T18:52:00",
                "Content": "using # as a marker for selectors does not play nice with compiler directives: #identifier at the beginning of the line is used by them. Alternatively we can try to adopt something Scala like: use _.<name>. I've tried to implement it (http://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary?branch=selectors), looks kinda nice."
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T09:13:00",
                "Content": "I would back the idea of having (.Name) just as syntactic sugar (with Intellisense, please) for (fun x -> x.Name)"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-10-13T11:02:00",
                "Content": "Of all the suggestions, I like Gibson's last suggestion the most.\r\nList.map String.length\r\nwhere String.Length is the property and String.length the corresponding function. It looks functional, plays nice with type inference and it's unambiguous (because of the lower case). Parenthesis are already too overloaded in F# for my taste.\r\nTo avoid incompatibilities with existing code, it might even be better to indicate explicitly that this is actually an instance method turned into a static method by prefixing it with ` (accent grave) or ^ (circumflex):\r\nList.map String.`length\r\nor\r\nList.map String.^length\r\nso that these \"virtual\" static methods only appear in Intellisense when you type:\r\nString.`\r\nor\r\nString.^\r\nThese \"virtual\" static methods kind of feel like the inverse of C# extension methods, which turn static methods into \"virtual\" instance methods."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-10-13T11:04:00",
                "Content": "(...continuing previous post:) Or maybe even:\r\nList.map String#length"
            },
            {
                "Submitter": "Ovidiu Deac",
                "Submitted": "2014-10-25T17:49:00",
                "Content": "My thoughts:\r\n1. The property functions should be namespaced properly to avoid name collisions. For this reason I'm against the approach .PropertyName suggested below\r\n2. For starters doing it for record getters should be easy enough because one cannot define a record like this:\r\ntype Point =\r\n{\r\nx : int\r\ny : int\r\n}\r\n\r\nstatic member x p = p.x\r\n// Error FS0023: The member 'x' can not be defined because the name 'x' clashes with the field 'x' in this type or module (FS0023)\r\n...so if the above static member Point.x is automatically generated it shouldn't break existing code\r\nAs Bryan Edds suggested below, this should also encourage people to use records more instead of classes.\r\n3. I wouldn't bother with the setters for now. The field updates could be considered as a separate feature and it probably needs more consideration.\r\n4. From the syntax perspective I think Point.x looks the most fsharp-ish.\r\n5. If you want to extend that to classes and other functions I like Python approach that member functions are just static functions which take the self instance as the first parameter. This way I the method calls below are identical in Python:\r\nc = MyClass()\r\nc.memberFunction()\r\nMyClass.memberFunction(c)\r\nFor me that's simple and intuitive.\r\nI also like Robert Gibson's suggestion to put the instance parameter last for currying reasons."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-12-23T15:45:00",
                "Content": "To amend my previous comment, I have to say that I quite urgently would also like this functionality to work for non-record property getters now. This is because I now use type extensions to provide syntactically clean getters to dynamic record-style fields like so -\r\ntype Entity with\r\n____member entity.CharacterType = entity?CharacterType : CharacterType\r\n____static member setCharacterType (value : CharacterType) (entity : Entity) = entity?CharacterType <- value\r\nWith this, I can do this -\r\nlet ct = character.CharacterType\r\nand\r\nlet c = Entity.setCharacterType ct c\r\nI know this contradicts what I said earlier, but I need this functionality very badly. Doubly so in the face of needing first-class lenses in F# (that is, support for lensing with F# syntax rather than with a library - tho that is a different subject for the most part)."
            },
            {
                "Submitter": "Scott Wlaschin",
                "Submitted": "2015-01-01T19:36:00",
                "Content": "+1 to the \"(.identifier)\" syntax. Alternatively, extend the preexisting custom prefix operator syntax with (~identifier). You could even use the same syntax to create infix operators the same way, a la backticks in haskell.\r\nFor tuples you could use (.#1) (.#2) etc or if using tildes, (~1), (~2).\r\nAs to name resolution, surely you could use the same scoping rules as for members. That is, if \"x\" is a valid member name in the scope of Point, then (.x) is also a valid name when applied to Points. I don't know how type inference would work though..."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2015-01-15T05:42:00",
                "Content": "Nice to see you here, Scott!\r\nThis would be a wonderful addition to the language, and I don't see any problem with type inference. (.name) would work wherever (fun x -> x.name) would, e.g.\r\nSeq.map (.name) people // => Not okay\r\npeople |> Seq.map (.name) // => This is just fine\r\nI also have no problem with the tilde syntax. Perhaps then you could drop the parens? E.g.\r\npeople |> Seq.map ~name"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-02-08T18:45:00",
                "Content": "What if we allowed the underscore to represent missing arguments to a member (including the instance), in which case a function for applying those arguments would be produced? Then we could do the following:\r\ncustomers\r\n|> Seq.map _.Name\r\n|> File.WriteAllLines(@\"C:\\CustomerList.txt\", _)\r\nThis would allow us to partially apply ordinary CLR methods with more than one argument, something I have always wanted.\r\nI do still like the .Name syntax without the underscore, but that could be a special case (allow the underscore for the instance to be dropped).\r\nI also think more complex expressions like _.Address.State could be supported. In this case, the entire expression would become a function. This would be distinct from (_.Address).State which would be a compiler error since (_.Address) is its own function."
            },
            {
                "Submitter": "Greg Rosenbaum",
                "Submitted": "2015-03-14T19:15:00",
                "Content": "I think I prefer the #Property syntax, rather than the (.Property) syntax. This is mainly because I don't like extraneous parentheses. ~Property is also possible, but I tend to associate ~ with other things so it's a bit strange.\r\nIt would be great if it could be extended to instance methods, and not just properties. It would make chaining methods and module functions more convenient. Something like:\r\n\"blah\" |> String.replicate 2 |> #Substring 1"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-03-20T20:57:00",
                "Content": "I don't see why the parentheses would be necessary at all. Elm doesn't need them for its record accessor syntax, for instance: http://elm-lang.org/learn/Records.elm#access"
            },
            {
                "Submitter": "Dmítrij Jevgénijevič Ačkásov",
                "Submitted": "2015-07-19T06:43:00",
                "Content": "Dot is an operator probably?\r\n((.)Name)"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-09-27T06:45:00",
                "Content": "This functionality does exist in the form\r\n.... let inline _Data x = ( ^a : ( member Data: 'b ) x )\r\nWhich works in situations like -\r\n.... type Bottom = { Data:string }\r\n.... type Middle = { Data:Bottom }\r\n.... type Top = { Data:Middle }\r\n.... let top = { Data = { Data = { Data = \"bottom\" }}}\r\n.... let inline d3 x = ( _Data >> _Data >> _Data ) x ;;\r\n.... d3 top\r\n.... > val it : string = \"bottom\"\r\nThe suggested `.` notation seems like it might cause issues with partial application unless surrounded by parens, so it's probably better to use a different operator as a unary operator on an identifier to create a function like _Data. Some possibilities are\r\n.... ( @. ) ___( @.Data ) <- my favorite option\r\n.... ( .@ ) ___( .@Data )\r\n.... ( @| ) ___( @|Data )\r\n.... ( |@ ) ___( |@Data )\r\n.... ( =| ) ____( =|Data )\r\n.... ( |= ) ____( |=Data )\r\n.... ( |- ) ____ ( |-Data )\r\n.... ( -| ) ____ ( -|Data )\r\n.... ( ./ ) ____ ( ./Data )\r\n.... ( /. ) ____ ( /.Data )\r\n.... ( |. ) ____ ( |.Data )\r\n.... ( .| ) ____ ( .|Data )\r\n.... ( !. ) ____ ( !.Data )\r\n.... ( *@ ) ___ ( *@Data )\r\n.... ( @* ) ___ ( @*Data )\r\n.... ( -@ ) ___ ( -@Data )\r\n.... ( @- ) ___ ( @-Data )\r\n.... ( |* ) ____ ( |*Data )\r\n.... ( *| ) ____ ( *|Data )\r\n( these are all currently valid operators )"
            },
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2015-10-06T20:50:00",
                "Content": "I like the idea of using a bare dot: List.map (.name),\r\nbut I think a better solution would be to have a fixed keyword for creating a lambda whose first and only argument is replaced by something. I've seen the usage of a keyword \"it\" in some language, but I can't remember which one it was.\r\nThis would allow not only: List.map (it.name)\r\nbut also: List.map (funcWithTupleArguments (arg1, arg2, it))\r\nor even: List.map (sprintf \"the square root of %f is %f\\n\" it (sqrt it))"
            },
            {
                "Submitter": "Varon",
                "Submitted": "2015-10-15T07:37:00",
                "Content": "The concept of 'functional properties' has been thoroughly explored under the name of Lenses in the formal side of the FP world.\r\nThere's an existing library that, if mixed with some code generation would probably perfectly work for this purpose. Don Syme has offered some comments relating to naming and usage in the \"Conventions for Lens declarations\" issue. You can read more about this on the github page at https://github.com/xyncro/aether .\r\nIncidentally, this isn't the first time someone's asked for functional properties in F#. Another attempt is visible in the \"Implement first-class lensing / lenses in F#\". This seems to be a generalization of this suggestion.\r\nYou can view this alternative proposal here: [/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f](/ideas/suggestion-6906132-implement-first-class-lensing-lenses-in-f.md) .\r\nI would suggest that rather than implementing a less general syntactic workaround, we focus on working towards what we need for functional style properties (aka lenses)."
            },
            {
                "Submitter": "Ibrahim",
                "Submitted": "2016-02-23T13:58:00",
                "Content": "I was thinking about this syntax:\r\nlet f = MyType1.Member1\r\nWhere f is equivalent to Member1 with arguments prefix with the 'this' parameter of type 'MyType1'"
            },
            {
                "Submitter": "George",
                "Submitted": "2016-02-29T21:07:00",
                "Content": "Actually there are already partial solutions...\r\nlet Name a = a.Name\r\nThis is a little more exotic and a better explanation of the principals is in the F# language reference pdf and here: http://stackoverflow.com/questions/33161244/in-f-is-it-possible-to-have-a-tryparse-function-that-infers-the-target-type\r\nlet inline id (a:^a) = (^a : (member Id:'b) (a))\r\nEssentially, static type constraints can be used to not only ensure that the parameter has a desired member (or static member) but also apply that member against the parameter to obtain a result."
            },
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2016-03-25T13:07:00",
                "Content": "Not only properties, but members of any kind. (e.g. I just found out about `Seq.map string` instead of `Seq.map (fun x -> x.ToString())` today.)\r\n[/ideas/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur](/ideas/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur.md) seems to enable this but be even more generic, and I think less ugly syntax memorization than \"(%$#) turns a member into a fn\".\r\nThe only downside of that proposal I can see is that it *only* works in lambdas, but I don't see any reason I'd ever want to call a naked `%$#DoSomething myThing` instead of `myThing.DoSomething()` anyway."
            },
            {
                "Submitter": "Abel",
                "Submitted": "2016-09-25T08:17:00",
                "Content": "Your title \"turning properties into functions\" suggests that F# wouldn't have support for this, but you can already do that (get the function accessor of the property):\r\nlet x = classWithNameProperty()\r\nlet f = x.get_Name // x.Name property as a function, f: unit -> string\r\nBut without the syntax decorations proposed in the comments, I don't see how this can be turned into a function if the object is not known (which is the second part of your request).\r\nUnless you need this for many different properties, you can create your own object-less syntax using ducktyping, but this is \"per property\":\r\ntype MyTest() =\r\n    member __.Name = \"foo\"\r\nlet inline name (x: ^a) = (^a: (member Name: string) x)\r\nlet f() =\r\n    Seq.singleton (MyTest())\r\n    |>Seq.map name                // works on any object in the seq with x.Name property\r\nOf course, it would be much nicer to have standard syntax for this."
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5663332": {
        "Number": "5663332",
        "Submitter": "Isaac Abraham",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow custom equality on record types.",
        "Text": "Record Types current support structural equality on all fields of the record, or none at all. There is no \"easy\" way to say \"make this record structurally equal using just the ID field\" etc. - you have to go back to implementing GetHashCode etc. etc. yourself.\r\nYou should have an option of decorating fields on the Record to explicitly state which fields you want structural equality on.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Thomas Clarke",
                "Submitted": "2015-08-24T05:40:00",
                "Content": "Just a slight modification. Given any ID field that allows equality, comparison is equally possible, and equality and comparison are needed for use of a record in maps and sets - a very common use case for me at any rate!\r\nSo the most useful (and fairly painless?) enhancement would be a (record) type attribute say AutoCompareAndEqualityAndHash which referenced a function (restriction to method would be Ok I think):\r\nidf: R -> I\r\nWhere R is the record type so annotated and I is any type implementing IComparable and IEquatable.\r\nTypical usage would be for idf to reference an integer id field in the record."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T05:31:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/11645070-exclude-mutable-fields-from-gethashcode-in-record"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:08:00",
                "Content": "The F# way to do custom equality and hashing is to implement your own Equals and GetHashCode.\r\nIt's hard to find an intermediate point (e.g. just use this field, skip that field, etc.), so we decided in F# 1.0 to only support being explicit. Since that decision was made nothing has really changed, so I don't think we should change the decision and venture into the intermediate ground.\r\nI will mark this as declined for this reason. It's not a bad suggestion, it's just that there is an existing general-purpose way to customize the Equals/GetHashCode."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment below, please take a look\r\nBest regards\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663374": {
        "Number": "5663374",
        "Submitter": "Richard Gibson",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow private constructors on DU cases",
        "Text": "Currently we can use DUs to represent several possible states. So if I want to I can have:\r\ntype EmailAddress =\r\n| ValidEmail of string\r\n| InvalidEmail of string with\r\nstatic member Create email =\r\nif Regex(\".+@.+\\..+\").IsMatch email\r\nthen ValidEmail email\r\nelse InvalidEmail email\r\n\r\nBut the problem with this is that anyone can create either of my cases. There's nothing to stop someone calling one of the constructors directly like so:\r\n\r\nlet email = ValidEmail \"wubwubwub\"\r\nI would like to be able to \"hide\" the constructors for the individual cases and have a constructor for the parent type.\r\nCould perhaps be combined with active patterns?",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T09:07:00",
                "Content": "That's already possible currently:\r\ntype EmailAddress =\r\nprivate | ValidEmail of string\r\n| InvalidEmail of string\r\nstatic member Create email =\r\nif Regex(\".+@.+\\..+\").IsMatch email\r\nthen ValidEmail email\r\nelse InvalidEmail email"
            },
            {
                "Submitter": "Andrew Cherry",
                "Submitted": "2014-03-21T10:35:00",
                "Content": "It's possible as Gustavo points out, but then anybody else can't match on that DU as the cases aren't accessible. Very useful for providing \"immutably safe\" arguments to an API perhaps, but maybe there's a more general solution? Essentially I think you'd want the DU constructors to be publicly read only, but I can't think of anything that's very close to that conceptually in current F# or ML..."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-22T03:27:00",
                "Content": "I think, this is one of the original use cases for Active Patterns, isn't it?. Make the constructors private and provide an active pattern to read it."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T15:06:00",
                "Content": "I've suggested a feature to allow implementing \"smart constructors\" for DU cases. This feature would probably fill your needs as well, without the potential drawbacks of hiding some of the union cases.\r\n[/ideas/suggestion-5671087-smart-constructors-for-du-cases](/ideas/suggestion-5671087-smart-constructors-for-du-cases.md)"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-24T05:44:00",
                "Content": "The problem with ActivePatterns are that the Union they generate is anonymous, so you can't use them as a type on a function parameter, for example:\r\nlet (|ValidEmail|InvalidEmail|) email =\r\nif Regex(\".+@.+\\..+\").IsMatch email\r\nthen ValidEmail\r\nelse InvalidEmail\r\n\r\nlet sendEmail (validEmail: ???) =\r\nprintfn \"Sending email to %s\" email\r\nWhat can I put as the type for validEmail?"
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-24T06:02:00",
                "Content": "You still put EmailAddress as your type. You just cannot access ValidEmail or InvalidEmail from outside of the DU, if you make the constructors private. The whole DU, however, is still accessible."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:37:00",
                "Content": "From the discussion below, I think there are adequate existing alternatives available to address this problem."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "5663470": {
        "Number": "5663470",
        "Submitter": "Eriawan Kusumawardhono",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Provide covariance/contravariance language support with syntaxes in F# in sync with covariance/contravariance in C#/VB",
        "Text": "Covariance/contravariance has its beginning in CLR 2.0 and also with the introduction of generics in .NET 2.0 (also in F#, C# and VB)\r\nThen in C# 4.0 and VB 10, we have covariance/contravariance supports in the language itself. Currently we don't have support for these covariance and contravariance in F#.\r\nI know it is a runtime feature of CLR 2.0 and 4.0 and I don't want to play catch up with C# and VB.\r\nBut this covariance/contravariance support in C# and VB are powerful to use and also have proven to provide cleaner and clearer ways to understand the code and variances in the types, especially when using parameterized generic types.\r\nThis is not the same as this feedback:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2363794-ocaml-like-variance-annotations-a-and-a-\r\nbut we can use that OCaml syntax as well for starter.\r\nThis feature should also be constrained to only use covariance/contravariance in interfaces and delegates just like in C# and VB, but F# may provide more supports for other types such as events.\r\nAn example of this is the way F# has provided the capability to create extensions to properties and methods, not just methods only in C# and VB.\r\nNOTE: Moved from http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3942302-provide-covariance-contravariance-language-support as suggested by Don Syme.",
        "Votes": 149,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T11:40:00",
                "Content": "FWIW, I used OCaml for many years and never once found a use for co/contravariance in real code. There are some corner cases in F# with interop with OO libs like WPF but these are rare IME.\r\nOn a related note, I would like implicit upcast when creating a literal list or array of subtypes like let myControls : Control list = [Label(); Button()]."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T07:42:00",
                "Content": "This would be a nice feature to have. Even if it were infrequently used in F#-only code, it would be very handy to have when implementing libraries to be consumed from C#.\r\nBTW, F# already does support a bit of contravariance via \"flexible types\". Flexible types don't seem to be used very often except with the 'seq<_>' type; if co-/contra-variance are properly supported in F# (a la C# 4.0), flexible types could be deprecated in favor of the variance annotations.\r\nIf this feature is implemented, I'd prefer it use the C#-style \"in\" and \"out\" keywords instead of OCaml's +/- syntax; I think the keywords are easier to read, they'll stand out when highlighted in an IDE, and it'll make it easier for C# developers to learn F# (or at least, they'll be able to re-use existing knowledge about the in/out keywords)."
            },
            {
                "Submitter": "Eriawan Kusumawardhono",
                "Submitted": "2014-03-24T00:24:00",
                "Content": "Thanks for your nice comment, Jack!\r\nIMHO, this is not just a nice feature to have, but it should be nice to have.\r\nIt's because the nature of F#'s strong typing, therefore it should span to strict and strong covariance and contravariance type.\r\nThese covariance and contravariance support is already supported deep inside the .NET CLR since .NET 2.0, so there should be a strong reason to leverage and promote this powerful runtime feature into language feature, not just C# 4.0 and VB 10 has done."
            },
            {
                "Submitter": "Eriawan Kusumawardhono",
                "Submitted": "2014-03-24T00:25:00",
                "Content": "Pardon my last comment, it should be must have instead of nice to have :)"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-27T11:35:00",
                "Content": "As a workaround, some time ago I wrote a little program to add variance annotations to an interface after compilation, though this is only for interop purposes. Of course it doesn't add proper variance support in F#\r\nhttps://github.com/mausch/VariantInterfaces"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-08T08:57:00",
                "Content": "Please don't do this. If you look at how badly variances complicate scala code and it's type system while realizing how surprisingly non-useful the feature is in practice (which is precisely as Jon H says), you realize such a feature is a net loss.\r\nIf you're wanting variance for interop, just remind yourself how much smaller this problem is, and how much easier it is to work around, than all the other problems with writing interop code."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T08:46:00",
                "Content": "I have run out of votes but this is a nice feature to have +3"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-07-14T12:19:00",
                "Content": "Tweet from Erik Meijer related to this: https://twitter.com/headinthebox/status/487572643714203648"
            },
            {
                "Submitter": "Mark Laws",
                "Submitted": "2015-05-29T05:50:00",
                "Content": "As the tweet from Erik Meijer linked below would suggest, F# lacks this due to its implications for type inference. Don Syme made a post about this same issue nearly ten years ago: http://osdir.com/ml/lang.fsharp.general/2008-09/msg00043.html\r\nIt would be a shame for F# to suffer for the sake of compatibility with a \"feature\" that's a corner case even in C# and VB."
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5663504": {
        "Number": "5663504",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow inheritance from .NET types that implement the same interface at different generic instantiations",
        "Text": "http://stackoverflow.com/questions/1464109/implementing-the-same-interface-at-different-generic-instantiations",
        "Votes": 60,
        "Comments": [
            {
                "Submitter": "Andrew Khmylov",
                "Submitted": "2014-03-21T09:50:00",
                "Content": "Looks like a quite important feature to me.\r\nWe have a fairly sophisticated C# code base which encodes a lot of business rules in type system and heavily uses multiple interface implementations with various type parameters. Converting it to F# is not possible at the moment due to this compiler restriction."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T07:51:00",
                "Content": "I've run into this a few times. I understand it may be a difficult feature to implement due to type inference (see Brian's answer to the linked StackOverflow question); but as Andrew said, it can be a show-stopping issue when you want to convert an existing C# library to F# but the public API can't be changed."
            },
            {
                "Submitter": "Aaron Bockover",
                "Submitted": "2014-08-28T10:46:00",
                "Content": "We ran into this with a type written in C# implementing multiple IObservable<T> interfaces. Fortunately we were able to change that API design on the C# time by the time we realized we were hosed on the F# side. This would be incredibly useful to support in F#."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T11:55:00",
                "Content": "The main problem is an interaction with type inference, where F# makes the assumption that if a type is constrained by both I < T > and I < U > then T = U.\r\nThis means it will be likely that there is an ongoing limitation that a type variable can’t be constrained by multiple interface instantiations. However that’s a much weaker restriction than the current one."
            },
            {
                "Submitter": "Maciej J. Bańkowski",
                "Submitted": "2014-09-16T14:44:00",
                "Content": "Don, correct me if I am wrong but the statement\r\nIF type constrained by I < T > and I < U > THEN T = U is simply false and hence is bound to cause problems down the line.\r\nCan this whole assumption be dropped from the compiler?"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-09-17T13:40:00",
                "Content": "Not fully implementing this feature as in C# makes it rather useless. You must be able to use I<T> and I<U> as interface constraints in F# if I is a generic interface and T and U are type parameters. The following assumption should be dropped from the compiler: _if a type is constrained by both I and I then T = U_\r\nLike Maciej said, this is going to cause problems in any case."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-11-10T12:45:00",
                "Content": "I still don't like the restricted version, but the notes (copied from the contribution) are interesting, especially the workaround:\r\n\"Note, the change still keeps the restriction that an F# type can itself only implement one instantiation of a generic interface type. For example\r\ntype C() =\r\ninterface I<int>\r\ninterface I<string>\r\nis not allowed. This is partly because of the way interface implementation methods are named in compiled IL (only the prefix \"I\" is added), and partly because the equivalent object expression form can inculde type unknowns, e.g.\r\n{ interface I<_> with ...\r\ninterface I<_> with ...\r\nand we don't want to support this kind of inference, and equally don't want a non-orthogonality between object expressions and class definitions. As a workaround you can always add an extra inherit each type you wish to introduce new interface instantiations, e.g.\r\ntype C() =\r\ninterface I<int> with ...\r\ntype D() =\r\ninherit C()\r\ninterface I<string> with ...\r\n\""
            },
            {
                "Submitter": "Abel",
                "Submitted": "2015-11-04T19:07:00",
                "Content": "Looks like the implementation of this is broken in VS 2015, or at least it works differently now. Generic implementations with different type parameters are still not possible (which is what the user suggested), and calling such an implementation from a .NET library leads to different results between F# 3 and 4.\r\nSee: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663504-allow-to-implement-the-same-interface-at-different, titled \"Difference between treatment of ambiguous generic interfaces by F# between VS 2012 and VS 2015 leading to compile errors in the latter\""
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "This has been completed for F# 4.0+\r\nThe user voice suggestion has been renamed to reflect the feature implemented – “Allow inheritance from .NET types that implement the same interface at different generic instantiations”\r\nThe overall status for F# 4.0 is at https://github.com/Microsoft/visualfsharp/wiki/F%23-4.0-Status\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663704": {
        "Number": "5663704",
        "Submitter": "Don Syme",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Copy-and-update on class types and on records of different types.",
        "Text": "People sometimes find it hard to transition from records to class types - something which comes up when seeking to encapsulate some of the details of the record type.\r\nOne particular reason for this is because their codebase may uses copy-and-update on record types. One approach to easing the transition would be to support copy-and-update on class types, as long as the class type follows a particular design pattern.\r\nOne pattern-based approach could permit both normal record syntax and copy-and-update syntax, e.g.\r\n[<RecordSyntax>]\r\ntype R(a:int, b:int) =\r\nmember x.A = a\r\nmember x.B = b\r\nmember x.C = f(a,b)\r\nwith\r\n{ a = e1; b = e2 } --> R(a=e1,b=e2}\r\n{ r with a = e1} --> R(a=e1,b=r.B)\r\nWhether there were one or two attributes (one for 'RecordSyntax' and one for 'CopyAndUpdateSyntax') would be up for discussion. Presumably using either attribute would give result in a declaration-time check that members exist to match constructor arguments.\r\nMatching uppercase properties to lowercase argument names is somewhat inelegant but in the balance is likely to be a reasonable price to pay for following .NET and F# design norms.",
        "Votes": 25,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:53:00",
                "Content": "As you know, I've certainly been bitten by this before. The other option would be to extend the record syntax a bit so that they can do most of the same things classes can already do."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-21T18:10:00",
                "Content": "If it can be extended or tweaked a little, this would be useful for structs as well. I'm currently having to do this: https://github.com/TIHan/FQuake3/blob/f6ad8a5809db7d57961a55ffd93e1ba0de85dde7/lib/FQuake3.Utils/src/FQuake3.Utils/math.fs#L117 to get a similar effect. Though, there are more than one possible constructors, which may throw a wrench in this..."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T05:24:00",
                "Content": "FWIW, OCaml has functional object update.\r\n@WillSmith: Looking at your code I'm thinking you would want the ability to mark a record type as struct."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-26T10:11:00",
                "Content": "Jon,\r\nI guess that is pretty much what I would want.\r\nThough, I am wondering how multiple constructors would work though in regards to using the record syntax."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:16:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6124011-easier-to-copy-data-between-records-of-different-t#comments"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:16:00",
                "Content": "C# is looking into allowing \"with\" on the proposed C# record types. What ever we do here would best align with that."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663709": {
        "Number": "5663709",
        "Submitter": "Nelak",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add support for implicit operators to facilitate language interop",
        "Text": "Add support for implicit operators to facilitate language interop instead of having to write an explicit operator like:\r\nhttp://stackoverflow.com/questions/10719770/is-there-anyway-to-use-c-sharp-implicit-operators-from-f",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:51:00",
                "Content": "Please no, I don't want any implicit conversions ruining my type safety."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-22T03:22:00",
                "Content": "I agree, the work-around with a local operator using duck-typing seems like a small cost, when compared to losing the very strong typing we have right now."
            },
            {
                "Submitter": "Nelak",
                "Submitted": "2014-03-22T12:53:00",
                "Content": "I'm not proposing to relax strong typing but to add someway to ease language interop.\r\nI don't see why we can't have something like an [<AllowImplicit>] that would be able to handle implicit operators without sacrificing type safety. In this way you need to opt-in for the desired behaviour\r\ne.g.:\r\n[<AllowNull>]\r\nThe null keyword is a valid keyword in the F# language, and you have to use it when you are working with .NET Framework APIs or other APIs that are written in another .NET language. The two situations in which you might need a null value are when you call a .NET API and pass a null value as an argument, and when you interpret the return value or an output parameter from a .NET method call."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663715": {
        "Number": "5663715",
        "Submitter": "Don Syme",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Warning for \"    member x.ABC = x.ABC\"",
        "Text": "In F#, it can happen that renaming and replacing identifiers gives rise to the non-sensical\r\nmember x.ABC = x.ABC\r\nWhile this is a special case, it is very obviously an error. It may be worth special-casing a warning for this.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Declining, no one has voted for this, this belongs in tools like FSharpLint."
        }
    },
    "5663721": {
        "Number": "5663721",
        "Submitter": "Don Syme",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add support for \"fixed\"",
        "Text": "F# 3.x doesn’t support “fixed” local variables in the style of C#. This is a missing hole in our native interop story and has been a user request. It is reasonable to lift this limitation if a quality implementation is provided.",
        "Votes": 45,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T09:30:00",
                "Content": "Would \"fixed\" be similar to how \"use\" works today? If you have a fixed local variable, at the end of its scope, it will get freed?"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T11:12:00",
                "Content": "Will -- there's two parts to 'fixed': the variable whose value is bound by the 'fixed', and the value which is bound to the variable. In C#, when you use a 'fixed' block, the object being fixed (e.g., an array) is pinned by the GC so it can't be relocated, and you're given a pointer to that object so it can be passed into native code. Both 'using' and 'fixed' blocks in C# are compiled into a try/finally; a 'using' block calls '.Dispose()' on the object bound by the block within the 'finally' clause, whereas a 'fixed' block simply zeros-out (assigns null) to the local variable holding the pinned reference.\r\nTo answer your question -- yes, 'fixed' would be very similar to how 'use' works today. When the variable goes out of scope, the finally block would be executed and assign null to the local variable (within the IL) holding the pinned reference, which triggers the GC to unpin the object."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T12:25:00",
                "Content": "Jack - the code gen should work the same as for C#"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T12:31:00",
                "Content": "I consider this approved in principle for F# 4.0, though some details may need to be sorted out.\r\nIf you think this should not be done, please chime in with details below.\r\nIf you have specific questions on the design, please chime in below.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest. F# 4.0 is open for business.\r\nI encourage you to work towards an implementation and testing for this feature.\r\nDon Syme, current BDFL, F# Language"
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-07-26T16:13:00",
                "Content": "Something that the CLI supports but is not allowed by C# is fixed pointers to generic types / arrays of generic types. This is very useful for communicating with DirectX/OpenGL and currently both major libraries for these APIs (SharpDX/OpenTK) have to rewrite their CIL code after C# compilation to add in fixed generic pointers. If we could diverge from C# here and allow everything the underlying CLI supports that would be useful."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T08:57:00",
                "Content": "See here for a good motivating example: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5670163-fixed-length-arrays and this gist https://gist.github.com/jack-pappas/9725445"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed. The RFC is at https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1015-support-for-fixed.md\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5663774": {
        "Number": "5663774",
        "Submitter": "Jorge Fioranelli",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Remove fun keyword from lambda expressions",
        "Text": "Maybe make it optional?\r\nOtherwise it is more verbose than C#.",
        "Votes": 267,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-04-04T01:39:00",
                "Content": "I personally like the current syntax."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-09T04:07:00",
                "Content": "Should be optional, not removed (otherwise code will break).\r\nAnd I'm all for it.\r\nIt happens to me countless of times that I forget it because my mind just always expects better."
            },
            {
                "Submitter": "Brian",
                "Submitted": "2014-07-06T08:47:00",
                "Content": "Seems like it would complicate the language a lot to make it optional. If we were starting from scratch though I'd support it. I would like to hear about what the reasoning behind requiring \"fun\" for lambda's. Was it simply because it was in OCAML? or was there other technical reasons?"
            },
            {
                "Submitter": "Tahir Hassan",
                "Submitted": "2014-07-25T05:59:00",
                "Content": "I agree, it looks horrible. C# has a much better lambda syntax, imho.\r\nPotentially we could use Haskell's backslash:\r\n[1;2;3] |> Seq.map (\\x -> x * x)\r\nAlthough it ain't as perfect like C#'s, it would work without making the language ambiguous."
            },
            {
                "Submitter": "Michael",
                "Submitted": "2014-09-07T18:34:00",
                "Content": "I really like the fun keyword."
            },
            {
                "Submitter": "Grant Crofton",
                "Submitted": "2015-02-14T12:09:00",
                "Content": "Would certainly improve our code golf scores a little! :-)"
            },
            {
                "Submitter": "Filip Kopecký",
                "Submitted": "2015-06-20T17:49:00",
                "Content": "I think it would be nice if we could write anonymous functions like expressions. The compiler could tell it is a function based on undeclared variables being used.\r\n(fun x y -> x + y)\r\n(x + y)"
            },
            {
                "Submitter": "Андрей Чебукин",
                "Submitted": "2015-07-19T18:33:00",
                "Content": "I agree that it is too long and actually moving to C# syntax would be reasonable.\r\nHowever current syntax allows to introduce a snippet for lambda that looks natural\r\nType fun, press tab (or just space in case of CodeRush) and fun is almost ready for you."
            },
            {
                "Submitter": "Andreas Vilinski",
                "Submitted": "2015-08-06T00:45:00",
                "Content": "You wanna take the fun out of F#!\r\nIt is not always needed. Often you can write ((+) y) instead of (fun x -> x + y). For other cases I have a R# live template expansion, which just adds me an arrow and braces, defined like here:\r\nfsfun ==> (fun x -> $END$)\r\nHowever it would be nice to map list of pairs like in Scala: List.map (_ + _)"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-01-16T01:29:00",
                "Content": "I think we should preserve the fun keyword to be backward compatible, however\r\nI really like the Elixir shorthand lambda expressions:\r\n1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum\r\nYou can for example make\r\nfun x y z -> x + y + z\r\ninto\r\n&(&1 + &2 + &3)\r\nit is not that much shorter, but it frees the programmer from thinking about what to name all those pesky variables.. just like the pipeline frees the programmer from making up a lot of variable names..."
            },
            {
                "Submitter": "Maciej J. Bańkowski",
                "Submitted": "2016-01-17T09:42:00",
                "Content": "to some Anonymous: variable names are important\r\nif you are lazy enough to name variables $1 $2 $3 then just name them a b c - it is even shorter.\r\nBesides, names do matter for maintainability. 2-3 months from now, nobody will know what the original programmer indented to do - names help.\r\nOn topic: It would be so cool to get rid of the 'fun' keyword and make lambdas as sexy as those in C#. However, I doubt it is possible due to statement evaluation logic of F# and ambiguity that would arise without some arbitrary discriminator for lambda expression.\r\nIn C# lambdas are clear from the context and I am not sure F# context is rich enough to get by without the 'fun' keyword but maybe it is - would be awesome."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2016-02-11T18:46:00",
                "Content": "I like what we currently have. It isn't that much more verbose than C#. In a way, it seems easier to spot out lambdas in a codebase when you see 'fun'."
            },
            {
                "Submitter": "Ideaflare",
                "Submitted": "2016-04-11T14:40:00",
                "Content": "I agree with Mastr Mastic, instead of removing it to make it optional.\r\nSomething else that could also be made optional is the let keyword."
            },
            {
                "Submitter": "Alan Ball",
                "Submitted": "2016-08-08T09:21:00",
                "Content": "In response to those who enjoy typing fun, and seeing fun, I do not think the language maintainers would break existing code. The reasonable way to interpret the requirement is to interpret it as optional. I personally think this might be nice. I'm sure there is a clean way to make this work. I would personally prefer the => syntax if possible, simply because many many languages currently use that, including C#."
            },
            {
                "Submitter": "Mohsin Syed",
                "Submitted": "2016-09-15T14:48:00",
                "Content": "looks verbose. Removing would make lambda looks cleaner."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-09-27T22:02:00",
                "Content": "I think the optional use of the fun keyword would be the way to go as well. Just like in React in ES6 the function keyword is no longer necessary"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5663895": {
        "Number": "5663895",
        "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Metaprogramming and Compiler Extentions",
        "Text": "Meta programming is getting a lot of attention lately. Also OCamlLabs is looking for improvements for this facility in OCaml. Like wise F# should look at providing solid Meta Programming facilities.",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:36:00",
                "Content": "This feature needs more details, and should be broken out into multiple features for different suggestions.\r\nF# already has substantial meta-programming facilities (quotations, type providers, reflection, dynamic code generation, compiler-as-a-service) as well as general capabilities as an ML-style meta language. We need to be clearer about what is being proposed."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-21T00:00:00",
            "Text": "As mentioned, this proposal needs to be more specific, and placed in relation to existing meta-programming facilities in the F# language.\r\nRecycling to allow you to reuse your votes. Please open new suggestions for specific meta-programming features etc."
        }
    },
    "5663938": {
        "Number": "5663938",
        "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Sound Parallel Programming Constructs",
        "Text": "Is it possible to provide solid parallel programming constructs out of the box E.g. Join based programming model, Algorithmic Skeletons, etc.",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-21T00:00:00",
            "Text": "Please make this suggestion more concrete, by creating indivudal suggestions for each proposed feature, and posting links and further information about the feature."
        }
    },
    "5663957": {
        "Number": "5663957",
        "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add Some Great Features Functors, Polymorphic Variants, etc. from OCaml and ML Variants",
        "Text": "F# is great but there are some great features in ML and Caml variants which have not make it to F#. Is it possible to add them.",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-21T00:00:00",
            "Text": "Please make this more specific – create individual items for each language feature."
        }
    },
    "5663965": {
        "Number": "5663965",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Integrate joinads extension",
        "Text": "",
        "Votes": 121,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:41:00",
                "Content": "You can try joinads here: http://tryjoinads.org/\r\nIt's already done, and from what I can tell seems to work great! What's holding this one back?"
            },
            {
                "Submitter": "thinkb4coding",
                "Submitted": "2014-04-04T06:56:00",
                "Content": "Joinads extend the computation expressions with the match! keyword to give control over the pattern matching to the underlying builder.\r\nlet putString = Channel<string>()\r\nlet putInt = Channel<int>()\r\nlet getString = ReplyChannel<string>()\r\njoin {\r\nmatch! getString, putString, putInt with\r\n| repl, v, ? -> repl.Reply(\"Echo \" + v)\r\n| repl, ?, v -> repl.Reply(\"Echo \" + (string v)) }\r\nIt becomes more and more useful for reactive applications and frameworks like Orleans, Akka.net and Rx extensions, to implement flexible pattern matching on messages.\r\nApplicative functors add 'let! x = xs and y =ys' and 'for x in xs and y in ys do ...' and enable to build zip semantic over computation expressions that can also prove useful in reactive applications, computations on time series, and much more:\r\nlet totalPrice =\r\ntimeseries {\r\nfor p in unitPrice\r\nand q in quantity\r\nyield p * q\r\nBoth have been implemented for F# 3.0 open source on Tomas Petricek and my research branch:\r\nhttps://github.com/tpetricek/fsharp/commits/research\r\nhttps://github.com/thinkbeforecoding/fsharp/commits/research\r\na first implementation based on F# 2.0 can be tested at http://tryjoinads.org/"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-08T09:01:00",
                "Content": "I'm with Richard here - I too wonder what's holding this one back?"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T08:47:00",
                "Content": "I don't know why this has not been incorporated."
            },
            {
                "Submitter": "Nicolas R",
                "Submitted": "2014-06-13T08:22:00",
                "Content": "I think it is tricky to prove it correct and this is not a small change. although I am not quite informed. concurrent programming is really valuable though."
            },
            {
                "Submitter": "Lev Gorodinski",
                "Submitted": "2015-04-21T16:14:00",
                "Content": "Would it be simpler to only support active patterns than can return `Choice` but wrapped in a type? For example:\r\nlet (|Left|Right|) (a:Async<'a>, b:Async<'b>) = async {\r\nlet! first,second = Async.choose (Choice1Of2 a) (Choice2Of2 b)\r\nmatch first with\r\n| Choice1Of2 a -> return Left a\r\n| Choice2Of2 b -> return Right b\r\n}\r\nand use like:\r\nmatch! a,b with\r\n| Left a ->\r\n| Right b ->"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2015-08-15T00:12:00",
                "Content": "I would guess that it might be internal politics within the F# team which might be holding this back. I do not know for sure though."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:53:00",
                "Content": "I think my position on joinads is fairly well known. The proposal is most definitely interesting from a research language design perspective.\r\nHowever the typical \"bang for buck\" tradeoff analysis just doesn't convince me that this should be in F# itself."
            },
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2016-06-18T22:20:00",
                "Content": "@DonSyme Your position is not well-known in the larger F# world, which is actually quite large now. Can you comment more about where you see the \"bang\" and the \"buck\"? I see some potentially useful ideas from tomasp's blogs, but not sure where the buck lands. Does it kill compiler time, or...?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "I’ve discussed this with Tomas today and he agreed it’s best to mark this as “declined” for now.\r\nIt wasn’t too political! Honest!!!! :)\r\nDon Syme, F# Language Evolution"
        }
    },
    "5663997": {
        "Number": "5663997",
        "Submitter": "Don Syme",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Make FSharp.Core collection functions for List, Array and Seq more regular",
        "Text": "F# 3.x is a little irregular in the functions it provides w.r.t. List, Array and Seq. For example, there is no List.groupBy.\r\nLincoln Atkinson has done an excellent analysis of what’s needed to make this more regular.\r\nThe full proposal is available here:\r\nhttps://github.com/dsyme/FSLangDesignGists/blob/master/CoreLibraryFunctions.md\r\nYou can submit comments below or as a pull request to the above file (log in to github and edit directly, your changes will be turned into a pull request by GitHub)",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T11:35:00",
                "Content": "Related to this, would be good to have something like LazyList in the standard collection, as seq doesn't support pattern matching"
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T12:01:00",
                "Content": "This is somewhat nice but potentially very bad. I think it is much more important to get the full complement of functions in each of the List, Array, Set and Map modules that actually leverage the specific benefits of those data structures.\r\nFor example, Set.partition should not be there because it is linear in time when we could have a log time Set.split function like OCaml. Furthermore, users cannot even add efficient log-time functions like Set.split because the data structure is abstract. The Map module should have functions equivalent to union, intersection and difference and a sub function that accepts a set of keys. I would value these much more highly than, for example, a List.singleton function when we already have the list literal syntax [x] or an Array.take function when we already have the array slice syntax xs.[0..n-1]."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:28:00",
                "Content": "Gustavo - Please add separate entries for separate requests\r\nJon - Likewise, yours is a separate request for a Set.partitionAt, and other functions over Map. They should be bundled into a single separate request."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:30:00",
                "Content": "I've updated the title to reflect the proposal more specifically."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:43:00",
                "Content": "Hrm, I don't think breaking changes to F# Core would be a good thing at all. It would only go to show those companies already using F# that we can't be trusted.\r\nAdding more functionality would certainly be useful though!"
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-03-23T20:19:00",
                "Content": "Always wanted this and wondered why Seq had a groupBy but not List. It's such a pain, not to mention inefficient, to be given a list and than have to use Seq for some operation only to convert it back to a list again!"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T09:39:00",
                "Content": "@Jon - note that one aspect of the proposal here is regularity. Looking at the matrix in the design-document link above, it is hard to justify leaving any particular entry in the top table unimplemented.\r\n@Rick - there is no proposal to make a breaking change to FSharp.Core."
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-06-29T17:39:00",
                "Content": "Most of the suggestions are fine, but it doesn't make sense to me to add something like Seq.scanBack or Seq.reduceBack. Seems to me the library is suggesting that Seq is a fine choice for doing these things."
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-06-29T17:47:00",
                "Content": "To further elaborate, List is also a poor choice for scanBack, but it's worse for Seq, cause with Seq, the assumption that a seq will never be materialized in memory at once is violated."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-07-08T08:20:00",
                "Content": "Not sure if this should be added as a new suggestion or if it fits ok here. While it's nice that List is getting Last can we have a method to get all but the last element as well (It's called init in Haskell but that's already taken). That would give us:\r\nHead - First element\r\nLast - Last element\r\nTail - All but first\r\nInit/Front/? - All but last\r\nWhich has a nice symmetry to it."
            },
            {
                "Submitter": "Mariusz",
                "Submitted": "2014-07-30T14:59:00",
                "Content": "I think that simple count function that takes predicate function and collection and returns number of item that satisfy the predicate is missing.\r\nFor me as a C# developer who has Count function in LINQ (http://msdn.microsoft.com/en-us/library/vstudio/bb535181%28v=vs.100%29.aspx) it's kind of weird that this function is missing.\r\nI know that I can use fold function but still dedicated count function will be much more concise and readable."
            },
            {
                "Submitter": "Nick",
                "Submitted": "2014-09-12T02:03:00",
                "Content": "@Mariusz\r\nIs that the same as the Length function?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-12T06:27:00",
                "Content": "@Nick @MariusZ I've started a discussion about a potential \"countWhere\" function here: https://github.com/fsharp/FSharpLangDesign/issues/36"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This is approved for F# 4.0+\r\nThe work has been divided into multiple pull requests which have all been now submitted, reviewed and committed to the “fsharp4” branch, see the overall status and history at https://visualfsharp.codeplex.com/wikipage?title=Status"
        }
    },
    "5664089": {
        "Number": "5664089",
        "Submitter": "Stephen Swensen",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow argument expressions to omit parentheses",
        "Text": "For example, given let f x y = x + y, currently we must do\r\nf (\"hello\".ToString()) (\"world\".ToString())\r\nbut it would be nice if we could omit the parenthesis:\r\nf \"hello\".ToString() \"world\".ToString()\r\nI understand that method application was deliberately weakened in the presence of functional application because it was thought that there would be confusion between application of tuples and application of method calls. But I believe that in practice this confusion does not exist and the majority of F# programmings would find omitting the parenthesis more natural and pleasant.",
        "Votes": 24,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T11:48:00",
                "Content": "So:\r\nf(\"hello\").ToString()\r\nwould have different meanings if \"f\" was a function or a member?"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-03-21T11:49:00",
                "Content": "I think making this depend on the presence of a space between the method name and the opening parenthesis would make sense. It would be consistent with `foo().bar()` vs `foo ().bar()` (the first succeeds, the second fails saying that unit has no method bar)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:40:00",
                "Content": "To be clear, what is being proposed is to allow high precedence application in argument position, specifically to remove the restriction here: https://github.com/fsharp/fsharp/blob/master/src/fsharp/pars.fsy#L3139\r\n\r\nif hpa2 then reportParseErrorAt ..."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:37:00",
                "Content": "Tomas Petricek and I talked this over as part of reviewing issues. We decided to finally mark this as \"declined\". While the suggestion makes total sense, we feel that the code that would result is just too subtle - a single space can make a huge difference. Tomas pointed out that \"f -3\" already confuses people. If that's the case, this would be even more so.\r\nMany thanks for the suggestion though, it is definitely interesting that this would be a feasible design point."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. It has been marked declined, please see my comment\r\nDon Syme, F# Language Evolution"
        }
    },
    "5664242": {
        "Number": "5664242",
        "Submitter": "Daniel Fabian",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Simulate higher-kinded polymorphism",
        "Text": "F# already has to make trade-offs when doing interop, e.g. it is possible to create a null value for a DU from C#, erased type providers don't work from anywhere but F# etc. Maybe F# could allow for higher-kinded polymorphism within F# code and use dynamic casts at runtime or maybe statically resolved inlining to simulate higher-kinded polymorphism.",
        "Votes": 490,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:38:00",
                "Content": "I think \"until the CLR finally supports it\" should be deleted from the title. To my knowledge there is no prospect of the CLR supporting HK polymorphism in any timeframe that matters for the purposes of this discussion."
            },
            {
                "Submitter": "Lev Gorodinski",
                "Submitted": "2014-03-24T08:23:00",
                "Content": "This would be very useful for higher-order functional programming, along with, to a lesser extent, something like either Scala implicits or Haskell type classes. This can be a slipper slope though - should higher-kinded currying also be supported (aka partially applied type parameters)? If not part of the type system at the core, should F# resort to Scala type lambdas?"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T21:24:00",
                "Content": "The best simulation of higher kinds I know is the technique explained in http://www.nut-cracker.com.ar/ . Work on this ended up in two libraries: FsControl ( https://github.com/gmpl/FsControl ) and FSharpPlus ( https://github.com/gmpl/FSharpPlus ), which builds on FsControl.\r\nIt's not perfect by any means (I need to finish a series of posts about it), but I'm already using it in production, and it works just fine (at least the parts I'm using).\r\nOf course, it would be much better if F# had explicit support for this."
            },
            {
                "Submitter": "Hodza Nassredin",
                "Submitted": "2014-06-27T00:28:00",
                "Content": "We can emulate some restricted form of Higher-Rank Polymorphism in c# for single inheritance pattern. For example function with forall https://gist.github.com/hodzanassredin/4de8fc7bbfbf4bb7dfa7 more details and monad and monad transformers are here http://hodzanassredin.github.io/2014/06/21/yet-another-monad-guide.html"
            },
            {
                "Submitter": "Hodza Nassredin",
                "Submitted": "2014-06-27T03:11:00",
                "Content": "Added some example how we can automatically translate code like this into c#:\r\npublic static List<A> Wrap(Func<A, List<A>> f, A val) forall A{\r\nwhere A : IConstraint\r\nreturn f(val);\r\n}\r\nhttps://gist.github.com/hodzanassredin/eb0aa76f48e37cbcc87f"
            },
            {
                "Submitter": "John Azariah",
                "Submitted": "2014-09-07T07:37:00",
                "Content": "1) Even without higher-kinded currying, being able to abstract over Monads and Functors without losing type inference would be pretty helpful. Doing that kind of thing in Scala is pretty painful.\r\n2) I'm not sure we need to include Scala-style implicits! I find them a way to reduce the transparency of the code and severely affect the ability to comprehend the code - although it may simply be my naivete!"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-11-13T01:04:00",
                "Content": "Since .Net is open-sourced, and they are open to PR, let us all push this request to https://github.com/dotnet/corefx and make this the most important feature for F# be realized."
            },
            {
                "Submitter": "Phylos",
                "Submitted": "2015-01-06T23:32:00",
                "Content": "In a recent Reddit post related to F# adoption, I saw a great comment from \"TarMil\" on higher kinds that I believe is worth repeating to illustrate their usefulness. Here is that comment in full ...\r\n\"Basically higher kinds are a type system for types: just like a value has a type, a type has a kind. And just like a function can take other values as arguments, a type variable can take other types as parameters. So where in F# you can have a parameterized type T<'a>, in Haskell the T part itself can be a type variable.\r\nFor an example of the usefulness, see how in F# we have a whole bunch of similar functions:\r\nList.map : ('a -> 'b) -> list<'a> -> list<'b>\r\nArray.map : ('a -> 'b) -> array<'a> -> array<'b>\r\nSeq.map : ('a -> 'b) -> seq<'a> -> seq<'b>\r\nOption.map : ('a -> 'b) -> option<'a> -> option<'b>\r\nEvent.map : ('a -> 'b) -> Event<'a> -> Event<'b>\r\n// Not in the standard library, but easy to implement:\r\nAsync.map : ('a -> 'b) -> Async<'a> -> Async<'b>\r\n// etc.\r\nIn Haskell, you can have a single function fmap, whose type (with an F#-like syntax) would be:\r\nfmap : ('a -> 'b) -> 'T<'a> -> 'T<'b>\r\nwhere (again in a hypothetic F#-like syntax):\r\n'T : Type -> Type\r\n// 'T takes a type as parameter and returns a type\r\nand this function has different implementations for different 'Ts. You can then use this function to write your own functions that can be called on any \"mappable\" type, and will do the right thing according to the type of the value passed.\r\n(I gave the example in Haskell because the way to do this in OCaml is more convoluted.)\""
            },
            {
                "Submitter": "Greg Rosenbaum",
                "Submitted": "2015-03-14T17:57:00",
                "Content": "This can only be practically implemented using statically resolved inlining (or reflection) because of constraints in the IL type system (this is where reified generics bites you in the ass!). Here is what an fmap function (as described by phylos) might look like:\r\nhttps://gist.github.com/Springwight/0368e8e7d7aec8b77e68\r\nI really don't see it as a technical challenge though, considering how much effort has already gone into the inlining system. It's more like, \"do we need to see this in the language?\" It's something that's very unlikely to be used by anyone except library developers, but it will help those library developers a lot."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-18T14:43:00",
                "Content": "Any comment from Don Syme or the F# Software Foundation Language Group on the chances of simulating higher-kinded polymorphism in the near future?\r\nI think this is a really important feature. Many expert functional programmers forego F# because they think can't take a language serious that does not have it. The F# community is losing a lot of potential expert functional programmers do to this."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2015-07-13T09:00:00",
                "Content": "Also a feature request with this many votes should not be ignored. Otherwise why go through all this Uservoice exercise."
            },
            {
                "Submitter": "Alexander Sidorenko",
                "Submitted": "2015-08-03T05:44:00",
                "Content": "CoreCLR is open-sourced, someday someone will do PL which adds HKT to CLR :) we just need to wait or do it yourself :)"
            },
            {
                "Submitter": "George",
                "Submitted": "2016-03-01T12:00:00",
                "Content": "This may do the trick...\r\nhttps://github.com/gmpl/FsControl"
            },
            {
                "Submitter": "Tobias Burger",
                "Submitted": "2016-04-12T04:02:00",
                "Content": "For reference here is the discussion of HKP in the roslyn issue tracker: https://github.com/dotnet/roslyn/issues/2212"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-09T09:47:00",
                "Content": "I just want to repeat my question from about one year ago, because I would really appreciate some comments (concerns, feasibility, effort) from the F# team on this:\r\n\"Any comment from Don Syme or the F# Software Foundation Language Group on the chances of simulating higher-kinded polymorphism in the near future?\r\nI think this is a really important feature. Many expert functional programmers forego F# because they think can't take a language serious that does not have it. The F# community is losing a lot of potential expert functional programmers [because of this].\"\r\nThis issue being more than 2 years old requires some kind of official response. Either decline it or approve it in principle, but not answering just keeps our hopes up and keeps our votes from being used for other feature requests."
            }
        ],
        "Status": "open",
        "Response": {
            "Responded": "2014-03-21T00:00:00",
            "Text": "removed “until the CLR fully supports it” from title"
        }
    },
    "5664335": {
        "Number": "5664335",
        "Submitter": "Craig Stuntz",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow Pattern Matching on Types",
        "Text": "I'm deserializing into abitrary record types and need to parse the deserialized values into appropriate types for the constructor. I'd like to do:\r\nmatch parameterInfo.ParameterType with\r\n| typeof<int> -> parseInt (attributes.[key]) :> obj\r\n| typeof<string> -> attributes.[key]) :> obj\r\n...etc\r\nUnfortunately, this doesn't compile. A (somewhat messy) workaround is:\r\nmatch parameterInfo.ParameterType with\r\n| x when x = typeof<int> -> parseInt (attributes.[key]) :> obj\r\n| x when x = typeof<string> -> attributes.[key]) :> obj\r\n...etc.",
        "Votes": 20,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-03-21T12:50:00",
                "Content": "My feeling is that the \"x = ...\" is adequate - this makes it clear that what's really going on is an equality check.\r\nAdding typeof<...> as a pattern may lead to false expectations that you can do things like \"typeof<list<_>>\" to match any list type."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:35:00",
                "Content": "You could easily make an active patten for this."
            },
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2014-03-21T20:15:00",
                "Content": "Richard, I considered an active pattern, but it seemed less readable than the workaround above, insofar as it at least includes the real type, typeof<int>, instead of a wrapper for same.\r\nDon's question is interesting. Should that work? I can see arguments both for and against."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-27T05:34:00",
                "Content": "My serialization library does a lot of this to dissect values. I tried using active patterns but you quickly run out of 7 choices when you're looking at byte, char, int, float, decimal, string, arrays, lists, sets, maps and dictionaries. So I used a union type with \"System.Type\"s in it to perform one level of dissection via a separate function. Then you can match over the available types easily."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-04T01:26:00",
                "Content": "I agree with Don, but only because this instance isn't an extremely reoccurring one.\r\nI also agree it would be nice to have this feature though."
            },
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2014-07-05T21:17:00",
                "Content": "Travis Brown pointed out tonight (on Twitter) that this feature, which is available in Scala, is \"too easy\" and is widely abused. I tend to agree, especially in a hybrid language with OO features. I still think it's the right answer for the specific example I gave, but I do agree the potential for abuse is high. I'm not sure how to rectify those two, conflicting opinions."
            },
            {
                "Submitter": "George",
                "Submitted": "2015-12-10T19:51:00",
                "Content": "typeof<> and typedefof<> are constants for non-generics. This fact alone should make them available as match targets. To keep form with F#, perhaps uppercased versions could be coined: TypeOf and TypeDefOf, respectively. In any event, the present work around breaks simplicity. The types in a program are a constant finite set."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declining per my comments, and also the comments from Craig. IMHO there is an adequate workaround for this that is clear, even if a little more explicit.\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "5664447": {
        "Number": "5664447",
        "Submitter": "John Tarbox",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Submit F# to ISO for acceptance as a standard",
        "Text": "Most major programming languages have recognition by a standards body such as ANSI or ISO. If F# is to be recognized as more than just a \"Microsoft Language\" then it is important that it be codified in a standard by an independent standards body.",
        "Votes": 39,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T08:24:00",
                "Content": "It may be easier (and therefore more likely) to get F# standardized through ECMA rather than ANSI or ISO. The .NET CLR is standardized as ECMA-335, C# 2.0 is ECMA-334, and C++/CLI is ECMA-372."
            },
            {
                "Submitter": "Steven Sagaert",
                "Submitted": "2014-04-02T09:00:00",
                "Content": "This is the worst idea ever because that would effectively kill all further innovation in the language! Since F# is a relatively young language with a small user base it's still free to rapidly innovate and add new features or even change existing features. This is one of its appeals for me. ISO standardisation would stop all that and updates would happen every 10 years or so at best. If you want a \"frozen\" entrenched language go with one the classic business languages like C++ or Java."
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-04-26T01:59:00",
                "Content": "I would tend to agree with Steven on this point. A relatively young language with a small but growing user base should not be standardized as it may slow down innovation. There are still some features missing such as type classes, functors, GADTs or even some sort of dependent typing, just to name a few, that may be difficult to add if a language is prematurely standardized."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T09:01:00",
                "Content": "+1m for ype classes, functors, GADTs & ependent typing.\r\nHas anybody opened a suggestion for them already?"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T09:06:00",
                "Content": "Also polymorphic variants"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T09:09:00",
                "Content": "Also built in Code Contracts like WhyML"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T09:10:00",
                "Content": "If there is interest in any of them other than just me somebody please open a suggestion."
            },
            {
                "Submitter": "Surya Halim",
                "Submitted": "2015-09-10T14:07:00",
                "Content": "Based on the age and userbase of F#, I have to agree that it's premature to lock in the design of F# through certification by ANSI or ISO. F# is a very young and very exciting programming language that still has ways to go."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing as, per most of the comments, this is premature.\r\nNote that C# has only been standardized up to 2.0, and it is expensive to submit to a standards org."
        }
    },
    "5664634": {
        "Number": "5664634",
        "Submitter": "Anonymous",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Provided Record Types",
        "Text": "The included type providers should have the option of emitting F# record types rather than class types.\r\nFor example, when reading and writing SQL data, your F# code has to either deal with classes, which don't have the nice benefits of F# records (immutability, copy/update syntax, code that is easier to reason about, fewer bugs, etc.), or you have to map your classes to corresponding F# records, do your processing, and then convert back to classes.\r\nHaving the option to provide F# record types would really bring the power of the language closer to the data.\r\n(see http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/5576101-the-included-type-providers-should-have-the-option, moved from there to here per Visual Studio Team)",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-27T00:00:00",
            "Text": "This is covered by existing suggestion http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663267-allow-to-generate-dus-and-records-in-type-provider\r\nDeclining to allow votes to be recycled"
        }
    },
    "5664643": {
        "Number": "5664643",
        "Submitter": "Richard Minerich",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add support for GADTs",
        "Text": "Generalized Algebraic Data Types essentially extend standard union types to allow different generic instantiations when defined recursively.\r\nYou can see a simple explanation of how they work in haskell here: https://en.wikibooks.org/wiki/Haskell/GADT\r\nThey open the door to such fantastic type safe data structures as heterogeneous lists and so can vastly improve type safety within the language.",
        "Votes": 219,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2014-04-21T15:31:00",
                "Content": "I don't think that benefits of GADTs outweight how they complicate type system and type inference (you may lose principal-type property).\r\nBTW: you can do heterogeneous lists without GADTs.\r\nBTW 2: you may be interested in Guarded Algebraic Data Types - http://gallium.inria.fr/~fpottier/publis/simonet-pottier-hmg-toplas.pdf"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T08:49:00",
                "Content": "Since OCaml has this I don't see why not F#"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-04T06:48:00",
                "Content": "There are some relevant commments here too: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6062821-add-dependent-types"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:45:00",
                "Content": "A major consideration is that GADTs are difficult to compile to .NET IL efficiently. Specifically, it is not possible to recover an existentially-hidden type variable except via virtual dispatch. For example\r\ntype C\r\ntype D<T> : C\r\nIf we have a C, a GADT implementation may \"know\" that for certain cases T has certain values, or decomposes in certain ways. But you can't implement this in .NET IL generics - you have to use reflection to recover the value of T and instantiate the branch code with a specific value. Russo and Kennedy had a proposal for what to do about this for C#.\r\nThis is a significant blocking factor for adding this to F# - GADT code would need reflection and would be less efficient."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5664786": {
        "Number": "5664786",
        "Submitter": "Tuomas Hietanen",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "dynamic -keyword support for F#",
        "Text": "There are times that e.g. F# value restriction could be solved with runtime dynamic code. C# has dynamic.\r\nI wish F# could use dynamic as it uses mutable:\r\nlet I x = x\r\nlet dynamic F = II\r\nAs far as I know, there is no this kind of limitation in pure OCaml:\r\nhttp://en.wikipedia.org/wiki/OCaml#Church_numerals\r\nThis could also help cross-language-scenarios (like using SignalR-library) which is possible now, when importing C# core dll, etc, but not easy.\r\nAnd it would also allow more dynamic actor/agent-model: how to upgrade agent's functionality's type syntax: http://fssnip.net/h3",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2014-03-22T03:35:00",
                "Content": "FWIW, I use FSharp.Dynamic to address this scenario: https://github.com/ekonbenefits/FSharp.Dynamic\r\nIt works pretty well"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T10:12:00",
                "Content": "Using existing C# libs that make use of dynamic is a fair argument. But IMO, F# should never support dynamic. Allowing dynamic is the opposite of what F# is, which is strongly typed. The ability to deviate from strong types just adds a layer complexity to the language which I think is unnecessary. I would hate to use existing F# code that made use of or exposed anything as dynamic; F# wouldn't feel the same in regards to safety.\r\nA much stronger argument needs to be made for dynamic support."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T21:17:00",
                "Content": "How is the OCaml example related to \"dynamic\"? Also, that example works just fine in F#."
            },
            {
                "Submitter": "Daniel Slapman",
                "Submitted": "2014-07-22T10:18:00",
                "Content": "I'm totally agree with others, F# has a reach type system and has no need in 'dynamic' type."
            },
            {
                "Submitter": "Onur",
                "Submitted": "2014-09-29T01:59:00",
                "Content": "Don, ? operator doesn't support generic methods. Also FSharp.Dynamic has no support for PCL.\r\nSo it cannot be used if you have a portable library. I prefer something baked into the language."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declining per the comments – the combination of the “?” operator, the “obj” type is sufficient for F#, plus the FSharp.Dynamic library is a good example of how to achieve this in purely library code.\r\nDon Syme, BDFL F# Language/Library Evolution"
        }
    },
    "5664936": {
        "Number": "5664936",
        "Submitter": "Petr Onderka",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Implement IReadOnlyCollection<'T> in list<'T>",
        "Text": ".Net 4.5 has a new type IReadOnlyCollection<'T> and list<'T> (a.k.a. FSharpList<'T>) fits this interface precisely, so I think it should implement it.\r\nOriginal on VS uservoice: http://visualstudio.uservoice.com/forums/121579/suggestions/2902147",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T19:46:00",
                "Content": "Workaround:\r\nmodule List =\r\nlet asReadOnlyList (this: _ list) =\r\n{ new System.Collections.Generic.IReadOnlyList<_> with\r\nmember x.GetEnumerator() = (this :> _ seq).GetEnumerator()\r\nmember x.GetEnumerator() = (this :> System.Collections.IEnumerable).GetEnumerator()\r\nmember x.Count = this.Length\r\nmember x.Item with get i = this.[i] }"
            },
            {
                "Submitter": "Brandon D'Imperio",
                "Submitted": "2015-04-23T12:39:00",
                "Content": "nice work-around Mauricio"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:34:00",
                "Content": "This seems entirely reasonable (we really should have done it n the FSharp.Core 4.4.0.0 revision)"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "This is approved for inclusion in a future release of the F# core library subject to an implementation.\r\nA pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp.\r\nDiscussion of the particular version where this is included can be started once an implementation is available.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "5665042": {
        "Number": "5665042",
        "Submitter": "Ryan Riley",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Allow extension interfaces",
        "Text": "Rather than just supporting single methods or properties, provide a mechanism by which to implement interfaces on existing types. This could be similar to protocols in Clojure and Elixir.",
        "Votes": 92,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:54:00",
                "Content": "If only I had more votes to give. This would be interop between various libraries a million times better."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T09:08:00",
                "Content": "This is an interesting idea, and I can think of some times in the past where it would have been useful.\r\nI could be mistaken, but after thinking it over a bit, it seems like this could only work for non-sealed classes; trying to extend sealed classes or value types would lead to issues when interoperating with non-F# code. Extending base classes or interfaces seems possible but very tricky to get right. For example, if you extended a base class which has some derived types, the F# compiler would have to create backing classes (in the compiled assembly) for the base class and any of the derived classes you used in your F# code, just to make sure the 'derives-from' and 'implements' relationships still hold correctly from the POV of any outside code."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-22T12:47:00",
                "Content": "In all fairness, don't object expressions already face pretty similar problems? This could be some sort of automatic implementation of object expressions using delegation."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-23T03:40:00",
                "Content": "I was thinking more about it a little more and I think, it could be done with some special object expression syntax. Something like\r\nlet myObj = MyClass() // does not implement the interface\r\nlet myAdoptedObj = { new IMyInterface on myObj } // if MyClass already has all the functions needed for the interface\r\nlet myAdoptedObj2 = { new IMyInterface on myObj with member x.MyAdditionalMemberOnlyPresentInTheInterface() = () } // if MyClass maybe implements half of the interface and we would like to add the second half. It is possible to use the existing object's methods as a default, but we can provide custom implementations for methods, that are missing or we can hide / override present methods on the object.\r\nAnd because type inference probably would work (it works for object expressions for the generic argument at least), one might introduce a function\r\nlet adopt x = { new _ on x }\r\nlet result = adopt myObj |> funcThatWantsMyInterface\r\nin this hypothetical syntax, { new IMyInterface on myObj } is a short-hand for\r\n{ new IMyInterface with member x.method1 = myObj.method1; member x.method2 = myObj.method2 }\r\nnot unlike the record copy syntax."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T12:07:00",
                "Content": "Daniel -- no, object expressions don't face the same problems, because they're only required to implement the interface. The problems with these proposed extension interfaces is that they need to have a type which matches both the class being extended and the interface(s) being added. This is the reason it's impossible for this to work with sealed classes and value types, or unsealed classes which have internal/protected constructors.\r\nThe only way I can think for this to work (unless I've misinterpreted Ryan's intentions) is that by extending existing types with these new interfaces, you'd basically just be making a shortcut for using object expressions somewhere else in your code. In other words, the compiler would not actually create a new type derived from the type being extended and the interfaces, but would in fact create a static method (in some module) which takes an instance of the type being extended and internally uses an object expression to produce an instance of the interface which was \"added\" to the type. It would then need to insert a call to this method into any call sites where instances of the interface were expected and you'd passed an instance of the type being extended."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-23T12:28:00",
                "Content": "Maybe I misunderstand the use-case here then. I thought the issue is, that you have a type that would be structurally compatible with an interface, but does not actually implement the interface.\r\nNow if a function requires an in instance of said interface, you cannot pass the object in question, because it does not implement the interface.\r\nSo you either interface your type with the interface, or you need to create an object expression delegating all the methods to the underlaying object. The first option makes implementing the interface easy, but it has to be done beforehand and cannot be don't when retrofitting existing (library) types. Also in the latter case, you do not need to take into account a lot of complicated inheritance hierarchies, because, you are implementing the interface through delegation instead of inheritance.\r\nIf I misunderstood the use-case, maybe the idea with extending the object expression syntax should be moved into a separate freature request."
            },
            {
                "Submitter": "mavnn",
                "Submitted": "2014-06-03T10:06:00",
                "Content": "I'm out of votes, unfortunately. This would be pretty awesome, however. Alternatively, something similar to member constraints where you could say \"anything that matches the signature of this interface\" as a constraint."
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2014-06-03T10:35:00",
                "Content": "Here's a quick sample of the current problem: https://dotnetfiddle.net/vm2CJ6"
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2014-06-03T10:50:00",
                "Content": "@mvann: Something like assembly neutral interfaces without the need for an actual interface implementation that also accepts type extensions would also satisfy me, though I would much prefer the stronger contract afforded by interfaces."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-06-03T11:04:00",
                "Content": "FsControl ( https://github.com/gmpl/FsControl ) is a workaround that does this *now* with the current F#.\r\n@Ryan for your concrete problem, FsControl has the ToString \"type method\": https://github.com/gmpl/FsControl/blob/master/FsControl.Core/Converter.fs#L98\r\nAnd it even does constraining for parametric types, i.e. like Haskell's Show a => Show (Maybe a)"
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2014-06-24T10:48:00",
                "Content": "Thanks all for your comments. FsControl is pretty great, and I'm using it now. I don't think sealed classes are a complete blocker, though they probably make performance a pain. See https://groups.google.com/d/msg/fsharp-opensource/ar8-lbRlTwQ/JzFakHTt1dgJ for an example. As Paul discovered, you can actually use object expressions to append interfaces, though I'm quite certain this won't last long using persistent data structures without doing something to change the module or type functions of the persistent data structures themselves. Consider, for example, the list type."
            },
            {
                "Submitter": "Phil de Joux",
                "Submitted": "2014-11-09T15:34:00",
                "Content": "Here's a concrete example from https://github.com/ServiceStack/ServiceStack/wiki/Error-Handling\r\n\"In addition to the above options, you can override the serialization of ad-hoc exceptions by implementing the IResponseStatusConvertible.ToResponseStatus() method and have it return your own populated ResponseStatus instance instead.\"\r\ntype StatusResponse =\r\n{mutable Status : ResponseStatus}\r\ninterface IHasResponseStatus with\r\nmember x.ResponseStatus\r\nwith get () = x.Status\r\nand set (v) = x.Status <- v\r\nexception StatusExn of StatusResponse\r\ntype StatusExn with\r\n//interface IResponseStatusConvertible\r\nmember x.ToResponseStatus () : StatusResponse = x.Data0"
            },
            {
                "Submitter": "Phil de Joux",
                "Submitted": "2014-11-09T15:42:00",
                "Content": "Classes derived from Exception declared using \"exception of\" are sealed."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T01:26:00",
                "Content": "Regarding this implementation I'd like to elaborate on what Jack Pappas said: Implementing an extension interface, would generate an adapter type and an adapter function that adapts the extended type to the same extension interface while making it appears identical to the extend type. This means that adapter type would need to inherit the extended type with all its interfaces in addition to implementing the new interface. IComparable must also be implemented to return the same result as the extended type. The only restriction is that this does not work with to-be-extended types that cannot be inherited from."
            },
            {
                "Submitter": "Kurt",
                "Submitted": "2015-07-06T02:39:00",
                "Content": "And now, protocols in Swift. https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html\r\nThey are a tasteful design of retro-active interface implementation in a language that seems to have much the same philosophy as F#.\r\nProtocols are extremely powerful, not so much for apps but in library design I've missed them often."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5665087": {
        "Number": "5665087",
        "Submitter": "Maciej",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add syntactic sugar for lambda expressions in F# - lambda expression C# style",
        "Text": "Add syntactic sugar for lambda expressions in F# so that one can write lambda expressions in a even shorter form like in C# (no fun keyword, => symbol).\r\nI do understand the lambda in F# are written this way because of many reasons, on the other hand I believe C# style lambda expressions are nice and concise and see no reason no to add optional syntax to the language.\r\nInstead of writing\r\nList.map (fun x -> x > ...) list we could write\r\nList.map (x => x > ...)",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T09:30:00",
                "Content": "This seems like a significant change to the language/compiler that only gains you the ability to not type 'fun' when writing lambdas. Would you rather the compiler team spent time implementing this, or implementing some new functionality (e.g., Intellisense in FSI)?"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T21:29:00",
                "Content": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5665087-add-syntactic-sugar-for-lambda-expressions-in-f (it has more votes).\r\nPersonally, I agree with Jack. IMHO this doesn't really buy you anything important."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T22:07:00",
                "Content": "Please don't do this. Everytime you introduce a duplicate syntax, companies end up with even more inconsistency in their code bases.\r\nThe more ways there are to 'do it', the more ways in which it will be done!"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T11:17:00",
                "Content": "Will close this as a duplicate since it is sufficiently close to [/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions](/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions.md)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Closed as a duplicate since it is sufficiently close to [/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions](/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions.md)"
        }
    },
    "5665226": {
        "Number": "5665226",
        "Submitter": "Jon Harrop",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "#r URLs",
        "Text": "Allow #r in scripts to reference on-line scripts via URLs.",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-21T16:34:00",
                "Content": "We do something like that with a project at Bayard Rock, except we use #N for nuget and it automatically goes and gets it, and pulls in the correct references for the specific version of the runtime.\r\nWe'll be adding it to the ipython F# profile soon."
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T17:05:00",
                "Content": "Would be great to have this for NuGet"
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-21T17:27:00",
                "Content": "Ok. I think this is *much* simpler than referencing a Nuget package."
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-03-21T20:13:00",
                "Content": "+3 Simple, beautiful."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:08:00",
                "Content": "I think this is not allowed in a Microsoft programming model for security reasons (a scripting referencing a malicious DLL can be sent around, and even the act of opening the script might compromise things if the referenced DLL contains a type provider)."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Unfortunately as much as I like this I have to mark it declined for the reason mentioned below\r\nDon Syme,\r\nF# Language Evolution"
        }
    },
    "5665274": {
        "Number": "5665274",
        "Submitter": "Richard Minerich",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Make Option Types implement IEnumerable<'T>",
        "Text": "It's such a pain to need to manually change option types into seqs when they're already obviously perfectly fit for being a collection. It sure would be nice to just be able to collect them up, or use them with \"yield!\".",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-27T05:28:00",
                "Content": "Problem is None is represented as null internally so enumerating None would give a null reference exception."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-27T11:52:00",
                "Content": "There doesn't seem to be anything wrong with this: open System.Collections\r\ntype MyOption<'t> =\r\n| Some of 't\r\n| None\r\ninterface seq<'t> with\r\nmember this.GetEnumerator() =\r\n(seq {\r\nmatch this with\r\n| Some t -> yield t\r\n| None -> ()\r\n}).GetEnumerator()\r\ninterface IEnumerable with\r\nmember this.GetEnumerator() =\r\n(this :> IEnumerable).GetEnumerator()\r\n\r\nNone |> Seq.iter (printfn \"%s\")"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-27T11:53:00",
                "Content": "The same goes for Ref; you could argue that a reference cell of 'T is a sequence of 'T with exactly one item in it."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-27T12:01:00",
                "Content": "In fact, there may be a way for any generic union type to implement seq... Take a look at this Tree implementation:\r\nopen System.Collections\r\ntype Tree<'t> =\r\n| Branch of 't Tree * 't Tree\r\n| Leaf of 't\r\ninterface seq<'t> with\r\nmember this.GetEnumerator() =\r\n(seq {\r\nmatch this with\r\n| Branch (left, right) ->\r\nyield! left\r\nyield! right\r\n| Leaf data -> yield data\r\n}).GetEnumerator()\r\ninterface IEnumerable with\r\nmember this.GetEnumerator() =\r\n(this :> IEnumerable).GetEnumerator()\r\n\r\nBranch(Branch((Leaf \"two\"), Leaf \"three\"), Leaf \"one\") |> Seq.iter (printfn \"%s\")"
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-06-20T12:09:00",
                "Content": "It's too bad we don't have extension interfaces, as you can do a null check in extension methods."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "As indicated in the comments, this can’t be done because of the use of “null” as a representation for “None”.\r\nDon Syme, BDFL Language/Library Evolution"
        }
    },
    "5665355": {
        "Number": "5665355",
        "Submitter": "Khan Thompson",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Add syntactic sugar for functions ala Scala/Clojure",
        "Text": "Add in shorthand syntax for anonymous functions, even if it is only for single argument functions.\r\nFor example:\r\n[1; 2; 3; 4] |> List.map (_ + 1)\r\nAs opposed to\r\n[1; 2; 3; 4] |> List.map (fun i -> i + 1)\r\nIt would be great to have this shorthand so that our anonymous functions are shorter than the C#ers' :).",
        "Votes": 37,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-21T18:13:00",
                "Content": "This is the same as this one: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663326-syntax-for-turning-properties-into-functions\r\n(your tittle is actually better, but there's already a bunch of votes there)"
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T09:50:00",
                "Content": "@Gustavo: I think this is a separate idea. That idea was just a shorthand for a lambda that just invokes a property like (fun foo -> foo.Name) could be #Name. This idea is more general. You could do (_.Name) but with this you can also do (_ + 1) as a shorthand for ((+) 1).\r\nFWIW, Mathematica has the shorthand notation #+1& for this where # is an anonymous argument in an anonymous function that ends with &. The syntax really is quite hideous!"
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T09:52:00",
                "Content": "Mathematica can also do multivariate anonymous parameters in anonymous functions. So (fun (x, y, z) -> x*y+z) can be written #1*#2+#3& in Mathematica."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T22:03:00",
                "Content": "This is silly. You have many alternative options -\r\n[1; 2; 3; 4] |> List.map ((+) 1)\r\n[1; 2; 3; 4] |> List.map (add 1) // where add = (+)\r\n[1; 2; 3; 4] |> List.map incr // where incr n = n + 1\r\nThese are all equivalent and good enough."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5665432": {
        "Number": "5665432",
        "Submitter": "Jon Harrop",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Make FSharp.Core collection functions for Array.Parallel more regular",
        "Text": "In F# 3.0, lots of standard functions are missing from Array.Parallel including tryFindIndex, exists, forall, filter, tryFind, reduce, minBy, maxBy and tryPick. A mapReduce function would also be useful.\r\nEfficient implementations of all of these have been described in the F# Journal. http://fsharpnews.blogspot.co.uk/2013/01/parallel-aggregates.html",
        "Votes": 63,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:41:00",
                "Content": "I am going to mark this as \"approved in principle\". That is, we would accept design additions with well-tested implementations of coherent subsets of these functions.\r\nIf someone would like to submit a PR for these that would be great."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Approved in principle subject to RFC and well-tested implementation being submitted as PR."
        }
    },
    "5665703": {
        "Number": "5665703",
        "Submitter": "Jorge Fioranelli",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Improve Record Type syntax when instantiating and another type has the same properties",
        "Text": "type UserInfo { Id: int; Name: string }\r\ntype CompanyInfo { Id: int; Name: string }\r\nlet user = new { UserInfo.Id = 1; UserInfo.Name = \"John Doe\" }\r\nHaving to specify the type in each property takes more time, specially if the type contains several ones.\r\nProposed solution (like C#):\r\nlet user = new UserInfo { Id = 1; Name = \"John Doe\" }",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-22T03:03:00",
                "Content": "But this already works. Just annotate the whole record with the type and you are done.\r\nlet user = { Id = 1; Name = \"John Doe\" } : UserInfo or use the annotation at the place where you\r\nare using user as in\r\nmyFuncThatNeedsAUser user (might already be inferred correctly now) or else\r\nmyFuncThatNeedsAUser (user : UserInfo)"
            },
            {
                "Submitter": "Jorge Fioranelli",
                "Submitted": "2014-03-22T10:04:00",
                "Content": "Thanks Daniel, I didn't know you can do that."
            },
            {
                "Submitter": "Jorge Fioranelli",
                "Submitted": "2014-03-22T10:05:00",
                "Content": "Please remove this idea."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declined at Jorge’s request"
        }
    },
    "5666097": {
        "Number": "5666097",
        "Submitter": "Jorge Fioranelli",
        "Submitted": "2014-03-21T00:00:00",
        "Title": "Remove the need for an arbitrary self-identifier (e.g. x) when declaring a member",
        "Text": "Being able to use any word or letter as self-identifier makes the code inconsistent quite easily.\r\nmember x.MethodA() = ...\r\nmember this.MethodB() = ...\r\nProposed solution:\r\nmember MethodA() = ...\r\nor using just \".\" before the name:\r\nmember .MethodA() = ...\r\nTo call any other member from inside the method, we can do it the same way, either just using the method name or adding \".\" before it, no need to use a self-identifier.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T09:46:00",
                "Content": "How do you then refer to self in the body of an instance method?"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2014-03-29T17:21:00",
                "Content": "@Jon Harrop\r\nIt's already possible to define a self-identifier at type level:\r\ntype Foo() as this =\r\nmember __.Bar() = 5\r\nmember __.Baz() = this.Bar()"
            },
            {
                "Submitter": "Jorge Fioranelli",
                "Submitted": "2014-05-01T23:52:00",
                "Content": "Jon, like in C#, you don't need to, just write the function name and if there is one defined in the scope of the object use that one. E.g.\r\nmember MethodA() = 1\r\nmember MethodB() = MethodB() + 1"
            },
            {
                "Submitter": "Frank Joppe",
                "Submitted": "2014-11-16T09:46:00",
                "Content": "IMHO, it would make the code more readable if you'd introduce a standard (keyword), like 'this' instead of letting it free, and one can use 'x', the other can use 'y'. A standard may prevent questions when coding, or educating the language."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:08:00",
                "Content": "We decided in F# 1.0 to make this identifier compulsory, for purposes of code regularity. Since this has served us well and nothing has really changed since we made that decision, I will decline this.\r\nFrank - requiring one single identifier causes problems when you have nested object expressions . Also IMHO forcing \"this\" encourages a certain style of OO thinking rather than the more algebraic thinking used in functional languages."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion, though declined per my comment below.\r\nBest regards\r\nDon Syme, F# Language Evolution"
        }
    },
    "5666323": {
        "Number": "5666323",
        "Submitter": "Iris Sakura",
        "Submitted": "2014-03-22T00:00:00",
        "Title": "Operator Overloads Problem in F#",
        "Text": "When redefine an operator function, the opeartor cannot be used for other purpose.\r\nExample:\r\ntype Point = { X : float; Y : float; }\r\nlet (-) p1 p2 = { X = p1.X - p2.X; Y = p1.Y - p2.Y; }\r\nthen the following code raises a compilation error:\r\nlet a = 2 - 1 // Error: excepting type \"Point\"\r\nOverloading in F# is limited, it may because of the type infering and usually it's not a problem because we may use a different function name. But operator's name cannot be changed due to the semantic reason.\r\nWe can overload opeators for a class, but how about a record or a tuple? Since F# allows opeator overloads for class already, so it's should not be too difficult to just extend it to all types.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-22T09:43:00",
                "Content": "You can already overload operators for records:\r\ntype Point = {\r\nX : float;\r\nY : float;\r\n} with\r\nstatic member (-) (a : Point, b : Point) =\r\n{ X = a.X - b.X; Y = a.Y - b.Y; }\r\n[<EntryPoint>]\r\nlet main argv =\r\nlet z = 2 - 1\r\nlet a = { X = 1.0; Y = 2.0 }\r\nlet b = { X = 3.0; Y = 0.0 }\r\nlet c = a - b\r\nprintfn \"Hello world!\"\r\n0 // Exit code\r\nYou can't (and shouldn't) overload operators for tuples, because they're implemented via the System.Tuple types which are treated just like any other type which is external to your code."
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-22T13:31:00",
                "Content": "If you could define operators in type extensions, it would solve lots of problems. The use case is: there's a .NET maths library that you want to use but is not F# friendly, and you want to define pointwise operators like (.*), (.+), etc... Because the type is defined in another assembly, F# doesn't allow you do define those operators as static members"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T22:17:00",
                "Content": "There are many threads in Stackoverflow that show how to do this:\r\nhttp://stackoverflow.com/questions/2812084/overload-operator-in-f\r\nhttp://stackoverflow.com/questions/19682432/global-operator-overloading-in-f\r\nhttp://stackoverflow.com/questions/22401010/f-operator-overloading-riddle-2\r\nhttp://stackoverflow.com/questions/7695393/overloading-operator-in-f\r\nhttp://stackoverflow.com/questions/12971965/overloaded-inline-operators-in-f"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-27T00:00:00",
            "Text": "This is answered by the comments and is not a concrete proposal."
        }
    },
    "5666371": {
        "Number": "5666371",
        "Submitter": "Anonymous",
        "Submitted": "2014-03-22T00:00:00",
        "Title": "F# 3.0 query expression with pipelined style",
        "Text": "http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2715068-f-3-0-query-expression-with-pipelined-style",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-03-22T02:07:00",
                "Content": "The idea title should be F# query expression with pipelined style\r\ndataSource\r\n|>Sql.where (fun a->a.ColumnA)\r\n|>Sql.sortBy (fun a->a.ColumnB)\r\n|>Sql.skip 10\r\n|>Sql.take 20\r\n|>Sql.run\r\n|>Seq.iter (fun a->printfn \"%s\" (string a.ColumnA))"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T04:12:00",
                "Content": "You can actually do this as a library today if you try hard enough. Just make Sql a type and each of the functions a method that takes a quotation as an argument implicitly.\r\nEither way, this belongs in a library not in FSharp.Core."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thank for the suggestion. Declined per my comment, please take a look\r\nThanks\r\nDon Syme, F# Language Evolution"
        }
    },
    "5667801": {
        "Number": "5667801",
        "Submitter": "Marc Sigrist",
        "Submitted": "2014-03-22T00:00:00",
        "Title": "Fix CIL representation of internal constructors of abstract classes in F#",
        "Text": "see http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2837399-fix-cil-representation-of-internal-constructors-of",
        "Votes": 1,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Completed in F# 4.0, see https://github.com/Microsoft/visualfsharp/issues/420\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5668239": {
        "Number": "5668239",
        "Submitter": "Mark Seemann",
        "Submitted": "2014-03-22T00:00:00",
        "Title": "Allow tuples for overloaded method and constructor arguments",
        "Text": "When a constructor or method isn't overloaded, you can use a tuple as arguments:\r\nopen System\r\nlet u = Uri(\"http://blog.ploeh.dk/tags.html#F#-ref\")\r\nlet pqd = u.GetComponents (UriComponents.PathAndQuery, UriFormat.SafeUnescaped)\r\nlet pqargs = (UriComponents.PathAndQuery, UriFormat.SafeUnescaped) // UriComponents * UriFormat\r\nlet pqa = u.GetComponents pqargs\r\nlet osd = OperatingSystem (PlatformID.Win32NT, Version(1, 2, 3, 4))\r\nlet osargs = (PlatformID.Win32NT, Version(1, 2, 3, 4)) // PlatformID * Version\r\nlet osa = OperatingSystem osargs\r\nHowever, when a constructor or method has overloads, it doesn't work:\r\nlet vd = Version (1, 2, 3, 4)\r\nlet vargs = (1, 2, 3, 4) // int * int * int * int\r\n//let va = Version vargs\r\n//The above line can't compile, but gives this error:\r\n//error FS0001: This expression was expected to have type\r\n// string\r\n//but here has type\r\n// int * int * int * int\r\nlet s = \"Some piece of text\"\r\nlet sd = s.StartsWith (\"Some\", StringComparison.CurrentCulture)\r\nlet swargs = (\"Some\", StringComparison.CurrentCulture) // string * StringComparison\r\n//let sa = s.StartsWith swargs\r\n//The above line can't compile, but gives this error:\r\n//error FS0001: This expression was expected to have type\r\n// string\r\n//but here has type\r\n// string * StringComparison\r\nIt would be nice if it also works for overloaded methods, since the tuples seem unambiguous to me.",
        "Votes": 28,
        "Comments": [
            {
                "Submitter": "Liviu",
                "Submitted": "2014-03-23T13:17:00",
                "Content": "I checked, and Nemerle language supports this feature since ages."
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-06-20T17:08:00",
                "Content": "Don't have more votes, but +1"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:28:00",
                "Content": "My inclination is not to change the F# behaviour here in the presence of method overloading.\r\nThe present design was chosen deliberately to have the programmer remove some of the ambiguity when method overloading, tuples and type inference collide. In overloaded cases we ask the programmer to split into individual arguments.\r\nAlso it actually seems relatively rare that it is useful to pass first-class tuples to overloaded methods. The Version example is one case where it happens."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per my comments below."
        }
    },
    "5669324": {
        "Number": "5669324",
        "Submitter": "Anonymous",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Allow the use of the tuple operator (,) as a function.",
        "Text": "I've seen F# code like\r\nfun x y = (x,y)\r\nor\r\nlet tuple2 x y = (x,y)\r\nused everywhere, I think it will be more elegant to allow to use the function (,) and (,,) and so on, as in Haskell.",
        "Votes": 53,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:03:00",
                "Content": "This seems too corner case to warrant addition to the language: it is simple enough to use a named function such as \"tuple2\""
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining per my comment below.\r\nDon Syme, F# Language Evolution"
        }
    },
    "5669367": {
        "Number": "5669367",
        "Submitter": "Mastr Mastic",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Allow Implicit Interface Implementation",
        "Text": "F# only supports explicit interface implementation with the price of unnecessary and excessive casting (also causes readability issues), potential confusion when working with other languages, and causes limitation with F#'s OOP that could be resolved without any major language change.\r\nTo expand on this, this post by Mauricio Scheffer describes the issue very well: http://bugsquash.blogspot.co.il/2009/01/implementing-interfaces-in-f.html\r\nIn addition, I'm sure I could argue that people would prefer to just write `identifier.Member` rather than `(identifier :> Type).Member` whenever the member is a signature provided by an interface.\r\nThis repeats quite a bit on average and it is messy, to say the least.\r\nIt should also be pointed out that even though F# is primarily functional (and interfaces are less of an issue), F# code is still being used from other languages, and also some domains and tasks could be easier to take on from an OO approach.\r\n(I am also finding very high limitations with using WPF & XAML with some MVVM approaches)\r\nCurrently the workaround would be to copy-paste the signatures for every member of an interface.",
        "Votes": 133,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T07:45:00",
                "Content": "I personally prefer the requirement for explicit interface implementation and would like to continue to enforce that requirement in my own codebase, so if this feature were implemented I would like to have a compiler option to disable it (or perhaps, it should be disabled by default and activated by a compiler flag)."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-03-23T08:20:00",
                "Content": "I'd like to expand a bit further on what I've mentioned about WPF and MVVM.\r\nThis issue makes F# not reliable for your view-models because other than being cumbersome and tedious (`{Binding Property}` becomes {`Binding Path=(namespace:InterfaceType.Property)}` for each property.\r\n(You have to type `Path=` to avoid an exception)) it also introduces limitations.\r\nFor instance, one limitation that shows up frequently is that WPF DataTemplates do not support interfaces, yet passing an interface is your only way to expose your members because they are explicit.\r\n(See: http://stackoverflow.com/a/327993/825637)"
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-03-23T11:17:00",
                "Content": "@Jack Pappas No worries there I think, this pretty much has to stay as default for the language so not to break existing-code (which I'm sure is one primary concern for the F# team).\r\nI do like the idea of the compiler flag very much and also I think attributes, keywords, or different syntax would be required to get more specific from one instance to another within the same compilation.\r\nThanks for your input."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T11:44:00",
                "Content": "@Mastr Mastic Admittedly, I do very little GUI programming, so I haven't run into the situation you described. The additional explanation you added makes a lot of sense, and I think you've made some good arguments for why this feature *should* be implemented. This would be a big change to the language though, and might also pose some challenges w.r.t. to type inference, so the more examples you can provide where the current behavior (explicit interface implementations only) is holding you back, the better."
            },
            {
                "Submitter": "Reed Copsey, Jr.",
                "Submitted": "2014-08-04T19:30:00",
                "Content": "I'd very much like this - and have run into this issue with WPF myself.\r\nMy preference would to allow this via an attribute like many other features - something like:\r\ninterface [<ImplicitInterface>] ISomeInterface with\r\nmember __.Foo = 42\r\nThis would align with how [<AbstractClass>] and similar are handled."
            },
            {
                "Submitter": "Paul",
                "Submitted": "2014-09-09T17:38:00",
                "Content": "I personally prefer the requirement for explicit interface implementation. But if you’re using WPF and not providing a proxy to allow WPF to access to a chosen interface an attribute like CLIMutableAttribute would be better. This would cause the decorated interface to additionally be compiled to Common Language Infrastructure (CLI) representation implicitly (but not exposed to f# code), allowing WPF binding to work. CLIMutableAttribute was added to F# 3.0 and adding this related attribute (called something like CLIImplicitInterface) to F# 4.0 would be a great addition, which would ease GUI development with F#.\r\nhttp://msdn.microsoft.com/en-us/library/hh289724(v=VS.110).aspx\r\nhttp://blogs.msdn.com/b/fsharpteam/archive/2012/07/19/more-about-fsharp-3.0-language-features.aspx\r\ninterface [<CLIImplicitInterface>] ISomeInterface with\r\nmember __.Foo = 42"
            },
            {
                "Submitter": "Saagar Ahluwalia",
                "Submitted": "2015-06-15T17:36:00",
                "Content": "This is not much of an issue as any methods one needs to expose implicitly can just be redefined outside."
            },
            {
                "Submitter": "Kasey Speakman",
                "Submitted": "2015-09-11T11:28:00",
                "Content": "@Saagar Ahluwalia. This is a large issue, depending on your use. Try creating a class which implements IDictionary<'k,'v>. Maintaining ~15 alias methods on the base class is an issue.\r\nI ran into this when creating a circular dictionary. Things I've tried:\r\n- Inherit Dictionary<'k,'v>. Problem: existing functions like Add and Remove can't be overridden, and using them will circumvent the circular buffer. (You can hide them, but there's no \"new\" keyword in F# to suppress the compiler warning.)\r\n- Implement IDictionary<'k,'v>. Problem: when you new up the class, none of the IDictionary methods are there. It's plain weird/unexpected to new up the class and immediately cast it to IDictionary. A static method could be created to do this for the user, but that suffers the same lack of obvious usage.\r\n- Create alias methods on the class which do the interface cast for the user. Problem: this introduces a lot of superfluous alias methods (15ish for IDictionary) which must be maintained (and tested depending on the strictness of your testing policy).\r\nAll of these alternatives are bad."
            },
            {
                "Submitter": "Alexander Batishchev",
                "Submitted": "2015-10-04T00:31:00",
                "Content": "This is a HUGE ISSUE. The worst thing about F#. Clearly indicates its immaturity."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-01-16T07:46:00",
                "Content": "Pls allow to use implicit interfaces. It is pain when creating an AST model and working with it."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5670027": {
        "Number": "5670027",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Implement try/fault expressions",
        "Text": "I would like F# to have try/fault expressions. It would work along the same lines as the current try/with syntax, although the 'fault' block would be constrained to a return type of 'unit'. I don't expect the usage of this to be terribly common, but it would be very handy to have for logging purposes.\r\nTo answer the inevitable question, \"Why not just use try/with and reraise()?\" -- with try/with you're actually catching the exception; unless you remember to call reraise() to terminate all paths in the control flow within the 'with' block, you'll end up swallowing the exception and not getting the expected behavior. Similarly, if an inexperienced (or perhaps just inattentive) developer re-raises the exception with 'raise' instead of 'reraise', the stack trace information will be lost.\r\nWith try/fault, it'd be easy to log relevant information (e.g., variable values) from functions when unwinding the stack due to an exception being thrown, without the downside of being able to affect the control flow.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T06:19:00",
                "Content": "Why not use try..finally?"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-28T18:33:00",
                "Content": "Jon -- With try/finally, the code in the finally block is always executed, whether an exception is raised within the protected (try) block or not. With try/fault, the code in the fault block is executed *only* when an exception has been raised in the try block.\r\nIt would be possible to emulate try/fault behavior with try/finally by writing something like this:\r\nlet mutable error = true\r\ntry\r\n// code which may or may not raise an exception\r\nerror <- false\r\nfinally\r\nif error then ... // execute the \"fault\" handler\r\nbut it's hacky and I'd prefer just to use a true 'fault' block (which is already a feature supported by the CLR). In addition, the code to implement try/finally in the compiler is basically identical to what's needed for try/fault, so it should be fairly straightforward to implement this. If this language feature were accepted, I'd be happy to contribute an implementation (or attempt to)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:39:00",
                "Content": "My inclination is that we won't do this in F#. I can see the use cases though - are there really no other ways to achieve this in .NET, e.g. by calling a library function with two lambdas?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:02:00",
                "Content": "One approach to this would be to add an OnException combinatory accepting a pair of functions. Likewise an Async.OnException."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5670098": {
        "Number": "5670098",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Fix the #use directive in F# interactive",
        "Text": "F# interactive supports a --use:myfile.fsx flag on the command-line, which pulls in the code from the myfile.fsx script just as if you manually typed the file's contents into the REPL. This is subtly -- but critically -- different from the --load:myfile.fsx flag, which compiles the code and imports it into the current REPL environment.\r\nWithin the F# interactive shell, you can issue #load \"myfile.fsx\" directives to perform the equivalent of specifying --load:myfile.fsx on the command line. There is currently no equivalent #use \"myfile.fsx\" directive equivalent to the --use:myfile.fsx command-line flag; looking through the F# source code, it appears this was attempted at some point and abandoned. I tried to finish the implementation when working on the NHol project (a port of hol-lite to F#), but ran into some issues I was unable to resolve. I'd be happy to share the work I did if it would be helpful in getting the #use directive implemented.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Declining as the removal of #use was indeed deliberate – the need to parse and import all directives from used files made source analysis of scripts in the editor considerably more difficult than we liked.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5670137": {
        "Number": "5670137",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "#package directive to import NuGet packages in F# interactive",
        "Text": "It would be quite useful for F# interactive to support a #package directive to allow NuGet packages to be downloaded from within the REPL. I think it would be best if this directive simply downloaded the package, unpacked it, and automatically included (#I) the correct folder based on the framework version F# interactive is running under (e.g., net45). If a package doesn't include assemblies for the specific framework version F# interactive is using, we'd automatically include the folder for the latest framework version which is compatible; e.g., if running on .NET 4.5 and a package only includes a 'net40' folder, we'd include (#I) that folder. I believe this behavior is consistent with how NuGet currently works when referencing packages from a project, e.g., in Visual Studio.\r\n#package should not, however, automatically reference (#r) the assemblies included in the package, in case you only want to reference some of them.\r\nHere's a usage example:\r\n#package \"ExtCore.0.8.41\"\r\n#r \"ExtCore.dll\";;\r\nlet substr = substring \"Hello World!\"\r\nprintfn \"Value: %O\" substr;;",
        "Votes": 248,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T08:46:00",
                "Content": "Yes!"
            },
            {
                "Submitter": "Christoph Rüegg",
                "Submitted": "2014-04-23T12:50:00",
                "Content": "See also: https://visualfsharp.codeplex.com/workitem/42"
            },
            {
                "Submitter": "Greg Chernis",
                "Submitted": "2014-09-15T20:03:00",
                "Content": "Here's a workaround: http://tobivnext.wordpress.com/2014/03/26/import-nuget-packages-to-fs-interactive/"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-14T12:04:00",
                "Content": "You can use the following formula to download both a package-management-client tool (paket.exe) at the start of a script and then use it to then download nuget packages:\r\nhttps://gist.github.com/dsyme/9b18608b78dccf92ba33\r\nIt's really cool and close to what's needed, without building in things into F# Interactive.\r\nAdding #nuget to F# Interactive would be a smoother experience, but also has some risks (e.g. nuget is still an evolving thing in many ways)."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T17:54:00",
                "Content": "I like that this would be independent of the package management client."
            },
            {
                "Submitter": "zjv",
                "Submitted": "2015-12-04T07:18:00",
                "Content": "It would be nice if one could also easily import DLL's from projects in the current solution !"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-28T00:38:00",
                "Content": "Instead of a specific directive what if we could define a set of preprocessors with custom behaviors in a dll and have fsi automatically reference that assembly at startup."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-07-28T19:11:00",
                "Content": "issue on github https://github.com/Microsoft/visualfsharp/issues/56"
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5670163": {
        "Number": "5670163",
        "Submitter": "Will Smith",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Fixed Length Arrays",
        "Text": "Originally posted here: https://groups.google.com/forum/#!topic/fsharp-opensource/pI73-GkoxbY\r\nThe ability to have fixed arrays would most definitely make interop easier, instead of having to calculate the size by hand and just hope for the best. I have been burned by calculating everything by hand a ton.",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T10:56:00",
                "Content": "Hi Will -- can't you already do this via the [<MarshalAs>] attribute? For example, the code from your newsgroup post could be implemented like this:\r\nnamespace Blah\r\nopen System.Runtime.InteropServices\r\n[<Struct>]\r\ntype vec3_t =\r\nval mutable X : int\r\nval mutable Y : int\r\nval mutable Z : int\r\n[<Struct>]\r\n[<StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]\r\ntype md3Frame_t =\r\n[<MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)>]\r\nval mutable bounds : vec3_t[];\r\nval mutable localOrigin : vec3_t;\r\nval mutable radius : float32;\r\n[<DefaultValue>]\r\n[<MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)>]\r\nval name : string;"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T11:35:00",
                "Content": "I believe I've tried this in the beginning, it doesn't exactly like I want. Some more info: http://www.mono-project.com/Interop_with_Native_Libraries#Marshaling_Class_and_Structure_Members\r\nExample:\r\n[<Struct>]\r\n[<StructLayout (LayoutKind.Sequential)>]\r\ntype ManagedStruct_Slow =\r\n[<MarshalAs (UnmanagedType.ByValArray, SizeConst=10)>]\r\nval data : int []\r\n[<MarshalAs (UnmanagedType.ByValTStr, SizeConst=32)>]\r\nval name : string\r\nThe actual size of this struct is only 8 bytes, and this struct isn't considered unmanaged anymore. I need the struct to be exactly the same size as what is on the C side. This makes the interop 1-to-1 completely. When I tried this in the beginning, it did not work, especially when C is calling F#."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-23T13:00:00",
                "Content": "Will -- one issue with your example code is that you left out the CharSet.Ansi modifier in [<StructLayout>]. This means that unless you're using Windows 98 or ME (hopefully not!), your strings are getting marshalled with 2-byte Unicode chars instead of 1-byte 'unsigned char's as C expects.\r\nIf you define this type, then do sizeof<ManagedStruct_Slow> in your code, it'll return 8 or 16 depending on whether you're on a 32- or 64-bit platform, because the struct only really contains two references. It should still be marshalled correctly though, thanks to the MarshalAs attributes.\r\nAs for the struct not being considered 'unmanaged', I assume you want to use the struct with nativeptr<'T>? If possible, you're better off using byref<'T> (&) instead of nativeptr<'T> (&&)/(*); I often just create simple structs wrapping 'nativeint' for this purpose. I'm personally not a big fan of nativeptr<'T> -- I've run into too many issues with it over the years."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T16:10:00",
                "Content": "Hey Jack,\r\nIt was an example to just show that the struct will not be the same size as a C version. I'm aware of the differences that occur with strings and how they need to be handled properly.\r\nI can try to give this another go using MarshalAs and byref; but if I remember right, this wasn't working for me. Last time I tried was 8-9 months ago. If it works out then cool, :) , interops will be a bit better.\r\nWhat are some the issues that you run into with nativeptr<'T>? I've only run into the fixed length problems.\r\nAlso, here is an example of how I'm using nativeptr https://github.com/TIHan/FQuake3/blob/7a42a92d1a182a173eb09590ffd7f0c50dd24adc/src/FSharp/Engine.Renderer/NativeMappings.fs"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T17:26:00",
                "Content": "From the Mono documentation in a previous comment, it says \"the runtime doesn't automatically allocate arrays specified as UnmanagedType.ByValArray. The programmer is still responsible for allocating the managed array.\" More info: http://www.mono-project.com/Interop_with_Native_Libraries#marshaling-members-summary\r\nThis is why I couldn't use it. Having to manually allocate, adds not only additionally overhead, but additional complexity. Only having the param type be \"nativeptr<md3Frame_t>\" and that's all I have to worry about, feels a lot more sane considering the magnitude of the amount of C structs I'm having to deal with. Also, with the type being unamanaged and using nativeptr, I'm not doing any marshaling at all, therefore I do not have any performance issues associated with marshaling at that layer.\r\nI need this kind of control when manually mapping an unmanaged type to an idiomatic F# record/struct, and vice versa."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-27T05:27:00",
                "Content": "I would also like fixed arrays in F# but, alas, I have long since run out of user voice votes. :-("
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-29T09:55:00",
                "Content": "I've hand-translated an example using C# fixed buffers to F#. Unfortunately, the F# code doesn't compile, because the original example used the C# 'fixed' construct to pin the class containing the buffer; however, the structs shown in the example could be used in current versions of F#, e.g., for marshalling purposes.\r\nhttps://gist.github.com/jack-pappas/9725445"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T08:56:00",
                "Content": "Looking at the discussion it seems the last comment by Jack Pappas shows a way to do this, apart from the orthogonal question of support for \"fixed\", covered here: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663721-add-support-for-fixed\r\nSo I think we can close this and I'll link across to here for the \"fixed\" issue"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Closing since it appears this is possible in F# – but “fixed” is missing, which is this approved issue: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5670163-fixed-length-arrays"
        }
    },
    "5670328": {
        "Number": "5670328",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Additional intrinsics for the NativePtr module",
        "Text": "When interoperating with native code, it would be handy if the NativePtr module included some additional \"intrinsic\" functions for taking advantage of low-level IL instructions; specifically, I'd like to be able to use 'cpblk', 'initblk', 'initobj', and 'copyobj'.\r\nIt would also be nice to have an easy way of checking for null pointer values.\r\nExample implementation of these functions:\r\n[<RequireQualifiedAccess>]\r\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\r\nmodule NativePtr =\r\n[<GeneralizableValue>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"Zero\")>]\r\nlet inline zero<'T when 'T : unmanaged> : nativeptr<'T> =\r\n(# \"ldnull\" : nativeptr<'T> #)\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"IsNull\")>]\r\nlet inline isNull<'T when 'T : unmanaged> (ptr : nativeptr<'T>) =\r\n(# \"ceq\" zero<'T> ptr : bool #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"InitBlockInlined\")>]\r\nlet inline initBlock (p : nativeptr<'T>) (value : byte) (size : uint32) =\r\n(# \"initblk\" p value size #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"CopyBlockInlined\")>]\r\nlet inline memcpy (destPtr : nativeptr<'T>) (srcPtr : nativeptr<'T>) (count : int) =\r\n(# \"cpblk\" destPtr srcPtr (count * sizeof<'T>) #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"InitPointerInlined\")>]\r\nlet inline clear (p : nativeptr<'T>) =\r\n(# \"initobj !0\" type ('T) p #)\r\n[<Unverifiable>]\r\n[<NoDynamicInvocation>]\r\n[<CompiledName(\"CopyPointerInlined\")>]\r\nlet inline copy (destPtr : nativeptr<'T>) (srcPtr : nativeptr<'T>) =\r\n(# \"copyobj !0\" type ('T) destPtr srcPtr #)",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-23T10:50:00",
                "Content": "Definitely agree with this! I've had to create my own naive versions of some of these. https://github.com/TIHan/FQuake3/blob/4d5a5702a6ae06cd8e4b57431e656ab4dfd39ac4/src/FSharp/Engine/NativeInterop.fs#L73\r\nWith your listings, maybe another one that casts a nativeptr to another nativeptr type would be super useful as well, though may not be related to your intrinsics. Perhaps, NativePtr.cast ?"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-28T18:19:00",
                "Content": "Will -- nativeptr<'T> is just nativeint with a generic type annotation grafted onto it, and it's erased to nativeint at compile-time. Implementing a cast function like you described should be straightforward if you use the F# proto-compiler. IMO it wouldn't be a good addition to FSharp.Core though, because it would totally bypass any and all type-safety. In any case, the difference between your cast function and the intrinsics I listed above -- you can implement your cast with the current version of F#, but the above intrinsics can't be compiled due to some changes that were made to the ILX layer and metadata picker in F# 3.0."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-28T18:21:00",
                "Content": "One other thing to point out -- having these intrinsics available in normal F# code would make it possible to implement high-speed native interop libraries like SharpDX without having to resort to IL-rewriting: https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/4334135-extend-c-to-close-gaps-for-high-performance-nativ"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-13T13:55:00",
                "Content": "Yea, it was only recently did I found out that nativeptr<'T> is really just a nativeint. Thanks for giving more info on it.\r\nYou make a good point on the type safety, but as we are already in an unsafe context and potentially messing with unmanaged memory, a NativePtr.cast would only benefit handling memory. Is there a better way of going about it? I would interested in an alternative."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-06-25T17:46:00",
                "Content": "In this vein, it would be useful to be able to easily use what amounts to a binary cast from a byte array, as in C# (fixed byte* p = &b[offset]) { return *(SomeUsefulStruct*)p; }"
            },
            {
                "Submitter": "Frank Niemeyer",
                "Submitted": "2014-07-02T03:42:00",
                "Content": "@Sebastian: The only thing that F# is missing for this is the \"fixed\" statement (you'd have to pin the byte[] by allocating a GCHandle). The dereferencing (i.e. copy the contents of the byte array to a struct of type T) can achieved today using p |> NativePtr.toNativeInt |> NativePtr.ofNativeInt<'T> |> NativePtr.read."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-09T19:00:00",
                "Content": "@Sebastian @FrankNiemeyer I've also suggested 'fixed' be implemented for F# 4.0: [/ideas/suggestion-5663721-add-support-for-fixed](/ideas/suggestion-5663721-add-support-for-fixed.md)"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-09T19:01:00",
                "Content": "I've implemented these additional intrinsic functions and will be sending a pull request ASAP: https://visualfsharp.codeplex.com/SourceControl/network/forks/jackpappas/fsharpcontrib?branch=native-interop"
            }
        ],
        "Status": "started",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "I’m marking this as “approved” for F# 4.0+.\r\nA pull request for this feature has been submitted here:\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/jackpappas/fsharpcontrib/contribution/7134\r\nThanks\r\nDon, F# Language Design"
        }
    },
    "5670335": {
        "Number": "5670335",
        "Submitter": "Will Smith",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Pure Functions - \"pure\" keyword",
        "Text": "I've been thinking about this one for a while.\r\nAt the moment, it's pretty easy to make a pure function and as a long as you follow a few rules, you should be fine. There is just no guarantee. A way for the F# compiler to enforce a function to be \"pure\" and not allow any side effects/mutations ever would ensure that guarantee. A \"pure\" function will have more constraints. This may also allow for more aggressive optimizations.\r\nA challenge with this is how do we handle existing functions that are referentially transparent and types that we know are immutable. My best shot at this is only allow the F# compiler to make exceptions to functions/types to be allowed in \"pure\" functions. An example would be the \"string\" type and its functions.",
        "Votes": 116,
        "Comments": [
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-03-25T06:19:00",
                "Content": "I like this idea. You could say that a pure function does not close over any variables in outer scope, and can only call methods & access properties that are themselves marked as pure. E.g.\r\nlet x = 5\r\nlet printx() = printfn \"%i\" x // This function is NOT pure\r\nlet pure add x y = x + y // This function is pure because it only acts on variables explicitly passed in, and because the \"+\" operator is pure.\r\ntype Customer = { Id: Guid; mutable Name: string }\r\nlet pure formatId c = sprintf \"The id is %A\" c.Id // Immutable properties can be accessed in pure methods\r\nlet formatName c = sprintf \"The name is %s\" c.Name // Mutable properties make the method non-pure\r\nThis seems more \"correct\" somehow, but I'm not 100% sure what pure methods would actually give you..."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-26T10:26:00",
                "Content": "Richard,\r\nPure functions give you an absolute guarantee that a function does not have any side effects. Can be very useful if you need to run computations in parallel. We can still do this, but there is no guarantee.\r\nI'm not sure how I feel with using immutable properties, I think I would only want to use immutable records/structs with no fields marked as mutable. But, maybe it does make sense to use only immutable properties. I think it's definitely worth exploring this idea. :D"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-29T10:54:00",
                "Content": "If this were implemented, why not use the existing [<Pure>] attribute instead of adding a keyword? http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute%28v=vs.110%29.aspx\r\nIf the keyword is implemented instead, the compiler should decorate the method with [<Pure>] in the compiled assembly for interoperability with Code Contracts."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-31T13:43:00",
                "Content": "Not fully against using the [<Pure>] attribute; however, when writing pure functions, I would hate to have to type out \"[<Pure>]\" over every method on top of \"let\".\r\nImagine this everytime:\r\n[<Pure>]\r\nlet addOne x = x + 1\r\n[<Pure>]\r\nlet addTwo x = x + 2\r\nvs.\r\nlet pure addOne x = x + 1\r\nlet pure addTwo x = x + 2\r\nUsing the keyword makes creating the pure functions a natural part of the language. Using the attribute just feels like a fix to get the desired behavior.\r\nNow, it's ok to decorate the compiled pure function with the [<Pure>] attribute."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2014-04-13T12:05:00",
                "Content": "IMHO, in the same way we have a 'mutable' keyword, we shouldn't have a 'pure' keyword, but an 'impure' one! Always default to the best outcome...\r\nThis way, all functions should be assumed pure, and when one is not, the compiler should generate a warning if it doesn't contain the \"impure\" keyword."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-13T12:12:00",
                "Content": "This means that all existing code would not compile and/or have warnings all over of the place. :(\r\nMaybe, \"pure\" can be on functions like this:\r\nlet pure f x = x + 1\r\n--\r\nbut we could also have it on modules:\r\nmodule pure internal BestModule\r\n--\r\nThat way, anything inside the module would only allow pure functions. Though, it gets more complicated as modules can contain classes, records, structs, etc."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2014-04-13T12:19:00",
                "Content": "> This means that all existing code would not compile and/or have warnings all over of the place\r\nYou would only pay this price if you upgrade to F# v.Next"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-13T12:36:00",
                "Content": "Maybe a better way to handle this would be to have a compiler directive:\r\n#pure\r\nThis will make the file you are in only able to use pure functions and immutable types. This would get rid of having to have \"pure\" being used with functions or modules as well as using the [<Pure>] attribute. Should be a fair compromise. Thinking about it, I think a compiler directive is the cleanest way."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-08T23:01:00",
                "Content": "May be an attribute would do"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-06-09T08:57:00",
                "Content": "Microsoft Research's Koka programming language infers this quality as part of the type. They take it further with Total functions (pure functions that do not diverge or throw). It seems like a logical next step to have the 'effectfulness' be a part of the type, and for it to naturally be inferred, although as the paper on it mentions this adds some complexity when composing.\r\nIf you can infer 'purity' or 'totalness' 'pure' or 'impure' could be an optional keyword on the type."
            },
            {
                "Submitter": "amazingant",
                "Submitted": "2014-06-25T14:58:00",
                "Content": "I'd definitely prefer the compiler directive as Will put it. Coming from VB development, it's nice to be able to turn off Option Strict for the few files in a project that haven't been cleaned up yet.\r\nFollowing that train of thought, for libraries and so forth, perhaps being able to set this value for the project as a whole? This would mean taking the opposite approach to the OP and more towards what I have to do with VB's Option Strict, namely telling the compiler \"please consider this entire project to be made of pure functions...except this file\""
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T10:27:00",
                "Content": "I like the idea, but I also think it would be more useful to mark whole modules or libraries as pure rather than single functions."
            },
            {
                "Submitter": "Ovidiu Deac",
                "Submitted": "2014-10-25T19:35:00",
                "Content": "As knocte suggested I think it's better to have impure, in the same way we have mutable. Then you should be able to disable the warning for backwards compatibility."
            },
            {
                "Submitter": "Jannick B",
                "Submitted": "2015-01-25T02:05:00",
                "Content": "I'd rather have an impure keyword added to anything that and let pure be the default"
            },
            {
                "Submitter": "amazingant",
                "Submitted": "2015-02-26T08:03:00",
                "Content": "While I agree it would have been nice when F# was originally being developed, Microsoft doesn't really do breaking changes like that. Even as just a compiler warning, if it's an opt-out I'll end up telling management that \"Microsoft changed this behavior in the last release, so I need to rewrite some code.\" Nobody will care that it improves the code quality or that it can be turned off, they'll just care that Microsoft \"broke\" something.\r\nIf this is added as a \"pure\" keyword, or some other opt-in, I can tell management that \"I'm turning on this new feature so that I write better code; it will probably tell me some old code isn't as good as it could be.\" While it means it's something they can tell me not to do because time constraints, I could still start sprinkling the pure keyword into code as things get added or rewritten."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T06:16:00",
                "Content": "The ramifications on a type system to track effects and/or purity are substantial, and considerably more is needed than declaring and checking named functions as pure. For example:\r\n- The integration with higher-order features is very difficult. \"List.map pureFunction\" is also pure, but the type system won't know this. \"Seq.map pureFunction\" is pure if the input enumerable is pure when enumeration is performed, but the type system won't know this\r\n- Other effects besides purity (the \"zero effect\" quickly become of interest, including termination, exceptions, read/write effects, IO effects etc.\r\n- The space of possible inferred types for code becomes large (with no \"best type\" guaranteed) and the inferred types themselves are large and subtle\r\nThere are human-factor considerations to take into account as well - \"can a beginner understand the type of List.map\" and \"when and where do we show effect annotations in error messages?\" and \"can a team mixing beginners and advanced experts make good use of this feature?\"\r\nFor F# the stable approach is has so far been to push this off to FSharpLint-style tooling. The F# compiler service exposure of typed expression trees is relevant here."
            },
            {
                "Submitter": "Schalk Dormehl",
                "Submitted": "2015-10-16T08:59:00",
                "Content": "The true value of the fuctional revolution has been to seperate commands and queries from one another. The problem is that the idea has been extrapolated beyond it's real usefulness, IE things like Haskell, where there are no commands, only functions but now commands need to be simulated.\r\nIronically good command / query seperation has existing in SQL for a long, long time. T-SQL functions do not have side effects, you can't even call Random or Print.\r\nThe introduction of a Command keyword and a \"pure\" keyword would be epic. I think that the best method for implementing the pure keyword is to have it as an extension to the language initially. It would simply not be allowed to do any re-assignements to mutables and it will not be allowed to call a command. It may be necessary to go one step further than that and not allow it to refer to any mutable variables either to ensure memiozation.\r\nPS Typescrypt has added the let keyword. I think the chances are best to introduce a pure fuction syntax into that."
            },
            {
                "Submitter": "knocte",
                "Submitted": "2016-01-06T21:04:00",
                "Content": "I've realized that there could be a simpler way to achieve this: in the same way C# requires you to use an -unsafe flag to call the compiler when you use the unsafe keyword in your project, F# could require a -mutable flag when you use the mutable keyword in any shared member (mutable keywords for variables inside a method, for example, would be allowed, as they are not shared).\r\nThis is maybe not a full solution w.r.t. purity/impurity handling (because you could still have impurity via IO without mutable members), but it would be a first step towards it."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:59:00",
                "Content": "The proposal doesn't mention what happens in higher order cases. For example, can you constrain an input function to be pure?\r\nAlso it's not actually clear what additional optimizations we would actually implement (rather than think about implementing) if \"pure\" were added....."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining per my comment of July 18, 2015 12:16\r\nDon Syme, F# Language Evolution"
        }
    },
    "5670437": {
        "Number": "5670437",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Improve support for managed pointers (as in C# unsafe code)",
        "Text": "It is currently quite difficult in F# to interoperate with 'unsafe' C# code due to C#'s use of managed pointers (ilsigptr<'T> in F#). At the very least, it would be handy to have a ManagedPtr module available in FSharp.Core under the Microsoft.FSharp.NativeInterop namespace, similar to the existing NativePtr module.\r\nIf support for managed pointers were to be improved, it would be beneficial to rename them -- ilsigptr<'T> is a rather obscure name for those without a good understanding of IL and the CLR's type system. Perhaps we could rename it to managedptr<'T>, which would fit nicely alongside the existing nativeptr<'T>.\r\nImproved support for managed pointers would also go hand-in-hand with support for 'fixed'-bound variables: [/ideas/suggestion-5663721-add-support-for-fixed](/ideas/suggestion-5663721-add-support-for-fixed.md)\r\nWhen using the (&&) operator, and the * modifier in external function signatures, the F# compiler infers the types as nativeptr<'T>; I think it would be preferable if the compiler inferred these as managedptr<'T> instead, for better type safety when interoperating with other languages (e.g., C#). This could be implemented as the new default behavior in a future version of F#, and anyone relying on the nativeptr<'T> behavior could turn it back on using a compiler flag (e.g., --prefer-nativeptrs).",
        "Votes": 33,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-29T10:02:00",
                "Content": "One additional idea which is semi-related to this -- the 'nativeptr<'T>' type in F# is currently just a type alias for 'nativeint'. Why doesn't it use the CLR's built-in unmanaged pointer type to preserve type information in the compiled assemblies? C# supports this unmanaged pointer type, e.g., when using the 'fixed' construct."
            },
            {
                "Submitter": "Frank Niemeyer",
                "Submitted": "2014-06-22T11:18:00",
                "Content": "@Jack: Only concrete instances of nativeptr<'T> translate to the corresponding T*. When you expose an F# function with a, e.g., nativeptr<byte> in its signature it surfaces as a byte* in C#; only a generic nativeptr<'T> shows up as an IntPtr (= native int), maybe because C# cannot really handle generic typed pointers (no \"unmanaged\" type constraint)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:02:00",
                "Content": "I need more information on this. Could you give an example please that shows a case where we need to make use of ilsigptr from C#, and they are not interpreted as byref<T>?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:03:00",
                "Content": "I will mark this as declined pending more details."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marking as declined pending an example where this is needed"
        }
    },
    "5670585": {
        "Number": "5670585",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Intellisense in F# Interactive",
        "Text": "F# Interactive can be pretty handy for prototyping code and one-off exploratory data coding. At the moment it seems like many people use it via writing code in an F# script file (e.g., in Visual Studio) and using the \"Send to F# Interactive\" command to evaluate the code, because F# Interactive doesn't support Intellisense. If F# Interactive did support Intellisense, it'd be much easier to stay within the REPL instead of jumping back and forth between the REPL and script files.",
        "Votes": 20,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T07:42:00",
                "Content": "I think you want an F# notebook front-end like Mathematica's notebook front end. If you'll be entering code directly into an interactive session then you probably want the ability to save and load it too."
            },
            {
                "Submitter": "Jack Fox",
                "Submitted": "2015-11-20T18:20:00",
                "Content": "http://alekseyv-dev.blogspot.com/2015/10/implementing-f-interactive-intellisense.html"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-27T00:00:00",
            "Text": "This suggestion belongs in Visual Studio user voice (for the Visual F# Tools) or the github issues for the Visual F# Power Tools. This user voice is for the F# language itself."
        }
    },
    "5670940": {
        "Number": "5670940",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Syntax coloring for type identifiers in VS F# language service",
        "Text": "Visual Studio supports the ability for a language service to 'tag' tokens representing type identifiers so they can be assigned custom colors by the user. C# and VB.NET both support custom coloring, which makes it trivial to tell the difference between structs and classes (for example). VB.NET supports custom colors for some other identifiers as well.\r\nIt would be nice for F# to at least support the basic coloring types (classes, delegates, interfaces, enums, generic parameters); if possible, it would be useful to add DU and record types and modules. Type abbreviations would 'inherit' the coloration of whatever type they're abbreviating.\r\nYou can see the color options in Visual Studio by going to Tools -> Options -> General -> Fonts and Colors. F# Interactive currently has it's own settings (under the \"Show Settings For\" drop-down), but personally I'd prefer it used the same font/color scheme as the rest of my F# code in Visual Studio. The only thing that really makes much sense to override for F# Interactive is the font size, e.g., when demonstrating on a projector.",
        "Votes": 9,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-03-27T00:00:00",
            "Text": "This suggestion belongs in Visual Studio user voice (for the Visual F# Tools) or the github issues for the Visual F# Power Tools. This user voice is for the F# language itself."
        }
    },
    "5671087": {
        "Number": "5671087",
        "Submitter": "Jack Pappas",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Smart constructors for DU cases",
        "Text": "When a DU type is defined, the F# compiler creates a static method on the class for each defined, non-nullary case. The method is called NewXYZ, where XYZ is the name of the case.\r\nIt would be useful to be able to decorate a non-nullary case with an attribute [<SmartConstructor>] which would cause the compiler to add a suffix (e.g., \"Impl\") to the normal factory method for the case (described above) and also mark it 'private'. The compiler would then require you to define a static NewXYZ method on the type, taking the same arguments in the same order as the case.\r\nThis would provide a way to implement \"smart constructors\" for a union type in such a way that there'd be no way to accidentally _not_ call them when creating an instance of the case. These \"smart constructors\" are extremely useful for enforcing invariants when implementing functional data structures, or automatically applying simplification routines (e.g., to an arithmetic AST) to enforce normalization and minimize computation time; it could also be used to enforce validation of data held by a DU type.\r\nWithin the custom factory method for a case, any places where an instance of _this_specific_case_ is created, we'd call the now-private, compiler-generated factory method. For any other cases being created, we'd call the normal, public factory method for that case (which may itself be a custom factory method).\r\nFor example:\r\ntype Email =\r\n[<SmartConstructor>]\r\n| Valid of EmailAddress:string\r\n| Invalid of ErrorMessage:string\r\nwith\r\nstatic member NewValid (address : string) =\r\n// Validate the given address.\r\nif String.IsNullOrEmpty address then\r\nInvalid \"The address was null or empty.\"\r\nelse\r\n// Pretend we have some validation function here which returns an error message if the email is invalid\r\nmatch EmailAddress.Validate address with\r\n| true, _ ->\r\nValid address\r\n| false, errMsg ->\r\nInvalid errMsg",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T08:49:00",
                "Content": "Thanks for the suggestion.\r\nEnforcing invariants on union and record types is a serious issue. The recommended way is either to use a class type, or to hide the representation.\r\nThis is an interesting midpoint, which is to intercept the construction methods for the union type. It's more difficult to design a corresponding way to do this for a record type.\r\nHowever, in the balance this feels too adhoc to embrace in the F# language design: would we do the same for Is*? for accessors? Would we make union types purely pattern-based? Just doing the New* case seems like scratching the surface and opening a box with more inside it.\r\nI will mark this as declined, though it's definitely an interesting idea and something I had not thought of doing."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion, which is definitely interesting. Declining per my comment, please take a look\r\nDon Syme, F# Language Evolution"
        }
    },
    "5672202": {
        "Number": "5672202",
        "Submitter": "Sergey Tihon",
        "Submitted": "2014-03-23T00:00:00",
        "Title": "Allow Type Providers to be compiled to *.exe file.",
        "Text": "http://stackoverflow.com/questions/18181906/f-type-provider-compiled-as-exe-file\r\nType Provider compiled as *.exe file can have [<EntryPoint>]. Such assembly may be executed as standalone process for design-time type inference.\r\nThis feature dramatically simplify development of Interop Type Providers (R, Python, PowerShel). It allows to execute type inference in 64 environments and safely deal with unmanaged code that potentially can crush VS process.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-24T17:43:00",
                "Content": "This is actually a very annoying limitation. I know it's not that a common pattern, but I often use libraries as .exe so they can have both uses, and not being allowed in TPs is annoying. I keep changing project type to debug"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:46:00",
                "Content": "This sounds like something that just needs to get done."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T07:36:00",
                "Content": "I think the best way to progress this is to somehow generalize the technique used by the FSharp R type provider, which (optionally?) uses a server process. Putting the generalization of that into the F# Type Provider Starter Pack would make sense.\r\nNeither of these would require changes to the F# compiler itself."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Declined per my comment – this is best done by having a type provider start a proxy process, just as the R provider does.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "5673015": {
        "Number": "5673015",
        "Submitter": "Howard Mansell",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Support C#-like Anonymous Types in F#",
        "Text": "Commonly I want to return some named values, or sequence of named values, in some expression. Currently I am forced to either go through the additional effort of defining a type, or use a tuple (with its associated error-proneness if there are multiple values of the same type). Anonymous record types would be very useful and would eliminate one of the areas of additional verbosity compared to C#.",
        "Votes": 215,
        "Comments": [
            {
                "Submitter": "Lev Gorodinski",
                "Submitted": "2014-03-24T08:26:00",
                "Content": "An alternative is to use a dynamic operator https://www.nuget.org/packages/FSharp.Dynamic/ which can be useful for constructing values at application boundaries. For calls within an application, I would stick to explicit types though."
            },
            {
                "Submitter": "Joel Mueller",
                "Submitted": "2014-04-22T11:51:00",
                "Content": "You can't use the dynamic operator in a quotation, however. There are some C# libraries (such as Neo4jClient) that expect LINQ expression trees that create anonymous types, and extract property names and data types from the expression tree. An F# equivalent is only possible if the dynamic operator is usable in a quotation, or if F# supports anonymous types."
            },
            {
                "Submitter": "Manuel",
                "Submitted": "2014-06-03T07:43:00",
                "Content": "Swift just introduced that also with named member tuples"
            },
            {
                "Submitter": "Maciej J. Bańkowski",
                "Submitted": "2014-06-05T09:54:00",
                "Content": "@Joel Mueller, I have created a pull request for Neo4jClient that includes support for tuples: https://github.com/Readify/Neo4jClient/pull/56 It is not perfect but works as a workaround for the lack of anonymous types.\r\nBTW I totally agree F# should support something like anonymous record types. I do not know why this comes up so late in the F# dev cycle but the requirement to create one-time-use types to work with data is hard for me to understand. As @Lev Gorodinski noted, dynamic has major drawback in that it relaxes strong typing which is a very important F# feature we should keep.\r\nDoes anyone know if there is any technical issue preventing implementation of anonymous types in F#?"
            },
            {
                "Submitter": "Eamon Nerbonne",
                "Submitted": "2014-06-21T03:01:00",
                "Content": "Swift's solution isn't very good, however, so let's not copy that. in particular, swift's names don't really matter, it's still just a positional tuple, so when you do a destructuring let binding, you bind by position, not name. If you happen to swap the names (or mistype one, or refactor and change a member's name), then swift will still let you destructure by position, ignoring the names."
            },
            {
                "Submitter": "Eamon Nerbonne",
                "Submitted": "2014-06-21T03:22:00",
                "Content": "I think this would go particularly well with destructuring let bindings for records - (http://fslang.uservoice.com/forums/245727-f-language/suggestions/6081483-allow-destructuring-let-bindings-for-records-or-t)."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-06-21T17:58:00",
                "Content": "For a bit of historical perspective, structural record types were part of Standard ML decades before C#."
            },
            {
                "Submitter": "Christopher Stevenson",
                "Submitted": "2014-07-04T02:43:00",
                "Content": "If the issue with this idea is syntax, here's a thought: \"new with { property1 = value; property2 = value }\". The \"new with\" indicates that this is an anonymous record."
            },
            {
                "Submitter": "Michael",
                "Submitted": "2014-11-12T17:21:00",
                "Content": "What's the benefit here? Creating anonymous types, just to turn around and use reflection on them seems sort of hacky. C# APIs like ASP.NET MVC use this because they don't have any slick way of doing [ \"prop1\", \"val1\"; \"prop2\", \"val2\" ]."
            },
            {
                "Submitter": "Jari Pennanen",
                "Submitted": "2015-06-24T00:54:00",
                "Content": "Anonymous Records (which is a same thing as propsed here) are really neat, they are basically like TypeScript interfaces, allowing structural typing where it makes sens.\r\nScala (library) implementation: http://downloads.typesafe.com/website/presentations/ScalaDaysSF2015/T4_Vogt_Compossible.pdf\r\nAbove Scala implementation has some really great benefits, potentially shortening typesafe SQL syntax a lot.\r\nHaskell (library) implementation https://gist.github.com/nikita-volkov/6977841 not very familiar with this one, but that is where I took the name."
            },
            {
                "Submitter": "Ben Lappin",
                "Submitted": "2015-09-18T11:13:00",
                "Content": "One benefit is that if you're only using a type in one place, somewhere deep inside a let binding, you currently need to define the type prior to the outermost let, which can be inconvenient. Take the following example:\r\ntype Thingy = { Inty: int; Stringy: string }\r\nlet ....\r\nlet ....\r\nlet aThingy = { Inty = 5; Stringy = \"F# is fun\" }\r\nIt would be preferable to be able to write something like:\r\nlet....\r\nlet....\r\nlet aLocalThingy = { Inty: int = 6; Stringy: string = \"Future F# is funner\" }\r\n...and in either case, you could then do what you needed with the record, as long as the flow of code allowed its (anonymous) type to be inferred.\r\nEssentially I would see this as \"syntactic sugar\" over defining a type that will only be used in one place."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:11:00",
                "Content": "See also this suggestion which is somewhat related http://fslang.uservoice.com/forums/245727-f-language/suggestions/8107647-extend-with-keyword-support-to-record-definition"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:21:00",
                "Content": "See also this suggestion on StructTuple compatible with C# tuples: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6148669-add-support-for-structtuple"
            },
            {
                "Submitter": "Yemi Bedu",
                "Submitted": "2016-06-01T17:08:00",
                "Content": "What is the expectation for these types to shadow each other?\r\nWould you want the compiler to warn about a named record that matches your anonymous one in certain use cases?\r\nExamples would be anonymous record of { Length:int ; Width:int } that could be in a lot of places.\r\nAnother example is if you describe a Point { X:int ; Y:int } and later the anonymous version gets used in a function.\r\nShould it infer Point or just warn \"a named record of type Point matches\"?\r\nWould we want the allow declaration signatures to be anonymous\r\nlet Girl = {Name: string ; Age: int }\r\nlet Boy = {Name: string; Age: int }\r\nlet greet (child: {Name;Age}) = printfn \"%A\" child.Name\r\ngreet {Name=\"you\";Age=21}"
            },
            {
                "Submitter": "Bruno Bozza",
                "Submitted": "2016-08-15T20:39:00",
                "Content": "This is badly needed for data wrangling over typed datasets. I tried to use F#, which I prefer for everything else, but when every 5 lines of query code induce a new record type, updating the records becomes tedious very quickly, so I am back to C# for this.\r\nC#'s support is not perfect (or new), but it has really convenient record punning. And for the drastic cuts they had to make in the design (i.e.: anonymous types being non-denotable and limited to method scope), my favorite feature of this design is that it allowed the team to ship it, and now I can use it. Yes, I expect more from F#, but I would be happy to give up on structural subtyping, first class labels and even denotability, in order to get C#-style functionality."
            },
            {
                "Submitter": "Tomas Lycken",
                "Submitted": "2016-09-05T09:05:00",
                "Content": "I'd love this! See http://stackoverflow.com/q/39306148/38055 for a use case."
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5674080": {
        "Number": "5674080",
        "Submitter": "Braden Evans",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Allow units of measure on structs without making them generic",
        "Text": "Currently you can create structs with a measure type argument like so:\r\n[<Struct>]\r\ntype vec3<[<Measure>] 'u> =\r\nval mutable X: float<'u>\r\nval mutable Y: float<'u>\r\nval mutable Z: float<'u>\r\nThis has the unfortunate side-effect of making the struct generic (and thus not blittable, and increasing the size by 8 bytes)\r\nSince units of measure are erased at compile time and the struct does not actually have any fields with generic types this is disappointing! Enabling use on primitive structs would greatly enhance the utility of units of measure - since they \"infect\" the codebase it is hard to use in some places but not others.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:25:00",
                "Content": "The underlying struct is not generic when a measure type parameter is added."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nAs far as I can tell the underlying struct type is not generic (in compiled code). Is there another issue lurking here?\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "5674917": {
        "Number": "5674917",
        "Submitter": "Mark Seemann",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Add Option.filter",
        "Text": "It may be that I'm missing something obvious, but doesn't the Option module lack a filter function?\r\nlet x1 = Some 1\r\nlet x2 = Some 3\r\nlet y1 = x1 |> Option.filter (fun i -> i = 3) // Returns None\r\nlet y2 = x2 |> Option.filter (fun i -> i = 3) // Returns Some 3",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T18:46:00",
                "Content": "You could just use FSharpx ( https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/ComputationExpressions/Monad.fs#L238 ) or ExtCore ( https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Pervasive.fs#L881 ) or FSharpPlus (the generic 'filter' function).\r\nJust like filter, there are a lot of functions that could be included in FSharp.Core. IMHO it's best to leave FSharp.Core to be minimal and implement these additional functions in separate libraries that can evolve at their own speed."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This is approved for F# 4.0+\r\nAn implementation and testing has been submitted to the “fsharp4” branch of visualfsharp.codeplex.com here: http://visualfsharp.codeplex.com/SourceControl/network/forks/ploeh/optionfilter/contribution/7011\r\nThe implementation has now been committed to the “fsharp4” branch"
        }
    },
    "5674940": {
        "Number": "5674940",
        "Submitter": "Bryan Edds",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Implement Syntactic Macros",
        "Text": "At least give it a try in a private branch, and upon success, enable them publicly with a compiler switch initially.",
        "Votes": 453,
        "Comments": [
            {
                "Submitter": "Tomas Petricek",
                "Submitted": "2014-03-24T16:03:00",
                "Content": "I would be quite interested in the use cases that you have in mind for this? Restricted macro functionality is already available with quotations, type providers & reflection, so I'd like to know what interesting use cases are left :-)"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-24T16:17:00",
                "Content": "Tomas, my friend, you ask for too much! I will attempt to post one use case for F# macros here every business day as long as I can manage :)\r\nFor today, the use case is more-automated generation of lens values. Lenses, both full and partial, are no where near first-class enough in F#. You can't do real FP without them. Macros should bring us closer, and also give a prototype showing how the language implementers might design them in the case they do make them first-class."
            },
            {
                "Submitter": "Giuseppe Maggiore",
                "Submitted": "2014-03-25T09:20:00",
                "Content": "Games would greatly benefit from having macros or other similar, high-performance, portable ways to generate complex code.\r\nSeconded with all my heart :)"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-25T10:05:00",
                "Content": "Gluseppe,\r\nFor games, inlining functions help a lot especially for linear algebra math operations. It's much more idiomatic to use inlined functions than macros for performance. It's not always true, however, that inlining a function will give you better performance, in fact, it can give you worse depending on the function if it's long + complex. A macro would be no better here.\r\nI'm doing this myself now and it works just as good as any macro would; however, there are a few outstanding issues with struct param types with inlined functions, but I have a slightly edited compiler that fixes that."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-03-25T10:27:00",
                "Content": "I could see something similar to template haskell being useful, one example of use would be generating lenses."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-25T23:02:00",
                "Content": "Macro use case for the day #2 -\r\nImplement F# features outside the compiler so that even idiomatic F# code can be back-ported to OCaml."
            },
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T05:57:00",
                "Content": "@Tomas: Macros are used to customise syntax. For example, you might want to replace the pattern \"| Add(f, g) -> d f + d g\" with \"| f+g -> d f + d g\"."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:28:00",
                "Content": "Macro use case of the day #3 -\r\nLet the community take more of a role in prototyping new F# language features with macros instead of forcing them to hack their own private compiler branch and thereby losing all portability."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-31T10:14:00",
                "Content": "Macro use case of the day -\r\nIf we can allow macros to be imported based on a containing namespace / module, various DSL contexts could be opened separately, without clashing."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-02T11:01:00",
                "Content": "Fully seconded, and Bryan you're a hero for initiating this.\r\nMacros are so underrated and to be fully honest, in my opinion this is a must!\r\nI'll even go as far to say that imo every programming language should have macro support.\r\nFor instance, I can't begin to describe how much I dislike GUI development just because you have to manually raise events and legit repeat yourself again and again and again, which just results in filthy messy code."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-02T11:06:00",
                "Content": "Also if I may add another macro use case:\r\nMore aliasing functionality.\r\nfor instance, I highly dislike having to re-type this again and again:\r\n[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>])\r\nType aliasing can't deal with this since the result is not a type.\r\nInheritance is not an option since the attribute is sealed.\r\nOnly option I can think of to deal with these kind of cases (this is merely an example) is macros."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-03T15:02:00",
                "Content": "If F# has proper macros, this means you would be able to create another language inside F#. Do we really want that?\r\n---\r\n\"Implement F# features outside the compiler so that even idiomatic F# code can be back-ported to OCaml.\"\r\nWhy would you want to use macros as a means of back-porting? Arn't there better ways that don't infect the language itself?\r\n\"Macros are used to customise syntax. For example, you might want to replace the pattern \"| Add(f, g) -> d f + d g\" with \"| f+g -> d f + d g\".\"\r\nCouldn't we find a way to extend the F# language that makes something like this possible without relying on macros?\r\n\"Let the community take more of a role in prototyping new F# language features with macros instead of forcing them to hack their own private compiler branch and thereby losing all portability.\"\r\nA true prototype of a language feature is to have a modified version of the compiler. That is the proper way. Using macros for a prototype do not tell you what is involved in actually implementing a language feature.\r\n\"If we can allow macros to be imported based on a containing namespace / module, various DSL contexts could be opened separately, without clashing\"\r\nHow is this a use case for a need to use macros?\r\n\"I can't begin to describe how much I dislike GUI development just because you have to manually raise events and legit repeat yourself again and again and again, which just results in filthy messy code.\"\r\nYou can create abstractions already, or even use type providers to generate all the mess so you don't have to.\r\n\"for instance, I highly dislike having to re-type this again and again:\r\n[<CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)>])\"\r\nSo we can use macros for anyone to call what this behavior does anything they want? I agree that I dislike typing that again and again; but, I feel like we could figure out a simple language feature that could solve this in an idiomatic way."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-04-04T19:23:00",
                "Content": "Other than lenses, lots of things could be derived for a type with a macro: functor, applicative, monad, a serializer. None of the current metaprogramming facilities can do that as far as I know, and you can't build all of that into the language (for example deriving a serializer depends on a specific serialization library)."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-04T19:43:00",
                "Content": "Sorry I haven't been posting the use cases for macros like I promised - I've been in the hospital for 4 days now (obviously unrelated).\r\nWill, if macros are only able to be enabled via a compiler-switch, it will not effectively change the language for the typical user, so there are no direct down sides there.\r\nFor people who need to program at the language level (such as framework developers), macros are a must (at least in a black-box language like F#). For those who have only ever consumed those types of services (as opposed to writing them properly), they will only see macros through the the Blub Paradox - http://paulgraham.com/avg.html .\r\nTherefore, only programmers who write at the language level will ever turn on the feature, but those who blithely consume our work will keep the feature off - if they even know it exists in the first place.\r\n* Yes, F# is a black-box language. Just because the compiler is open source does not mean it is white box. If you want to see a white box language, look at AML here - https://github.com/bryanedds/OmniBlade"
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-07T10:35:00",
                "Content": "@Will Smith\r\nThere is mess with abstractions as-well.\r\nAs for the attribute, I'll mention again that this is merely an example.\r\nSure, the F# team could introduce a ModuleSuffixAttribute as a shortcut, and maybe even have an optional Boolean parameter for RequireQualifiedAccess, and I was even about to suggest this but then the idea of macros came up and swiped it away because with macros you could do that + more + a lot more!"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-08T08:48:00",
                "Content": "* Just for clarification *\r\nThe compiler switch for enabling macros should allow new macros to be defined. Using existing macros should not require a compiler flag. This way, library developer can opt-in to access macro implementation syntax, and consumers can use library macros more transparently (either as if they were an ambient language feature, or a custom syntax imported from an F# namespace / module)."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-13T13:38:00",
                "Content": "That stinks you were in the hospital Bryan! I hope you are feeling better!\r\nIf macros were going to be implemented, a compiler directive or switch would be the least of all evils. That is my opinion and I could live with it.\r\nThis feature currently has the most votes, so it is clear that a lot of people want this for a good reason.\r\nI want to be convinced that macros would really benefit F#; because I really fear this feature a lot. I'm looking for the bigger picture here, but so far all I see is syntactic sugar. I read there is the framework side, but I don't have a clear understanding of the problems devs are facing when developing a framework.\r\nCould anyone show some example problems that macros would truly help resolve? Syntactic sugar is not one of them."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-14T18:02:00",
                "Content": "Will, personally I can't think of any (at least atm); I also can't think what more they need to do, because after all that is their purpose.\r\nBut how about share your thoughts and let us know what's daunting about macros.\r\nI mean, yeah, it can definitely be misused like any other feature, but the good thing about macros is that you can simply choose not to use them.\r\nThey will not invade your work, but only be there for you to use when the trade-offs worth it in your opinion.\r\nAnd perhaps if macros will be implemented (fingers crossed) they could also be removed from a certain point (very much like #undefine in C & C++).\r\nThat being said, I'd like to point out (to everyone) that all in all, macros allow you to make code more compact, shorter, succinct, readable, simpler, etc.\r\nThat's their point (syntactic sugar).\r\nNow just notice how about any best practice you read in a book, online, hear from a friend will have the same reasons for usage. That's what we need, simple compact code.\r\nSo my viewpoint is: Program with care, play nice, have macro support, and the result is a maintainable code, that is a pleasure for the eyes to see."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-04-14T18:16:00",
                "Content": "Will, a lot of use cases have been mentioned in this thread that are not about syntactic sugar: lenses, serialization, derivation of functor/applicative/monad. Also derive curried constructors for records, which would help a lot with applicative functors.\r\nAll of these are about reducing boilerplate by generating code at compile-time."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-15T00:06:00",
                "Content": "I'm starting to wonder if there is a bit of confusion between textual macros (like those found in C and C++) and my suggestion of syntactic macros.\r\nFor surefire clarification, here are links describing each -\r\nTextual Macros - http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Text_substitution_macros\r\nSyntactic Macros - http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Syntactic_macros\r\nThe difference between the two is very big, and I too would object to any suggestion of putting textual macros in F#! :)"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-04-24T03:37:00",
                "Content": "I think I would prefer expanded quotation and Type Provider support. The language is at a very stable base and Im not sure you could convince me that macros are necessary."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-24T06:54:00",
                "Content": "Hi Dave!\r\nCould you elaborate on what you mean by 'expanded' in these cases, and perhaps give examples where they would obviate macros?"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-24T07:13:00",
                "Content": "Dave and all,\r\nHere's a super nice macro use case; Making FSCL more syntactically elegant. FSCL is amazing, but the amount of attributes and <@code quotation symbols@> flying around in its usage code makes it much harder to read and write than it should be, as well as error prone -\r\n\"Ah, why doesn't this work?! Did I leave out an attribute or parameter again?\"\r\nImagine all that encapsulated behind a DSL that looks like first-class F# syntax - all just by opening the appropriate module.\r\nCould expanded code quotations and / or type providers really obviate macros in cases like this?"
            },
            {
                "Submitter": "mavnn",
                "Submitted": "2014-04-25T10:04:00",
                "Content": "@Bryan I don't know if this is what Dave was thinking, but a lot of type kind like functionality could be implemented by type providers that could be parameterized by type or by quotation.\r\nCombined with better quotation evaluation out of the box, it would cover most of the use cases I've seen so far, especially Mauricio's lens et al."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-25T10:25:00",
                "Content": "Hi mavnn!\r\nIt would be interesting to see some explanation of what the semantics of better / expanded type providers and quotations would entail, along with a couple of examples demonstrating how they would obviate macros.\r\nWould you or Dave mind writing something like that up as an F# user voice suggestion so we can study upon and vote for it?"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T08:33:00",
                "Content": "I think the following related concepts might be relevant:\r\n1) Metaprogramming\r\n2) Dilecting - Syntax mutation is dilecting\r\n3) Extensible programming\r\n4) Higher Order Abstract Syntax - http://en.wikipedia.org/wiki/Higher-order_abstract_syntax, http://www.cs.cmu.edu/~fp/papers/pldi88.pdf\r\n5) Staging"
            },
            {
                "Submitter": "mavnn",
                "Submitted": "2014-05-07T04:41:00",
                "Content": "@Bryan sorry for the slow response. Type providers that could take a type would allow you to generate things like lenses on the fly. Having said that...\r\n... I actually very much like the idea of syntactic macros and have voted for this idea. So I'm not going to spend too long disagreeing with you!\r\nIt does have to said that a lot of very similar functionality could be provided by better support for evaluating quotations and that may be the more practical solution in the short term."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-07T22:55:00",
                "Content": "There are 3 ways to do this\r\n1) Quasi Quotes (QQ)\r\n2) Macros\r\n3) GADT\r\nWhy not have all 3. F# is very well capable of doing this. If you use QQ you are dealing with concrete syntax. In other ways you can deal with it at the AST level also."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-07T22:58:00",
                "Content": "MetaOCaml, PPX, Camlp4/5 can be a good starting reference to explore the possibilities. Especially MetaOCaml. Love the concepts in this."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-08T00:07:00",
                "Content": "Also it would be very cool if you can use the meta programming facility to have projectional editors within the language."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-08T03:35:00",
                "Content": "Also MetaML and Template Haskell would be good starting points to flesh out a strawman speck for this feature."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-10T01:09:00",
                "Content": "Something interesting I stumbled across. Some of this research could be taken into consideration http://ltamer.sourceforge.net/"
            },
            {
                "Submitter": "Kurt",
                "Submitted": "2015-07-06T05:46:00",
                "Content": "Here's how Boo does it: https://github.com/bamboo/boo/wiki/Syntactic-Macros"
            },
            {
                "Submitter": "Yaar Hever",
                "Submitted": "2016-03-13T22:31:00",
                "Content": "I think macros would make it much easier to implement the missing functionalities of type providers (like creating F# specific types) and to have a functional way of writing type providers."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-03-14T08:08:00",
                "Content": "Having a proper macro system would probably make type providers obsolete, the current mechanism (putting it politely) is a crap fest."
            },
            {
                "Submitter": "Kurren Nischal",
                "Submitted": "2016-03-19T05:02:00",
                "Content": "This would be a dream come true"
            },
            {
                "Submitter": "Yemi Bedu",
                "Submitted": "2016-05-29T04:03:00",
                "Content": "[/ideas/suggestion-5975797-allow-implicit-quotation-of-expressions-used-as-a](/ideas/suggestion-5975797-allow-implicit-quotation-of-expressions-used-as-a.md)\r\nHello,\r\nSo I would recommend that the above be extended to work with general methods (functions)\r\nThe definition of it could look like:\r\ndef nameof (q:'T) = match q with\r\n| Quotations.Patterns.ValueWithName(o, ty, n) -> n\r\n| Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nwhich is shorthand for writing:\r\nlet nameof ([<ReflectedDefinition>] q:Quotations.Expr<'T>) : string = match q with\r\n| Quotations.Patterns.ValueWithName(o, ty, n) -> n\r\n| Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nlet y = 1\r\nprintfn \"%s\" (nameof y)\r\nThank you. Good day."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5675548": {
        "Number": "5675548",
        "Submitter": "Anonymous",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Implement monadic getters and setters",
        "Text": "The get/set syntax for F# is very cool, but it has an issue: sometimes, the property we would like to get and set is only available through a workflow/monad, like the async workflow.\r\nThus, I would like to alter the typechecking rules for getters and setters. This is what they are right now (pseudocode) for the Async monad:\r\nProperty x : Async<'a>\r\nget : unit -> Async<'a>\r\nset : Async<'a> -> unit\r\nIndexedProperty x : 'k -> Async<'v>\r\nget : 'k -> Async<'v>\r\nset : 'k -> Async<'v> -> 'unit\r\nThis is what I would like to see made possible:\r\ntype Id<'a> = 'a\r\nProperty x : Async<'a>\r\nget : unit -> Async<'a>\r\nset : 'a -> Async<unit>\r\nIndexedProperty x : 'k -> Async<'v>\r\nget : 'k -> Async<'v>\r\nset : 'k -> 'v -> Async<unit>",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-24T18:50:00",
                "Content": "Interesting, could you post a snippet illustrating how the current syntax/typechecking is insufficient, and how this suggestion would make it better?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:59:00",
                "Content": "I am very sympathetic to this proposal. However, please note that the items would likely not be \"proper\" .NET properties since those are required to have \"unit\" return type on the setter method."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5675977": {
        "Number": "5675977",
        "Submitter": "Tracy",
        "Submitted": "2014-03-24T00:00:00",
        "Title": "Allow type providers to generate types from other types",
        "Text": "There are occasions where it would be extremely useful to generate types from other types.\r\nAs an example, F# interop with NHibernate is very clumsy simply because it's difficult to express types of the sort:\r\n// C# record class\r\npublic class MyRecord\r\n{\r\npublic virtual int Id { get; set; }\r\npublic virtual string Description { get; set; }\r\n// etc...\r\n}\r\nIt would be very compelling to be able to represent these as F# record types, but the CIL code generated for F# records is incompatible with NHibernate.\r\nPerhaps it could be possible, using a type provider, to generate the POCO class above from an F# record type of the sort:\r\ntype MyRecord = { Id : int, Description : string }\r\nThe type could be generated as shown below:\r\ntype MyPocoRecord = PocoTypeProvider<MyRecord>()\r\nI understand the difficulty of doing this at compile type.Tomas P actually explained why in a forum post (that I can't seem to find.) However, this sort of problem is the reason by the CLIMutable attribute was created, which as far as I can tell, was hard-coded directly into the F# compiler.\r\nI can see these interop dilemmas becoming more common as F# adoption increases, especially in the enterprise where tools like NHibernate are in widespread use. There ought to be a way to address them without creating one-off CLIMutable-esque attributes per se.\r\nThe feature itself would open the door to incredibly powerful metaprogramming opportunities.",
        "Votes": 116,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:42:00",
                "Content": "I think this is very interesting and would love to hear about its advantages and disadvatages from the F# team."
            },
            {
                "Submitter": "Nicolas R",
                "Submitted": "2014-05-14T09:28:00",
                "Content": "This amount to \"staged programming\" no ? You have to resolve all the types you give as parameters, run the higher level program on that input, and use the result of that in the \"normal precedence\" program."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2014-06-25T08:27:00",
                "Content": "We might have a simpler implementation by restricting that the types you give to a type provider must be fully resolved before compiling the current file.\r\nExample:\r\n// in A.fs\r\ntype MyRecord = ... // fully defined.\r\n// in B.fs\r\ntype ProvidedType = TypeProvider<MyRecord>;\r\nB.fs must go after A.fs, but you can still put B.fs and A.fs in one project and compile them together.\r\nI think this should enable most benefits without resorting to staged programming. Actually, this seems to play quite nicely with the current fsharp compilation model, which already requires fully resolving dependencies before compiling the source file.\r\n(currently you can simulate this feature by compiling A.fs in its own assembly, then give the assembly file path to the type provider. But doing so means you need to split things that should naturally go together into multiple projects, and it quickly become very cumbersome.)"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-02T04:41:00",
                "Content": "You can already have generative types that inherit from a prescribed type, it would be interesting to extend the syntax so that the prescribed type can be included as a generic argument, or perhaps typeof<'a> in the static arguments."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T14:01:00",
                "Content": "I would love to see this feature implemented, it would increase the power of F# type providers immensely.\r\nI will mark this as \"approved in principle\" and we will eventually open an RFC for it. However it will be a difficult feature to land in practice and will be subject to very many caveats and likely limitations."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2016-04-19T02:40:00",
                "Content": "One thing that heads towards this is getting intrinsic type extensions working with generative providers. So that you can then create a type from a provider and immediately augment it in some way. RE:https://github.com/Microsoft/visualfsharp/pull/882"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-06-24T00:00:00",
            "Text": "Marking this as “approved in principle” per comment below.\r\nHowever it will be a difficult feature to land in practice and will be subject to very many caveats and likely limitations. There’s no certainty that this will make it into F#.\r\nWe will open an RFC for it eventually (it won’t be fast :) )\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "5676471": {
        "Number": "5676471",
        "Submitter": "Steven Taylor",
        "Submitted": "2014-03-25T00:00:00",
        "Title": "Allow n partitions for ActivePatterns instead of a max 7",
        "Text": "Active patterns can only have seven partitions (see: http://msdn.microsoft.com/en-us/library/dd233248.aspx)\r\nIt would be good if this was a stylistic constraint that could be overridden if desired.\r\nFor example, if active patterns are getting used to split up XML nodes meaningfully, you aren't in control of how many nodes sensibly fit into the top level.",
        "Votes": 23,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-28T18:05:00",
                "Content": "I have often wished for F# to have this feature. I would be OK if the compiler required active patterns with >7 cases to be inlined -- most of the time I've wanted to use this, the active pattern would only be used in 1 or 2 places in the code, and I've mainly wanted to use an active pattern to take advantage of the exhaustivity checking provided by the compiler."
            },
            {
                "Submitter": "Mickey",
                "Submitted": "2014-11-10T10:42:00",
                "Content": "640K. That'll be enough!"
            },
            {
                "Submitter": "bleis-tift",
                "Submitted": "2015-11-07T20:04:00",
                "Content": "type Choice<'T1> =\r\n| Choice1Of1 of 'T1\r\ntype Choice<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'TRest> =\r\n| Choice1OfN of 'T1\r\n| Choice2OfN of 'T2\r\n| Choice3OfN of 'T3\r\n| Choice4OfN of 'T4\r\n| Choice5OfN of 'T5\r\n| Choice6OfN of 'T6\r\n| Choice7OfN of 'T7\r\n| ChioceRest of 'TRest\r\nlet (|P1|P2|P3|P4|P5|P6|P7|P8|) x =\r\nmatch x with\r\n| 1 -> P1\r\n| 2 -> P2\r\n| 3 -> P3\r\n| 4 -> P4\r\n| 5 -> P5\r\n| 6 -> P6\r\n| 7 -> P7\r\n| _ -> P8\r\n// Chice<unit, unit, unit, unit, unit, unit, unit, Choice<unit>>\r\nThis is the same way as the System.Tuple."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:06:00",
                "Content": "As an aside, we looked at implementing this in F# 2.0 and it seems that it became surprisingly hard very quickly. I can't quite remember the details though."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5676502": {
        "Number": "5676502",
        "Submitter": "Steven Taylor",
        "Submitted": "2014-03-25T00:00:00",
        "Title": "Disable compiler warnings per line",
        "Text": "Over time, the value of warnings get noisy and their value goes down if there's not a simple way to partition them into \"as intended\" and \"could be a problem\" buckets. Also, it would be good to ignore the \"as intended\" ones (is there a better way to do this than introduce an ugly pragma?).\r\nExample: a warning pops up such as \"This construct causes code to be less generic than indicated by...\", you investigate, and determine that this is intentional. Normally you would not allow the way the doSomething function works, but in this case it is succinct, and you think an okay way to proceed given <insert situation & context here> .",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Robert Nielsen",
                "Submitted": "2014-06-22T10:49:00",
                "Content": "I have posted a vaguely related suggestion: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085102-allow-f-compiler-directives-like-nowarn-to-span"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:03:00",
                "Content": "This is related: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085102-allow-f-compiler-directives-like-nowarn-to-span"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:35:00",
                "Content": "Closing as duplicate in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085102-allow-f-compiler-directives-like-nowarn-to-span"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Close enough to being a duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085102-allow-f-compiler-directives-like-nowarn-to-span"
        }
    },
    "5676508": {
        "Number": "5676508",
        "Submitter": "Steven Taylor",
        "Submitted": "2014-03-25T00:00:00",
        "Title": "allow us to edit suggestions after we post them",
        "Text": "allow us to edit suggestions after we post them",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-07T10:38:00",
                "Content": "This would be great, and it could even be as an additional edit right below the original if editing is too much.\r\nHope they could allow that even though this site is a uservoice."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "Declining for now as this is just a limitation of uservoice."
        }
    },
    "5678806": {
        "Number": "5678806",
        "Submitter": "Liviu",
        "Submitted": "2014-03-25T00:00:00",
        "Title": "String Interpolation",
        "Text": "It will be excellent to have string interpolation with intellisense support as opposed to the anacronical printf variants.\r\nSyntax may be:\r\nlet a = 40\r\nlet p = \"John\"\r\nlet b = $\" ${p} has $(a*2) items\"",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Liviu",
                "Submitted": "2014-03-25T12:50:00",
                "Content": "correction:\r\nlet b = $\" $(p) has $(a*2) items\""
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-03-27T10:51:00",
                "Content": "-1 to this. I agree with Martin Odersky's argument in http://permalink.gmane.org/gmane.comp.lang.scala.debate/872 , this doesn't really save much typing. (even though Scala ended up getting string interpolation after that discussion).\r\nPlus it's really easy to forget the interpolation symbol '$', and then you end up with the literal string \"${p} has $(a*2) items\", this has happened to me many times while programming in Scala.\r\nAlternatively, one could implement this as a type provider, which isn't as terse but it's explicit about the variables being passed and could do strict type checking."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-03-27T11:58:00",
                "Content": "I'm also -1 for this as it cannot be partially applied."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-06-02T18:18:00",
                "Content": "Similar suggestion but restricted to printf only http://fslang.uservoice.com/forums/245727-f-language/suggestions/6002107-steal-nice-println-syntax-from-swift"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declining as [/ideas/suggestion-6002107-steal-nice-println-syntax-from-swift](/ideas/suggestion-6002107-steal-nice-println-syntax-from-swift.md) is close enough to act as a “duplicate”.\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "5679733": {
        "Number": "5679733",
        "Submitter": "let rec",
        "Submitted": "2014-03-25T00:00:00",
        "Title": "Extend try with \"success\" or match with \"failure\" handling.",
        "Text": "Extend try with \"success\" or match with \"failure\" handling.\r\nhttp://ocamllabs.github.io/compiler-hacking/2014/02/04/handler-case.html",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:38:00",
                "Content": "I'd like to see some serious consideration for this idea as it's not merely duplicative, and seems like it would become happily idiomatic in F#. Would vote more points, but ran out for today :)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:22:00",
                "Content": "This is a duplication of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6536829-implement-ocaml-s-new-match-exception-syntax\r\nThe idea is a good one."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Closing as duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6536829-implement-ocaml-s-new-match-exception-syntax"
        }
    },
    "5681764": {
        "Number": "5681764",
        "Submitter": "Phillip Trelford",
        "Submitted": "2014-03-26T00:00:00",
        "Title": "Make let optional",
        "Text": "Make F# even more terse by removing the requirement for the let keyword, particularly on local variables.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Jon Harrop",
                "Submitted": "2014-03-26T05:26:00",
                "Content": "How would you distinguish between the definition x=2 and the test for equality x=2?"
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-03-28T19:37:00",
                "Content": "I've made a related suggestion that doesn't completely get rid of \"let\", but allows a single let to create multiple bindings. This is similar to how \"where\" in Haskell can group together a number of bindings. See \"Allow a single let to create multiple bindings\" for details."
            },
            {
                "Submitter": "Eamon Nerbonne",
                "Submitted": "2014-06-21T03:04:00",
                "Content": "Go uses a slightly different operator to distinguish assignment from definitition with assignment - F# could use a slightly different operator to distinguish definition from equality."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:57:00",
                "Content": "I propose to decline this. A completely revamped F# syntax may choose to make let optional. But I don't think it is really technically feasible within the current F# syntax."
            },
            {
                "Submitter": "Ideaflare",
                "Submitted": "2016-05-14T08:29:00",
                "Content": "I think it's a great idea!\r\nBut I agree that making things optional opens up the door for multiple ways of doing the same thing, which adds unnecessary cognitive load for maintainers.\r\nMy suggestion is - that if it is optional, that it is a toggle feature that requires all code per-project(or solution) mandatory to have let, or mandatory to not have the let for that project, but not to be able to mix let and no let in the same project."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion, though declined per my comment below\r\nBest regards\r\nDon Syme, F# Language Evolution"
        }
    },
    "5681770": {
        "Number": "5681770",
        "Submitter": "Phillip Trelford",
        "Submitted": "2014-03-26T00:00:00",
        "Title": "Query expression array and list syntax",
        "Text": "For brevity instead of\r\nquery { (*... body *) } |> Seq.toList\r\nallow\r\nquery [ (* body *) ]",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Keith Battocchi",
                "Submitted": "2014-04-10T08:36:00",
                "Content": "As a workaround, you can also add a suitable ToList extension member to QueryBuilder and put it into the query itself, which looks a bit cleaner than piping to Seq.toList."
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-02-03T14:43:00",
                "Content": "The use of Seq.toList or the workaround below seems adequate for this case."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining per the comment from Don Syme below"
        }
    },
    "5682628": {
        "Number": "5682628",
        "Submitter": "Jon Harrop",
        "Submitted": "2014-03-26T00:00:00",
        "Title": "Save and load FSI sessions",
        "Text": "The ability to save and load FSI sessions would be very valuable when initialization (e.g. database interop) takes a long time.",
        "Votes": 22,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:59:00",
                "Content": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/8784865-f-interactive-could-support-saving-and-loading-it"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/8784865-f-interactive-could-support-saving-and-loading-it"
        }
    },
    "5683305": {
        "Number": "5683305",
        "Submitter": "Jon Harrop",
        "Submitted": "2014-03-26T00:00:00",
        "Title": "Allow the syntax 1<=x<10",
        "Text": "This traditional mathematical notation is only allowed in a few elite programming languages. I would like F# to be one of them!\r\nAt the moment you have to write 1<=x && x<10.\r\nOf course, what I really want is 1≤x<10 but we've got to start somewhere. ;-)",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-03T01:51:00",
                "Content": "I love this, and as for the last sentence I'd like to add that I always dream of the day languages would freely let you use Unicode and IDEs would allow you to insert them easily from your keyboard (like Windows does in some foreign languages). Especially when it comes to functional programming."
            },
            {
                "Submitter": "Goswin",
                "Submitted": "2014-04-08T03:39:00",
                "Content": "you could write 1 <. x .< 10 using these custom operators:\r\n///* Point must be at middle of expression: like this: min <=. x .<= max\r\nlet inline (<=.) left middle = (left <= middle, middle)\r\nlet inline (.<=) (leftResult, middle) right = leftResult && (middle <= right)\r\nlet inline (>=.) left middle = (left >= middle, middle)\r\nlet inline (.>=) (leftResult, middle) right = leftResult && (middle >= right)\r\n// Point must be at middle of expression: like this: min <. x .< max\r\nlet inline (<.) left middle = (left < middle, middle)\r\nlet inline (.<) (leftResult, middle) right = leftResult && (middle < right)\r\nlet inline (>.) left middle = (left > middle, middle)\r\nlet inline (.>) (leftResult, middle) right = leftResult && (middle > right)"
            },
            {
                "Submitter": "Steve Gilham",
                "Submitted": "2014-04-10T03:56:00",
                "Content": "This is the same suggestion as http://fslang.uservoice.com/forums/245727-f-language/suggestions/5726029-support-conjunctional-operator"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "This is a duplicate of [/ideas/suggestion-5726029-support-conjunctional-operator](/ideas/suggestion-5726029-support-conjunctional-operator.md)"
        }
    },
    "5683698": {
        "Number": "5683698",
        "Submitter": "Loic Denuziere",
        "Submitted": "2014-03-26T00:00:00",
        "Title": "Make .Tag and .Is* discriminated union properties visible from F#",
        "Text": "The .NET class that encodes a discriminated union has `.Is* : bool` properties, for example this:\r\ntype Foo = A | B\r\nhas the following:\r\nmember IsA : bool\r\nmember IsB : bool\r\nThey are hidden from F#, but they could actually be quite useful. I regularly find myself writing something like this:\r\nList.filter (function A -> true | _ -> false)\r\nwhen I could write:\r\nList.filter (fun x -> x.IsA)",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Peter Strøiman",
                "Submitted": "2014-05-13T03:32:00",
                "Content": "Or even better, have it exposed as static members, so you can write\r\nList.filter Foo.IsA\r\nThe latter can work better with some cases of type inference, e.g.\r\nlet get<'T> () = instance :?> 'T // instance is declared as an obj\r\nIn that case\r\nget () |> List.filter Foo.IsA\r\nWould automatically type infer 'T to be List<Foo>, where\r\nget () |> List.filter (x -> x.IsA)\r\nwould not, and thus would not compile"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-05-13T04:40:00",
                "Content": "Peter: The thing is, these methods already exist as instance methods, they're just not exposed in F#. Making them static would break backward compatibility for C# code that uses them.\r\nThere is a discussion about a static syntax for instance methods here: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663326-syntax-for-turning-properties-into-functions which would provide the same advantages as you cite, but for all instance methods."
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-06-26T16:12:00",
                "Content": "I agree with Peter, it would be nice to have this as part of the static type.\r\nWe should have both: The static `IsA` would call the instance `IsA`."
            },
            {
                "Submitter": "Christopher Atkins",
                "Submitted": "2014-07-17T07:10:00",
                "Content": "There are a few considerations to take into account when tackling this, per Don Syme:\r\n* The problem is that the generated “Is*” and “New*” for unions are inserted very late in the compilation pipeline, in the “ILX” phase, using nasty code that is somewhat ancient. There are lots of corresponding cases in tc.fs and check.fs to check that the user doesn’t define these him/herself.\r\n\r\n* The whole generation of these should probably be lifted up to happen during type checking (the same time we generate compare/equality methods, for example, see augment.fs). Then the “check for duplicates” core would be irrelevant.\r\n\r\n* The messiness is compounded by the fact that there are special cases in ILX generation for lists, options and AllowNullValueAsRepresentation unions."
            },
            {
                "Submitter": "Ovidiu Deac",
                "Submitted": "2014-10-25T20:03:00",
                "Content": "Combined with [/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions](/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions.md) would be even nicer:\r\nThe code would be:\r\nList.filter Foo.isA"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "This proposal is “approved in principle” for F# 4.0+. It would make a good addition to F#. (I don’t think the loss of purity (e.g. wr.t. ordering of union cases) is a critical problem and I believe you can turn of the DefaultAugmentation in any case)\r\nSome technical issues may need to be ironed out during implementation.\r\nIf this is done, the Tag properties present on these types should also be revealed, that is covered by a separate item.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library..\r\nI’d be glad to help guide people through the implementation process.\r\nIf you strongly think this should not be approved please chime in with your technical feedback.\r\nThanks\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5688199": {
        "Number": "5688199",
        "Submitter": "Anton Tayanovskyy",
        "Submitted": "2014-03-27T00:00:00",
        "Title": "Allow re-exporting from modules",
        "Text": "OCaml, Haskell, Racket all provide mechanisms for re-exporting module bindings that the module imports from somwhere else rather than defining. This allows a simple library development startegy:\r\nFirst, you start with one module (and file):\r\nmodule MyLib =\r\n...\r\n...\r\n...\r\nAs it grows too large, you move definitions out into separate modules that are kept internal, without breaking the interface.\r\nmodule Imlp1.. =\r\n...\r\n...\r\n...\r\nmodule Impl2 =\r\n...\r\n...\r\nmodule MyLib =\r\nopen Impl1\r\nopen Impl2\r\nThat allows a logical module to be assembled from separately written components, while being a single logical entity to the user.\r\nIn F#, some approximations are possible (manually re-exporting aliases, using namespaces), but overall the experience is irritating. Constraints F# currently imposes feel a bit baroque.",
        "Votes": 60,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:33:00",
                "Content": "I find this interesting, and specifically useful in several places in my code."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-05-06T08:55:00",
                "Content": "Also 1st class modules would be interesting. One of the best selling points of OCaml."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-06-10T03:10:00",
                "Content": "Suggested syntax:\r\nmodule MyLib =\r\nopen Impl1 // doesn't re-export anything from Impl2 (existing syntax)\r\nopen public Impl2 // re-exports everything from Impl1\r\nopen internal Impl3 // not sure if that would ever be useful, but why not\r\nmodule SomeSubModule = Impl4 // local module alias (existing syntax)\r\nmodule public SomeOtherSubModule = Impl5 // export a module alias"
            },
            {
                "Submitter": "Anton Tayanovskyy",
                "Submitted": "2014-06-18T14:47:00",
                "Content": "First class modules would be nice but an order of magnitude harder to implement. Say, Haskell does not have them. I would like to keep this proposal simple to implement as this increases the probability it gets actually implemented."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T08:58:00",
                "Content": "Hi all,\r\nI generally have a negative predisposition to this feature from my experiences. For example, I've watched some OCaml programmers make a compete mess with it. In the scenarios I've seen, people have been trying to use the feature to achieve mixin-like software engineering composition - though the feature is very limited for this purpose. However, I haven't really seen them succeed with this in any way that looked convincing - and indeed they created code that was very hard to understand even in its basic shape and APIs.\r\nI suppose this means I have a general negative predisposition to mixin features (except perhaps traits), since you have to \"execute\" the mixins to understand the resulting generated API. It seems wrong for F#. F# code (apart from provided APIs) doesn't generally have this property. For F# software engineering APIs - modules and object types - F# code has a \"what you see is what you get\" property, at least with regard to named items in the modules and object types.\r\nCould you point us to examples of OCaml code that uses this in what you regard as very positive ways?\r\nThanks\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T07:34:00",
                "Content": "One particular concern not mentioned before is that type identity (i.e. the exact module where a type was originally defined) would still be visible after the re-export. That is, a signature couldn't hide that fact that a type ultimately came from Impl1 or Impl2 (because in .NET compiled code types have a full path)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "As per my comments, I am declining this suggestion for now to allow votes to be recycled.\r\nI am open to continued suggestions and discussions in the area of mixins, that cover both object programming and module programming. More code examples for would be welcome to help guide the discussion.\r\nDon Syme, current BDFL F# Language/Library Evolution"
        }
    },
    "5688398": {
        "Number": "5688398",
        "Submitter": "Jerold Haas",
        "Submitted": "2014-03-27T00:00:00",
        "Title": "Allow Unicode symbols to be used as operators",
        "Text": "Suggestion moved from https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2314078-allow-unicode-symbols-to-be-used-as-operators\r\nIt would be great to define mathematical operators (e.g. ∀, ∑, ∩) in F#, and be able to use other Unicode symbols (such as arrows) in operators as well. So instead of saying\r\nlet inline (!++) xs = xs |> Seq.sum\r\nyou could say\r\nlet inline (~∑) xs = xs |> Seq.sum\r\nWriting \"∑myList\" is much, much easier on the eyes and brain than trying to figure out what \"!++myList\" does.",
        "Votes": 76,
        "Comments": [
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-27T12:19:00",
                "Content": "There used to be an addon like that. http://apollo13cn.blogspot.ch/2012/09/math-unicode-symbol-add-on-for-f.html\r\nAnd what stops you right now from using unicode symbols in source code (apart from being rather exotic, that is)"
            },
            {
                "Submitter": "Jerold Haas",
                "Submitted": "2014-03-27T13:07:00",
                "Content": "That add-on is simply text substitution: There's no actual Unicode characters in the source files using that method:\r\n\"This add-on only changes the visual of the string and the source code is untouched. So if you open it in a notepad, the code won't contain any math (Unicode) symbol.\""
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-03-27T20:33:00",
                "Content": "It makes perfect sense that this should be supported, especially for a functional language."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-03-28T17:58:00",
                "Content": "This is an often-requested feature for F#, usually from people doing heavy mathematical or algorithmic work, and can see how having code which more closely adheres to the underlying math could be helpful.\r\nHowever, I have to say -- I don't think it would be good for F# to add this feature. My chief concern is that you'd be forcing consumers of your code to use these symbols as well. This would be annoying at best (I prefer the identifiers as they are now, and would probably end up implementing my own library instead of one that forced me into using Unicode symbols as operators); at worst, code with Unicode operators is much less approachable for newcomers to F# -- especially those who don't come from a math/science-heavy background -- and I worry it would keep people away from F# who might otherwise be quite happy with the language.\r\nAnother drawback -- a number of mainstream development tools (including parts of VS) weren't designed with Unicode symbols in mind, and won't work properly when code or compiled assemblies use them in type/field/method names. You can make a good argument that these tools should be fixed to properly handle Unicode symbols (and I would agree with you); but if having Unicode operators means that many of the common .NET development tools couldn't be used with F# due to such issues, I think that would be a serious problem. Even well-known C# libraries have removed the uses of Unicode characters from their method names due to this issue: http://rx.codeplex.com/releases/view/114891\r\nWhat's the downside of having an IDE plugin (like F# Power Tools), or the add-on Daniel linked to, that could recognize naming conventions for variables and convert them to Unicode characters in the IDE (but not in the actual code)? Proof General (an Emacs package) does this for Isar (a proof language for the Isabelle theorem prover) and it seems to work quite well: http://proofgeneral.inf.ed.ac.uk/releases/ProofGeneral-3.7/isar/isar-unicode-tokens.el"
            },
            {
                "Submitter": "Steve Gilham",
                "Submitted": "2014-04-06T15:16:00",
                "Content": "As code like `let (<+>) = ...` compiles to an all-ASCII function name `op_LessPlusGreater` I would expect code like `let (∪) = ...` to compile to a similarly all-ASCII function name like `op_U222A` in the IL. And just as one can invoke the <+> function by ASCII name (just not as an infix), so too op_U222A could be invoked by that name if input for the mathematical symbol was difficult.\r\nIdeally, this change would be coupled with a more general facility to define infix operators -- along the lines of ML's `infix` keyword -- but lacking a suitable reserved keyword some other syntax, maybe like `let (Union) = ...` compiling to `op_Union` would be required. Or maybe a compiler directive that when switched on made functions defined as explicitly as `op_<whatever>` invokable as infix `<whatever>`"
            },
            {
                "Submitter": "Robert Nielsen",
                "Submitted": "2014-06-22T11:04:00",
                "Content": "Daniel Fabian the main thing that is stopping us from using unicode in the source code is the need for double-backtick marks (`` ``) to make F# understand the meaning, and even then a lot of the language constructs simply refuse to use non-normal names."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T11:22:00",
                "Content": "I tend agree with Jack Pappas that this would not be a good thing for F#, for the reasons he describes."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-09-26T15:56:00",
                "Content": "What if it required a `#nowarn` and the Unicode characters supported for operators were limited to specific blocks, e.g. Mathematical Operators[1], Supplemental Mathematical Operators[2], and maybe even some of Miscellaneous Technical[3] ;)\r\n[1] http://www.fileformat.info/info/unicode/block/mathematical_operators/utf8test.htm\r\n[2] http://www.fileformat.info/info/unicode/block/supplemental_mathematical_operators/utf8test.htm\r\n[3] http://www.fileformat.info/info/unicode/block/miscellaneous_technical/utf8test.htm"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-01-09T15:36:00",
                "Content": "[ Part 2 of 2 ]\r\n> What's the downside of having an IDE plugin (like F# Power Tools), or the add-on Daniel linked to, that could recognize naming conventions for variables and convert them to Unicode characters in the IDE (but not in the actual code)?\r\nThis downside is that this does nothing for operators. Operators are what are in question, and converting variable names does nothing to help the fact that the set of possible operators that can be created is fairly constricted and most of them are part of the language already. Not to mention between Suave, FParsec, and Freya there aren't many you can define or use without colliding fairly quickly under 3 characters. The built in precedence rules of F# only further compound these issues `^` is going to start any operator that you want to have right associativity. Swift gets this right[1], when declaring a custom operator you declare whether it's prefix, infix, or postfix; you pick whether the associativity is left, right, or none; and you set an associativity level between 0 and 255. And operators can be created from Unicode Math, Symbol, Arrow, Dingbat, line/box drawing and Unicode combining characters.[2] One additional feature that they should have included is the ability to give your operator a named\r\nalias to use during autocomplete.\r\nFurthermore there's not reason to create a naming convention for variables so they can be disguised as Unicode characters while rendered, because we can just use those those characters already.\r\nThese are all valid binding names:\r\nʀ ʁ ʂ ʃ ʄ ʅ ʆ ʇ ʈ ʉ ʊ ʋ ʌ ʍ ʎ ʏ ʐ ʑ ʒ ʓ ʔ ʕ ʖ ʗ ʘ ʙ ʚ ʛ ʜ ʝ ʞ ʟ\r\nɀ Ɂ ɂ Ƀ Ʉ Ʌ Ɇ ɇ Ɉ ɉ Ɋ ɋ Ɍ ɍ Ɏ ɏ ɐ ɑ ɒ ɓ ɔ ɕ ɖ ɗ ɘ ə ɚ ɛ ɜ ɝ ɞ ɟ\r\nɠ ɡ ɢ ɣ ɤ ɥ ɦ ɧ ɨ ɩ ɪ ɫ ɬ ɭ ɮ ɯ ɰ ɱ ɲ ɳ ɴ ɵ ɶ ɷ ɸ ɹ ɺ ɻ ɼ ɽ ɾ ɿ\r\nʀ ʁ ʂ ʃ ʄ ʅ ʆ ʇ ʈ ʉ ʊ ʋ ʌ ʍ ʎ ʏ ʐ ʑ ʒ ʓ ʔ ʕ ʖ ʗ ʘ ʙ ʚ ʛ ʜ ʝ ʞ ʟ\r\nπ ρ ς σ τ υ φ χ ψ ω ϊ ϋ ό ύ ώ Ϗ ϐ ϑ ϒ ϓ ϔ ϕ ϖ ϗ Ϙ ϙ Ϛ ϛ Ϝ ϝ Ϟ ϟ\r\nϠ ϡ Ϣ ϣ Ϥ ϥ Ϧ ϧ Ϩ ϩ Ϫ ϫ Ϭ ϭ Ϯ ϯ ϰ ϱ ϲ ϳ ϴ ϵ\r\nڀ ځ ڂ ڃ ڄ څ چ ڇ ڈ ډ ڊ ڋ ڌ ڍ ڎ ڏ ڐ ڑ ڒ ړ ڔ ڕ ږ ڗ ژ ڙ ښ ڛ ڜ ڝ ڞ ڟ\r\nᐁ ᐂ ᐃ ᐄ ᐅ ᐆ ᐇ ᐈ ᐉ ᐊ ᐋ ᐌ ᐍ ᐎ ᐏ ᐐ ᐑ ᐒ ᐓ ᐔ ᐕ ᐖ ᐗ ᐘ ᐙ ᐚ ᐛ ᐜ ᐝ ᐞ ᐟ\r\nⅠ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ Ⅺ Ⅻ Ⅼ Ⅽ Ⅾ Ⅿ ⅰ ⅱ ⅲ ⅳ ⅴ ⅵ ⅶ ⅷ ⅸ ⅹ ⅺ ⅻ ⅼ ⅽ ⅾ ⅿ\r\nↀ ↁ ↂ Ↄ ↄ ↅ ↆ ↇ ↈ\r\nAnd for the wide swath of glyphs and characters that cause compiler errors due to unrecognized characters if you include them in your source, all you need are some backticks\r\n``∠`` ``∡`` ``∢`` ``∣`` ``∤`` ``∥`` ``∦`` ``∧`` ``∨`` ``∩`` ``∪`` ``∫`` ``∬`` ``∭`` ``∮`` ``∯`` ``∰`` ``∱`` ``∲`` ``∳``\r\nand you're free to use and abuse them as much as you please.\r\nIt's almost as though people fear F# will turn into APL if the operator system is improved, but it won't, because people don't want that. This is a feature that will be very beneficial to some people, and for the most part it'll have little to no effect on everyone else. But there's a still decent chance that most people will reach a point in time, maybe a few times, where having these extra capabilities was essential and incredibly useful, just like with Units Of Measure.\r\nLet me be clear I don't want to use operators all the time, and I think that most of the time it's better and easier to understand code by using well named functions over glyph jumbles. My biggest issue with the current state of F# on this issue is it's very easy to make the worst kind code that fulfills and embodies all of the concerns people have brought up already. But there's no way to make and employ the symbols that would actually be useful.\r\n[1] https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html\r\n[2] https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID418"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-01-09T15:37:00",
                "Content": "[ Part 1 of 2 ]\r\nI disagree with the majority of Jack's points.\r\n> My chief concern is that you'd be forcing consumers of your code to use these symbols as well.\r\nThat's the point, it's not a detrimental aspect. When working in a specialized domain the ability to use a common and familiar set of symbols is of great benefit to reducing the overall cognitive load applied to problem solving. If a developer is using these symbols in their code, the intended consumers probably want to use them as well.\r\n> code with Unicode operators is much less approachable for newcomers to F# -- especially those who don't come from a math/science-heavy background -- and I worry it would keep people away from F# who might otherwise be quite happy with the language.\r\nThis is a completely unrealistic fear. The kinds of code it would most likely be used in are for highly domain specific math and science projects. These are not the kind of projects that newcomers to the language would be using in the first place. Even without the Unicode glyphs it'd still be unapproachable to newcomers. But that's fine, because it's not for them. We should want to have features in the language that make it more appealing to a wider group of people than it currently does, if a language as obtuse as Haskell can reach the level of popularity that it already has, I think F# will be fine with a few more options for operators.\r\n> Another drawback -- a number of mainstream development tools (including parts of VS) weren't designed with Unicode symbols in mind, and won't work properly when code or compiled assemblies use them in type/field/method names.\r\nAtom, Kate, Brackets, VsCode, Sublime, Vim, Emacs, XCode, Xamarin, these tools all work fine with Unicode Symbols. I use them all the time. I even added Unicode glyph support to Ionide for Atom to make it even easier to use them. Yes the tools should be fixed to handle them properly, but there's no impetus to do so if no one needs the functionality."
            },
            {
                "Submitter": "Matthew Orlando",
                "Submitted": "2016-01-23T14:49:00",
                "Content": "Everything Jared said. My browser (chrome on windows 10) doesn't even display all the characters he listed as valid binding names and yet... they're valid binding names. There is nothing but the fact that people are mostly sane keeping them from running amok with identifier names already. It's just certain sets of characters that seem arbitrarily excluded and would actually logically make sense in a functional language.\r\nOne of the biggest benefits of FP in general is that it's easy to make DSLs. Why would you want to artificially limit the expressiveness of those DSLs?\r\nThe structure of the arguments against adding math symbols as valid operators is identical to the arguments against allowing gay marriage. \"I'm uncomfortable with it, therefore others shouldn't be allowed.\" \"If we allow some people to start doing this, then everyone will start doing this and humanity (programmerity?) will be doomed\""
            },
            {
                "Submitter": "Alan Ball",
                "Submitted": "2016-07-29T13:04:00",
                "Content": "Let's not forget that the link to this page already had 110 votes."
            },
            {
                "Submitter": "Alan Ball",
                "Submitted": "2016-08-02T12:57:00",
                "Content": "The opponents to this suggestion would have us believe that some random assortment of characters is better than a simple symbol that you can even copy and paste into google to find what it means. The idea of \"substitution\" where you can actually figure out what each thing is supposed to mean predictably ultimately leads to something where you have unicode names as functions, losing operator precedence.\r\nu2211 mylist, or\r\nset1 |> u2229 <| set2\r\nis not easier than\r\n∑mylist\r\nand\r\nset1 ∩ set2"
            },
            {
                "Submitter": "Charles Roddie",
                "Submitted": "2016-09-20T16:50:00",
                "Content": "I think there are a few common operators which should be added to the F# spec.\r\n≤, ≥ and ≠ are very common but quite ugly and hard to understand in F#. <= and >= are familiar to progammers but not to non-programmers, and a <= b looks more like a⇐b than a≤b. <> looks nothing like ≠ and is unintelligible to anyone who has not read the F# spec.\r\nI think it would be close to no effort to include these as alternative syntax, and it would allow quantitative code to look a lot better.\r\n← and → could also be treated as more concise and better looking versions of <- and ->\r\n(Maybe ¬ ∧ ∨ for not, &&, ||, and ○ for <| too but these are less universally understood symbols.)\r\nF# is a very expressive language. You can often write code that is basically intelligible to technical people without specific programming knowledge. For example in teaching/presenting maths you can write F# code that is universally understandable, like pseudocode, except that it actually runs. With some small tweaks to approve attractiveness, readability, and intelligibility it can be even better."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5688699": {
        "Number": "5688699",
        "Submitter": "Braden Evans",
        "Submitted": "2014-03-27T00:00:00",
        "Title": "Early return from functions",
        "Text": "I have found that when porting code from other languages (especially optimized loopy code) the lack of early return is a real pain point. It is always possible to re-arrange code (especially with pattern matching) but it can be very time consuming and the \"gist\" of many algorithms can be lost.\r\nI don't think this is a desirable feature for general use, perhaps this could be made just ugly enough to discourage abuse - maybe require an attribute on functions that use it?\r\nI'm sure this will be highly controversial, my own experience is that imperative code in f# is still nicer than other languages, and I would like to be able to write everything in f# instead of splitting between f# and c#.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-03-28T09:54:00",
                "Content": "If you really need that you can use http://tomasp.net/blog/imperative-i-return.aspx/\r\nI think it's a bad idea to have in the language"
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-03-31T06:23:00",
                "Content": "Early returns is a bad idea that definitely should NOT be introduced. Simulating early returns should be done via computation expressions."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-31T13:34:00",
                "Content": "Agree with the previous comments. Returns should not be introduced, encourages bad styles."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2014-04-04T16:24:00",
                "Content": "In C# I very much like early returns rather than the usual practice of \"declare a variable called ReturnValue at the start of the method, assign it in various random places throughout the method, and then return whatever it is at the end\". However, in F# I find that it's usually not necessary as expressions, pattern matching and the ability to declare arbitrary functions inline of one another means that you can still easily reason about code and have only one return point."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T15:08:00",
                "Content": "I'm inclined to decline this: F# is expression oriented and that is one of its strengths. Early returns become a little harder, but the advantages of being expression oriented outweigh the problems it brings"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per my comment\r\nDon Syme, F# Language Evolution"
        }
    },
    "5689176": {
        "Number": "5689176",
        "Submitter": "Don Syme",
        "Submitted": "2014-03-27T00:00:00",
        "Title": "Privatise F#'s MailboxProcessor",
        "Text": "<joke>\r\nThe UK government privatised Royal Mail for £3,000,000,000. It's basically a MailboxProcessor. F# has a MailboxProcessor type, lighter and more efficient than Royal Mail. Can we privatise the MailboxProcessor type too?\r\nIf we do, maybe we can use the funds to build a MessageProcessor type, to be acquired by Facebook?\r\nSee https://twitter.com/businessBoris/status/448983711451983872\r\n</joke>",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "bB",
                "Submitted": "2014-03-27T14:04:00",
                "Content": "Where do I sign?"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-03-27T00:00:00",
            "Text": "Sold. We’ve spent the proceeds on beer."
        }
    },
    "5690218": {
        "Number": "5690218",
        "Submitter": "Anonymous",
        "Submitted": "2014-03-27T00:00:00",
        "Title": "Allow open in local declarations like in Standard ML and O'Caml (>= 3.12)",
        "Text": "See e.g. http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#localdecs",
        "Votes": 67,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-03-27T21:30:00",
                "Content": "I like this, though I don't know what the downsides might be."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-03-28T19:00:00",
                "Content": "I don't think there are any downsides to this. An \"open Module\" declaration has no run-time effects nor does it generate new types so there are no major semantic issues to worry about. It merely allows finer grained scoping of existing bindings."
            },
            {
                "Submitter": "Paul",
                "Submitted": "2014-11-13T18:36:00",
                "Content": "A prototype is available here.\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowOpenInExpressions/contribution/7691"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T06:41:00",
                "Content": "Paul, could you please bring the PR across to http://github.com/Microsoft/visualfsharp? It is of definite interest (though no commitment about including the feature as yet)"
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5691666": {
        "Number": "5691666",
        "Submitter": "Martin Bodocky",
        "Submitted": "2014-03-28T00:00:00",
        "Title": "What do you think to add F# atom data type as it's used in Erlang?",
        "Text": "I think to implement Erlang like atoms can add language more readability more precise pattern matching. More here http://www.erlang.org/doc/reference_manual/data_types.html#id66445.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-28T05:29:00",
                "Content": "What is the difference between atoms and DU cases without annotated data?"
            },
            {
                "Submitter": "Martin Bodocky",
                "Submitted": "2014-03-28T05:43:00",
                "Content": "Atom is represent as value it self, for example atom is 'request' is just request is not string is atom. It should be differentiate from other variables, in Erlang should start by lower case or '.\r\nLet's imagine we have atom in F# and we decide atoms in F# should start with one single quote like 'atom.\r\nThe reall example can be in pattern matching like :\r\nlet receive request =\r\nmatch request with\r\n| 'remove, Value -> action()\r\n| 'add, Value -> action()\r\nThe atom 'remove is static, the variable request is tuple if atom and another data value type.\r\nDU defines data by data value types, atoms are valueless in this sense.\r\nI hope this helps you, if no I will try explain again, I don't know your level of Erlang :)"
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-28T05:48:00",
                "Content": "I meant, in what is it diffent from a DU like:\r\ntype RequestType = Remove | Add\r\nlet receive request =\r\nmatch request with\r\n| Remove, value -> action()\r\n| Add, value -> anotherAction()\r\nin this case the DU RequestType is reeally either Remove or Add but both cases have no value associated with them. The \"Remove\" or \"Add\" are the values themselves."
            },
            {
                "Submitter": "Martin Bodocky",
                "Submitted": "2014-03-28T06:15:00",
                "Content": "Daniel, your approach is right! I really cannot argue, you convinced me I don't need atoms in pattern matching also I see advantage when I upgrade RequestType compiler will push me to update my code. You see that's why I love F# I learn new thing every day."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "5691744": {
        "Number": "5691744",
        "Submitter": "Patrick Q",
        "Submitted": "2014-03-28T00:00:00",
        "Title": "Allow a single let to create multiple bindings",
        "Text": "Because spaces will be removed when this is posted I've used dots in their place.\r\nIt can often clutter up code when one needs create a lot of let bindings. My suggestion would be to allow a single let to create a group of bindings.\r\nFor instance, instead of this ...\r\nlet x = blah\r\nlet y = blah\r\nlet k = blah\r\nlet add a b = a + b\r\nlet LT a b = a < b\r\nlet addMult a b c = (add a b) * c\r\nmatch x, y with\r\n| blah -> z\r\n| blah -> add x y\r\nwe could use the following ...\r\nlet x = blah\r\n.....y = blah\r\n.....k = blah\r\n.....add a b = a + b\r\n.....LT a b = a < b\r\n.....addMult a b c = (add a b) * c\r\nmatch x, y with\r\n| blah -> z\r\n| blah -> add x y\r\nImplementing this feature would de-clutter code without having to completely remove the let keyword, which is unlikely to be practical.This idea should be doable because the indentation can be used to know the scope of the grouped let bindings.",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-03-28T13:35:00",
                "Content": "not quite the same, but you can use tuple syntax in a few cases. E.g. you could write\r\nlet x, y, k = blah, blah, blah"
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-03-28T20:03:00",
                "Content": "Daniel, you correct here. I often do this when faced with a few simple bindings, but this won't work for function bindings. Haskell has a similar capability with its \"where\" clause."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2014-03-30T10:08:00",
                "Content": "Supporting let/in and where from haskell would be even greater\r\nlet a =\r\nb =\r\nc =\r\nin\r\nmatch a;b with\r\n...\r\nmatch a, b with\r\n...\r\nwhere\r\na =\r\nb ="
            },
            {
                "Submitter": "let rec",
                "Submitted": "2014-03-31T13:16:00",
                "Content": "Using tuples costs allocation, because the compiler doesn't optimize tuples away.\r\nThis http://connect.microsoft.com/VisualStudio/feedback/details/719299/tuple-allocations-are-not-eliminated-for-tuples-constructed-from-implicitly-returned-formal-arguments proposal along with the fix was rejected for some reason."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-03-31T13:33:00",
                "Content": "let rec,\r\nNot always true, sometimes the compiler does optimize tuples away. It depends on what is going on."
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-06-16T06:59:00",
                "Content": "To make my original suggestion more practical, may I also suggest that the now rarely unused \"in\" keyword be made use of when \"let\" is bound to multiple values as in the following:\r\nlet x = blah\r\n.....p, q = List.partition fn stuff\r\n.....k = List.length y\r\n.....add a b = a + b\r\n.....addMult a b c = (add a b) * c\r\nin // NOTE: \"in\" required when a single \"let\" is bound to multiple values\r\nmatch x, y with\r\n| aaa, bbb -> addMult p q k\r\n| ccc, ddd -> add p q"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T07:23:00",
                "Content": "Hi @letrec - I see the link to your proposed optimization patch for tuples. Please consider submitting this improvement to https://visualfsharp.codeplex.com/, now that contributions are being accepted for the F# compiler and language\r\nThanks\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:57:00",
                "Content": "I will mark this as declined, since it would introduce multiple ways of doing the same thing into the F# language. See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/5681764-make-let-optional which was declined on similar grounds."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment below\r\nBest regards & thanks again,\r\nDon Syme, F# Language Evolution"
        }
    },
    "5695277": {
        "Number": "5695277",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-03-28T00:00:00",
        "Title": "Allow the addition of operators in type extensions, and also operators on internal types",
        "Text": "This is currently not allowed:\r\ntype Foo with\r\nstatic member (+) (foo1, foo2) = foo1.Bar + foo2.Bar",
        "Votes": 80,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-04-09T22:09:00",
                "Content": "This seems more concrete than http://fslang.uservoice.com/forums/245727-f-language/suggestions/5666323-operator-overloads-problem-in-f but since it can already be done with inline + static type parameters I wonder what would be the benefit of doing it via type extensions."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T14:04:00",
                "Content": "See some commentary here that discusses a related problem and the relevant commpiler code: https://visualfsharp.codeplex.com/workitem/2"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-08-17T13:09:00",
                "Content": "This would help with generic arithmetic on novel types, e.g. http://stackoverflow.com/questions/25346246/why-cant-we-satisfy-f-static-member-constraints-with-type-extensions/25347602#25347602"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-02-25T10:08:00",
                "Content": "Just ran into this problem today, and worked around it with the scary inline workaround :) Would be nice if this worked and didn't cause any problems elsewhere!"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T22:32:00",
                "Content": "Yes, I need this too."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5699234": {
        "Number": "5699234",
        "Submitter": "mikero",
        "Submitted": "2014-03-29T00:00:00",
        "Title": "Allow declaration of precedence for operators for writing internal DSLs",
        "Text": "F# has great internals for DSLs, such as DU's and pattern-matching, but the operator definition rules are restrictive and baroque.\r\nIt would be great to be able to define operators with user-defined names, arity, fixity and precedence without restriction on what characters are in the operator for given operator class. Syntax modules with operator definitions (not behaviors) could be explicitly referenced.\r\nThis could be a step toward (and maybe as far as one need go) more general compile-time eval / macro support.\r\nsyntax module MyDSL\r\n// Prology syntax here - but whatever\r\nop (\"==>\", xfy, 200)\r\nop (\"not\", fx, 1000)\r\n...\r\nopen syntax MyDSL1, MyDSL2\r\n...code here...\r\nor could have a workflow-like syntax for including the operators in a specific scope:\r\nMyDSL { .... }\r\nI think I understand the bag of worms here, but it's worth it to me over having to move to another language for a project or write a parser (even if in FParsec, etc.) for an external file and then slowly interpret an AST or go through the effort of code-gen, which after all is what we have the compiler for.",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "mikero",
                "Submitted": "2014-03-29T11:45:00",
                "Content": "Missing in the op statements is the mapping from the syntax to the corresponding F# function\r\nop (\"==>\", xfy, 200, Implies)\r\nthen the user would bind the syntax module to a class that implements Implies, Not, etc."
            },
            {
                "Submitter": "Peter Strøiman",
                "Submitted": "2014-12-01T07:49:00",
                "Content": "Just being able to control associativity would help me out greatly. I have a project where I needed my custom infix operator to be right associative. This forces me to choose the first character in the operator to be either * or ^.\r\nNeither are particularly pretty."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:53:00",
                "Content": "This is bag of worms territory :)\r\nIn F# 1.0 we decided against having notational declarations, and we've generally been sticking with this decision, e.g. see here http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663255-allow-infix-notation-on-functions and a few other suggestions. I'm going to decline this suggestion on the same basis."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment as part of house-keeping of old suggestions that have relatively few votes.\r\nThat said I understand the use cases here. and that internal DSLs are sometimes unsatisfactory in F#. But equally, having parsing be free of scoped declarations is a great simplification in the language, and means the “can of worms” is not opened too far :)\r\nBest regards\r\nDon Syme, F# Language Evolution"
        }
    },
    "5702281": {
        "Number": "5702281",
        "Submitter": "Tuomas Hietanen",
        "Submitted": "2014-03-30T00:00:00",
        "Title": "Improve the query { ... } -syntax",
        "Text": "Three ideas of the new query{ ... } -syntax:\r\n1) Do something for the amount of white space needed for new line as the arrow \"->\" can't break the line!\r\nAs the tutorial shows, there is like one word per line:\r\nhttp://www.tryfsharp.org/Learn/data-science#further-data-analysis\r\n2) Improve the syntax: Now it is weird and have more noise than SQL or LINQ. So I even rather use LINQ-to-IQueryable in F# than F#'s own query-syntax. This can be done By making as simple query {...} as possible and then use Linq-library to manipulate it further.\r\n3) Make it compile-time-aware of capacities of the queryed interface. For example, Azure Table Storage won't support most of the queries:\r\nhttp://msdn.microsoft.com/en-us/library/windowsazure/dd135725.aspx",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-03-31T08:39:00",
                "Content": "1) you can perfectly break the line before or after \"->\". In the linked example this works just fine:\r\nChart.Point([for cy in cyclonesWithFatalities ->\r\ncy.``Highest winds``.Value,\r\ncy.``Total fatalities``.Value])\r\n(in case the whitespace gets mangled: the \"cy...\" lines are indented further than the start of \"for\")\r\n2) Do you have concrete examples?\r\n3) I agree with this one, it would be nice."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:47:00",
                "Content": "My feeling is that the solution to these problems is not in modifications to the \"query\" feature but in taking alternative approaches to querying. For example:\r\nThe Azure Storage Type Provider shows a better way to have queries when the query language is limited: http://fsprojects.github.io/AzureStorageTypeProvider/\r\nThe SqlCommandProvider shows how to do checked SQL directly using type providers: http://fsprojects.github.io/FSharp.Data.SqlClient/"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestions! Per my comment and the other comments, I’m declining this, please take a look at the links.\r\nOne reason for declining was that some of the suggestions were not that concrete. Please open new issues if there are specific changes proposed\r\nMany thanks\r\nDon Syme, F# Language Evolution"
        }
    },
    "5704447": {
        "Number": "5704447",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2014-03-31T00:00:00",
        "Title": "Introduce public Range types",
        "Text": "Range types exist in F#, as they manifest themselves in computation expression for loops:\r\nfor i in 1 .. 100 do ()\r\nThese take the form of internal IEnumerable implementations. Therefore, one cannot define a .For method override that only permits range types at its domain, instead having to cover all possible IEnumerable's.\r\nWhy could this be a problem, you may ask? It is the case that many IEnumerators are not serializable, whereas certain computation expressions inherently demand a persistable execution state. In such cases we are forced to only support concrete manifestations of collections such as arrays, resulting in the following inefficient and awkward use:\r\nfor i in [| 1 .. 100 |] do ()\r\nMaking Range types public would remedy this issue.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T04:13:00",
                "Content": "My understanding is that one way to solve this is to make sure the enclosing cloud/monadic computation has a Delay method."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T04:14:00",
                "Content": "I will close this as I don't think chasing down non-serializable sequence objects one by one is the way we will solve this?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Declined, per my comment, thanks!\r\nDon Syme, F# Language Evolution"
        }
    },
    "5710374": {
        "Number": "5710374",
        "Submitter": "Steven Sagaert",
        "Submitted": "2014-04-01T00:00:00",
        "Title": "add distributed arrays",
        "Text": "Like suggested on the F#.org website, F# could be an excellent language for modern scientific computing/machine learning. However for large scale computing (Big Data), it is missing some things. One of these is distributed (in-memory) arrays. I was hoping that \"Microsoft Cloud numerics\" would have been available by now but like so many MSR projects this one seems to have died a quiet death. So I propose to add a distributed array type directly to F# similar to Fortran co-arrays (see co-array Fortran of Fortran 2008). This could be implemented on top of MPI (MS MPI, MPI.NET). That would make it run from a single host, a cluster of servers connected via ethernet to a real supercomputer with a grid-type network.\r\nThis would allow to build parallel & distributed algo's to run on computed clusters/cloud for number crunching & large scale machine learning (\"big learning\" on big data).",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T07:16:00",
                "Content": "Hi Steven\r\nAs with [/ideas/suggestion-5710458-create-a-standard-free-open-source-comprehensive-m,](/ideas/suggestion-5710458-create-a-standard-free-open-source-comprehensive-m,.md) I'm very sympatheric to this request. An upstack library in this domain would be a great addition to th F# ecosystem, and its possible some upstack .NET libraries already exist for this, or other R/Python libraries that can be used from F#.\r\nRight now it's a bit off topic for fslang.uservoice.com, which focuses on the language and core library FSharp.Core.\r\nHave you searched around for F#, C# open source projects implementing distributed arrays for .NET, publishing packages on http://nuget.org, or considered starting one?\r\nThis would be a great addition to the"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "Declined, see comment by Don Syme,\r\n“As with [/ideas/suggestion-5710458-create-a-standard-free-open-source-comprehensive-m,](/ideas/suggestion-5710458-create-a-standard-free-open-source-comprehensive-m,.md) I’m very sympathetic to this request. An upstack library in this domain would be a great addition to the F# ecosystem, and its possible some upstack .NET libraries already exist for this, or other R/Python libraries that can be used from F#.\r\nRight now it’s off topic for fslang.uservoice.com, which focuses on the language and core library FSharp.Core.\r\nHave you searched around for F#, C# open source projects implementing distributed arrays for .NET, publishing packages on http://nuget.org, or considered starting one?\r\n\""
        }
    },
    "5710458": {
        "Number": "5710458",
        "Submitter": "Steven Sagaert",
        "Submitted": "2014-04-01T00:00:00",
        "Title": "create a standard free open source comprehensive machine learning library",
        "Text": "Like suggested on the F#.org website, F# could be an excellent language for modern machine learning. In fact it could be one of it's killer niches. There a few C# ML libs like Accord.net that one can call from F# but there isn't a \"native\" F# one using those wonderful F# specific features (e.g. type providers, async & parallel,...) and exposing a functional API.\r\nRather than hoping that such a library will spontaneously emerge from the open source community maybe a more structured approach should be followed and the initiative should be taken by the core team responsible for the F# platform (of course volunteers from the ML community should be able to join in and collaborate). This would ensure one large comprehensive ML library with a uniform style covering all of the modern ML models (kernel models,Bayesian models/probabilistic graphical models, deep learning, ensemble methods,...) rather than N little open source libraries each which implement a small fraction of the models and each in another style/API.\r\nSince this is 2014 and the multicore & cloud revolution is now firmly upon us, this library should aim to implement as much a possible data parallel versions of the algo's (if possible of course) and also distributed versions to run on clusters/cloud because that's what's missing from most ML libs out there (in any language).",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T07:10:00",
                "Content": "Hi Steven,\r\nI'm strongly sympathetic to this and consider it really important for growing F# use in this area.\r\nThis is a bit off topic for fslang.uservoice.com, which is about the F# language and core library (FSharp.Core), so I'll decline it here. However some upstack open source efforts to get involved in would be\r\n- http://fslab.org\r\n- MathNet.Numerics\r\n- other machine learning packages and projects on http://nuget.org\r\n- make Vorpal Wabbit better available for C# and F# and document its use http://hunch.net/~vw/\r\n- likewise with other industry-standard machine-learning libraries\r\nAnything you do or get involved with can be documented at http://fsharp.org/guides/machine-learning/\r\nThanks\r\nDon"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "See comment and links by Don Syme."
        }
    },
    "5710778": {
        "Number": "5710778",
        "Submitter": "Steven Sagaert",
        "Submitted": "2014-04-01T00:00:00",
        "Title": "add a memory-mapped array type",
        "Text": "Add a memory mapped array similar to what is available in the Julia and Python languages. This would allow to process arrays backed by a binary file that do not fit in RAM (on a single host) transparently as if they did. This would be very useful for scientific programming / machine learning on big data on a single host. The syntax/interface of the array should be the same as a standard array/ distributed array (see my proposal concerning distributed arrays) so that one can transparently switch the implementation from standard array -> mmapped array -> distributed array to scale up from small data/single host -> large data/single host -> large data/multiple hosts to transparently scale in data size & computing power size.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-04-02T04:35:00",
                "Content": "You are aware of the existing support for memory mapped files in .Net? Why not just go and implement the idea?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T07:03:00",
                "Content": "Support for memory-mapped files exists in .NET 4.5, e.g. http://msdn.microsoft.com/en-us/library/dd997372(v=vs.110).aspx.\r\nI believe that can be used directly."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "Support for memory mapped files already exists in .NET 4.5 and can be used already.\r\nIt’s possible that nicer support can be added for an F#-defined type too. However that should be done in an upstack library like MathNet.Numerics or FSharp.Data or Deedle or elsewhere, rather then in the language and FSharp.Core library.\r\nIf you’re interested in contributing some functionality here, http://fslab.org may be a place to do so?\r\nDon Syme, F# Lang"
        }
    },
    "5716959": {
        "Number": "5716959",
        "Submitter": "Anonymous",
        "Submitted": "2014-04-02T00:00:00",
        "Title": "Support markdown in documentation comments",
        "Text": "F# currently supports documentation comments with either XML tags or no tags. The no tags format is convenient to write, but does not allow formatting the comments for the VS IDE. Use of XML tags allows formatting the documentation comment, but the act of writing the documentation comment becomes a heavy burden as XML is not a very convenient format for manual editing. I would like to suggest supporting some lighter-weight formatting syntax such as markdown.",
        "Votes": 19,
        "Comments": [
            {
                "Submitter": "Tomas Petricek",
                "Submitted": "2014-04-03T10:46:00",
                "Content": "The F# Formatting library (http://tpetricek.github.io/FSharp.Formatting/metadata.html) already partly lets you do this. It is not integrated with the compiler, so it won't work nicely in Visual Studio - but if someone added transformation that generates standard XML comments from the Markdown that we already parse, it would work nicely at least for libraries. There is even an open issue for this: https://github.com/tpetricek/FSharp.Formatting/issues/44\r\nI think this is quite close - and with the transformation, you could document libraries with Markdown perfectly. But further integration with compiler would make it even nicer."
            },
            {
                "Submitter": "Mastr Mastic",
                "Submitted": "2014-04-07T10:48:00",
                "Content": "I would love this, and especially if the VS would support this in the IntelliSense tooltips."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5726029": {
        "Number": "5726029",
        "Submitter": "bleis-tift",
        "Submitted": "2014-04-03T00:00:00",
        "Title": "Support conjunctional operator",
        "Text": "'a < x < b' means 'a < x && x < b'. (but x is evaluate only once)\r\nPython implements this feature.",
        "Votes": 27,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-04T03:10:00",
                "Content": "similar http://fslang.uservoice.com/forums/245727-f-language/suggestions/5683305-allow-the-syntax-1-x-10"
            },
            {
                "Submitter": "Goswin",
                "Submitted": "2014-04-08T03:52:00",
                "Content": "until this feature comes you could write 'a <. x .< b' by using these custom operators:\r\n///* Point must be at middle of expression: like this: min <=. x .<= max\r\nlet inline (<=.) left middle = (left <= middle, middle)\r\nlet inline (.<=) (leftResult, middle) right = leftResult && (middle <= right)\r\nlet inline (>=.) left middle = (left >= middle, middle)\r\nlet inline (.>=) (leftResult, middle) right = leftResult && (middle >= right)\r\n// Point must be at middle of expression: like this: min <. x .< max\r\nlet inline (<.) left middle = (left < middle, middle)\r\nlet inline (.<) (leftResult, middle) right = leftResult && (middle < right)\r\nlet inline (>.) left middle = (left > middle, middle)\r\nlet inline (.>) (leftResult, middle) right = leftResult && (middle > right)"
            },
            {
                "Submitter": "bleis-tift",
                "Submitted": "2014-04-08T04:50:00",
                "Content": "@Goswin\r\nI want to write the code like this:\r\n0 < x < y < ... < 100\r\nYour approach needs more operators like the following:\r\nlet inline (.<.) (leftResult, middle) right = (leftResult && middle < right, right)\r\n// and more...\r\n0 <. x .<. y .<. ... .< 100\r\nDots are too noisy..."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T09:24:00",
                "Content": "My gut feeling is that this special case doesn't \"make the cut\", though the fact it is in Python is interesting and speaks in its favour.\r\nDo we have ny information on how often is this used in Python?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "I’m declining this because I feel the added expression form doesn’t make the very high bar for adding new expression constructs to the language. See the discussion for other comments.\r\nFurther input and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "5736822": {
        "Number": "5736822",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2014-04-06T00:00:00",
        "Title": "Make the .Tag property public in DUs",
        "Text": "A common problem I encounter is when I need to group a list of incuming DU values according to branch. Having the .Tag property public would make this as simple as writing\r\nvalues |> Seq.groupBy (fun v -> v.Tag)\r\nAt the moment, this can only be achieved either by cumbersomely defining a custom tag function or by using reflection.\r\nFor the ML purists that don't like the idea of a property, this could also be achieved through the definition of a static method, for instance\r\nUnionType.GetInternalBranchRepresentationValue : UnionType -> int",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T11:57:00",
                "Content": "I generally approve of this particular suggestion and think it would make a good addition to F#. (I don't think the loss of purity (e.g. wr.t. ordering of union cases) is a critical problem and I believe you can turn of the DefaultAugmentation in any case)\r\nSome technical issues may need to be ironed out during implementation.\r\nIf this is done, the Is* properties present on these types should also be revealed, that is covered by a separate item.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nImplementations of approved language design can now be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest.\r\nI'd be glad to help guide people through the implementation process.\r\nIf you strongly think this should _not_ be approved please chime in with your technical feedback.\r\nThanks\r\nDon Syme, current BDFL for F# Language Design"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-25T00:00:00",
            "Text": "Merging this with [/ideas/suggestion-5683698-make-is-discriminated-union-properties-visible-f](/ideas/suggestion-5683698-make-is-discriminated-union-properties-visible-f.md)\r\nThis is not actually being declined, quite the opposite, it is being approved and merged"
        }
    },
    "5749571": {
        "Number": "5749571",
        "Submitter": "exercitus vir",
        "Submitted": "2014-04-09T00:00:00",
        "Title": "Add support for primitive sub-types (types constrained by sub-ranges or length)",
        "Text": "Please add support for sub-types like Ada which are enforced by the F# compiler. A sub-type is basically just a sub-range of an existing primitive type like int.\r\nThis is extremely useful for domain modelling and makes code much more robust.\r\nExamples using existing range syntax or existing for-loop syntax or :\r\n//restrict range (specify min value and max value)\r\ntype percent = decimal for 0M to 1M //for-loop syntax\r\ntype positive_int = int in 1 .. int.MaxValue //range syntax\r\ntype non_negative_int = int for 0 to int.MaxValue //for-loop syntax\r\n//a positive_int should be assignable to a non_negative_int\r\n//specify minimum and maximum length of string\r\ntype path = string for 1 to 256 //for-loop syntax",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "Tony Williams",
                "Submitted": "2014-04-16T04:58:00",
                "Content": "Wouldn't dependent typing also solve this? If so then hopefully the work on F* could be used here."
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-05-01T07:12:00",
                "Content": "Wish I could give more votes. Ever since I saw this in Ada I've always thought it would such a useful feature to have in F#. Certainly agree that it would enhance safety and robustness."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T05:53:00",
                "Content": "Just to note that this feature is very difficult to add to F# satisfactorily, and quickly leads you towards full dependent types."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below: this feature almost immediately leads you to dependent types, see the comments here: [/ideas/suggestion-6062821-add-dependent-types](/ideas/suggestion-6062821-add-dependent-types.md)"
        }
    },
    "5752551": {
        "Number": "5752551",
        "Submitter": "Matthew Peacock",
        "Submitted": "2014-04-09T00:00:00",
        "Title": "Make printf handle units of measure.",
        "Text": "Currently printf requires all numeric types with units of measure to have the units removed. For example:\r\nlet years = 1<year>\r\nprintfn \"%d\" years // compile error\r\nprintfn \"%d\" (int years) // works\r\nThis gets quite ugly in code that uses units of measure heavily.",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-04-25T11:41:00",
                "Content": "printf could even take advantage of the presence of the measure. We could imagine something like:\r\n[<Measure>]\r\n[<MeasurePrintFormat(\" meters\")>]\r\ntype meter\r\nlet distance = 3<meter>\r\nprintfn \"The distance is %d\" distance // Prints: The distance is 3 meters"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-10T10:59:00",
                "Content": "An implementation of this feature has now been submitted at: https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7107"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:10:00",
                "Content": "This was definitely needed. I love Loic's idea of being able to specify the print format of measures."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This work has now been completed for the “fsharp4” branch (submitted, reviewed and committed)\r\nhttps://visualfsharp.codeplex.com/SourceControl/changeset/aa7e945db107d0baf8af8d39c2d82185213c2796\r\nThanks\r\nDon Syme, current BDFL for F# Language Design"
        }
    },
    "5761691": {
        "Number": "5761691",
        "Submitter": "john palmer",
        "Submitted": "2014-04-12T00:00:00",
        "Title": "Disallow constants on the left hand side of a let binding",
        "Text": "Currently, the following code is valid\r\nlet 1 = 1\r\nThis will compile (and produce a warning) and is fine at run time.\r\nEven more confusingly, this will compile\r\nlet 1 = 2\r\nbut it will fail at run time with a match failure exception.\r\nThe reason for this behavior is that currently the left hand side of the `let` can be anything used in a `match`. In the case of `match`, allowing constants makes sense, but for let this makes no sense.\r\nAccording to Don, apparently some people write\r\nlet () = ...\r\ninstead of\r\n\r\ndo ....\r\nso it might be possible to allow the unit literal, but not say int or string.\r\nThis will actually require a change to the spec, but it is relatively minor",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Keith Battocchi",
                "Submitted": "2014-04-14T23:27:00",
                "Content": "This would be a breaking change, and the code you'd outlaw is reasonable (if not idiomatic) as a shorthand for asserting that a value is known. You say that the current behavior is confusing, but has anyone ever used it mistakenly? I don't see any real benefit to disallowing it."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-04-24T15:19:00",
                "Content": "I think the current behaviour of throwing a warning is sufficient. Keeping consistency (ie. `let` behaves exactly like `match`) is more important IMO."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-24T20:04:00",
                "Content": "I don't know why anybody would write `let () = expr` when they could more idiomatically write `let _ = expr`..."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-24T20:08:00",
                "Content": "I don't know why anybody would write `let () = expr` when they could more idiomatically write `let _ = expr`...\r\nAs to keeping syntactic similarity between let and match, I think that's conceptually baseless. There's no semantic relationship between them, AFAICT."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-04-25T11:36:00",
                "Content": "There is a semantic relationship between let and match:\r\nlet <pattern> = x in y\r\nis equivalent to\r\nmatch x with <pattern> -> y\r\nAs for `let ()` vs `let _`, the former makes it explicit that the type of `expr` is unit, whereas the latter leaves a doubt as to whether we're ignoring a value that could be useful. But anyway `do` does it just as well; I suspect people only use `let ()` because they come from OCaml where you can't use `do` for this purpose."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "In my view, the warning is sufficient, as discussed above.\r\nDeclining this for now to recycle votes.\r\nThanks\r\nDon Syme"
        }
    },
    "5762135": {
        "Number": "5762135",
        "Submitter": "exercitus vir",
        "Submitted": "2014-04-12T00:00:00",
        "Title": "Support for type classes or implicits",
        "Text": "(Updated the suggestion to \"type classes or implicits\", and edited it)\r\nPlease add support for type classes or implicits.\r\nCurrently, it's possible to hack type classes into F# using statically resolved type parameters and operators, but it is really ugly and not easily extensible.\r\nI'd like to see something similar to an interface declaration:\r\nclass Mappable =\r\nabstract map : ('a -> 'b) -> 'm<'a> -> 'm<'b>\r\nExisting types could then be made instances of a type classes by writing them as type extensions:\r\ntype Seq with\r\nclass Mappable with\r\nmember map = Seq.map\r\ntype Option with\r\nclass Mappable with\r\nmember map = Option.map\r\nI know that the 'class' keyword could be confusing for OO-folks but I could not come up with a better keyword for a type class but since 'class' is not used in F# anyway, this is probably less of a problem.",
        "Votes": 391,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-13T13:13:00",
                "Content": "I wouldn't say it's currently a hack; it's just how it's done. But, I think something like this would have potential if we can figure out what the actual benefits are and how do to design it in a way without confusing anyone.\r\nMore info: http://www.infoq.com/interviews/F-Sharp-Don-Syme\r\nNumber 6 shows Don talking about type classes."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-04-15T06:35:00",
                "Content": "Currently, it's definitely a hack. It's not extensible, you need to overload unused operators and F# Interactive has problems with scripts that depend on type classes (requires a restart of the session each time its run). Check this for more information on hacking type classes in F#: http://www.nut-cracker.com.ar/index.php/typeclasses-for-fsharp"
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-04-15T16:07:00",
                "Content": "Really good post about it. Thanks for the link.\r\nIt definitely feels like a hack if you try to make it behave exactly like Haskell."
            },
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-04-18T03:10:00",
                "Content": "Whilst, I would love to see this, I think for it be actually useful, we need higher-kinded polymorphism. As it stands now, even if you were able to define type classes, your Mappable would not compile, because 'm<'a> cannot be expressed with the .net type system.\r\nThe technique to simulate type classes has actually evolved somewhat and is _slightly_ less hacky now. E.g. you no longer need a special operator, etc. https://github.com/gmpl/FsControl"
            },
            {
                "Submitter": "Gusty",
                "Submitted": "2014-05-13T04:43:00",
                "Content": "\"...It's not extensible\" It is extensible, just orphan instances are not supported.\r\n\"...you need to overload unused operators\" this was due to a bug in F# parser, since the introduction of F# 3.0 this is not longer required.\r\nRegarding the script issue, I really don't get it, could you possible open an issue in https://github.com/gmpl/FsControl/issues describing this problem?\r\nI personally think F# can add Typeclass support requiring inline functions instead of support at the CLR Level. The same applies to Higher Kinds.\r\nSo the argument \"this is a suggestion for the CLR team\" is not valid, at least that's not what I'm suggesting.\r\nTo avoid the problem Don Syme mentions in the video, just keep ignoring extensions methods in overload resolution and create a \"prelude\" for existing types (that's the goal of FsControl)."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-06-23T10:30:00",
                "Content": "Daniel and Gusty,\r\nI was not talking about FsControl and I have not tried FsControl. The script issue occurs when you use the solution presented in http://www.nut-cracker.com.ar/index.php/typeclasses-for-fsharp\r\nI personally do not care about support at the CLR level. It would already be great if it was an F#-only solution like units of measure and statically resolved type parameters."
            },
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2014-06-25T12:32:00",
                "Content": "One possible keyword might be\r\ntype class Mappable = ...\r\nThat reads well and doesn't introduce any new reserved words. It does introduce ambiguity into the grammar, though."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-07T06:22:00",
                "Content": "I'd like to point people to the two talks about implicits at the ML workshop to get a feeling for implicits and type classes in a mixed OO/FP language, or in an ML-class language.\r\nAny design for implicits in F# would differ substantially from these though.\r\nhttp://www.youtube.com/watch?v=3wVUXTd4WNc\r\nhttp://www.youtube.com/watch?v=--mrQSd6eas"
            },
            {
                "Submitter": "David Ellis",
                "Submitted": "2014-10-27T16:13:00",
                "Content": "I think this is the biggest missing piece to F#. F# needs some kind of support for ad-hoc polymorphism. Haskell has type classes and clojure has protocols. F# needs type classes. If I could use all my votes on this, I would."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-11-07T05:50:00",
                "Content": "I was not asking for implicits originally because I am not a big fan of implicits. Implicits can be abused to make code less type safe (e.g. converting floats to ints). They also feel hacky to me if you only want is type classes. Adapting types (implicits in Skala) is also less efficient that calling the functions directly (type classes in Haskell).\r\nI would prefer pure type classes and you could leverage the member constraints implementation of F# for a clean implementation of type classes in F#."
            },
            {
                "Submitter": "Gusty",
                "Submitted": "2014-11-19T16:26:00",
                "Content": "I know you were not talking about FsControl (http://github.com/gmpl/FsControl) but in the post you mentioned (now moved to http://nut-cracker.azurewebsites.net/typeclasses-for-fsharp) I described a technique which inspired me later to develop FsControl, which runs in F# 3.0 so you don't need to use operators at all. Support for this technique (or similar) at the language level (not CLR) will be nice."
            },
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-06-07T05:47:00",
                "Content": "What about implementation similar to type providers? For each parameter annotated with [<Witness>] attribute where the argument is not given explicitly in the code the compiler would call all witness providers in the scope to generate the argument. If only single witness is generated then this witness becomes the argument otherwise it's an error.\r\nAdditionally if there is a single value in the scope which can be used as the argument then it is used as the argument and witness providers are not used."
            },
            {
                "Submitter": "Kurt",
                "Submitted": "2015-07-06T02:58:00",
                "Content": "I haven't given this any votes because what I've missed is some sort of retro-active interface implementation, like is possible with protocols in Clojure and recently swift. So I voted for this one instead:\r\n[/ideas/suggestion-5665042-allow-extension-interfaces](/ideas/suggestion-5665042-allow-extension-interfaces.md)\r\nbecause it is more focused.\r\nTypeclasses solve that problem but protocols seems to me like a solution that is closer to the existing design space of F# (i.e. a functional first language with OO concepts like subtyping). Typeclasses have many extensions - functional dependencies, overlapping instances, etc that are essentially research problems. What happens if you use two libraries that each instantiate the same typeclass for the same type in a different way? And how do typeclasses work with subtyping?\r\nFinally proposing an idea for A or B (even if A and B are related) draws votes away from more focused suggestions. (e.g. this suggestion has something for everyone so it's not clear what I'm voting for here. Even the original poster commented they don't really want implicits...)"
            },
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-10-19T16:15:00",
                "Content": "> What happens if you use two libraries that each instantiate the same typeclass for the same type in a different way?\r\n@Kurt Doesn't this problem exist with protocols too? What should happen when two different assemblies implement the same protocol for the same type in a different way?\r\nAFAIK in Haskell this leads to failure when linking. In Scala this is resolved by scoping rules for implicits (which is IMO better than Haskell).\r\n> And how do typeclasses work with subtyping?\r\nThis could be derived from implicits."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:45:00",
                "Content": "See also\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/6343928-allow-naming-of-member-constraints\r\nThese various features tug in different incompatible directions."
            },
            {
                "Submitter": "bleis-tift",
                "Submitted": "2016-03-02T18:18:00",
                "Content": "OCaml way: http://www.lpw25.net/ml2014.pdf"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5769706": {
        "Number": "5769706",
        "Submitter": "Anonymous",
        "Submitted": "2014-04-13T00:00:00",
        "Title": "The pattern name of Active Patterns can duplicate define",
        "Text": "When input parameters different from each other, the pattern name of Active Patterns can duplicate define, It will be cool as below.\r\n[<AutoOpen>]\r\nmodule ActiveModule=\r\nlet (|HasError|HasNotError|) (input:QueryResult)=\r\nif input.HasError then HasError (input:>ResultBase)\r\nelse HasNotError (input.ResultData)\r\nlet (|HasError|HasNotError|) (input: ExecuteResult) =\r\nif input.HasError then HasError (input:>ResultBase)\r\nelse HasNotError input",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "Realistically, we’re not going to add this to the active pattern feature.\r\nType-directed overloading of this kind doesn’t fit well with the feature.\r\nIf active patterns could be defined on objects as members we might consider adding type-directed overloading like this.\r\nDeclining this for now to recycle votes.\r\nDon Syme"
        }
    },
    "5810569": {
        "Number": "5810569",
        "Submitter": "Radek Micek",
        "Submitted": "2014-04-21T00:00:00",
        "Title": "Add support for implicit parameters",
        "Text": "Implicit parameters in Scala are used to simulate type classes or to pass singleton values (eg. database connection) to functions without explicitly writing them.\r\nWe will need: syntax to mark parameters as implicit, syntax to mark values eligible for use as implicit arguments and syntax to call functions with implicit arguments written explicitly. Additionally we will need to invent scoping rules for implicit values.\r\nPros: It can make F# programs more modular and it can nicely play with other .NET languages (eg. they will see parameter with attribute `Implicit`).\r\nCons: It can make programs harder to read.",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-05-03T12:13:00",
                "Content": "I actually think that the best way to go if we want a typeclass/implicit-like feature is to have it show up in the F# language as type classes, and be imlemented in .NET the way you suggest."
            },
            {
                "Submitter": "Nelak",
                "Submitted": "2014-06-20T15:25:00",
                "Content": "There's nothing avoiding writing a type with an op_implicit member, also doing the implicit conversion is possible if you do something like what Thomas describes here:\r\nhttp://stackoverflow.com/questions/10719770/is-there-anyway-to-use-c-sharp-implicit-operators-from-f\r\nI tried to take the concepts a little bit further by implementing something similar with a computation builder a while ago. This seems to play nice with the language but got I got stuck trying to implement ctor implicit casting and haven't been able to continue investigating it for a while, if you are interested you can take a look at it here:\r\nhttps://github.com/nelak/FSharp.Implicit"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "This is now a duplicate of [/ideas/suggestion-5762135-support-for-type-classes-or-implicits](/ideas/suggestion-5762135-support-for-type-classes-or-implicits.md)"
        }
    },
    "5810888": {
        "Number": "5810888",
        "Submitter": "Eduardo Cavazos",
        "Submitted": "2014-04-21T00:00:00",
        "Title": "add method cascades",
        "Text": "Method cascades as implemented in Dart are described here:\r\nhttp://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-24T13:31:00",
                "Content": "Oppose. Alternative proposal - http://fslang.uservoice.com/forums/245727-f-language/suggestions/5827477-implement-a-more-idiomatic-flow-syntax"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T05:28:00",
                "Content": "Looking at the Dart syntax doesn't make me think this feature is appropriate for F#. I'm inclined to decline this."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declined per my comment\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "5821261": {
        "Number": "5821261",
        "Submitter": "Christoph Rüegg",
        "Submitted": "2014-04-23T00:00:00",
        "Title": "FSI #I directive to add path to process path environment variable",
        "Text": "If a managed assembly that uses native DLLs with p/invoke is referenced in F# Interactive using #r and #I directives, using them may fail with a DllNotFoundException even if the native assembly is in the same folder as the managed one and the folder has been included using the #I directive. Note that it is not possible to reference native DLLs explicitly in .Net.\r\nSuggestion: make the #I directive automatically add the specified path also to the process-local Path environment variable, this way it would help not only resolving managed but also native assemblies.\r\nWindows only; loading libraries is quite different in Linux.\r\nOriginal ticket with more details: https://github.com/fsharp/fsharp/issues/164",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:44:00",
                "Content": "It seems you can work around this by adding to the path manually. I think I would prefer to keep that as the solution rather than making implicit changes to the path."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion! Declining per my comment below.\r\nDon Syme, F# Language Evolution"
        }
    },
    "5823074": {
        "Number": "5823074",
        "Submitter": "Christoph Rüegg",
        "Submitted": "2014-04-23T00:00:00",
        "Title": "Stronger type directed conversion from functions to .Net delegates",
        "Text": "It seems in some cases type directed conversion from functions to .Net Func<_,_> delegates only works if the called method has overloads. It would be convenient if it worked the same way for methods without overloads as well.\r\nFor example:\r\nopen System.Linq\r\nlet even n = n % 2 = 0\r\nlet seqA = seq { 0..2..10 }\r\nseqA.Where(even) // works\r\nseqA.All(even) // does not work\r\nhttp://stackoverflow.com/questions/23256355/passing-f-function-to-ienumerable-where-vs-ienumerable-all\r\nhttp://stackoverflow.com/questions/12933366/f-func-type-inference-difference-between-seq-and-pseq-todictionary",
        "Votes": 25,
        "Comments": [
            {
                "Submitter": "Christoph Rüegg",
                "Submitted": "2014-04-23T18:01:00",
                "Content": "Workarounds:\r\nseqA.All(System.Func<_,_>(even))\r\nseqA.All(fun x -> even x)"
            },
            {
                "Submitter": "Albert-Jan",
                "Submitted": "2014-08-01T13:06:00",
                "Content": "This does work:\r\neven |> seqA.all"
            },
            {
                "Submitter": "Daniel Ferreira Monteiro Alves",
                "Submitted": "2015-04-26T13:31:00",
                "Content": "Why not use the .NET native Action and Func and other delegates unstead of the only F# specific closure? Or at least, allow some implicit convertion here."
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "5827517": {
        "Number": "5827517",
        "Submitter": "Bryan Edds",
        "Submitted": "2014-04-24T00:00:00",
        "Title": "Implement a more idiomatic Flow Syntax",
        "Text": "F#'s current FlowSyntax().WhitspaceHack() should be displaced with a more ML-style syntax -\r\n// Multi-line usage.\r\n// Please pardon the underlines, the webpage is eating my space chars...\r\nwith person do\r\n____SetName \"Joe\"\r\n____SetAge 35\r\n____SetHeight 6.1\r\n// Single-line usage.\r\nwith person do SetName \"Joe\"; SetAge 35; SetHeight 6.1\r\nOf course, the actual keyword `with` could probably not be used since it's already pretty overloaded, but coming up with an alternative would be easy.\r\nVisually tracking where the current F# flow-syntax hack is used is painful, and makes code formatting very inconsistent (a lot of people just use it everywhere without knowing it has special meaning). () is unit, and should be conventional have white space between it and its previous token.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-04-26T07:19:00",
                "Content": "Addendum:\r\nFor the single-liner, I think an end token might be required -\r\nwith person do SetName \"Joe\"; SetAge 35; SetHeight 6.1 end\r\nOtherwise the last two sections might be ambiguous to parse."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T11:59:00",
                "Content": "For better or worse, removing or deprecating the existing syntax would not be possible at this stage of the language evolution. Adding another alternative syntax probably wouldn't achieve the goals and benefits outlined."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information and discussion welcome"
        }
    },
    "5841349": {
        "Number": "5841349",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-04-27T00:00:00",
        "Title": "Allow provided types to be non-nullable by specifying AllowNullLiteralAttribute(false)",
        "Text": "As we can only generate classes in type providers and not records, it would be at least very useful to be able to tell the compiler to not allow to use the null literal.\r\nCurrently in FSharp.Data, when using the write api for Json and Xml, there's no way to prevent the user to pass null in the constructor of a non-optional parameter, and it would be nice to be able to do that",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-04-27T11:07:00",
                "Content": "I'm thinking about erased type providers here, for generated it's probably not going to be that easy, as they are real classes, but for erased they aren't real classes, so maybe this can be doable"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T11:45:00",
                "Content": "This is a very reasonable request. Although it needs protoyping and testing, I consider it basically approved. Comments and feedback welcome.\r\nI believe the design would simply be\r\n1. Allow the type provider to specify AllowNullLiteralAttribute(false) as a provided attribute of the provided type definition.\r\n2. The onus is on the type provider to make sure the implied non-nullness contract is satisfied.\r\nThanks\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T11:45:00",
                "Content": "I actually have a prototype implementation adjusting TypeNullIsExtraValue (approx code below - this requires some fiddling around putting things in the right compilation order in tastops.fs). I could submit some initial dev testing too. Gustavo, would you be interested in providing review and extra testing for this if i submit it to the F# 4.0 branch?\r\nThanks\r\nDon\r\nlet TypeNullIsExtraValue m g ty =\r\nif isILReferenceTy g ty || isDelegateTy g ty then\r\n// Putting AllowNullLiteralAttribute(false) on an IL or provided type means 'null' can't be used with that type\r\nnot (isAppTy g ty && TryFindTyconRefBoolAttribute g m g.attrib_AllowNullLiteralAttribute (tcrefOfAppTy g ty) = Some(false))\r\nelif TypeNullNever g ty then false\r\nelse\r\n// Putting AllowNullLiteralAttribute(true) on an F# type means 'null' can be used with that type\r\nisAppTy g ty && TryFindTyconRefBoolAttribute g m g.attrib_AllowNullLiteralAttribute (tcrefOfAppTy g ty) = Some(true))"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-06-24T13:09:00",
                "Content": "Yes, I can help test. I like the attribute approach as it allows to have the same code base for F# 3.1 and 4.0, 3.1 will just ignore it, if I got it right"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-06T03:50:00",
                "Content": "In the proposed implementation, other uses are described that mention the use named arguments, will this be expanded upon?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-07T09:55:00",
                "Content": "Hi Dave,\r\nThat comment is really just about an internal implementation detail.\r\nCheers\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-16T10:48:00",
                "Content": "A speclet for this feature is here: https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/NonNullProvidedTypes.md"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "This has been completed for F# 4.0+, see https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/NonNullProvidedTypesDesignAndSpec.md"
        }
    },
    "5881657": {
        "Number": "5881657",
        "Submitter": "Anonymous",
        "Submitted": "2014-05-03T00:00:00",
        "Title": "Sealed member can be 'override' with 'member new' keyword like c#",
        "Text": "C# can do it perfect\r\npublic class ObservableBindingDictionary<TKey, TValue> : ObservableDictionary<TKey, TValue>\r\n{\r\n/// <summary>\r\n/// new if for Hide any implementation\r\n/// </summary>\r\n/// <param name=\"key\"></param>\r\n/// <returns></returns>\r\npublic new TValue this[TKey key]\r\n{\r\nget\r\n{\r\nif (!base.ContainsKey(key))\r\n{\r\nbase.Add(key, default(TValue));\r\nreturn base[key];\r\n}\r\nelse\r\n{\r\nreturn base[key];\r\n}\r\n}\r\nset\r\n{\r\nif (!base.ContainsKey(key)) //Get和Set的处理都是必要的\r\n{\r\nbase.Add(key, value);\r\n}\r\nelse if ((base[key]==null && value!=null) || (base[key]!=null && !(base[key].Equals(value))))\r\n{\r\nbase[key] = value;\r\n}\r\n}\r\n}\r\n}\r\nF# can do it but with warning message 'This new member hides the abstract member...'\r\ntype BindingDictionary<'a,'b when 'a:equality and 'b:equality and 'b:(new:unit->'b)>()=\r\ninherit Generic.Dictionary<'a,'b>()\r\nmember this.Item\r\nwith get key=\r\nif this.ContainsKey key|>not then base.Add (key,new 'b())\r\nbase.[key]\r\nand set key v=\r\nif this.ContainsKey key|>not then base.Add (key,new 'b())\r\nif base.[key]<>v then base.[key]<-v",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining as this is by design in F#"
        }
    },
    "5900625": {
        "Number": "5900625",
        "Submitter": "amazingant",
        "Submitted": "2014-05-08T00:00:00",
        "Title": "Add NameOf operator to follow C#/VB update",
        "Text": "The Roslyn compiler currently (as of 2014-05-08) has a new NameOf operator listed as \"Planned\" for both C# and VB:\r\n(https://roslyn.codeplex.com/wikipage?title=Language%20Feature%20Status&referringTitle=Documentation)\r\nPending its arrival there, it would be awesome to get something similar in F# as well.",
        "Votes": 126,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-14T12:35:00",
                "Content": "I agree this should be added to F#.\r\nThe exact design needs nailing down. A special library intrinsic \"val nameof : 'T -> string\" looks appropriate, where \"T\" can be either an expression, a first-class use of a method or a typeof<...> expression may be simplest. The check.fs and opt.fs in the F# compiler would then treat this construct as special, doing a compile-time evaluation.\r\nhttps://gist.github.com/forki/7c8ef4c3126c953630fb shows the kind of place where this is used in C#."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2014-11-15T06:24:00",
                "Content": "I have a prototype implementation. Will send a first pull request for discussion soon."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2014-11-15T13:30:00",
                "Content": "Pull request is at https://visualfsharp.codeplex.com/SourceControl/network/forks/forki/fsharp/contribution/7698"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:06:00",
                "Content": "This is adding the name at compile-time right?"
            },
            {
                "Submitter": "zjv",
                "Submitted": "2015-12-01T03:35:00",
                "Content": "Would really like this feature. Currently I have some ugly code with a hardcoded string in F# which I would like to improve. A nameof would make the code much safer against refactorings.\r\n[<ReflectedDefinition(true)>]\r\nlet foo (x) = ...\r\nlet fooType = foo.GetType().DeclaringType.GetMethod(\"foo\")\r\nlet fooExpr = Expr.TryGetReflectedDefinition(fooType)"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-02-03T13:55:00",
                "Content": "PR at https://github.com/Microsoft/visualfsharp/pull/908"
            },
            {
                "Submitter": "Yemi Bedu",
                "Submitted": "2016-05-27T10:59:00",
                "Content": "[/ideas/suggestion-5674940-implement-syntactic-macros](/ideas/suggestion-5674940-implement-syntactic-macros.md)\r\nAllowing my suggested function extension or macros would allow this implementation to be trivial. I explain this again below:\r\n-----\r\nSo what would be nice is to extend the resolution of function parameters so that they wrap their parameters to be quotation expressions if it is a macro definition. Otherwise it would pass in the direct object value as normal. We can introduce a new keyword to make the distinction.\r\nThe definition of it could look like:\r\n// def is a let that will pass in arguments as a Quotations.Expr\r\ndef nameof (arg:Quotations.Expr) : string = match arg with | Quotations.Patterns.Let(v, e1,e2) -> v.Name | expr -> expr.ToString()\r\nlet y = 1\r\nprintfn \"%s\" (nameof y)\r\nThe boxing will just find the most local definition of parameter if it is a variable or wrap the expression directly as <@ expression @>\r\nThis could allow us to use a lot of existing code and framework already in F#"
            }
        ],
        "Status": "started",
        "Response": {
            "Responded": "2016-06-17T00:00:00",
            "Text": "RFC is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1003-nameof-operator.md"
        }
    },
    "5920231": {
        "Number": "5920231",
        "Submitter": "Anonymous",
        "Submitted": "2014-05-13T00:00:00",
        "Title": "Add first class support for lenses and prisms",
        "Text": "Lenses and prisms provide principled support for functional getters and setters. There is a decent amount of machinery that goes into creating them, and that machinery could be added into the language. I am not offering up a recommendation yet, but would love to see some research into how this could be done and F# seems like the language that could really innovate in this space.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T11:50:00",
                "Content": "This is a good research area. However it feels like it should be closed until a more concrete design proposal is available. Otherwise people don't quite know what they are voting on :)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "See comment – a more detailed design proposal is needed to progress this"
        }
    },
    "5926493": {
        "Number": "5926493",
        "Submitter": "knocte",
        "Submitted": "2014-05-14T00:00:00",
        "Title": "Syntax sugar to throw ObjectDisposedException automatically",
        "Text": "I know that F# is not the holy grail that would save us from the nonRAII/ResourceLeaks problems that are common in garbage-collected languages, but at least maybe it can help us cope with them?\r\nI'm now thinking about those pesky times when we need to create an IDisposable object, and then we need to be careful to throw ObjectDisposedException in *every* method and property checking if the object has been disposed already. Doing this manually is very tedious and subject to failure, so having some syntax sugar in F# to do it automatically (so under the hood it generated the typical \"mutable bool disposed\" field, and checks it before every call to any member...). This way it will prevent people going the AOP route, which is usually painful.",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T11:49:00",
                "Content": "My feeling is that it would not be right to special-case this specific functionality in F#. It would have to be a specific use-case of some more general language feature."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-24T00:00:00",
            "Text": "I’m declining this, see the comment.“My feeling is that it would not be right to special-case this specific functionality in F#. It would have to be a specific use-case of some more general language feature”\r\nI’m sympathetic to this kind of proposal: detecting very common cases of idioms and adding support for them in the language, but the solutions to the problem have to be very general purpose with broad applicability.\r\nGeneralizations of the proposal are of interest, as are more examples.\r\nDon Syme, F# Lang Design"
        }
    },
    "5927125": {
        "Number": "5927125",
        "Submitter": "Gusty",
        "Submitted": "2014-05-14T00:00:00",
        "Title": "Allow implementation of generic methods with constraints of the form 'T :> 'U",
        "Text": "Currently this is solved as 'a = 'b.\r\nThis limitation does not exists in C# and it makes impossible to interact with some existing libraries, as in this case http://stackoverflow.com/questions/23643989/is-it-possible-to-implement-the-idbsett-interface-in-f\r\nThis will also allow to work around F#'s lack of generic (co/contra)-variance.",
        "Votes": 136,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-18T14:30:00",
                "Content": "Could Don Syme or someone from the F# team comment on whether this can be realized?"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2015-07-13T09:05:00",
                "Content": "Maybe you can tweet him with this. But completed features have a very low vote count generally: https://fslang.uservoice.com/forums/245727-f-language/status/1225916. Possibly suggested by the core team."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2015-07-13T09:05:00",
                "Content": "Twitter link is: https://twitter.com/dsyme"
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-02-11T06:35:00",
                "Content": "What makes you think they were suggested by the core team? You can see the names of people that have raised each of the completed features."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-05-26T13:35:00",
                "Content": "Yes please"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "5933485": {
        "Number": "5933485",
        "Submitter": "Umut Karakoç",
        "Submitted": "2014-05-16T00:00:00",
        "Title": "full Windows RT (windows 8 and Windows Phone 8) project support.",
        "Text": "",
        "Votes": 19,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "Because WinRT is a Windows-only, Microsoft-only interoperabiliity feature, it seems this suggestion is best categorized as a Microsoft Visual F# Tools team support for F#.\r\nThis user voice is about the F# language itself.\r\nPlease move this suggestion to the Visual F# Tools user voice here: http://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools\r\nDon Syme"
        }
    },
    "5952264": {
        "Number": "5952264",
        "Submitter": "Gulshanur Rahman",
        "Submitted": "2014-05-21T00:00:00",
        "Title": "Provide shortcut for type annotation of Lists",
        "Text": "I suggest to provide a shortcut syntax ( `[<typname>]` ) for type annotation of F# Lists. Instead of this-\r\nlet upto (a:int): int list = [1..a]\r\nI want to have-\r\nlet upto (a:int): [int] = [1..a]\r\nThen list of list of int will be `[[int]]` instead of `int list list`. When type gets complex, we tend to use more brackets for clarity like- `(int list) list`. This proposed annotation should reduce some verbosity maintaining clarity. As in F#, `[..]` is already associated with lists, I am for using this in type also.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T05:23:00",
                "Content": "My feeling is that this is not appropriate for F#, given the existiing availability of \"int[]\" for arrays."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declining per my comment\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "5975011": {
        "Number": "5975011",
        "Submitter": "Patrick Q",
        "Submitted": "2014-05-27T00:00:00",
        "Title": "Add String.filter",
        "Text": "The absence of a filter function from the String module is a major deficit for the usefulness of the String module. It already supports map, mapi, iter and iteri, so it seems quite strange that filter is missing. Not having a filter function means that we have to turn the string into an array (or seq/list), do the filtering and then convert back to a string, resulting in complicated and convoluted code.\r\nAs map, mapi, iter and iteri already exist it would seem that most of the core machinery already exists, so it shouldn't be too difficult to add a filter function.\r\nI would like add that a filter function would actually be more useful for string processing that map and iter, so it's absence is all the more puzzling.",
        "Votes": 4,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This work has been completed for the “fsharp4” branch, see https://visualfsharp.codeplex.com/SourceControl/network/forks/marten_range/visualfsharp/contribution/7255\r\nThanks\r\nDon Syme, current BDFL for F# Language Design"
        }
    },
    "5975797": {
        "Number": "5975797",
        "Submitter": "Tomas Petricek",
        "Submitted": "2014-05-27T00:00:00",
        "Title": "Allow implicit quotation of expressions used as a method arguments",
        "Text": "In many data science scenarios, if a method can \"see\" what expression the caller passed as an argument. For example in R, you can write:\r\nprices = c(10.0, 11.0, 9.0)\r\ndays = (1, 2, 3)\r\nplot(days, prices)\r\nThis shows a chart where the X and Y axes are labelled as \"days\" and \"prices\", because the plot function can look at the expression passed as an argument. Similarly, we could automatically name newly added series to a data frame, etc.\r\nOne way to implement this would be to allow the `ReflectedDefinition` attribute on parameters and pass a hidden quotation as a next argument. For example, we could write the declaration as:\r\ntype Chart =\r\nstatic member Plot([<ReflectedDefinition>] values:seq<float>, expr:Expr<seq<float>>) = (...)\r\nAnd call it by writing:\r\nlet prices = [1.0; 2.0; 3.0]\r\nChart.Plot(prices)\r\nThe call would be translated to something like:\r\nChart.Plot(prices, <@@ prices @@>)\r\nThis also requires extending the quotations to actually capture names of local let-bound values (so that the quotation contains the name in some form).",
        "Votes": 27,
        "Comments": [
            {
                "Submitter": "Howard Mansell",
                "Submitted": "2014-05-28T07:16:00",
                "Content": "It should also be possible to do this with the param-array argument, so one can pass some arbitrary number of arguments. This would allow (for example) the construction of Deedle Frames with columns named according to the expression passed in.\r\nAlso, note that if I call something like plot(xs, ys ^ 2) this allows the axes of the plot to be labelled with the textual form of the expression, just as they do in R. So this is strictly more powerful that the Python kwargs feature.\r\nIn terms of implementation/syntax, I think having two separate formal parameters for each argument is strange. It would be better to pass some type that wraps up the whole thing.\r\nBTW a string version of the expression covers all the use cases I think of, though some AST-based approach would presumably be generally more powerful."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T10:37:00",
                "Content": "I am strongly sympathetic to this design proposal consider it basically \"approved\" though a prototype is needed.\r\nAs Tomas mentions one main problem is a limitation in F# quotations w.r.t. local values. When given this code:\r\nlet f() =\r\nlet prices = [1.0; 2.0]\r\nChart.Plot(prices, <@@ prices @@>)\r\nthen the quotation <@@ prices @@> becomes an Expr.Value quotation node containing the value [1.0;2.0] value but no trace of the name \"prices\". This means that the feature would require some kind of extension to F# quotations to properly propagate metadata\r\nOne such extension may be to have a new node Expr.NamedValue(\"prices\", <value>, <type>) which is also successfully matched by the existing Quotations.Patterns.Value active pattern (to avoid breaking backwards compatibility). This would be the first time that extensions like this to the set of quotation nodes have been used, but I believe it is sound and compatible.\r\nLibraries which used this feature would pick up a dependency on the corresponding FSharp.Core 4.x\r\nCheers\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T11:10:00",
                "Content": "Here's an alternative design (in addition to the need for NamedLocalValue):\r\nAt the declaration site we just have one argument with the following very natural form:\r\ntype Chart =\r\nstatic member Plot([<ReflectedDefinition>] values:Expr<X>) = (...)\r\nWith an implicit conversion from X --> Expr<X> at the callsite. In this second design, the quotation node generated would be of a new kind that would match both Expr.Value plus other expression tree nodes. Let's say this new kind of node is created by Expr.ReflectedValue(T, Expr).\r\nSo for\r\nChart.Plot(f x + f y)\r\nthe caller becomes:\r\nChart.Plot(Expr.ReflectedValue(f x + f y, <@ f x + f y @>))\r\nand the quotation value Q received by Chart.Plot matches both:\r\nmatch Q with\r\n| Expr.Value(v, ty) --> // v = f x + f y\r\nand\r\nmatch Q with\r\n| Expr.Call(...) // the addition call\r\nThe point is, the quotation node contains the value \"v\".\r\nThere are a lot of advantages to design (2) - there is no insertion of an additional implicit argument (which might confuse IDE tools I suppose), there are no new public types in the F# library design, and the rules for the implicit coercion can be made the same as other implicit conversions to delegates or Expression<T>.\r\nThe minimal overall library additions for option (2) would be:\r\n/// Create a new quotation expression that matches the same set of active patterns as\r\n/// 'expr' except it also matches the Expr.Value active pattern, returning value 'value'\r\n/// and type typeof<T>\r\nstatic method Expr.ReflectedValue : value: T * expr: Expr<T> --> Expr<T>\r\n/// Create a new node that matches both the NamedLocalValue and Value active patterns\r\nstatic method Expr.NamedLocalValue : T * Expr --> Expr\r\n/// Match a NamedLocalValue node\r\nactive pattern (|NamedLocalValue|_|) : Expr<T> --> (string * T * Type) option"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-30T12:27:00",
                "Content": "I have submitted a design here:https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7638\r\nThe refined design is similar to the one below. At the declaration site we have:\r\nstatic member Plot([<ReflectedDefinition>] values:Expr<X>) = (...)\r\nWith an implicit conversion from X --> <@ X @> at the callsite. So for\r\nChart.Plot(f x + f y)\r\nthe caller becomes:\r\nChart.Plot(<@ f x + f y @>)\r\nAdditionally, the method can declare that it wants both the quotation AND the evaluation of the expression, by giving \"true\" as the \"withValue\" argument of the ReflectedDefinitionAttribute.\r\nstatic member Plot([<ReflectedDefinition(true)>] values:Expr<X>) = (...)\r\nQuotations that capture named local values can now look at the captured name by matching ValueWithName, so\r\nlet f x = <@ x @>\r\nThis means that\r\nmatch (f 3) with\r\n| ValueWithName(obj,ty,\"x\") -> true\r\n| _ -> false\r\nreturns 'true'\r\nThe named local values embedded in the quotation are irrelevant for the purposes of quotation equality."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-16T09:18:00",
                "Content": "A speclet for this feature has been added here: https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/AutoQuotation.md"
            },
            {
                "Submitter": "Yemi Bedu",
                "Submitted": "2016-05-29T03:45:00",
                "Content": "Hello,\r\nSo I have the following and can not pass in a quotation as the parameter:\r\ntype NameOf =\r\nstatic member NameOf([<ReflectedDefinition>] q:Quotations.Expr<'T>) =\r\nmatch q with\r\n| Quotations.Patterns.Call(a, b, c) -> sprintf \"%s %A\" b.Name c\r\n| Quotations.Patterns.Let(a, b, c) -> a.Name\r\n| Quotations.Patterns.ValueWithName(a, b, c) -> c\r\n| expr -> expr.ToString()\r\n// ----- later on -----\r\nlet v = 1 + 1\r\nlet w = \"2\"\r\nlet x = <@ 1 + 1@>\r\nprintfn \"%s\" (NameOf.NameOf (1 + 1) )\r\nprintfn \"%s\" (NameOf.NameOf v)\r\nprintfn \"%s\" (NameOf.NameOf w)\r\nprintfn \"%s\" (NameOf.NameOf x) // will not compile. it will accept %x but does not give ValueWithName\r\nError FS0193: Type constraint mismatch. The type\r\nQuotations.Expr<int>\r\nis not compatible with type\r\nQuotations.Expr<Quotations.Expr<int>>\r\nThe type 'Quotations.Expr<int>' does not match the type 'int' (FS0193)\r\nCan you extend this feature to include Quotations? Thank you. Good day."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Completed in F# 4.0"
        }
    },
    "5975840": {
        "Number": "5975840",
        "Submitter": "Tomas Petricek",
        "Submitted": "2014-05-27T00:00:00",
        "Title": "Allow \"params\" dictionaries as method arguments",
        "Text": "When interoperating with languages that are more dynamic than F# (like Python, Matlab or R), we can often get the list of available methods/functions, but we cannot always get the names and types of parameters. For example, in R provider, you sometimes have to write:\r\nnamedParams [ (\"xval\", days), (\"yval\", prices), (\"another\", box 1) ]\r\n|> R.plot\r\nIt would be nice if I could put the \"Params\" attribute on a \"IDictionary<string, 'T>\" and let the compiler provide all additional named parameters as a dictionary:\r\nR.plot(xval=days, yval=prices, another=1)\r\nThis would have other uses - for example, when creating a Deedle data frame, you need to specify names of columns. We have a custom operator and function for that:\r\nframe [ \"prices\" => prices; \"days\" => days ]\r\nBut with the new feature, we could let you write, for example:\r\nFrame.ofColumns(prices = [...], days, = [...])\r\nThis could really be done just by adding [Params] attribute to an IDicitionary parameter. To support the R provider case, this needs to work in type providers too.",
        "Votes": 30,
        "Comments": [
            {
                "Submitter": "Tomas Petricek",
                "Submitted": "2014-05-27T12:02:00",
                "Content": "Just for a reference, I imagine that the definition would look like this:\r\ntype R =\r\nstatic member plot([<Params>] args:IDictionary<string, obj>) = (...)\r\nI suppose one subtle thing here is to make sure that the type information propagates correctly through the type inference - so when you define it as taking `obj`, the arguments will need to be boxed, but when you define the dictionary as containing just `float` values, the optional arguments would presumably be restricted to floats."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-05-27T14:12:00",
                "Content": "It also should be noted that IDictionary does not have an ordering while the arguments do. It would be ideal to capture this information."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T11:46:00",
                "Content": "I'm generally in favour of addressing this for F# 4.0, if a technically feasible design is proposed, analyzed in detail, and an implementation+testing provided by the F# Community.\r\nTo get more concrete, what's being proposed is presumably a new attribute ParamDictionary used like this:\r\nopen System\r\nopen System.Collections.Generic\r\nopen System.Runtime.CompilerServices\r\ntype C() =\r\nstatic member DoSomething1([<ParamArray>] args: 'T[]) = ()\r\nstatic member DoSomething2([<ParamDictionary>] args: IDictionary<string,obj>) = ()\r\nC.DoSomething2(arg1=1, arg2=3)\r\nIs that correct?\r\nImplementing this is non-trivial (Tomas mentions some reasons why) and libraries would pick up a dependency on the updated FSharp.Core containing the attribute."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-06T09:42:00",
                "Content": "I don't know about the user-facing side of things (i.e., how to expose this in the language), but on the compiled side of things, you could represent this using the usual [<ParamArray>] attribute with a KeyValuePair<string,obj>[]-typed parameter. That would avoid the need for consuming code to take a dependency on FSharp.Core and it would preserve parameter ordering (as Rick mentioned). Although this doesn't actually use IDictionary<_,_>, it doesn't seem likely that most real-world uses are going to pass in more than, say, 20-30 arguments, so lookups can use a linear scan of the argument array to find a matching k-v pair without too much performance overhead."
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-06T09:48:00",
                "Content": "Another way to implement this (besides what I mentioned below) would be to have a [<ParamDictionary>] attribute and have the F# compiler compile that parameter into an ExpandoObject. That would interop a bit more closely with C# dynamic and the DLR, but the price is that it wouldn't work if targeting a .NET Framework earlier than 4.0."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "Updating to planned to indicate this is approved in general terms. A detailed design and implementation would be needed.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "5980924": {
        "Number": "5980924",
        "Submitter": "Tomas Petricek",
        "Submitted": "2014-05-28T00:00:00",
        "Title": "Allow specifying subset of type arguments explicitly",
        "Text": "Say we have a generic type Frame<TRow, TColumn>. When using instance methods of the frame, it is possible to write a generic method that takes a single additional type parameter - for example, to get a column as a specific type:\r\nframe.GetColumn<float>(\"Value\")\r\nHowever, doing the same thing using module and function is not possible, because the corresponding `getCol` function requires three type arguments (TRow, TCol and the additional one):\r\nframe |> Frame.getCol<_, _, float> \"Value\"\r\nIt would be nice if F# had some mechanism that would allow specifying only subset of the type parameters. For example:\r\nlet getCol<[<RequiresExplicitTypeArguments>] 'T, 'TCol, 'TRow> frame = (...)\r\nAnd then I could write just:\r\nframe |> Frame.getCol<float> \"Value\"\r\nInterestingly, this is also problem for extension methods. When you define a C#-style extension method for a generic type like frame, it also has three type arguments and it is impossible to call it with just a single type argument.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T11:38:00",
                "Content": "Having seen the impact this problem has on Deedle, I'm in favour of addressing it for F# 4.0. I will mark it \"approved\" (using the label \"planned\") as a result, though the details need to be worked out.\r\nAnother possible declaration syntax is this:\r\nlet getCol< 'T, 'TCol, [<OptionalArgument>] 'TRow > frame = ()\r\nor this\r\nlet getCol< 'T, 'TCol, 'TRow? > frame = ()\r\nThe former has the downside that it could only be used with an updated FSharp.Core since the Microsoft.FSharp.Core.OptionalAttribute would need to be updated with a flag to say it's permissible to use the attribute here (or the F# 4.0 compiler would need to be adjusted to allow the use of this attribute even if the flag has not been updated, e.g. when using FSharp.Core 4.3.0.0 with F# 4.0 compiler)\r\nWe should also now consider what the precise language/spec rules should be. Please list questions to be addressed below."
            },
            {
                "Submitter": "Gusty",
                "Submitted": "2015-11-08T02:12:00",
                "Content": "For completeness it will be nice to allow to use the underscores in the declaration as well.\r\nlet func<_> = ()\r\nCurrently this is allowed: let func< 'T, .. > = ()\r\nSo, this should be allowed too: let func< .. > = ()"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "Updating to planned to indicate this is approved in general terms. A detailed design and implementation would be needed.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6002107": {
        "Number": "6002107",
        "Submitter": "Robert Jeppesen",
        "Submitted": "2014-06-02T00:00:00",
        "Title": "Add string interpolation to println syntax (from Swift)",
        "Text": "The new language from Apple, Swift has a really nice syntax for println:\r\nhttp://en.wikipedia.org/wiki/Swift_(programming_language)\r\nlet people = [\"Anna\": 67, \"Beto\": 8, \"Jack\": 33, \"Sam\": 25]\r\nfor (name, age) in people {\r\nprintln(\"\\(name) is \\(age) years old.\")\r\n}\r\nWe could steal the idea but use % instead of \\ for a better fit. It would also be compatible, and combinable (is that a word?) with existing printfn syntax:\r\nlet name = \"Robert\"\r\nprintfn \"Hi %(name), your age is %d\"\r\nprintfn : int -> string\r\nNaturally there would be compiler errors if name does not exist.",
        "Votes": 179,
        "Comments": [
            {
                "Submitter": "Jarle Stabell",
                "Submitted": "2014-06-02T17:50:00",
                "Content": "I've \"always\" wanted something like this in F#. It feels very old-fashioned having to manually specify the \"types\" in printf in a language with type inference. Also, it's a totally separate, although simple, \"type language\".\r\n(Scala has a much more generic mechanism, perhaps overkill though)."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-06-02T18:19:00",
                "Content": "Related: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5678806-string-interpolation"
            },
            {
                "Submitter": "Marcin Juraszek",
                "Submitted": "2014-06-02T19:21:00",
                "Content": "There is similar idea for C#: http://roslyn.codeplex.com/discussions/540869"
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2014-06-02T21:45:00",
                "Content": "@Marcin: not really. The Roslyn thread is about general string interpolation. This one is a limited application for printf. See my link above for the F# discussion about general string interpolation."
            },
            {
                "Submitter": "Heather Cynede",
                "Submitted": "2014-06-03T01:55:00",
                "Content": "from Nemerle?\r\nhttp://en.wikipedia.org/wiki/Nemerle#String_formatting"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-06-03T04:43:00",
                "Content": "General string interpolation exists in many languages, including Nemerle as you noted Heather. A big inconvenient is that it would require yet another string delimiter (we have 3 already...). This is about having it as an extra *printf format character, which is probably a smaller can of worms to open."
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-06-03T17:57:00",
                "Content": "It's worth noting that in Swift (and Nemerle), these interpolations are expressions, so you can do\r\nprintfn \"The sum is %(a + b)\"\r\nThis would be nice here, but if that raises the amount of work to prohibiting levels, I think it can be skipped."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T09:57:00",
                "Content": "I am very positively predisposed to this feature - at least where only a variable name can be interpolated.\r\nQuestions\r\n- Could you use a long identifer %(name1.name2)? I presume not, but it may be a relatively simple extension to allow this.\r\n- What formatting would be used, e.g. for floating point values. Is it %A? Can you modify formatting specifiers?\r\n- Could you use a mix of %d and %(name) specifiers in a single printf format string? My intuition is to allow this, but if the implementation becomes too complex then to disallow it.\r\nDo other people have detailed questions about the specification and scope of this feature?\r\nNote that I have begun labelling some features as \"approved\" (actually the label is currently called \"planned\", though I think of it as \"approved\"), see https://fslang.uservoice.com/forums/245727-f-language/status/1225914.\r\nLabelling something as \"approved\" is not committing to \"doing\" the feature, but it does mean we would in theory accept implementations (with corresponding testing) of these features into the \"fsharp4\" branch at https://visualfsharp.codeplex.com/.\r\nSo we would ask you to consider implementing this feature and submitting it. The implementation would then flow throughout all delivery vehicles for F#. We would provide lots of assistance to those seeking to implement the feature.\r\nI already labelled a couple of printf suggestions as \"approved\".\r\nIf you disagree with labelling a feature as \"approved\", please argue your case through the User Voice comments, at least initially :)\r\nThanks\r\nDon Syme"
            },
            {
                "Submitter": "bleis-tift",
                "Submitted": "2014-06-20T20:00:00",
                "Content": "FYI, scala has similar feature.\r\nhttp://docs.scala-lang.org/overviews/core/string-interpolation.html"
            },
            {
                "Submitter": "Vladimir Matveev",
                "Submitted": "2014-07-01T17:51:00",
                "Content": "ok, I took a stab on this feature and have a working prototype (https://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary?branch=fsharp4)\r\nbriefly: when analyzing format string compiler splits it into chunks: textblocks and embedded expressions (that are denoted by wrapping them in %()).Then final string that will be passed as a parameter to the constructor of PrintFormat is evaluated as ' string.Concat([| textblock1; expr1; textblock2; expr2... |]) '. All logic that manufactures phantom types remains intact. To evaluate expressions typechecker tries to parse it using provided access point to parser and typecheck it.\r\nPros: implementation is relatively simple, supports both %(expr) and %(d) specifiers, embedded expressions are regular F# expressions so long names or operators inside are not problem.\r\nCons: the entire feature is implemented on the semantic level so purely syntax based goodies will require extra effort to work with it, As an example if syntax highlighting is implemented only based on syntactic information then embedded expressions will be highlighted as a string."
            },
            {
                "Submitter": "Nikita Nemkin",
                "Submitted": "2015-06-02T10:09:00",
                "Content": "Rascal (metaprogramming language) has an amazing string interpolation facility: http://tutor.rascal-mpl.org/Rascal/Expressions/Values/String/String.html\r\nIt works for all strings (not only println argument) and interpolates arbitrary expressions and even basic control structures."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:05:00",
                "Content": "This is awesome."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-09-05T06:02:00",
                "Content": "This feature didn't make it for F# 4.0 due to some lingering concerns about the design. The prototype for this feature can be found here: https://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary/contribution/7063. If you would like to pick up the prototype and take it further please rebase it as a fork of \"master\" of http://github.com/Microsoft/visualfsharp"
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2016-02-01T08:39:00",
                "Content": "Rebased version can be found at https://github.com/Microsoft/visualfsharp/pull/921"
            },
            {
                "Submitter": "Jon Nyman",
                "Submitted": "2016-02-18T10:42:00",
                "Content": "type Person = {name: string; age: int}\r\nlet person = {name = \"Robert\"; age=5}\r\nprintfn \"Hi %(person, A), your age is %(person.age, 5i) with space or age %(person.age) without.\"\r\nprintfn : int -> unit"
            },
            {
                "Submitter": "Jon Nyman",
                "Submitted": "2016-02-18T10:43:00",
                "Content": "or rather\r\nprintfn : unit -> string"
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2016-02-19T05:47:00",
                "Content": "I'd prefer it if this feature isn't limited to printf functions, but applied generally to all string literals, like literals in C# with '$' prefix."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Approved in principle (and has been for a while), please see RFC FS-1001 https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1001-StringInterpolation.md\r\nDon Syme, F# Language Evolution"
        }
    },
    "6023655": {
        "Number": "6023655",
        "Submitter": "Loic Denuziere",
        "Submitted": "2014-06-08T00:00:00",
        "Title": "Allow passing other types of parameters to type providers",
        "Text": "It would be very useful to be able to pass lists, arrays, options, tuples as static parameters to type providers. Something like this:\r\ntype Foo = FooProvider<files = [\"file1.txt\"; \"file2.txt\"]>\r\nNote that this is different from http://fslang.uservoice.com/forums/245727-f-language/suggestions/5675977-allow-type-providers-to-generate-types-from-other which is about taking *types* as parameter; this is about taking *values* of a few specific predefined types, which should be much simpler as it doesn't need staged compilation.",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:25:00",
                "Content": "I am going to decline this. If we did something more in this area it would be to allow System.Type and arbitrary quotation expressions to be passed as arguments. These are covered by http://fslang.uservoice.com/forums/245727-f-language/suggestions/8306538-allow-quotations-of-expressions-used-as-type-provi and http://fslang.uservoice.com/forums/245727-f-language/suggestions/5675977-allow-type-providers-to-generate-types-from-other"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Declined per my comment below, in favour of two other suggestions\r\nThanks\r\nDon"
        }
    },
    "6027309": {
        "Number": "6027309",
        "Submitter": "Patrick Q",
        "Submitted": "2014-06-09T00:00:00",
        "Title": "Allow pattern matching on ranges",
        "Text": "It would be quite useful to allow pattern matching on ranges as in the following:\r\nlet find x =\r\nmatch x with\r\n| 42 -> \"aaa\"\r\n| 150 .. 180 -> \"bbb\"\r\n| 222 .. 333 -> \"ccc\"\r\n| _ -> \"zzz\"\r\nWhile one can use guards or active patterns to provide equivalent functionality, it would be quite useful and result in cleaner code if pattern matching on ranges was natively supported.",
        "Votes": 19,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "I’m declining this because a general mechanism (active patterns) already exists that achieves the desired result. In F# 2.0 we decided to add the more general mechanism and remove special cases such as character range patterns (present in OCaml).\r\nLanguage design is always a tradeoff, and adding new special syntactic cases for this case doesn’t seem appropriate. For example, we would have to consider ranges of other types including floating point numbers, decimals, user-defined numeric literals etc.\r\nDon Syme, current BDFL for the F# Language Design"
        }
    },
    "6027459": {
        "Number": "6027459",
        "Submitter": "Onur",
        "Submitted": "2014-06-09T00:00:00",
        "Title": "Support code contracts",
        "Text": "Currently Code Contracts doesn't work in F# properly, especially in the primary contructors. Although F# is null safe and functional , I still find code contracts for the public surface of the projects.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-06-10T03:00:00",
                "Content": "I have run out of votes but +3 for this"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2014-06-20T09:10:00",
                "Content": "This is surely a request for the Code Contracts feature team at Microsoft. What needs to change for F# to make this work?\r\nthanks\r\nDon Syme, BDFL for F# Language"
            },
            {
                "Submitter": "Onur",
                "Submitted": "2014-06-20T09:21:00",
                "Content": "Don,\r\nCode Contracts are almost working with F# as in C# (besides IDE support) except one thing. The F# constructors. If we put Contract.Requires inside a constructor, then Code Contracts complains this/me cannot be used inside a constructor regerdless of primary or secondary ctor. Maybe this is all code contracts fault. I just wish someone from F# team contacted to Code Contracts for a resolution or vice versa"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-06-20T10:30:00",
                "Content": "Have a look at WhyML (link on http://why3.lri.fr/) as ML is very much close to F#."
            },
            {
                "Submitter": "Onur",
                "Submitted": "2014-11-03T08:48:00",
                "Content": "Don, F# compiler does a lot of magic. Especially if we put Contract.Requires to the beginning of a method or a constructor, F# can (if it is a constructor it will) put additional code.\r\nThere is nothing code contract team can do anything about this because this is about how F# compiler works. It basically adds code to the prologue methods and ctors. What compiler can do is to respect System.Diagnostics.Contract class and don't put any code above it."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "I’m supportive of this if we can identify what’s needed.\r\nPlease provide more details about what would need to change with F# to make code contracts work, and reopen a new suggestion for each necessary change.\r\nThanks\r\nDon"
        }
    },
    "6038048": {
        "Number": "6038048",
        "Submitter": "Vanh Phom",
        "Submitted": "2014-06-11T00:00:00",
        "Title": "Make F# interactive console work like playground in Xcode 6",
        "Text": "it would be great to make F# script interactive-console really interactive like the Apple new Xcode 6 playground. Also support color and graphic. Which will shorten the feed back loop in development.",
        "Votes": 2,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "This uservoice is for the F# language and core library design.\r\nThis feature seems more appropriate for one of the F# IDE tooling projects – either the Visual F# Power Tools, or the Xamarin tools for F#, or the FsLab project.\r\nClosing for now as the suggestion is about tooling, not language or library. The suggestion itself is very worthwhile.\r\nDon Syme, current BDFL for the F# Language Design"
        }
    },
    "6040236": {
        "Number": "6040236",
        "Submitter": "Alireza H",
        "Submitted": "2014-06-11T00:00:00",
        "Title": "explicit sytax for defining properties",
        "Text": "function without parameter generate static properties\r\nthat hurts.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Alireza H",
                "Submitted": "2014-06-11T12:32:00",
                "Content": "actually parentheses should be optional in function invokation"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "Thanks for the suggestion. The suggestion would need to be made more concrete with examples and more details to be considered.\r\nDo you have an example?"
        }
    },
    "6044099": {
        "Number": "6044099",
        "Submitter": "Lee Ho Yeung",
        "Submitted": "2014-06-12T00:00:00",
        "Title": "dynamic match for append more rules dynamically and extend type",
        "Text": "dynamic match for append more rules dynamically and extend type",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "Thanks for the suggestion. The suggestion would need to be made more concrete with examples and more details to be considered."
        }
    },
    "6059616": {
        "Number": "6059616",
        "Submitter": "ben",
        "Submitted": "2014-06-16T00:00:00",
        "Title": "Add support for Edit and Continue",
        "Text": "F# doesn't support Edit and Continue which has been a part of Visual Studio since 1998 (for C++), and 2005 (for C#). While FSI and the REPL reduce the need for it, this can become awkward when working with large numerical data sets which aren't readily available outside of the host program.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "This is a suggestion for the Visual F# Tools, rather than the F# language. Suggestions for the Visual F# Tools go to a different user voice. See http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2315271--edit-and-continue-feature-for-f"
        }
    },
    "6062821": {
        "Number": "6062821",
        "Submitter": "Jared Hester",
        "Submitted": "2014-06-16T00:00:00",
        "Title": "Add Dependent Types",
        "Text": "Dependent types allow types to be predicated on values. Full-spectrum dependent types would be preferable so that there is no restriction\r\non which values may appear in types. An example would be declaring a type 'Vector' a list that carries its size in the type.\r\nThe type decleration of a dependent type is actually declaring a family of types that maintain an invariant.\r\nFunctions can be defined on dependent types, for example a function 'vector_append' would append two Vectors, returning a Vector which is the sum of the lengths of the inputs.",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-06-17T08:34:00",
                "Content": "A few comments on this topic:\r\n* Dependent types are a big effort and are far beyond the intended scope of F#. They also make type inference extremely difficult, and generally indecidable.\r\n* For the particular example that you gave (encoding the length of a vector in the type), dependent types are overkill. GADTs are sufficient, and they are much smaller and easier to implement and infer. You are probably posting this in light of this article that has been making the rounds lately: http://www.thesoftwaredevelopmentlifecycle.com/an-almost-type-safe-library-for-linear-algebra/ Note that it talks about *fake* dependent types, and it actually uses GADTs, which can do this particular thing that have traditionally been associated with dependent types, but cannot do a lot of other things that dependent types can.\r\nSo in short: if what you want is Vector, ask for GADTs, not dependent types, at least they might be implemented in F# one day; dependent types almost certainly never will.\r\n* You can have a look at F*, an F#-based dependently-typed language, maybe this can be interesting for you."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2014-06-22T22:27:00",
                "Content": "That's an interesting article, but I actually hadn't seen it before. I wanted to keep the example simple for people who are unfamiliar with dependent types. My interest in dependent types came from reading about Idris ( http://eb.host.cs.st-andrews.ac.uk/writings/plpv11.pdf , http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf ), a desire to enforce strong type invariants that are checked at compile time, and I think it'd be pretty cool to instantiate a single algorithm across a variety of datatypes.\r\nPerhaps there's a way to implement dependent types with restrictions or expand the type system to include datatype constructors in type declarations and datatypes to appear in Kind declarations (obviously Kinds would need to be added to F# as well) so that Datatype lifting would be possible.\r\nPlus it seems like theres been some interesting research into building workable type inference systems for Dependent Types in the past year or two-\r\n\"Compositional and Lightweight Dependent Type Inference for ML\" https://www.cs.purdue.edu/homes/suresh/papers/vmcai13.pdf\r\n\"Dependent Types: Easy as PIE - Work-In-Progress Project Description\" http://research.microsoft.com/en-us/people/dimitris/pie.pdf\r\n\"Type Inference, Haskell and Dependent Types\" https://personal.cis.strath.ac.uk/adam.gundry/thesis/thesis-2013-12-03.pdf\r\nWhile F-star is an intriguing project, at its current state it's even more useless than Haskell =P"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T10:22:00",
                "Content": "I agree with Loic Denuziere that dependent types are well beyond the intended scope of F#, along with the other comments he makes."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-07-03T15:15:00",
                "Content": "In regards to GADTs there's a paper from MS Research[1] about how GADTs are equivalent in expressiveness to parametric types and type equality constraints. Just adding type equality constraints would be enough to express GADT equivalent constructs in F#. Type equality constraints aren't too complex, I actually looked at them as my final year project [2], using \"special\" methods to declare constraints and cast with regards to those constraints and an F# checker that used Mono.Cecil to read the methods and check the methods and call sites matched the constraints.\r\n[1] Generalized Algebraic Data Types and Object-Oriented Programming, Andrew Kennedy and Claudio V Russo\r\n[2] https://github.com/Frassle/Imperial-FYP/blob/master/report.bib"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-04T06:47:00",
                "Content": "Hi Fraser - thanks for this, I have a copy of your final year project report and am looking forward to reading it."
            },
            {
                "Submitter": "Dude",
                "Submitted": "2016-08-24T05:27:00",
                "Content": "One less reason to learn F# I guess..."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-03T00:00:00",
            "Text": "As mentioned in the comments, this is beyond the scope of F#. It could be considered in some future derivative language (and feel free to experiment!). See the comment by Loic in particular.\r\nClosing this to give clarity and recycle the votes.\r\nDon Syme, Current BDFL for F# Language Evolution"
        }
    },
    "6063696": {
        "Number": "6063696",
        "Submitter": "Goswin",
        "Submitted": "2014-06-17T00:00:00",
        "Title": "Internationalized printf formatting of numbers",
        "Text": "Most non-english speaking countries use \",\" as deciamal separator.\r\nit would be nice if I could write <sprintf \"%,1f\" 2.222> instead of <sprintf \"%.1f\" 2.222> to get a comma as a decimal separator.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T06:40:00",
                "Content": "This is a reasonable suggestion. From the point of view of the F# language design, I would be happy to see a well-considered set of practical extensions to printf added to F# 4.0 or later versions. This could be one of them.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly incuding Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest.\r\nIf provided, the design should be\r\n- analyzed and extended with respect to a broader set of potential non-english-speaking numerical formats\r\n- sent for community discussion, for example by adding a link to a more detailed proposal to the end of this post, or by submitting a concrete implementation\r\nThanks\r\nDon Syme, current \"BDFL\" for F# Language Design"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T12:04:00",
                "Content": "Adjusted the title to match my earlier comment"
            },
            {
                "Submitter": "Goswin",
                "Submitted": "2014-06-30T03:56:00",
                "Content": "related:\r\nhttp://stackoverflow.com/questions/21462617/how-to-get-culture-aware-output-with-printf-like-functions"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "This is a reasonable suggestion. From the point of view of the F# language design, I would be happy to see a well-considered set of extensions to printf added to F# 4.x or later versions.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).\r\nWe would strongly welcome an implementation proposal and initial testing for this.\r\nImplementations of approved language design can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library..\r\nThanks\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6078896": {
        "Number": "6078896",
        "Submitter": "Dude",
        "Submitted": "2014-06-20T00:00:00",
        "Title": "Enable a Roslyn/ReSharper level of automated refactoring",
        "Text": "",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-20T00:00:00",
            "Text": "This is a duplicate. See http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2213611-provide-refactoring-support-for-f-code.\r\nFor Visual Studio you can get refactoring tools here: http://fsprojects.github.io/VisualFSharpPowerTools/"
        }
    },
    "6079342": {
        "Number": "6079342",
        "Submitter": "Don Syme",
        "Submitted": "2014-06-20T00:00:00",
        "Title": "Allow extended #if grammar",
        "Text": "Allow an extended grammar for #if/#elif.\r\n#if expr\r\n#elif expr\r\nwith grammar:\r\nexpr =\r\n| expr && expr\r\n| expr || expr\r\n| not expr\r\n| (expr)\r\n| IDENT\r\nWith usual precedences. The syntax !IDENT should also be parsed and interpreted as “not”, though a warning given that “not” should be used instead in F# code.\r\nThe implementation must also provide sufficient tests.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-20T12:22:00",
                "Content": "I consider this approved in principle, though details may need to be sorted out.\r\nIf you think this should not be done, please chime in with details below.\r\nIf you have specific questions on the design, please chime in below.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them).Currently, initial implementations of approved language design can be submitted as pull requests to the \"fsharp4\" branch of https://visualfsharp.codeplex.com/SourceControl/latest. F# 4.0 is open for business.\r\nI encourage you to work towards an implementation and testing for this feature.\r\nDon Syme, current BDFL, F# Language"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0+ see https://github.com/Microsoft/visualfsharp/pull/55\r\nDon Syme, F# Language Evolution"
        }
    },
    "6080367": {
        "Number": "6080367",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-06-20T00:00:00",
        "Title": "Support for Generic Provided Type Definitions",
        "Text": "This is needed for TPs that interop with other languages. A good example is the TypeScript type provider in Funscript",
        "Votes": 85,
        "Comments": [],
        "Status": "open",
        "Response": null
    },
    "6080632": {
        "Number": "6080632",
        "Submitter": "David Siegel",
        "Submitted": "2014-06-20T00:00:00",
        "Title": "Allow modules within classes",
        "Text": "I assumed I could declare modules within classes, and I tried to create one to organize values private to my class, and found that it was not allowed:\r\ntype MyView() =\r\nmodule Colors =\r\nlet button = 0x0000FF\r\nlet label = 0xCCCCCC\r\n\r\nlet Button = new UIButton(BackgroundColor=Colors.button)",
        "Votes": 2,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-06T00:00:00",
            "Text": "Declining this. Allowing nested type definitions ala C# would take priority, and nested modules would be considered as part of that feature.\r\nDon Syme, BDFL F# Language Evolution"
        }
    },
    "6081483": {
        "Number": "6081483",
        "Submitter": "Eamon Nerbonne",
        "Submitted": "2014-06-21T00:00:00",
        "Title": "Allow destructuring let bindings for records (or tuples with named values)",
        "Text": "Tuples are often bug-prone and hard to read because the ordering of members is critical. However, their use is so convenient that they're often used where they're inappropriate. \"Tuples\" with named members would be a huge improvement, and records are almost that.\r\nIn a similar vein, it would be helpful if this record or named-value tuple were as easy to construct as a tuple: in particular, there's no reason to require an explicitly defined type; all the relevant information about the type is present at the construction site - just like with tuples.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Eamon Nerbonne",
                "Submitted": "2014-06-21T03:21:00",
                "Content": "This would go particularly well with http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f - support for anonymous records. The combination would make records as well supported as tuples."
            },
            {
                "Submitter": "Eamon Nerbonne",
                "Submitted": "2014-06-25T08:15:00",
                "Content": "Even without anonymous types, I'd like to have destructuring let bindings; destructuring let bindings make API returning records much more practical. Of course there's synergy with anonymous types, but I don't see how they're the same thing - anonymous types don't necessarily imply destructuring let bindings nor do destructuring let bindings necessarily imply anonymous types (though they'd go well together). In particularly, even with anonymous types and even if they support destructuring let bindings, I'd still want that for records too...\r\nI probably should have left out the \"in a similar vein\" bit. I get the feeling I misphrased the suggestion. Would it be useful to add a suggestion about just the destructuring and not confuse it with the anonymous types, or do you still think the distinction isn't worth making?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-06-24T00:00:00",
            "Text": "Closing this as it looks very close to being a duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f -\r\nAt least close enough that it can’t be treated independently.\r\nPlease reassign the votes there."
        }
    },
    "6085086": {
        "Number": "6085086",
        "Submitter": "Robert Nielsen",
        "Submitted": "2014-06-22T00:00:00",
        "Title": "Nested types for F#",
        "Text": "I don't think F# supports nested type definitions yet.\r\nThe idea was posted here:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2313137-inner-types-for-f\r\nTwo other references on nested types:\r\nhttp://msdn.microsoft.com/en-us/library/ms173120.aspx\r\nhttp://cs.hubfs.net/topic/None/57397",
        "Votes": 45,
        "Comments": [
            {
                "Submitter": "James Freiwirth",
                "Submitted": "2014-10-20T15:10:00",
                "Content": "This would be great. Also allowing 'open' statements in the same way that you can with nested modules would help to make large codebases more organised and easier to maintain."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-08-05T07:01:00",
                "Content": "I concur that we need fuller support of .net type system."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6085102": {
        "Number": "6085102",
        "Submitter": "Robert Nielsen",
        "Submitted": "2014-06-22T00:00:00",
        "Title": "Allow F# compiler directives like #nowarn to span less than an entire file.",
        "Text": "Idea posted here:\r\nhttp://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3338653-allow-f-compiler-directives-like-nowarn-to-span\r\nA possibly related issue / suggestion is listed here:\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/5676502-disable-compiler-warnings-per-line",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T17:32:00",
                "Content": "You could use #endnowarn \"[number]\" to explicitely end a compiler directive."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-05-29T02:11:00",
                "Content": "In C#, this feature exists, and has the following form:\r\n#pragma warning disable 618\r\ncode...\r\n#pragma warning enable 618\r\nThis enables you to suppress specific compiler warnings locally, which is quite important for evolving APIs: sometimes you need to deprecate a particular API (function, type), but keep it around for backwards compatibility. This means that your own code may still need to use the deprecated code for a while longer (for e.g. unit tests), so it'd be nice to enable that scenario without suppressing all other warnings."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6092853": {
        "Number": "6092853",
        "Submitter": "thinkb4coding",
        "Submitted": "2014-06-24T00:00:00",
        "Title": "Async.WaitTask for non generic Task",
        "Text": "Async.WaitTask has an overload for Task<'T> but has no support for Task.\r\nAdding a Task -> Async<unit> overload would make things easier when dealing with C# and BCL async methods.",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-06-24T09:27:00",
                "Content": "This ones easy, I think its only a one or two line change, wont take you long :-)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-24T10:10:00",
                "Content": "I consider this \"approved in principle\" for the F# language design, to be added as soon as implementation+testing is provided, for F# 4.0 or beyond.\r\nI'd encourage you to contribute the implementation and testing for this one.\r\nThere is one small problem: adding an extra overload can be considered a breaking change, e.g.\r\nlet f x = Async.AwaitTask(x)\r\nwill no longer compile. For this reason, it looks sensible to call the new method \"AwaitTaskUntyped\", \"AwaitTaskNonGeneric\" or the like. A good satisfying name is hard to find.\r\nComments on names welcome."
            },
            {
                "Submitter": "Veikko Eeva",
                "Submitted": "2014-07-29T11:55:00",
                "Content": "I'm not sure if this is the right place for this, but it looks like there's on occassion a need to also convert Task<Unit> to plain Task.\r\nMaybe something like this\r\nlet inline TaskUnitToTask(task: Task<Unit>) =\r\ntask :> Task\r\nIt may not be \"easy\" to discover one could do a plain upcast to transform a F# Task<Unit> to C# style Task. Which is the situation I've come across Task<Unit> types (e.g. C# function returning taking or giving plain tasks)."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "Approved for the F# 4.0+ stream – see discussion.\r\nAn implementation has now been submitted, reviewed and committed to the “fsharp4” branch, see https://visualfsharp.codeplex.com/SourceControl/network/forks/thinkb4coding/visualfsharp/contribution/7019\r\nFurther discussions should be directed there."
        }
    },
    "6097685": {
        "Number": "6097685",
        "Submitter": "Dmitry Morozov",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Allow static arguments to Type Provider methods eg M<\"ABC\">()",
        "Text": "This in addition to static arguments to types.\r\nUse case:\r\nhttp://fsprojects.github.io/FSharp.Data.SqlClient/\r\nSqlCommandProvider typical usage is\r\ntype MyCommand1 = SqlCommandProvider<\"SELECT 42\", connStr>\r\ntype MyCommand2 = SqlCommandProvider<\"SELECT 43\", connStr>\r\nSome information as connection string and database-level info (user defined types for exaample) can be shared. Only query itself is different. It will look like:\r\ntype MyDb = SqlCommandProvider<connStr>\r\ntype MyCommand1 = MyDb.GetCommand<\"SELECT 42\">\r\ntype MyCommand2 = MyDb.GetCommand<\"SELECT 43\">\r\nShared db definition will bring performance benefits to this particular provider. Sharing types (especially user defined table types used for table-valued parameters) will allow to pipe output of one command into input param of another.\r\nThis change will enable to merge SqlCommandProvider and SqlProgrammability into single cohesive type provider\r\ntype AdventureWorks = SqlClient<connStr>\r\nTriggered by dsyme tweet\r\nhttps://twitter.com/dsyme/status/430094038771843072",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-29T13:13:00",
                "Content": "An early prototype (including a pull request and a sample using it) is detailed at: https://github.com/dsyme/SampleMethStaticParamProvider/blob/master/README.md"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-12T00:00:00",
            "Text": "This is now completed and available in preview releases of F# 4.0.\r\nFor an early Visual Studio preview release see here (cross platform releases will follow) – http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx\r\nDon Syme, F# Language Evolution"
        }
    },
    "6098424": {
        "Number": "6098424",
        "Submitter": "Huw Simpson",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Add safe versions of collection functions tryTake and trySkip.",
        "Text": "The take and skip functions on the Seq module raise an error when bounds are exceeded. I suggest the following safe alternatives:\r\n// Safely skip n elements of a sequence, and return the rest.\r\ntrySkip : count:int -> source:Seq<'T> -> Seq<'T>\r\n// Safely take n elements from the beginning of a sequence, skip the rest.\r\ntryTake : count:int -> source:Seq<'T> -> Seq<'T>\r\nThe suggested functions operate in a similar manner to their link equivalents which don't raise errors when bounds are exceeded.\r\nIf this suggestion is accepted it would make sense to implement these functions for List and Array also.",
        "Votes": 0,
        "Comments": [
            {
                "Submitter": "Huw Simpson",
                "Submitted": "2014-06-25T11:52:00",
                "Content": "Typo: \"link equivalents\" should be \"LINQ equivalents\""
            },
            {
                "Submitter": "Huw Simpson",
                "Submitted": "2014-06-25T12:03:00",
                "Content": "@dsyme has mentioned that the nth function is to be deprecated and replaced with item, also the corresponding tryItem is to be provided. See: https://github.com/fsharp/FSharpLangDesign/blob/master/CoreLibraryFunctions.md"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Closing issue with no votes."
        }
    },
    "6098490": {
        "Number": "6098490",
        "Submitter": "fsharporg-lang",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Add a module of efficient non-structural equality/comparison operators",
        "Text": "In F# 3.x uses of =, <>, <, >, <=, >=, compare, max and min use “structural equality and comparison”. This is the right default for a functional data-oriented language.\r\nHowever, this gives rise to problems because\r\n(a) the .NET op_Equality, op_LessThan and other corresponding static methods are not easily accessible from F#.\r\n(b) the use of F#'s structural equality and comparison can be slow for user-defined value types.\r\nIn F# 4.0, it is reasonable to add a module NonStructuralOperators to FSharp.Core which gives an implementation of non-structural equality/comparison operators. Opening this module will ensure these operators are used within that scope, similar to the “Checked” module.",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T09:03:00",
                "Content": "Operator overloading has always posed a risk to the readability of the code. I'm not sure if it's a good idea to make it too easy to change the behaviour of common operators. The Checked module adds extra checks but doesn't change the intrinsic behaviour of the operators.\r\nI would be in favour of giving easier access to .NET comparison methods but in a way that this is more explicit to the future reader of the code."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-11T05:40:00",
                "Content": "An implementation of a NonStructuralComparison module is here: https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7675"
            },
            {
                "Submitter": "Matthew Peacock",
                "Submitted": "2015-04-30T21:09:00",
                "Content": "This addresses a serious problem faced when using F# for time series analysis: the default comparison operators for DateTime and TimeSpan are very slow, and always show up as hot spots under the profiler. However, unless I'm mistaken, this change doesn't help when using these types in collections (for example, Set<DateTime> and Map<DateTime,_> will still be slow), or when calling various methods that do comparison (such as sort, groupBy, partition, etc)?"
            },
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2015-07-29T14:23:00",
                "Content": "@Matthew,\r\nhttps://github.com/Microsoft/visualfsharp/pull/513 changes addresses your concerns. Maybe f# 5?\r\nCheer,\r\nPaul."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, See https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7675\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "6098514": {
        "Number": "6098514",
        "Submitter": "Huw Simpson",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Add a function to concat Options",
        "Text": "I suggest the following enhancement to the Option module:\r\n// Combines the given option-of-option into a single option.\r\nlet concat value =\r\nmatch value with\r\n| None -> None\r\n| Some o -> o\r\nconcat : value : 'a option option -> 'a option",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Daniel Fabian",
                "Submitted": "2014-06-25T14:11:00",
                "Content": "You can use \"Option.bind id\" for that exactly"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-07-08T05:59:00",
                "Content": "I would call that \"flatten\" instead. concat would take more than one (unnested) option."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declining as “Option.bind id” is a suitable workaround, or it is very easy to define this function in user code.\r\nDon Syme Current BDFL F# Language/Library Evolution"
        }
    },
    "6098767": {
        "Number": "6098767",
        "Submitter": "Craig Stuntz",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Add Lens focus unfocus",
        "Text": "Lenses allow you to read/write fields in a clean, generic, and extensible way. Here are a few before/after cases using made-up syntax. I'm not sure what the ideal syntax for F# would be.\r\nI'm deserializing XML into F# records. For application-specific reasons, I can't use an off-the-shelf framework. My code contains this:\r\nlet private readRatebookServiceDataNode (ratebook : RawRatebook) (reader: XmlReader) =\r\nlet serviceDataType, serviceData = readElementAndReturnContentAsServiceData reader\r\nmatch serviceDataType with\r\n| \"AccidentViolationOrder\" -> { ratebook with AccidentViolationOrder = serviceData }\r\n| \"AdditionalInterest\" -> { ratebook with AdditionalInterest = serviceData }\r\n| \"AntiTheft\" -> { ratebook with AntiTheft = serviceData }\r\n...and so on, for many more, mostly duplicated lines. If I had a dictionary of lenses, I could write this long function in one line:\r\nratebookLenses.[serviceDataType].Set serviceData\r\nAlso, lenses allow composition of record fields when setting values. See the worked out example here:\r\nhttp://bugsquash.blogspot.com/2011/11/lenses-in-f.html\r\nThere's an implementation in FSharpX:\r\nhttps://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/Lens.fs\r\nLenses in F# today have a major drawback, however. You must write them out explicitly for every label on a record. If you only use the lens once, it's usually more code with the lens than without.\r\nIdeally I'd like to be able to focus and unfocus labels similar to the Haskell examples here:\r\nhttp://www.scs.stanford.edu/14sp-cs240h/slides/lenses.html\r\nSo in more F# terms I'd write something like:\r\nlet labelALens = Lens.focus <@ myRecord.labelA @>\r\nOr, with implicit quotation ( http://fslang.uservoice.com/forums/245727-f-language/suggestions/5975797-allow-implicit-quotation-of-expressions-used-as-a )\r\nlet labelALens = Lens.focus myRecord.labelA\r\nMauricio's code goes from:\r\ntype Car with\r\nstatic member mileage =\r\n{ Get = fun (c: Car) -> c.Mileage\r\nSet = fun v (x: Car) -> { x with Mileage = v } }\r\n...to something like:\r\ntype Car with\r\nmember mileage = Lens.focus c.Mileage\r\nWorth noting: If F# gets hygenic macros ( http://fslang.uservoice.com/forums/245727-f-language/suggestions/5674940-implement-syntactic-macros ) then you could implement lenses that way and no special feature would be necessary. But I'd like lens support even if F# never gets macros!",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2014-06-25T15:53:00",
                "Content": "Also related: \"Syntax for turning properties into functions\" [/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions](/ideas/suggestion-5663326-syntax-for-turning-properties-into-functions.md)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T04:07:00",
                "Content": "Close enough to http://fslang.uservoice.com/forums/245727-f-language/suggestions/6906132-implement-first-class-lensing-lenses-in-f that I will close as a duplicate"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Closing as duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6906132-implement-first-class-lensing-lenses-in-f, or close enough, please see my comment\r\nDon Syme, F# Language Evolution"
        }
    },
    "6099437": {
        "Number": "6099437",
        "Submitter": "Dave Thomas",
        "Submitted": "2014-06-25T00:00:00",
        "Title": "Add a tryUnbox, isNull builtin operators",
        "Text": "Add builtin functions:\r\ntryUnbox : obj -> 'T option\r\nisNull: 'T -> bool when 'T : null\r\nThe first is an unbox operation which if successful would return Some<'a> on a successful unbox and None for a fail. This would allow the Option module to be used efficiently for single type matches and processing.",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-06-25T16:22:00",
                "Content": "How about the operator has the name \"tryUnbox\" , as in x |> tryUnbox<string>"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-06-25T16:32:00",
                "Content": "I was thinking more of an extended operator to supplement :> and :?>\r\nNothing spring to mind that would be intuitive though."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-06-26T03:05:00",
                "Content": "Essentially its just:\r\nlet inline tryUnbox<'a> (x:obj) =\r\nmatch x with\r\n| :? 'a as result -> Some (result)\r\n| _ -> None\r\nAlthough it might want some direct IL generated like the other primitives."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-06-27T22:40:00",
                "Content": "Looks great. How about ':/>'\r\n?\r\nKeystrokes are almost the same, just one less 'Shift' keypress."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-02T04:34:00",
                "Content": "This is really similar to: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6103054-add-option-ofnull-to-help-remove-nulls\r\nI would prefer this as a primitive though.\r\nDon would a symbol be considered here?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-07-02T07:46:00",
                "Content": "Hi Dave,\r\nMy instinct is that we wouldn't consider a symbol here, but would consider a named primitive ala tryUnbox\r\ncheers\r\ndon"
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-06T03:41:00",
                "Content": "I think a named function would suffice as this can be piped into in any case.\r\nI expect a more efficient implementation could be achieved through use of in line IL e.g. (# ... # )"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-10T11:28:00",
                "Content": "I have submitted a PR for tryUnbox and isNull in FSharp.Core for F# 4.0+ https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "6103054": {
        "Number": "6103054",
        "Submitter": "Cameron Taggart",
        "Submitted": "2014-06-26T00:00:00",
        "Title": "add Option.ofNull to help remove nulls",
        "Text": "Many APIs and types support the use of null. To help remove null and promote the use of option, It would be good to add a standard function that can be used to wrap nullable types.\r\nMay be something like:\r\ntype Option<'A> with\r\nstatic member ofNull (t:'T when 'T : null) = function\r\n| null -> None\r\n| x -> Some x\r\nhttp://stackoverflow.com/questions/24418816/in-the-f-api-is-there-something-like-option-ofnull",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Cameron Taggart",
                "Submitted": "2014-06-26T18:27:00",
                "Content": "Or just:\r\ntype Option<'A> with\r\nstatic member ofNull (t:'T when 'T : null) =\r\nif t = null then None else Some t"
            },
            {
                "Submitter": "Ruben Bartelink",
                "Submitted": "2014-06-26T18:38:00",
                "Content": "or call it Option.ofObj"
            },
            {
                "Submitter": "Jerold Haas",
                "Submitted": "2014-06-28T00:03:00",
                "Content": "Perhaps the name isn't perfect, but I fully support the elimination of nulls by wrapping them.\r\nOther names suggested, indicating its use outside Option<'A>: \"deNull, tryNull, nullToOption, toOption\""
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-06-28T01:50:00",
                "Content": "I think it's not very productive to add one function at a time. Someone made a PR that contained only single function (Option.filter).\r\nI suggest to pull all useful functions from here https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Pervasive.fs#L705 and here https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/ComputationExpressions/Monad.fs#L84, discuss the list and add them all at once, including the tests."
            },
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-06-28T03:40:00",
                "Content": "Integrating ExtCore would be nice, it's very well thought out and optimised."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2014-07-03T08:12:00",
                "Content": "Mapping between Nullable<T> and Option<T> would also be useful."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-10T11:27:00",
                "Content": "I have submitted a PR with names Option.ofObj and Option.toObj, see https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672"
            },
            {
                "Submitter": "George",
                "Submitted": "2015-06-03T13:09:00",
                "Content": "Excellent idea.\r\nAlso Option.ofNullable for mapping System.Nullable<T> into F# Option types and converse operations Option.toObj and Option.toNullable to map options to reference and value types, respectively."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "6107641": {
        "Number": "6107641",
        "Submitter": "Don Syme",
        "Submitted": "2014-06-27T00:00:00",
        "Title": "Make “Microsoft” prefix optional when using core FSharp.Core namespaces, types and modules",
        "Text": "The modules and types from the FSharp.Core dll use the names \"Microsoft.FSharp.Collections\" etc.\r\nSince the F# language is now cross-platform and open-source, it is appropriate that source code be able to optionally use just \"FSharp.Collections\". This would also mean the names match the name of the DLL (FSharp.Core).\r\nThis would not be a breaking change, existing code would continue to compile.\r\nThe compiled form used in FSharp.Core.dll wouldn't change, for reasons of binary compatibility.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "John Tarbox",
                "Submitted": "2014-09-07T08:03:00",
                "Content": "Is this a breaking change? In other words will references to Microsoft.FSharp.Collections need to be changed before a program will compile under F# 4.0?"
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T08:25:00",
                "Content": "I don't believe it's a bad thing to keep \"Microsoft\" prefix as a remainder that F# started as a contribution of Microsoft to the community. This can be an incentive for big companies to contribute to open source projects."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-07T09:49:00",
                "Content": "@JohnTarbox - using the \"Microsoft\" prefix would be optional (as stated in the title of the suggestion)"
            },
            {
                "Submitter": "Kevin Ransom",
                "Submitted": "2014-09-07T12:02:00",
                "Content": "This will indeed break applications that, contain types with the names of our collection types in the namespace fsharp.collections. That may not be very likely but it could happen."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-07T14:34:00",
                "Content": "Hi Kevin - Yes, I'd like to investigate this to make sure this is not a breaking change.\r\nThe F# name resolution rules currently mean that types defined in non-FSharp.Core DLLs would have precedence (F# name resolution prefers the most recently introduced type based on the assembly reference list and \"open\" declarations, Since FSharp.Core comes first in asssembly resolution, later types will have precedence).\r\nHowever there are some exceptions that we need to innvestigate, particularly for generic types that get overloaded on arity. However that case will very rare indeed and any example would be very contrived - but we'll still check it out."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "This has been completed for F# 4.0+, see https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/MicrosoftOptionalDesignAndSpec.md\r\nThe overall status for F# 4.0+ is here: https://github.com/Microsoft/visualfsharp/wiki/F%23-4.0-Status\r\nDon Syme, current BDFL for F# Language Evolution"
        }
    },
    "6108408": {
        "Number": "6108408",
        "Submitter": "Expandable",
        "Submitted": "2014-06-27T00:00:00",
        "Title": "Support for sealed methods and properties in F#",
        "Text": "I've recently noticed that F# doesn't support the definition of sealed overriding methods and properties. When you seal an overriding method or property in C#, only that method or property can no longer be overridden in deriving classes while other methods or properties still can be (in contrast to sealing the entire class, where the entire class can no longer be inherited).\r\nF# honors sealed classes defined in both C# and F# as well as sealed methods and properties defined in C# code in the sense that it does not allow deriving from such a type or overriding such a method or property. However, while it is possible to seal a class defined in F# using the [<Sealed>] attribute, it is currently not possible to seal an overriding method or property.\r\nI suggest to add this feature, as it is occasionally useful and shouldn't be that hard to implement, given that the compiler already rejects all attempts to override a sealed method or property. Implementing this feature would require the following changes, as far as I can see:\r\n- The F# core library must be updated so that the [<Sealed>] attribute can also be used on methods and properties. That change is trivial.\r\n- The F# compiler must emit the required IL metadata for properties and methods marked with the [<Sealed>] attribute.\r\n- The F# compiler should raise an error if the [<Sealed>] attribute is applied to a non-overriding method or property (i.e., methods/properties that are not virtual at all as well as for definitions of virtual methods and properties, just like you can't use both the sealed and virtual keywords in C#).\r\nDo you think that would be worth doing? Sure it's only a small change with very limited impact, but it would bring F# closer to feature parity with C# when it comes to object-oriented constructs. If you think it's worth implementing, I'll be happy to do it, although I have to admit that I've never modified the F# compiler before.\r\nI'm looking forward to hearing your opinions on that suggestion!",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:25:00",
                "Content": "My inclination is not to implement this feature. I understand its utility, but we don't aim for 100% feature parity with C# OO. Specifically the F# emphasis is more to hide the implementation of object types rather than creating object inheritance hierarchies based on implementation inheritance. So we tend to strongly de-emphasize features related to supporting implementation inheritance as a technique - we allow basic implementation inheritance but not every bell-and-whistle of C#."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion!\r\nI’ve marked it declined per my comment. I’m not 100% opposed to the feature and appreciate it being noted. However I’ve given the explanation in the comment\r\nThat said, we may implement this feature one day as part of some overall “feature parity with C# implementation inheritance” work. But that day seems a fair way off for now.\r\nBest wishes\r\nDon Syme, F# Language Evolution"
        }
    },
    "6108807": {
        "Number": "6108807",
        "Submitter": "Dave Thomas",
        "Submitted": "2014-06-27T00:00:00",
        "Title": "Allow Object expressions to have attributes applied to them",
        "Text": "In the simplest case something like this would be possible:\r\n[<MyAttribute>]\r\nlet makeResource name =\r\n{ new System.IDisposable\r\nwith member this.Dispose() = printfn \"%s disposed\" name }\r\nAnd then when the code is compiled the expression thats generated would also have the attribute applied to it.\r\nThis would interoperability with frameworks that use declarative attributes which would otherwise require adding a full type",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-06-28T01:44:00",
                "Content": "I think it's more logical to place attributes right before object expression itself, like this:\r\nlet makeResource name =\r\n[<MyAttribute>]\r\n{ new System.IDisposable with\r\nmember this.Dispose() = printfn \"%s disposed\" name }\r\nIt's also better since we now can apply attributes not only in bindings, but in any expression:\r\nfunc ([<MyAttribute>]\r\n{ new System.IDisposable with\r\nmember this.Dispose() = printfn \"%s disposed\" name },\r\nanotherArg)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:28:00",
                "Content": "I tend to agree that this should be supported (though the location for the attributes would be different to shown above)"
            },
            {
                "Submitter": "zhonglei chen",
                "Submitted": "2016-01-30T12:29:00",
                "Content": "I agree with this suggestion due to performance consideration.\r\nIf we can add attribute to object expression, we can apply the following pattern to improve the performance of algorithms:\r\nlet sort<'a, 'c when 'c :> System.Collection.Generic.IComparer<'a>>( array : 'a[], comparer : 'c ) = ...\r\nlet filter<'a, 'p when 'p :> XXX.Predicate<'a>>( array : seq<'a> , predicate : 'p) = ...\r\n...\r\nnow, users can access these algorithms by passing an object expression:\r\nsort([0..1000000], { new IComparer<int> with member this.Compare(a, b) = a.CompareTo(b) })\r\nfilter([0..1000000], { new Predicate with member this.Filter(a) = a % 2 = 0 })\r\nat this point, it looks like the client code injection mechanism goes back to java, so how can we benifit from this ?\r\nwe can apply the struct attribute to object expression to force the anonymous type to be generated as struct:\r\nsort([0..1000000], [<Struct>] { new IComparer<int> with member this.Compare(a, b) = a.CompareTo(b) })\r\nfilter([0..1000000], [<Struct>] { new Predicate with member this.Filter(a) = a % 2 = 0 })\r\nand then the JIT compiler will generate some individual algorithms for each anonymous type here, and inlining the Compare/Filter method into inner loop of algorithm.\r\nwe can benifit much from this."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6122717": {
        "Number": "6122717",
        "Submitter": "Don Syme",
        "Submitted": "2014-07-01T00:00:00",
        "Title": "Allow nested property setters and collection property setters in initializers",
        "Text": "I suggest we consider allowing A.B=expr property setters in initializers, e.g.\r\n\r\nUIButton(UIButtonType.Custom, Layer.BorderWidth = 1.0, Layer.BorderColor=UIColor.Gray.CGColor, Radius = size / 2.0)\r\ncf. https://github.com/dvdsgl/shallow/blob/master/Shallow/RoundButton.fs#L6\r\nAlso, we should consider allowing collection setters, e.g.\r\nC(CollectionProperty = [ 1;2;3 ])\r\nwhere CollectionProperty has the \"Add\" pattern of C#. One design would make it tht any IEnumerable<T> would be assignable, where T corresponds to the type of an Add method, though that may not be fully compatible with the C# mechanism.",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Dave Thomas",
                "Submitted": "2014-07-06T03:37:00",
                "Content": "Having an IList<_>.Add mechanism as mentioned would make interop with lots of C# more palatable as extra create methods would ordinarily have to be added or assign an intermediate type."
            },
            {
                "Submitter": "Paul",
                "Submitted": "2014-07-21T19:29:00",
                "Content": "It might be more readable to explicitly specify the property setter to distinguish it from a standard setter with something like\r\nlet init values f = values |> Seq.iter f\r\nC(CollectionProperty.Add |> init [1;2;3])\r\nOr use a property setter extension which adds the items to given collection.\r\nC(InitializingCollectionPropertyExtension = [1;2;3])"
            },
            {
                "Submitter": "Paul",
                "Submitted": "2014-10-19T13:52:00",
                "Content": "An initial implementation of this feature has now been submitted here: https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-20T09:35:00",
                "Content": "Hi Paul,\r\nThat's great news! I'll definitely be taking a look at this.\r\nCould you submit a pull request for that branch so we can see the overall changes more easily? (You may need to rebase the branch) Also could you write up a description of what is and isn't allowed (this should also match your testing)\r\nThanks\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-20T10:08:00",
                "Content": "(BTW I now see the implementation in the \"master\" branch of https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-20T10:09:00",
                "Content": "(Also, for those wondering, the design is summarized in this commit: https://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/AllowNestedAndColllectionPropSetters/changeset/147eff4c8542fd5d5f1e351c831da7d653d679f3)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-20T10:09:00",
                "Content": "(That's the proposed, experimental design)"
            },
            {
                "Submitter": "Paul",
                "Submitted": "2014-10-21T11:28:00",
                "Content": "A pull request has now been submitted."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6124011": {
        "Number": "6124011",
        "Submitter": "Matthew Moloney",
        "Submitted": "2014-07-01T00:00:00",
        "Title": "Easier to copy data between records of different types.",
        "Text": "Large data projects require lots of records with 100+ fields. These records require small changes over time, e.g. a new field is added. To update the data the old records are read in and copied to the new record field by field. The proposal is to automatically copy fields from an old record of type A to a new record of Type B where both the field names and the field types match.\r\ntype A = {x : int}\r\ntype B = {x : int; y : int}\r\nlet a : A = {x = 1}\r\nlet b : B = {a with y = 2}",
        "Votes": 32,
        "Comments": [
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2015-05-25T09:54:00",
                "Content": "I'd extend this idea to also make it easier to *create* records of different types.\r\ntype A = {x: int}\r\ntype B = {A with y:int}"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:16:00",
                "Content": "This is very much related to http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663704-copy-and-update-on-class-types\r\nI will close this suggestion in favour of that one and link back here"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing in favor of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663704-copy-and-update-on-class-types"
        }
    },
    "6135254": {
        "Number": "6135254",
        "Submitter": "Mårten Rånge",
        "Submitted": "2014-07-04T00:00:00",
        "Title": "Add reverse pipe operator that is right associative and low precedence.",
        "Text": "The current reverse pipe (<|) is left-associative and same precedence.\r\nLeft-associativity is \"unnatural\" for reverse pipe making it's usage harder, ie this doesn't compile: let x = abs <| abs <| 2;\r\nIn addition sharing the precedence of |> makes mixing them harder.\r\nThere are already existing languages with such an operator ie Haskell and operator '$'.\r\nI propose adding a right-associative low precedence reverse pipe operator to F# in order to improve reverse-piping.\r\nI know some people disagree with reverse-piping but I personally like it as it can be used to remove parantheses. To me excessive amount of paratheses makes code harder to read (I guess this is the reason I struggle to enjoy LISP).",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Mårten Rånge",
                "Submitted": "2014-07-04T13:18:00",
                "Content": "For the interested I a PR as a proposal: https://visualfsharp.codeplex.com/SourceControl/network/forks/marten_range/visualfsharp/contribution/7074"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:02:00",
                "Content": "This can always be added as an operator outside the core library.\r\nI must admit I'm not a fan of encouraging the widespread use of reverse piping beyond a single \"f <| x\" It seems to me that reverse piping supporting a single function is reasonable but the other cases tend to code obscurity.\r\nI will decline this since we don't plan to add such an operator to FSharp.Core, and because you can define an operator outside the core library in your own implementation code."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion, though I’m declining per my comment below.\r\nMany thanks,\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6137978": {
        "Number": "6137978",
        "Submitter": "Nick Palladinos",
        "Submitted": "2014-07-05T00:00:00",
        "Title": "Better inlining analysis and heuristic algorithms",
        "Text": "It would be great if the compiler can inline away CPS compositions like the following.\r\nlet inline f k = (fun x -> k (x + 1))\r\nlet inline g k = (fun x -> k (x + 2))\r\n\r\n(f << g) id 1 // 4\r\nIn general better inlining analysis and heuristic algorithms",
        "Votes": 22,
        "Comments": [
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-06T09:28:00",
                "Content": "There was a related question on StackOverflow yesterday which provides another case where the F# compiler's inlining analysis could be improved: https://stackoverflow.com/questions/24589480/why-cant-the-f-compiler-fully-inline-function-arguments-of-a-higher-order-func"
            },
            {
                "Submitter": "Jack Pappas",
                "Submitted": "2014-07-06T09:56:00",
                "Content": "One more related StackOverflow question: https://stackoverflow.com/questions/23875598/why-is-function-composition-from-left-to-right-11x-to-19x-faster-than-right-to-l"
            },
            {
                "Submitter": "Arbil",
                "Submitted": "2014-07-07T07:28:00",
                "Content": "The problem I've described in one of the links Jack has linked to is actually more basic than the OP's. It's that the first order function passed as an argument to a second order function is not inlined even if both the second and first order functions are marked as inline. This makes it so that using second order functions always comes with a performance penalty, which is not the case for first order functions."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:22:00",
                "Content": "Note this suggestion is automatically \"approved\" under the general heading of \"we accept optimization improvements\". It's not a design change to the language per se.\r\n> It's that the first order function passed as an argument to a second order function is not inlined even if both the second and first order functions are marked as inline\r\nI would like to see this fixed!"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:56:00",
                "Content": "I'm going to close this because it's automatically approved.\r\nWe would _love_ some PRs to improve inlining.\r\nI've tracked the potential optimization in the compiler guide here: https://github.com/fsharp/fsharp.github.io/commit/f33141115b0646450e872b86949ac25ab9d86f44"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "This is automatically approved – definitely something we want to do – but not individually tracked individually here. Let’s do it… Please submit your PRs for improved inlining :)\r\nDon Syme, F# Language Evolution"
        }
    },
    "6147144": {
        "Number": "6147144",
        "Submitter": "exercitus vir",
        "Submitted": "2014-07-08T00:00:00",
        "Title": "Allow single case unions to be compiled as structs",
        "Text": "Single case unions are often used to define domain types that just wrap another primitive type. See http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/ for examples.\r\nIt would be great if we could mark these single case unions \"inline\" for optimized code generation. An \"inline\" single case union would not be converted to a class with a single \"Item\" property like an ordinary single case union, but instead the wrapped \"Item\" of the single case union would be passed directly (as is).\r\nThis would be similar to units of measure that are checked by the F# compiler, but are no longer visible in the generated code.\r\nThis would avoid the overhead of instantiating a class with the sole purpose of wrapping another type.",
        "Votes": 37,
        "Comments": [
            {
                "Submitter": "Expandable",
                "Submitted": "2014-07-08T08:52:00",
                "Content": "But that would break type safety when the code is used from outside F#. True, that's also the case with units of measure and the inline annotation is purely optional.\r\nBut what about generating a struct instead? That would also avoid the heap allocation, instances of the type would not consume any additional memory compared to raw instances of the wrapped type and the just in time compiler should be able to inline pretty much all function calls (of course, the Equals methods, etc. should be overridden and point to the equivalent methods of the wrapped type)."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-07-11T09:11:00",
                "Content": "Wrapping with a struct sounds sensible. It would be lighter weight than currently and keeps it type safe when used from C#/VB/etc."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-07-11T14:15:00",
                "Content": "I also like Expandable's idea of generating a struct instead of a reference type. But I think structs would also break type safety because they are automatically initialized and the default of the struct could be passed into a function that expects a non-default single case union."
            },
            {
                "Submitter": "Expandable",
                "Submitted": "2014-07-20T09:48:00",
                "Content": "@exercitus vir: These benchmarks do not take garbage collection into account, as far as I can see."
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2014-09-16T05:08:00",
                "Content": "Title updated to \"Allow single case unions to be compiled as structs\""
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-10-21T07:30:00",
                "Content": "I don't think that the new title is appropriate. I was not asking for single case unions to be compiled as structs, but \"inlined\". For example:\r\ntype inline SingleCaseUnion = SingleCaseUnion of int\r\nlet f (SingleCaseUnion item) = ...\r\nshould not compile to \"SingleCaseUnion.Item\" when passing the single value of \"SingleCaseUnion\" to function \"f\", but instead inline the int value in place of the \"SingleCaseUnion.Item\" property, so that \"f\" would look like this:\r\nlet f (item : int) = ..."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2015-09-07T18:45:00",
                "Content": "Obviously, we like wrapping types, but we also do not like heap allocation. Making them structs I think is what we want.\r\nIf you are worried about performance, allowing single case unions to be structs is very sufficient and close enough to the performance as if the type was erased. It might be slower, but not by much, where as reference types might be on an order of magnitude slower if you are creating a lot of them. You also have access to inline functions, so you can avoid the copying of structs if you need to."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-01-22T03:32:00",
                "Content": "This feature (description, not the title) looks like newtype in haskell.\r\nhttps://wiki.haskell.org/Newtype"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-07T08:15:00",
                "Content": "While I was initially asking for something different (inline vs. struct), single case unions compiled to structs solve the same problem. While structs are more type-safe than inlined when used from other languages, it would not be completely safe either when used from other languages that can call the default non-overridable parameterless constructor of structs, which wrap reference types. But it's great that you prevent calling that constructor from within F#!\r\nTo be completely safe, the author of the single case union compiled to struct must remember to wrap value types only, because wrapping reference types that default to `null` would be dangerous. This feature would still make a great addition to F# vNext."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-07T08:17:00",
                "Content": "The related records compiled to structs feature suggestion has already been implemented and merged:\r\n- uservoice: [/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu](/ideas/suggestion-6547517-record-types-can-be-marked-with-the-struct-attribu.md)\r\n- github: https://github.com/Microsoft/visualfsharp/pull/620"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed\r\nRFC here with links to implementation https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1014-struct-unions-single-case.md\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6148669": {
        "Number": "6148669",
        "Submitter": "Arbil",
        "Submitted": "2014-07-08T00:00:00",
        "Title": "Add support for StructTuple",
        "Text": "According to my tests short struct tuples perform up to 25x faster than default ones if the cost of garbage collecting is taken into account. The code below allocates an array of default tuples/struct tuples respectively and collects it. The results are:\r\n1249 ms for default tuples\r\n44 ms for struct tuples\r\nI remember reading that the Microsoft team had considered implementing tuples as structs but didn't see their advantage in the internal tests. I suspect the tests failed to take the garbage collection into account. If this is done the difference is huge.\r\nCurrently, even such a basic operation for high-performance code as a Dictionary.TryGetValue allocates memory! (Unless it is JITed away; the System.Tuple constructor is in the IL code).\r\nI feel this is a real impediment for F# as a language for scientific, financial or game development.\r\nCode:\r\ntype Pair<'a, 'b> =\r\nstruct\r\nval Item1 : 'a\r\nval Item2 : 'b\r\nnew(item1, item2) = {\r\nItem1 = item1\r\nItem2 = item2\r\n}\r\nend\r\nlet run() =\r\nlet size = 10000000\r\nGC.Collect()\r\nlet watch = Diagnostics.Stopwatch.StartNew()\r\nlet mutable arrTuple = Array.init size (fun i -> (i,i))\r\narrTuple <- [|(0,0)|]\r\nGC.Collect()\r\nwatch.Stop()\r\nprintfn \"Took %A ms\" watch.Elapsed.TotalMilliseconds\r\nwatch.Restart()\r\nlet mutable arrStruct = Array.init size (fun i -> Pair(i,i))\r\narrStruct <- [|Pair(0,0)|]\r\nGC.Collect()\r\nwatch.Stop()\r\nprintfn \"Took %A ms\" watch.Elapsed.TotalMilliseconds",
        "Votes": 136,
        "Comments": [
            {
                "Submitter": "Expandable",
                "Submitted": "2014-07-09T11:52:00",
                "Content": "Are you sure that you're not measuring the difference between writing objects of a value type into an array vs writing objects of a reference type into an array? The latter might have to perform type checks on every write.\r\nBut still, it also worries me that tuples are implemented as classes. But I guess that's because you'd have to pass the tuples by ref (in C# terminology) for optimal performance when passing tuples to functions and that is somewhat frowned upon in the C# world. For F#, of course, the compiler could generate the appropriate function signatures."
            },
            {
                "Submitter": "Braden Evans",
                "Submitted": "2014-07-09T12:43:00",
                "Content": "This has been my experience as well, it is hard to write idiomatic f# code when avoiding allocations (option is another big offender)\r\nIn a batch workload (like the f# compiler) this isn't such a big deal (I remember reading the BCL team's test was actually with the f# compiler) but it is an annoying show-stopper for realtime stuff.\r\nI wonder if it is possible to make major breaking changes like this to major f# versions?"
            },
            {
                "Submitter": "Arbil",
                "Submitted": "2014-07-09T13:52:00",
                "Content": "@Expandable The difference is not due to using an array. I repeated the test with\r\nlet mutable tup = (0,0)\r\nfor i = 1 to 10000000 do tup <- (i,i)\r\nand analogous code for Pair. The results are 47 ms and 3.3 ms, and the ratio is 15x. Short struct tuples will remain much faster even if you don't pass them as ref. I recall Jon Harrop claiming the cut-off when class tuples become faster even if passed to a function is length of 7.\r\n@Braden I've been intending to make an analogous proposal for option but first things first! As you say, the difference between struct and class implementations is not visible in most synthetic benchmarks and one-time workloads, which is I believe why it has been overlooked. And it is indeed a show stopper particularly when guaranteed low latency is required (financial applications and games).\r\nI wouldn't call the change breaking, it wouldn't break any existing functionality. It would degrade performance only in a pathological situation when a tuple is passed around ad infinitum, and dramatically improve performance in the remaining 99.99% cases."
            },
            {
                "Submitter": "Expandable",
                "Submitted": "2014-07-10T02:15:00",
                "Content": "@Arbit: The problem is: It wouldn't break anything for F# code, but it would certainly break some F#/C# interop scenarios. From F#'s point of view, implementing tuples and option as classes or structs is just an internal optimization, but C# facing code might break, as structs vs classes have significantly different semantics in C# and there is no way the C# compiler can hide that. On the other hand, I'd say this breaking change is worth it, especially since you normally don't expose F#-specific data structures to C# as they're ugly to use from C# anyway. Now for tuples it might be a bit different, but I personally hate to use tuples in C# anyway."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2014-07-10T09:06:00",
                "Content": "I'd like to +1000 on this (and also making option types structs) if I could :-) That will make idiomatic F# a fantastic choice for games.\r\nI wonder if this could be enabled with a compiler flag, which will be good enough for those of us who don't need/care C# interop. Compiler could also generate function wrappers that convert from System.Tuple to/from the struct tuples for public functions to facilitate C# interop."
            },
            {
                "Submitter": "Braden Evans",
                "Submitted": "2014-07-10T11:01:00",
                "Content": "I like the idea of a compiler flag if a breaking change is out of the question.\r\nShould note the compiler actually has a struct implementation for tuple2 already: https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/prim-types.fs#L520 (Haven't tried to compile with it yet though)"
            },
            {
                "Submitter": "Arbil",
                "Submitted": "2014-07-15T06:33:00",
                "Content": "I see what you mean with breaking C# interop. I do however think that impeding the development of a language by considering what might become broken by changes within that same language is quite enough. Binding development of F# to C# would be bad -- especially considering C# is at a point where they are hesitant to fix bugs because there are application that depend on them! I believe many who moved to F# to C# highly appreciate that F# is actively developing.\r\nBut this is of course something for the head honchos of F# and not me to decide."
            },
            {
                "Submitter": "Arbil",
                "Submitted": "2014-07-28T03:53:00",
                "Content": "I compiled the source with the struct tuple flag (https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/prim-types.fs#L520) but 2-tuples are still compiled as classes. I might have overlooked something though. Still, it seems this is an irrevelevant/dead code branch because in reality the tuples are compiled as System.Tuple, while this branch defines its own Tuple type whether the struct flag is set or not. It is not used."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-07-31T05:11:00",
                "Content": "I think this is a difficult issue in many ways.\r\nFirst of all there is the value of interoperability. It is difficult to say how important this is. Personally I'd like the F# compiler to do much more aggressive optimization and could even accept having to do more work to interop with other .Net languages, but I believe I'm in a very small minority and the interop is vital to the success of F#. Without the interop, I believe F# would be doomed to be a niche language, because it would make it harder for developers from other .Net languages to use F# in their projects. Compare with the success of C++, for example.\r\nThen there is the fact that currently .Net does not seem to generate very efficient code when dealing with structs. This is reported in many places. The current JIT generates many redundant copies when you are initializing structs, passing them as arguments to or returning the as results from functions. My experience is that with the current JIT, structs are only a win in few specific scenarios, such as when you basically make sure that a struct is allocated once (on stack or as part of some other object), is processed via a reference and structs are not arbitrarily passed around. When you do pass structs around arbitrarily, as a rule of thumb, a stack allocated struct with two pointer sized elements seems to be roughly as efficient as the equivalent two element heap allocated object. A pointer sized struct will generally be a win, while a struct larger than two pointers is likely to be a lose.\r\nThen there is the fact that the internals of the F# compiler do not seem to be particularly designed for making sophisticated optimizations. In order to really make an effective optimizing compiler, you need to transform the surface language to a suitable intermediate language (e.g. SSA / CPS) that makes it relatively easy to write effective analysis and transformation passes for that intermediate language and also allows the desired optimizations to be expressed in the first place. Currently there is no such intermediate language in the F# compiler. The current intermediate languages within the F# compiler will not allow you to express control flow optimizations such as contification, which could be effective for optimizing non-trivial sets of local tail recursive functions into efficient loops."
            },
            {
                "Submitter": "Arbil",
                "Submitted": "2014-08-04T05:01:00",
                "Content": "@Anonymous That's helpful. Prompted by you I looked at some of the IL generated by struct usage and it often is indeed bizarro code. However, I think you are wrong when you say that 3 pointer sized structs are usually slower than 3 pointer sized classes. I tested it with passing to a function once and the 3-structs came over two times faster. And this is a test unfavourable to structs. Tuples are primarily made to be returned from functions and immediately deconstructed.\r\nCode:\r\nlet checkT tup =\r\nlet (fst,_,_) = tup\r\nif fst = -1 then printf \"bad\"\r\nlet checkS (str:Triple<_,_,_>) = if str.Item1 = -1 then printf \"bad\"\r\nlet run() =\r\nlet size = 100000000\r\nGC.Collect()\r\nlet watch = Diagnostics.Stopwatch.StartNew()\r\nlet mutable tup = (0,0,0)\r\nfor i = 1 to size do\r\ntup <- (i,i,i)\r\ncheckT tup\r\nGC.Collect()\r\nwatch.Stop()\r\nprintfn \"Took %A ms\" watch.Elapsed.TotalMilliseconds\r\nwatch.Restart()\r\nlet mutable trip = Triple(0,0,0)\r\nfor i = 1 to size do\r\ntrip <- Triple(i,i,i)\r\ncheckS trip\r\nGC.Collect()\r\nwatch.Stop()\r\nprintfn \"Took %A ms\" watch.Elapsed.TotalMilliseconds"
            },
            {
                "Submitter": "trek42",
                "Submitted": "2014-08-07T16:20:00",
                "Content": "@Anonymous -- I agree with your comments on .net optimizer, but I think they missed the big point which is garbage collection issues. For real-time applications, especially the now popular mobile and game development (where F# should really shine IMO), people often need to avoid garbage collection pause at all cost --- often, it's totally fine to pay a small extra cost each time a struct passed around, while avoiding piling up garbage quickly and cause observable lags.\r\nAlso note that we are specifically discussing about *Tuple*, not the general \"struct vs class\" tradeoff. Tuples are usually short-lived, local variables (mostly for multiple return values), and avoiding GC could lead to a larger win."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-08-25T20:02:00",
                "Content": "@Arbil Just for the record, below are timings I get with your test code on my laptop.\r\nfsianycpu.exe --optimize with server GC:\r\n> run () ;;\r\nTook 923.3096 ms\r\nTook 1215.1609 ms\r\nval it : unit = ()\r\n> run () ;;\r\nTook 913.3422 ms\r\nTook 1217.4542 ms\r\nval it : unit = ()\r\nStruct version run slower.\r\nfsi.exe --optimize with server GC:\r\n> run () ;;\r\nTook 750.8876 ms\r\nTook 462.6067 ms\r\nval it : unit = ()\r\n> run () ;;\r\nTook 758.2908 ms\r\nTook 459.7404 ms\r\nval it : unit = ()\r\nStruct version runs faster.\r\nRyuJIT CTP4 gives roughly similar timings."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-08-25T20:40:00",
                "Content": "@Arbil Regarding your benchmark. I took a look at the JITted code (I made sure JIT optimizes even when running under debugger, placed breakpoints on the loops, and viewed the assembly in debugger) and it seems that, in your benchmark, some undesired optimizations do kick in depending on whether it is 64-bit or 32-bit and whether tuples or structs are being used. By \"undesired optimizations\" I mean that either the F# compiler (by inlining and then optimizing the functions called in the loops) or the JIT is able to eliminate some parts out of the code so you are not really measuring what you wrote. On the 64-bit JIT, the struct version generates an insane amount of instructions that clear and copy temporary copies of the struct.\r\nWhat my earlier rules of thumb are based upon are my many attempts to use structs to gain performance in much more realistic settings where things can't get reduced to nothing. Even with two element structs it can take careful tweaks to get things moving really efficiently (e.g. if you pass byref and the target function can be inlined by the JIT, then copying can be avoided).\r\nWhat I'd really like to see would be good enough escape analysis and elimination of object allocations (in RyuJIT) that would basically make it unnecessary to use structs for performance reasons."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T08:01:00",
                "Content": "Given the binary-compat issues of changing the representation of Option and Tuple, One approach to this problem is to add struct-tuples as a language feature. For example, we could do this today simply by adding a set of \"StructTuple<A,B,C>\" types to FSharp.Core. Of course that would only work up to a fixed size of tuple - say 7 for symmetry.\r\nPeople would then use StructOption and StructTuple when they needed. The FSharp.Core library wouldn't use these otherwise - e.g. they would not be used in the return type of List.* operations - but upstack libraries would be free to use them internally.\r\nIf we went in this direction, it would be even better to add StructOption and StructTuple in a way that was very close to the existing Option and Tuple support - allowing Some/None pattern matching for options, and arbitrary size of tuples, and pattern matching on tuples (without allocation).\r\nOverall it becomes a more sizable feature - but if done well it would at least allow smoother transitions to allocation-free code."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:47:00",
                "Content": "I believe we will have to add unboxed struct tuples to F# in some form or another.\r\nThe C# design for tuples is progressing and it will almost certainly involve using structs for at least smaller tuples. That's reasonable.\r\nIt is undecided as yet where the StructTuple<...> types will live and whether they will have identical semantics to the existing System.Tuple<...> types. F# will likely be quite exposed to C# design decisions here.\r\nC# tuple types will also likely carry erased metadata (the metadata won't be in object instances)\r\nMy preferred sketch design is to add a struct annotation to the syntax of types like this:\r\ntype = struct (idopt: type * idopt: type)\r\n| ...\r\nand to expressions:\r\nexpr = struct (idopt: expr * idopt: expr)\r\n| ...\r\nand to patterns:\r\npat = struct (idopt: pat * idopt: pat)\r\n| ...\r\nThe \"structness\" and optional identifiers would be propagated through the F# type inference process through standard unification. Otherwise, wherever possible, the existing design of F# tuples would apply.\r\nThe idea is that no code would break with this design. Unless otherwise unified, F# tuple syntax would default to the existing reference types with no identifiers.\r\nThe FSharp.Reflection facilities on tuples would be extended for struct tuples, as would the FSharp.Quotation facilities.\r\nThis is a sketch and there would no doubt be many details to add, and we must also be careful to interoperate with C# (we are in discussion with the C# team about this).\r\nWe will go ahead and marked this as \"approved in principle\" and we will open an RFC sooner or later."
            },
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2016-02-17T14:51:00",
                "Content": "Just a reminder: on the 64-bit JIT, for value types > 64-bit in size there is a potential performance minefield when interacting with the \"tail\" IL instruction."
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-03-01T05:42:00",
                "Content": "RFC created! https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1006-struct-tuples.md"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-09T09:36:00",
                "Content": "Great idea! But I am not a big fan of the syntax. Other than the possible syntax ambiguities mentioned in the RFC, it would be inconsistent with the records and unions compiled to struct, which are going to use the \"Struct\"-attribute. The \"Struct\"-attribute is also more flexible as it can be placed on top of the type, which looks much cleaner. I also don't like seeing even more parenthesis in my code, which are currently part of the RFC. An alternative to the \"Struct\"-attribute, e.g. [<Struct>] int * int, would be to use syntax similar to how `byref is specified`, which is actually a type. E.g. Struct<int * int>.\r\nStructness inference seems to be an essential feature (rather than an optional feature). Otherwise, it would be no fun working with struct tuples.\r\nI don't really understand the value-add of tuple field metadata.I think that if you want to name the components and have them be part of the type, then you should simply use a (struct) record since that what it's for."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed, see https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1006-struct-tuples.md\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6153074": {
        "Number": "6153074",
        "Submitter": "Cameron Taggart",
        "Submitted": "2014-07-09T00:00:00",
        "Title": "replace COM PdbWriter with F# PdbWriter",
        "Text": "Please replace the COM based PdbWriter and with a fully managed F# PdbWriter that can be used on Mono on Linux too. As adoption of F# increases on Linux, it is important that debugging binaries be able to be shared. Source indexing leverages pdb files and this would be great to have on Linux as well.\r\nI wrote SourceLink which is an F# project with an Apache License. It is able to read the Root and Info streams of a pdb. It could be used as a starting point. I was hoping to be able to reverse engineer the entire pdb file, but it is a fairly difficult task without access to some of the legacy source code or Microsoft engineering support.\r\nhttps://github.com/fsharp/FSharp.Compiler.Service/blob/master/src/absil/ilsupp.fs#L867\r\nhttps://github.com/ctaggart/SourceLink",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-03T04:58:00",
                "Content": "Hi Cameron,\r\nThat would be great - but do you know of an appropriately licensed and available F# PDB writer?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-03T04:58:00",
                "Content": "(Or even a spec for the PDB format)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:41:00",
                "Content": "Appropriate changes to PDB/MDB/... writing are happening as part of the CoreCLR work. I'll close this as while we will continue to use the COM PDB writer, other writers will be in managed code AFAIK"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per comment by Don Syme"
        }
    },
    "6153846": {
        "Number": "6153846",
        "Submitter": "Chojrak",
        "Submitted": "2014-07-09T00:00:00",
        "Title": "Make curly braces in record type definition optional",
        "Text": "Since we have indentation, the braces are not needed. It's a relict of dark ages. It'd be nice to have:\r\ntype Person =\r\nFirstName : string\r\nLastName : string\r\ninstead of\r\ntype Person = {\r\nFirstName : string\r\nLastName : string }",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Chojrak",
                "Submitted": "2014-07-10T11:20:00",
                "Content": "I would like to extend this suggestion to also cover computation expressions. They are also indented, so curly braces can be thrown out for good!"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-08-17T03:05:00",
                "Content": "The braces are still needed to construct a record value, and I like the visual similarity between the way a type is declared and the way it is used.\r\nAs for computation expressions, a brace-less syntax would be ambiguous. Considering that the word that introduces a CE (such as \"async\" or \"seq\") is actually not a keyword but an object, and that we can also define custom operations (such as query's \"where\", \"select\" and co), it would be impossible to distinguish between a CE and a function call whose arguments are indented on the next line."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:52:00",
                "Content": "My assessment is that this creates too much ambiguity between classes and records. Records have sufficeintly different semantics (especially with regard to strucutral equality and comparison) that we don't want to conflate these too much.\r\nAlso, for symmetry there would need to be matching removal of the braces in expression and patterns, which is not going to be at all easy.\r\nFor these reasons I propose to decline."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "See comments above\r\nDon Syme, BDFL F# Language Evolution"
        }
    },
    "6181848": {
        "Number": "6181848",
        "Submitter": "Isaac Abraham",
        "Submitted": "2014-07-16T00:00:00",
        "Title": "Provide better support for structural typing",
        "Text": "In F#3 you can declare a function which can operate on e.g. records which has no relation aside from the fact that they share e.g. field name + type. This can occasionally be useful - however, the syntax for achieving this is somewhat awkward e.g. http://codebetter.com/matthewpodwysocki/2009/06/11/f-duck-typing-and-structural-typing/\r\nIf there were a more succinct way to achieve this, it could be a very powerful feature e.g.\r\ndecorating a function with [<StructuralTyping>] to automatically indicate to the compiler to infer the implicit structure of the type, or at least simplifying the syntax to not have to mess around with \"'a member\" etc..",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2014-08-27T12:35:00",
                "Content": "structural typing is in general very useful, and can avoid using the OO-style inheritance in many places.\r\nWould be nice if F# supports typeclass, and implements this particular type of structural typing in the framework of typeclass. Something like:\r\ntypeclass ClassName = { property_name: type; ... }\r\nand every record type that has all the listed fields automatically becomes an instance of the typeclass."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-09-12T05:47:00",
                "Content": "I really like the way Typescript does this. You can either use an interface (the object in question does not have to explicitly implement the interface to satisfy it, although it can) or you can declare the 'shape' of the object inline. Such as:\r\nclass Person\r\n{\r\nconstructor(public name : string)\r\n{}\r\n}\r\nvar sayHello = function (named : { name : string })\r\n{\r\nreturn \"Hello \" + named.name;\r\n}\r\nsayHello(new Person(\"John\"));"
            },
            {
                "Submitter": "Tobias Burger",
                "Submitted": "2014-12-12T08:46:00",
                "Content": "Would be cool to have a structural type syntax like in TypeScript. Especially for interop scenarios, where often a type/class is needed for binding.\r\ntype PersonController() =\r\ninherit ApiController()\r\nmember __.GetGreeting(person: { name: string; age: int }) =\r\nsprintf \"hello %s, you are %i years old\" person.name person.age"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:20:00",
                "Content": "Strucutral subtyping is hard to implement within the constraints of the .NET type system. Any implementation would effectively have to erase to property bags at compile time. See the discussion here for example: http://fslang.uservoice.com/forums/245727-f-language/suggestions/9633858-structural-extensible-records-like-elm-concrete. This representation would also not work particularly well with .NET reflection.\r\nHow bad is this? Well, for normal F# use it is quite bad. But for lower-performance information-representation scenarios it may not too bad.\r\nI'll leave this open as a general placeholder for votes on \"better structural subtyping\""
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-08-12T07:05:00",
                "Content": "Don - I'm not really sure if I'm thinking along the same lines here - I'm thinking for just syntactic sugar for either the duck-typing support that already exists in F#. I don't even know how this works internally (is the structural constraint erased at runtime? what's the signature of the method at runtime?).\r\nThis could even be something that was erased away at compile-time and resorted to something less than that at runtime (in a similar way to units of measure?). I don't know :-)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6183592": {
        "Number": "6183592",
        "Submitter": "trek42",
        "Submitted": "2014-07-17T00:00:00",
        "Title": "Allow overloading based on unit of measure",
        "Text": "It will be very useful if we could e.g.,\r\n[<Measure>] type rad\r\n[<Measure>] type deg\r\nand call Math.Cosine(10.0<rad>) and Math.Cosine(10.0<deg>).\r\nThis can be useful in other scenarios, such as using one function \"toSecond\" to convert from <hour>, <minute>, etc.\r\nCurrently this is not allowed because after removing the measure tag these two functions have the exact same signature. There is a way to workaournd this by adding a dummy DU and using duck type (similar to http://stackoverflow.com/questions/21862335/f-operator-overloading-for-conversion-of-multiple-different-units-of-measure), but this seems too hacky. (plus, the DU is not optimized away in debug mode and makes testing more expensive due to garbage collection pressure).\r\nProposal: we could give these methods different [<CompiledName>] attributes to avoid conflicts, and compiler should then allow them to have the same name in FSharp, like\r\n/// This should compile fine because these methods don't conflict in compiled assembly.\r\ntype Math =\r\n[<CompiledName(\"CosineRad\")>]\r\nstatic member Cosine(x: float<rad>) = ...\r\n[<CompiledName(\"CosineDeg\")>]\r\nstatic member Cosine(x: float<deg>) = ...",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-03T00:00:00",
            "Text": "Unfortunately limitations on compiled .NET code mean that this is not possible – .NET requires that erased signatures be distinct.\r\nDon Syme, Current BDFL for F# Language Evolution"
        }
    },
    "6193110": {
        "Number": "6193110",
        "Submitter": "Demetrios Obenour",
        "Submitted": "2014-07-19T00:00:00",
        "Title": "Add StructOption<T>",
        "Text": "Currently, whenever a new Option is created, a heap allocation is required. This comes at a performance penalty.\r\nI suggest that a new type StructOption<T> be made available for performance.",
        "Votes": 59,
        "Comments": [
            {
                "Submitter": "Arbil",
                "Submitted": "2014-07-20T02:53:00",
                "Content": "This is much needed. For maximum performance, is there a reason why options on reference types cannot be just syntactic sugar on `null`? By that I mean that for both `T` and `T option` the underlying type is just `T`, and matching on option is compiled to `if opt = null then..;else..`."
            },
            {
                "Submitter": "Demetrios Obenour",
                "Submitted": "2014-07-20T12:14:00",
                "Content": "I agree with Arbil. This would have the further advantage that Option<T> could be restricted (as a .NET type in the CIL) to where T is a struct -- so Option<T> would not box the struct.\r\nIf this is not possible, use two types: one where T is a reference type, and one where T is a value type -- it is not acceptable for Option<T> where T is a struct to box the struct."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-07-21T06:03:00",
                "Content": "\"Also, it would be nice if there was a way to create an Option<T> type (where T is a struct) without boxing the struct.\" This is already the case. Option is a proper generic type, when T is a value type the jit will create new instances of Option so that the value stored does not need to be boxed (Same way List<T> doesn't box value types).\r\n\"For maximum performance, is there a reason why options on reference types cannot be just syntactic sugar on `null`?\" I figure generics throw a spanner in the works here, if you have a generic method that takes a generic option that has to be done with the proper option class to support being able to pass both structs and classes in (structs couldn't be passed in as null, and nullable<T> is a totally different type).\r\nIt's probably possible to have an optimization pass that erases instances of Option<class> to just class and replaces matches/instance methods (e.g. opt.IsNone becomes (opt == null)). There's probably some corner cases where you can't erase every instance, and of course if changes your public API which you may or may not be wanted, but it sounds possible.\r\nYou could probably do a similar pass with Option<struct> to Nullable<T>. Nullable is a value type so it could help with performance and GC pressure, but that probably has even more corner cases."
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T10:41:00",
                "Content": "Having a compiler flag to desugar options on reference types as null would increase performance when writing F# to be compiled into other languages like JavaScript."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-09-21T05:01:00",
                "Content": "This is not purely an optimization though, it changes the semantics of the language. Currently, None and Some null are different, whereas with this proposal they would be equal."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-05T09:07:00",
                "Content": "None is represented as null in compiled code due to [<CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)>] applied on Option<'T>. So, only Some<'T> values are heap allocated."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2015-05-14T19:12:00",
                "Content": "This is tricky. If Option<'T> can be made into a struct, then discriminated unions should be made into structs."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:50:00",
                "Content": "I will mark this as approved in principle and we will open an RFC for it. We should add a StructOption<T> type to FSharp.Core.\r\nMore details are needed, but the intent is to augment FSharp.Core with a StructOption<'T> type that can be used as a substitute for the current option type in pattern matching etc. That will require ironing out many details.\r\nThe library functions using Option (e.g. choose) would not initially be redefined, that could be discussed in the RFC\r\nThe type would be opt-in, e.g. by opening a namespace or using a specific type name or StructSome/StructNone etc. Details will be discussed in the RFC"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Approved in principle, per my comment below.\r\nLink to RFC to follow\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6200089": {
        "Number": "6200089",
        "Submitter": "Paul",
        "Submitted": "2014-07-21T00:00:00",
        "Title": "Allow Extension properties setters in initializers",
        "Text": "I suggest we consider allowing ExtensionProperty=expr property setters in initializers.\r\nFor example\r\nC(ExtensionProperty = [1;2;3])\r\nOr for example to provide c# “add” pattern like support\r\ntype StackLayout with\r\nmember x.ChildrenInitializer with set (values : UIElement seq)=\r\nvalues |> Seq.iter x.Children.Add\r\nlet layout = StackLayout (Orientation = StackOrientation.Horizonta,\r\nChildrenInitializer = [Entry(Placeholder = “Username”);Entry()])",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Paul",
                "Submitted": "2014-07-22T19:03:00",
                "Content": "An initial implementation of this feature has now been submitted here:\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/EdwardPaul/PropertyInitializationExperiments"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T11:20:00",
                "Content": "I very much like this proposal, especially as i comes with a trial implementation that appears sound on a quick review.\r\nHowever, it would be great to get more eyes on this and get more votes for the featue. If you are on twitter, could you advocate for this feature using the #fsharp tag please."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-10T08:13:00",
                "Content": "Hi Paul,\r\nThere's a problem with your submission, could you take a look? Also you will need to sign the CLA for submitting to http://visualfsharp.codeplex.com\r\nOtherwise I think it's ready to go.\r\nThanks\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-16T10:49:00",
                "Content": "A speclet for this feature is here: https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/ExtensionPropertyInitializers.md"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-21T06:10:00",
                "Content": "Speclet is now here: https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/ExtensionPropertyInitializersDesignAndSpec.md"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "This has now been completed for F# 4.0+, see https://github.com/Microsoft/visualfsharp/pull/17 and https://github.com/fsharp/FSharpLangDesign/blob/master/FSharp-4.0/ExtensionPropertyInitializersDesignAndSpec.md"
        }
    },
    "6201317": {
        "Number": "6201317",
        "Submitter": "Dmítrij Jevgénijevič Ačkásov",
        "Submitted": "2014-07-22T00:00:00",
        "Title": "Add syntactic sugar for multiline entries to avoid hanging brackets",
        "Text": "Hanging brackets are bad why don't we replace those with initial opening bracket in multiline implementations and drop the closing one? The same way we use | and |> for multiline statements for the sake of symmetry? :)\r\nFrom this:\r\ntype ComplexNumber =\r\n{\r\nreal: float;\r\nimaginary: float\r\n}\r\nlet array = [|\r\n{real = 3.0; imaginary = 0.0};\r\n{real = 2.0; imaginary = 0.1};\r\n{real = 1.0; imaginary = 0.2};\r\n{real = 0.0; imaginary = 0.3};|]\r\n\r\nTo this:\r\ntype ComplexNumber =\r\n{ real: float\r\n{ imaginary: float\r\nlet array =\r\n[| {real = 3.0; imaginary = 0.0}\r\n[| {real = 2.0; imaginary = 0.1}\r\n[| {real = 1.0; imaginary = 0.2}\r\n[| {real = 0.0; imaginary = 0.3}",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Interesting suggestion, but removing closing brackets would be a radical departure for F# syntax. Declining for now.\r\nDon Syme, current BDFL F# Language/Library Evolution."
        }
    },
    "6236793": {
        "Number": "6236793",
        "Submitter": "Johann Dirry",
        "Submitted": "2014-07-31T00:00:00",
        "Title": "Allow rational units",
        "Text": "In physics and electronics, units with rational exponents are very common, specially in the CGS system. Using it is more natural and makes many formulas easier and the computations more efficient.\r\nFurther, rational exponents are also unavoidable without changing the unit system. They are less common in the SI system, but ie. quantities with units like Watts^1/2 are common in electrical engineering.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Andrew Kennedy",
                "Submitted": "2014-10-17T08:08:00",
                "Content": "A number of people have suggested this. I'm currently prototyping the feature. Couple of design points\r\n* Syntax. Do we permit omission of parentheses e.g. float<kg^1/2> rather than float<kg^(1/2)>. We must disambiguate float<m^2/s> - this is possible, as we didn't previously expect an integer literal after the /. But is it desirable?\r\n* Genericity. \"Simplified form\" for type schemes is different now e.g. float<'u^2> -> float<'u^2> is equivalent to equivalent to float<'u> -> float<'u> indeed even to float<'u^(1/2)> -> float<'u^(1/2)>.\r\nBy the way, I would be interested in any good references to *essential* use of fractional exponents in units.\r\nAndrew."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/andrewjkennedy/fsharpcontrib/contribution/7632.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6236802": {
        "Number": "6236802",
        "Submitter": "Johann Dirry",
        "Submitted": "2014-07-31T00:00:00",
        "Title": "add support for dimensions and implicit unit conversions",
        "Text": "Dimensions could be described as discriminated unions of a set of units (Measure's). It should also be possible to convert units explicitly to the base unit.\r\n// some units\r\n[<Measure>] type Kelvin\r\n[<Measure>] type DegreeCelsius\r\n[<Measure>] type DegreeFahreinheit\r\n// Example: dimensions\r\n// Advantage: failwith condition not needed anymore, because of additional checking by the compiler -> less bugs\r\n[<Measure>] type Time = Second | Minute\r\n[<Measure>] type Temperature = Kelvin | DegreeCelsius | DegreeFahreinheit\r\nlet temperatureToSI (value : float<Temperature>) : float<Kelvin> =\r\nmatch value with\r\n| :? float<Kelvin> -> value\r\n| :? float<DegreeCelsius> -> (value - 273,15<DegreeCelsius>) * 1.0<Kelvin/DegreeCelsius>\r\n| :? float<DegreeFahreinheit> -> (value + 459,67<DegreeFahreinheit>) * 5.0<Kelvin> / 9.0<DegreeFahreinheit>\r\n// | _ -> failwith \"unknown temperature\"\r\n// Example: implicit unit conversion\r\n// Advantage: derived units always converts to base unit when used\r\n[<Measure>] type Second\r\n[<Measure>] type Minute (value:float) : (float<Second>) = value * 60.0<Second/Minute>",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:42:00",
                "Content": "We decided against this in F# 2.0 because it requires witness passing (i.e. passing extra arguments around in generic code and storing them in generic classes) , and it is not particularly apparent where the floating point conversions get applied in generic code\r\nI also would have though this issue might get more votes, and it's interesting to me that it has only one.\r\nI will mark the issue as declined as part of house keeping, though we're still interested in collecting more feedback on this"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. Marking as declined as part of house keeping per my comment below. However we’re still interested in collecting more feedback over time on this issue.\r\nDon Syme, F# Language Evolution"
        }
    },
    "6237585": {
        "Number": "6237585",
        "Submitter": "Yusuf Motara",
        "Submitted": "2014-07-31T00:00:00",
        "Title": "Allow \"inline\" keyword in the case \"let f = fun a -> ...\"",
        "Text": "Currently, the code \"let inline f = fun a -> ...\" does not compile, but the code \"let inline f a = ...\" does compile. Since the two mean the same thing, \"inline\" should be allowed on both.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "amazingant",
                "Submitted": "2015-03-21T21:01:00",
                "Content": "Posted an issue on the fsharp/FSharp.Compiler.Service repository over on GitHub here:\r\nhttps://github.com/fsharp/FSharp.Compiler.Service/issues/315\r\nDon Syme suggested either moving it to the Microsoft/VisualFSharp repository as a bug or posting it as a feature request here, and seeing as it's already mentioned here, I'll tag along for the ride.\r\nAdding my +3 for the time-being :)"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-05-21T17:09:00",
                "Content": "I have the exact same problem (also inspired by your suggestion in the comments on Haskell-style type annotations).\r\nI feel that this is a bug - not a feature request - because it is valid syntax and compiles to exactly the same code as the more standard 'let inline f a = ...'."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-05-21T17:36:00",
                "Content": "I've also posted this as a bug on https://github.com/Microsoft/visualfsharp/issues/467"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:30:00",
                "Content": "This is not something I see as a priority (because there is an adequate way of working around the problem), but a pull request (with adequate testing etc.) that implements this could well be accepted, assuming no gotchas are found along the way."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-07-11T08:15:00",
                "Content": "I'm changing this to be marked as \"approved\". This means someone can propose a PR for the issue. PRs should be submitted to http://github.com/Microsoft/visualfsharp."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-07-11T00:00:00",
            "Text": "This is approved for inclusion in a future release of F# subject to completion of an RFC and implementation.\r\nAn RFC can be submitted to https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nA pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp.\r\nDiscussion of the particular version for this to be included in can be made once an implementation is available."
        }
    },
    "6237671": {
        "Number": "6237671",
        "Submitter": "Steffen Forkmann",
        "Submitted": "2014-07-31T00:00:00",
        "Title": "add sortDescending to Seq, List and Array",
        "Text": "http://stackoverflow.com/questions/3111448/f-seq-sortby-in-descending-order shows that there are some strange edge cases if we want to use sortBy - it should be much easier than this.",
        "Votes": 7,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This proposal has been approved for inclusion in F# 4.0+.\r\nThe sortDescending and sortByDescending functions have been added to the list here: https://github.com/fsharp/FSharpLangDesign/blob/master/CoreLibraryFunctions.md\r\nThe work has now been submitted, reviewed and committed, see https://visualfsharp.codeplex.com/wikipage?title=Status\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "6257366": {
        "Number": "6257366",
        "Submitter": "David Tchepak",
        "Submitted": "2014-08-04T00:00:00",
        "Title": "Generate curried creation functions for records",
        "Text": "This suggestion is along the lines of [1], but for records.\r\n[1]: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663317-allow-to-use-class-constructors-as-functions\r\nIt can be handy to have curried creation functions for records.\r\nSay we have a record with a categoryId:\r\ntype Product = { categoryId : int; id : int; name : string }\r\nAnd we want to create a number of records with the same categoryId. If we have a curried creation method we could do something like:\r\n> type Product with static member create c i n = { categoryId = c; id = i; name = n };;\r\n> let createPl = Product.create 432;;\r\nval createPl : (int -> string -> Product)\r\n> createPl 27 \"F#\", createPl 42 \"Haskell\", createPl 123 \"C#\";;\r\nIt would be great to have the compiler generate this. I don't really have a preference for the syntax (create a function with same name as type? So in this case we'd also get a function `Product : int -> int -> string`?)",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Bartosz Przygoda",
                "Submitted": "2014-08-20T08:54:00",
                "Content": "WebSharper users would love this, as their formlets syntax suffer a bit from lack of such curried constructor (and you've got those fun x y z -> { ... } lambdas everywhere then)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-03T03:51:00",
                "Content": "It seems the natural thing in F# would be to allow the record type name to be used as an uncurried constructor allowing named arguments, e.g.\r\nProduct(3, \"three\")\r\nProduct(categoryId=3, name=\"three\")\r\n[ (3, \"4\"); (5, \"five\") ] |> List.map Product"
            },
            {
                "Submitter": "David Tchepak",
                "Submitted": "2014-09-16T20:33:00",
                "Content": "Hi Don,\r\nCurried helps for code like this:\r\nhttps://github.com/mausch/Fleece/blob/c8f7f59417d3b4c68b32a59fd45dd46a3778b977/Tests/Tests.fs#L26\r\nAlthough we can always call `curryX` I guess."
            },
            {
                "Submitter": "Huw Simpson",
                "Submitted": "2016-07-12T05:45:00",
                "Content": "Anyone know where the suggestion for the non curried constructor is, which Don refers to?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "I’m declining this particular suggestion because of the comment below – “It seems the natural thing in F# would be to allow the record type name to be used as an uncurried constructor allowing named arguments…”\r\nI will open a new suggestion for this.\r\nDon Syme\r\nCurrent BDFL F# Language/Library Evolution"
        }
    },
    "6272047": {
        "Number": "6272047",
        "Submitter": "Ted P",
        "Submitted": "2014-08-08T00:00:00",
        "Title": "Add support for default values in record types",
        "Text": "It would be able to define default values for fields in a record type definition so that those fields don't need to be set unless they differ from the default values.\r\nSimple example:\r\ntype TransactionLogEntry = {\r\ntimeStamp: DateTime;\r\nstate: string = \"Initial state\"\r\n}\r\nlet a:TransactionLogEntry = {timeStamp = DateTime.Now}\r\nHere by explicitly saying which record type we mean, we would not need to set the 'state' field since the default value is what we want in most cases. Yes, this could be accomplished through a factory method on the record type but this a nicer approach I think.",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-08-08T08:03:00",
                "Content": "This would be particularly useful for compilation to JavaScript (via WebSharper or TypeScript, although I can only speak for the former) when using external JS libraries. A very common pattern in JavaScript is the \"configuration object\", to pass named arguments as an object:\r\nmyLibrary.someFunction({arg1: 'test', arg2: 12})\r\nRight now the way we make this work in WebSharper is using a class with mutable properties:\r\nMyLibrary.SomeFunction(MyLibrary.SomeFunctionConfig(Arg1 = \"test\", Arg2 = 12))\r\nBut it's quite verbose. Records with optional or default values would allow us to be as succint as javascript:\r\nMyLibrary.SomeFunction({Arg1 = \"test\"; Arg2 = 12})"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-08-20T10:10:00",
                "Content": "I know it's more verbose than what you've got, but at the moment I do this which isn't too bad:\r\ntype TransactionLogEntry = {\r\ntimeStamp: DateTime;\r\nstate: string\r\n} with\r\nstatic member Default = {\r\ntimeStamp = DateTime.MinValue\r\nstate = \"Initial state\"\r\n}\r\nlet a:TransactionLogEntry = { TransactionLogEntry.Default with timeStamp = DateTime.Now }\r\nUnfortunately it requires that you give default values for all fields in order to keep the compiler happy."
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-08-21T08:07:00",
                "Content": "@Richard Gibson: Another inconvenient of your method is that every time you recreate the Default record, and then create another record with the updated fields. That's twice as many memory allocations as necessary. I guess you could do something like:\r\ntype TransactionLogEntry = { timeStamp: DateTime; state: string }\r\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\r\nmodule TransactionLogEntry =\r\nlet Default = { timeStamp = DateTime.MinValue; state = \"Initial state\" }\r\nBut it gets really verbose."
            },
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-07T10:32:00",
                "Content": "I agree with Loic, this would be very helpful when writing F# to be compiled to JavaScript in FunScript too."
            },
            {
                "Submitter": "Ted P",
                "Submitted": "2014-09-14T02:59:00",
                "Content": "An alternate syntax for instantiation which reads nicer could be:\r\nlet a = { TransactionLogEntry with timeStamp = DateTime.Now }\r\nwith the type name instead of an instance before the 'with' keyword."
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-02-28T07:40:00",
                "Content": "Would be better handled at library level if we had type class support:\r\nhttps://github.com/mauke/data-default"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:15:00",
                "Content": "The F# approach is that once you cross the boundary of needing record-type-invariants, or defaults, or extra internal state computed stored in hidden fields and so on, then you should switch to a class type. I think this also applies here: rather than trying to load more features into record types, we would say \"ok, if you want default, it's time to switch to a class type, and use optional named arguments in the class constructor\"."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:16:00",
                "Content": "For that reason we've always taken the approach not to add bells-and-whistles to the record type mechanism in F#. So I will apply a rule of consistency and mark this as declined."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2016-03-17T06:33:00",
                "Content": "I disagree. I don't see why adding default values are bad for records.\r\nInstead of:\r\ntype R =\r\n{ A: int = 0\r\nB: string = \"foo\"\r\nC: float }\r\nwe currently have to write:\r\n\r\ntype C(c: float, ?a: int, ?b: string) =\r\nlet a = defaultArg a 0\r\nlet b = defaultArg b \"foo\"\r\nmember __.A = a\r\nmember __.B = b\r\nmember __.C = c\r\nand we don't get record's `{ x with ... }` syntax and pattern matching.\r\nSo we have very primitive functional records and very OOP classes, so when we cannot fit what we want into the record concept we fall down to full blown C#-slyle boilerplate."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-03-17T06:37:00",
                "Content": "\"default\" records are incredibly common across F# codebases, it hardly seems worth it to switch to a class and lose the pattern matching benefits of records just to use optional named arguments in the constructor."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. It is quite a reasonable one. However I have marked it as declined for the reason listed below.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6323146": {
        "Number": "6323146",
        "Submitter": "Daniel Bradley",
        "Submitted": "2014-08-20T00:00:00",
        "Title": "Syntactically describe dependencies between files (by using '#requires', '#load' or extending 'open' syntax)",
        "Text": "With F# becoming more and more multi-editor and cross-platform, it is becoming increasingly difficult to teach all build/edit tools about F#'s file order. The F# community are currently struggling to \"update\" each new build/edit tool to understand that F# actually needs a file order.\r\nPart of the problem is that there is no standard textual way to specify this file order except as command line arguments, and these are not stored in an editable form. There is no standard way to specify the F# file order. We need an (optional) solution to this problem that is closer to home and doesn't involve modifying build/edit tools.\r\nThis proposal is one of three alternatives to deal with this problem in the F# language/compiler itself.\r\nThe specific proposal covered by this UV entry is to use #requrie declarations within files to specify a file order\r\n#require \"Helpers.fs\"\r\nThen, the compiler could automatically infer the dependencies between the files and not require files to be passed in pre-ordered by least dependent first.\r\nRelated alternative #3: Keep a file order, but optionally have it specified by a fileorder.fsx or fileorder.txt or fileorder.json: [/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx](/ideas/suggestion-13394442-optionally-specify-file-order-by-a-fileorder-fsx.md)",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:49:00",
                "Content": "Other suggestions have been\r\n#requires \"Helpers.fs\"\r\nor\r\n#load \"Helpers.fs\" (which already describes dependencies in scripts)\r\nSee also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6323146-describe-dependencies-between-files-by-extending"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-02-03T14:51:00",
                "Content": "See http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:29:00",
                "Content": "Closing this in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/10276974-allow-the-compiler-to-take-source-code-files-in-an"
            }
        ],
        "Status": "under-review",
        "Response": null
    },
    "6323201": {
        "Number": "6323201",
        "Submitter": "Daniel Bradley",
        "Submitted": "2014-08-20T00:00:00",
        "Title": "Aliases for namespaces",
        "Text": "[ Edited by admin to apply to namespaces only, since as per comment you can already do this with module aliases ]\r\nWhen using the ‘open’ keyword, allow a namespace being imported, to be assigned to an alias rather than the imported contents being made available to the current scope e.g.\r\nnamespace Foo = Some.Long.Path.To.Foo\r\nThis would be useful when importing namespaces containing modules/types with the same name to avoid fully qualifying all of the usages.",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-08-21T08:00:00",
                "Content": "You can already do:\r\nmodule Foo = Some.Long.Path.To.Foo\r\nUnfortunately you can't do that with namespaces, that would indeed be useful."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T14:08:00",
                "Content": "I edited the content to apply to namespaces only, since module aliases are already available."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:12:00",
                "Content": "My feeling is that we will not do this feature. You can already alias types and modules so can define alternative names for those inn ambiguous cases. You can also use \"global.Namespace1.Namespace2.....\" to disambiguate things. My feeling is that is sufficient in F# and also results in a good balance between code readability and aliasing."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. It is quite a reasonable one and it has taken me a long time to mark this as declined. However I have now done so for the reasons listed below.\r\nDon Syme, F# Language Evolution"
        }
    },
    "6323264": {
        "Number": "6323264",
        "Submitter": "Daniel Bradley",
        "Submitted": "2014-08-20T00:00:00",
        "Title": "Compiler integrated assembly imports from inside .fs files",
        "Text": "Would it be possible to integrate things like package management into the F# compiler without tying it directly to NuGet using something similar in concept to type providers, but for importing assemblies from (potentially) remote locations? I would imagine the usage of some specific examples of assembly providers might look something like:\r\nopen Github<\"fsharp/fsharpx\",\"1.2.3beta\">\r\nor\r\nopen NuGet<\"fsharpx\",\"1.2.3\">\r\nThe compiler would be agnostic to any specific platform, such as NuGet, but would provide an API, much like for type providers, to provide assemblies.",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "This is effectively a duplicate of [/ideas/suggestion-5670137--package-directive-to-import-nuget-packages-in-f](/ideas/suggestion-5670137--package-directive-to-import-nuget-packages-in-f.md)\r\nThe ideas aren’t identical. but it seems best to consider them as one."
        }
    },
    "6337095": {
        "Number": "6337095",
        "Submitter": "Mårten Rånge",
        "Submitted": "2014-08-23T00:00:00",
        "Title": "Allow use on let bindings in classes",
        "Text": "A common task in .NET is to implement is IDisposable.\r\nI find the most common task is implementing IDisposable on a class that have fields that are subclasses of IDisposable and no unmanaged resources.\r\nImplementing IDisposable is tedious and error prone. F# supports use on local bindings. Why not support it for member bindings as well?",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Mårten Rånge",
                "Submitted": "2014-08-23T17:12:00",
                "Content": "The title should read: Allow use on member bindings.\r\nNot sure if I can update it."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2014-08-24T08:16:00",
                "Content": "There's different ways of implementing IDisposable, it's not immediately clear what use on a member binding would do."
            },
            {
                "Submitter": "Kevin Ransom",
                "Submitted": "2014-08-28T12:23:00",
                "Content": "initial PR with a prototype implementation can be found here: https://visualfsharp.codeplex.com/SourceControl/network/forks/marten_range/visualfsharp/contribution/7318"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T10:56:00",
                "Content": "After consideration my belief is that this is too hard for F#, because of the reasons discussed in the PRs below: implementing disposal is best done explicitly. Also, when you consider things like the IAsyncDisposable pattern then I don't think it's necessarily the right thing to continue to hardwire F# as a language to the very imperative Dispose pattern."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. it’s definitely an interesting one and it took me a long time to decline it. I’ve listed the reasons below. It is possible we might reconsider this at some point, but for now marking it declined as I don’t think we can proceed with it in the language as things stand\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6343373": {
        "Number": "6343373",
        "Submitter": "Kevin Jones",
        "Submitted": "2014-08-25T00:00:00",
        "Title": "Allow defining extern methods in a class",
        "Text": "Currently it appears that extern methods for platform invoke only work properly when used inside of a module (see this discussion: http://stackoverflow.com/questions/22275072/why-does-the-f-compiler-give-an-error-for-one-case-but-not-the-other) this limitation poses problems when organizing your code in an efficient manner and results in having multiple modules defined (for an example, see here: http://stackoverflow.com/questions/25004314/working-with-safehandles-in-f)\r\nIt would be nice if extern methods could be defined in classes (and work correctly) even if the scope of the method is always limited to the type itself.",
        "Votes": 3,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "This is now “approved in principle” for some version of F# 4.x or beyond. It is entirely reasonable to eventually allow this for F#.\r\nHowever, because there is a workaround (using a module), and because the implementation and testing is a little complicated, involving new code paths, it may be that the feature is not seen as high priority. Only a fully implemented and tested feature would be accepted.\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, Current BDFL for F# Language Evolution"
        }
    },
    "6343892": {
        "Number": "6343892",
        "Submitter": "Mark Laws",
        "Submitted": "2014-08-25T00:00:00",
        "Title": "Allow custom get/set functions when declaring auto-properties (and fix a related FSI bug)",
        "Text": "Auto-properties are nice, but there should be a way of providing functions for the get and set methods so that e.g. setting a property can automatically call other side-effecting functions. In other words, it would be nice to be able to write this:\r\ntype foo(?boolguy, ?settyguy) =\r\nmember val boolguy = defaultArg boolguy true with get\r\nmember val x.settyguy = defaultArg settyguy 1 with get, set v = x.settyguy <- v; printfn \"hi\"\r\nRight now, you have to write this instead:\r\ntype foo(?boolguy, ?settyguy) =\r\nlet mutable _settyguy = defaultArg settyguy 1\r\nmember val boolguy = defaultArg boolguy true with get\r\nmember x.settyguy with get() = _settyguy and set v = _settyguy <- v; printfn \"hi\"\r\nThe proposed \"member val x.settyguy\" syntax would be a non-breaking change, because it's currently not legal syntax. In fact, there is a bug regarding this: in FSI, this passes without any warning or error:\r\ntype foo(?settyguy) =\r\nmember val x.settyguy = 1 with get, set\r\nmember x.settyguy = 1234\r\nlet () =\r\nlet q = foo()\r\nprintfn \"%A\" foo.settyguy // prints 1234\r\nIn FSC, the \"member val x.settyguy\" is flagged as an error.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-03T04:48:00",
                "Content": "For me, the second code you show gives an error about a duplicate definition, in both FSI and FSC"
            },
            {
                "Submitter": "Mark Laws",
                "Submitted": "2014-09-04T05:46:00",
                "Content": "Seems that FSI doesn't directly accept it, but in emacs fsharp-mode, if you put the second code into foo.fsx and do C-c C-f (fsharp-load-buffer-file), it passes."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-04T06:16:00",
                "Content": "That's very odd! I wonder if something unusual is going on in the emacs mode"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T11:07:00",
                "Content": "My view on this proposal is that the syntax is not really that good for F# as it stands. While the syntax using a \"let mutable\" is longer, it is regular uses existing constructs. Making further additions to the auto-property syntax at this stage doesn't seem the right tradeoff of value v. language-churn. It's possible we could revisit this in a later stage.\r\nFor now I think we should decline this - though it's not a bad idea as such."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-06T00:00:00",
            "Text": "Declining per comment. Please add additional information if you think this should be reopened.\r\nDon Syme, BDFL F# Language Evolution"
        }
    },
    "6343928": {
        "Number": "6343928",
        "Submitter": "Mark Laws",
        "Submitted": "2014-08-25T00:00:00",
        "Title": "Allow naming of member constraints",
        "Text": "Static type constraints are rather poorly documented on MSDN; there are few examples, their limitations are not well described (even less so the workarounds), and it's not made clear that you can use them in a manner such as the following example:\r\nmodule qasd =\r\ntype foo = {\r\nquack : int\r\nother : bool\r\n}\r\ntype bar = {\r\nquack : int\r\nblah : double\r\n}\r\ntype 'a qwop = { quack : int; hooblor : 'a }\r\nlet qx = { quack=0; other=true }\r\nlet qz = { quack=1; blah=1.0 }\r\nlet aa = { quack=2; hooblor=\"aaaaa\" }\r\nlet inline m x =\r\nmatch (^t : (member quack : int) (x)) with // <- HERE\r\n| 0 -> 1\r\n| 1 -> 2\r\n| _ -> 3\r\nlet asdfasdfsad = m qx\r\nlet aldfjasdk = m qz\r\nlet aldcjklz = m aa\r\nThe issue is that this doesn't work:\r\nmodule asdlfjk =\r\ntype foo = { quack : int; other : bool }\r\nlet qx = { quack=0; other=true }\r\nlet inline m (x : ^T when ^T : (member quack : int)) =\r\nmatch x.quack with\r\n| 0 -> 1\r\n| 1 -> 2\r\n| _ -> 3\r\nlet asdfasdfsad = m qx\r\n^T gets constrained to type foo. This is surprising, and the solution is rather unintuitive. I'm not sure if this should be simply a documentation fix (because changing it is incompatible with the existing behavior) or whether some sort of new construct should be introduced.\r\nAt any rate, there should be some way of \"naming\" member constraints so that you don't have to repeat them constantly and to make them easier to invoke.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-10-21T07:58:00",
                "Content": "I would like this idea to be extended to more than one member constraint. That is, I would like to name a set of member constraints. For example:\r\nx : ^T when ^T : (member quack : int) and (member walk : int))\r\nIt would be even better if I could name a set of member constraints that would be valid (and enforced) outside of a particular inline function, therefore reusable across many inline functions. For example:\r\n[<Constraints>]\r\ntype Duck =\r\nabstract member quack : unit -> int\r\nlet inline m (x : ^T when ^T <: Duck) =\r\nmatch x.quack() with\r\n| 0 -> 1\r\n| 1 -> 2\r\n| _ -> 3"
            },
            {
                "Submitter": "Greg Rosenbaum",
                "Submitted": "2015-03-16T10:37:00",
                "Content": "Okay, I've done a writeup on a type system feature called 'inline traits' that replicates this behavior in more concrete terms, with syntax examples. It captures the power of statically resolved member constraints and turns them into a part of the type system.\r\nhttps://gist.github.com/GregRos/fcc103e777fa13a575bf\r\nAn earlier idea of making these things work like interfaces doesn't work well. It either reduces the power of member constraints or makes them break polymorphism in pretty weird ways. As it is, it's a bit weird that conforming to an inline trait isn't inharitable."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T18:32:00",
                "Content": "I have incorporated your suggestion in my suggestion for \"Interfaces as simple, reusable and named sets of member constraints on statically resolved type parameters\": http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-06-22T05:32:00",
                "Content": "Declare them as inline functions -\r\nlet inline quackfn x = ( ^t : (member quack : int) x)\r\nlet inline m2 x =\r\nmatch quackfn x with\r\n| 0 -> \"zero\" | 1 -> \"one\" | _ -> \"two\""
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:33:00",
                "Content": "Closing in favour of suggestions http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m and http://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing in favour of suggestions http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m and http://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct"
        }
    },
    "6358998": {
        "Number": "6358998",
        "Submitter": "Nikon the Third",
        "Submitted": "2014-08-28T00:00:00",
        "Title": "Add match! (match-bang) to computation expressions",
        "Text": "Often I come across code like this:\r\nasync {\r\nlet! value = readValueTask\r\nmatch value with\r\n| ...\r\n| ...\r\n}\r\nwhere value has to be bound using let! and is only ever used in the following pattern match.\r\nIt would be nice to just write:\r\nasync {\r\nmatch! readValueTask with\r\n| ...\r\n| ...\r\n}",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-03T04:45:00",
                "Content": "The conflict with the proposed syntax for \"joinads\" seems like a problem here\r\nSee [/ideas/suggestion-5663965-integrate-joinads-extension](/ideas/suggestion-5663965-integrate-joinads-extension.md)"
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-05-24T00:51:00",
                "Content": "The joinads proposal is also closed, so could we reopen this one?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-06T00:00:00",
            "Text": "Declining due to the conflict with the Joinads proposal., see comment below.\r\nDon Syme, BDFL F# Language Evolution"
        }
    },
    "6359526": {
        "Number": "6359526",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2014-08-28T00:00:00",
        "Title": "Add 'serializable' and 'blittable' constraints for types",
        "Text": "I think it would be a good idea to let the F# compiler reason about serializable types. This could be implemented along the lines of the 'comparison' constraint, i.e. based upon an assortment of criteria for deciding when it is satisfied.\r\nFor instance, a type could be statically deemed serializable iff\r\n* it is primitive, string, byte array, etc.\r\n* It is a subtype of System.Exception\r\n* it is a managed class or struct that carries the Serializable attribute.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "thinkb4coding",
                "Submitted": "2014-08-28T11:07:00",
                "Content": "That could be useful, it would avoid knowing this only at runtime.. But It makes me wonder if it could not be more generic and that you could create your own constraint that would run at design and compile time (like done with Type Providers)..\r\nThis way you could check various things about types used in a function to validate that behavior will be correct then at runtime... thoughts ?"
            },
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2014-08-28T11:48:00",
                "Content": "@thinkb4coding you mean having arbitrary pluggable type predicates? I'm not even sure what the consequences would be to that."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:13:00",
                "Content": "I've combined this with the suggestion for \"blittable\" types: http://fslang.uservoice.com/forums/245727-f-language/suggestions/9989010-add-blittable-type-constraints-in-order-to-support"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-08T14:12:00",
                "Content": "I think \"serializable\" and \"blittable\" are two completely different issues and should be kept seperate. Serialization is an abstract concept that can apply to any proper data type and \"blittable\" seems to be about unmanaged types (I don't really understand what blittable means).\r\nI find serialization via attributes and Reflection less than ideal (slow and unsafe). The C# team actually wants to get away from serialization via Reflection."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6367266": {
        "Number": "6367266",
        "Submitter": "Loic Denuziere",
        "Submitted": "2014-08-30T00:00:00",
        "Title": "Add combinators in the Async module",
        "Text": "I think the Async module could use some extra functions, such as:\r\n* Async.Map : ('a -> 'b) -> Async<'a> -> Async<'b>\r\n(self-explanatory)\r\n* Async.Bind : ('a -> Async<'b>) -> Async<'a> -> Async<'b>\r\n(I guess this would just be a curried, static version of async.Bind)\r\n* Potentially other classic functor/monadic operations (filter, etc)\r\n* Async.ParallelChoice : seq<Async<'a>> -> Async<'a>\r\n(similar to Async.Parallel, except it stops as soon as one returns and cancels the others)\r\nMost functor/monadic operations are trivial to implement for yourself, but would still be nice to have as standard. ParallelChoice, on the other hand, is not obvious to get right and is useful even if you exclusively use a computation expression style (I've seen it requested several times on Stack Overflow).",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-05T02:58:00",
                "Content": "FSharpx contains all these and much more https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/ComputationExpressions/Monad.fs#L27\r\nExtCore contains lots of stuff like AsyncChoice, AsyncMaybe, StatefulChoice and so on, see the list of available computation expressions here https://github.com/jack-pappas/ExtCore/blob/e693e34ecc9ad4649fe08f1bb75c2531d992d147/ExtCore/Control.fs#L1725\r\nAlso ExtCore contains a bunch of modules that allow operations on collections of monadic values, like this https://github.com/jack-pappas/ExtCore/blob/e693e34ecc9ad4649fe08f1bb75c2531d992d147/ExtCore/ControlCollections.AsyncChoice.fs#L31\r\nPersonally, I reference ExtCore (and often FSharpx) in every F# project, so I see no value to add a (small) subset of the mentioned functionality right into FSharp.Core."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2015-04-05T12:02:00",
                "Content": "Here are some examples where Async.map would have been useful:\r\n- http://stackoverflow.com/a/6793961/126014\r\n- http://stackoverflow.com/a/29459410/126014\r\nWhile, as Vasily Kirichenko points out, it's available in FSharpx and other libraries, I never understood why it should be an argument against including such functionality in FSharp.Core. It's quite fundamental functionality that's isolated, in that it doesn't drag in unwanted dependencies. The fact that it's available in several add-on libraries is only an indication that this functionality is needed and missed."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:14:00",
                "Content": "Async.Choice has been added in FSharp.Core 4.4.1.0+ (not yet released_\r\nI think the others can be written with async { ... } easily enough and I agree with Vasily that they can go in other libraries, or in utility code."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-03-12T04:43:00",
                "Content": "Just my two cents... I can understand some of the larger pieces not being in FSharp.Core but some of the fundamental ones e.g. map, bind, iter should IMHO be there - I create them on virtually every project I work on."
            },
            {
                "Submitter": "Kevin Ransom",
                "Submitted": "2016-03-12T11:40:00",
                "Content": "If these are common and idiomatic, then having them in Fsharp.core ensures a consistent cross platform, cross profile implementation available and documented, and included in books.\r\nThe principle for including an API in the core library should be:\r\n1. It is generally applicable, I.e most programs would make use of it.\r\n2. It is platform agnostic, I.e it doesn't tie the core to a specific platform.\r\n3. It supports idiomatic F# programming styles\r\nAdding these or similar APIs to core will make them more generally available, and available with the same implementation all platforms."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-03-12T11:56:00",
                "Content": "I complete agree with Kevin Ransom's and Isaac Abraham's comments.\r\nThe issue isn't that these features are easy to write. The problem with most software isn't how easy or difficult it is to write, but how easy or difficult it is to read.\r\nProgrammers spend more time reading than writing code; often by orders of magnitude.\r\nWhile everyone can implement these features easily enough by themselves, there will be all sorts of slight variations. People will give the functions different names, or implement them slightly differently. This will slow down code reading, because whenever you encounter such a function, you can never be sure that it has behaviour identical to what you expect.\r\nOr, even worse, you'll assume that it behaves in a particular way, but this particular version behaves differently, and you'll now waste a couple of hours troubleshooting some subtle bug, and you can't see the source of it because your assumptions are invalid.\r\nPutting general-purpose logic into the core library will prevent such problems."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Declining per my comment (note, Async.Choice has been added in a separate request)\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "6368913": {
        "Number": "6368913",
        "Submitter": "Frank A. Krueger",
        "Submitted": "2014-08-30T00:00:00",
        "Title": "Add Array.foralli",
        "Text": "I seem to be joining two arrays of varying types quite often to do comparisons.\r\nFor example:\r\nlet nums = [| 0; 1 |]\r\nlet alphas = [| \"a\"; \"b\" |]\r\nlet compare n a = ...\r\nI would like:\r\nalphas |> Array.foralli (fun i a -> compare nums.[i] a)",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-09-03T07:05:00",
                "Content": "Note that you can use `Array.forall2` in your particular case."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Combining with http://fslang.uservoice.com/forums/245727-f-language/suggestions/6952125-create-filteri-functions-for-the-various-collect and treating that one as canonical as it has more votes"
        }
    },
    "6375455": {
        "Number": "6375455",
        "Submitter": "Blair Davidson",
        "Submitted": "2014-09-01T00:00:00",
        "Title": "discriminate union constructors",
        "Text": "Allow custom constructors for Discriminated Unions so that we can guard invariants on elements like regular classes",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T10:59:00",
                "Content": "Please add a concrete syntax proposal for this feature?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-06T00:00:00",
            "Text": "Declining for now until a more concrete syntax/design proposal is given (though that’s not to say it’s a bad idea…)"
        }
    },
    "6397168": {
        "Number": "6397168",
        "Submitter": "Steffen Forkmann",
        "Submitted": "2014-09-05T00:00:00",
        "Title": "add WebClient.AsyncDownloadFile/Data",
        "Text": "We already have Webclient.AsyncDownloadString http://msdn.microsoft.com/en-us/library/ee340415.aspx",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T10:59:00",
                "Content": "This seems reasonable given the existence of AsyncDownloadString."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/mexx24/visualfsharp/contribution/7566 and https://github.com/Microsoft/visualfsharp/commit/bb6711873a63ad4761c26ed63dfd754a3dce7bc6\r\nDon Syme, BDFL F# Language/Core Library evolution"
        }
    },
    "6402275": {
        "Number": "6402275",
        "Submitter": "Stanislaw Halik",
        "Submitted": "2014-09-06T00:00:00",
        "Title": "compexpr usage memory pressure",
        "Text": "Instantiating compexpr causes GC heap usage for all the DUs that are called as part of compexpr flow.\r\nThis automatic memory management caused by mere Bind/Return pessimizes certain workflows. No newtype infrastructure either.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T10:58:00",
                "Content": "Yes, though please convert this to a concrete design proposal."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "Declined as this is not a concrete design proposal.\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "6402339": {
        "Number": "6402339",
        "Submitter": "Don Syme",
        "Submitted": "2014-09-06T00:00:00",
        "Title": "Add \"chunkBy\" function to Seq/Array/List",
        "Text": "Left-to-right chunking has been a commonly requested functions for FSharp.Core over the years\r\nSee initial proposals at\r\nhttps://github.com/fsharp/FSharpLangDesign/issues/25",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-06T10:43:00",
                "Content": "This particular discussion will continue at https://github.com/fsharp/FSharpLangDesign/issues/25"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Was added in F# 4.0 as chunkBySize"
        }
    },
    "6405857": {
        "Number": "6405857",
        "Submitter": "Alfonso Garcia-Caro",
        "Submitted": "2014-09-07T00:00:00",
        "Title": "Add new expression like ForIntegerRangeLoop but with step value",
        "Text": "I guess there is a good reason that Expr.ForIntegerRangeLoop doesn't have a step argument, but I wonder why downto loops are not allowed in quotations. This could be also useful to optimize loops like:\r\nfor i in 0 .. 2 .. 10 do",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-09-16T11:23:00",
                "Content": "Thanks for reviewing the suggestion, Don. I was afraid that quotations couldn't be touched but I appreciate a lot your comment. I'll work in the direction you suggest and when I get satisfactory results, I'll share it with the community.\r\nCheers!"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "This suggestion is being declined for FSharp.Core itself because the primitive quotation forms supported are “fixed” and won’t be changed for backwards compatibility reasons.\r\nHowever it is possible to add new Expr.* and DerivedPatterns.* functions and/or active patterns to create and/or detect additional derived constructs.\r\nIt is possible a library of these routines should be developed and share between the F# community.\r\nDon Syme, Current BDFL F# Language/Library Evolution"
        }
    },
    "6420709": {
        "Number": "6420709",
        "Submitter": "mikero",
        "Submitted": "2014-09-10T00:00:00",
        "Title": "Allow record-like {obj with newvals...} syntax for arbitrary classes",
        "Text": "The { oldObj with newval1=x ... } syntax is great syntax - I'd like to see it available for other objects, whether they are defined in F# or not.\r\nI suggest:\r\n- If the object has an IRecordClone (or whatever) implementation (or simply an implementation of a required method), then call it first. This would allow the copying of private data, etc. It returns the new object.\r\n- If there was no pre-copy method to call, or after it runs, perform the standard record-like behavior of copying Public properties over to the new object.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "mikero",
                "Submitted": "2014-09-10T16:54:00",
                "Content": "- *Copying all but the override values*\r\n- and finally setting the new values, obviously"
            },
            {
                "Submitter": "mikero",
                "Submitted": "2014-09-10T17:07:00",
                "Content": "The related feature is to allow records to take part in inheritance"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "This is a duplicate of [/ideas/suggestion-5663704-copy-and-update-on-class-types](/ideas/suggestion-5663704-copy-and-update-on-class-types.md)"
        }
    },
    "6421736": {
        "Number": "6421736",
        "Submitter": "Alexander Baggett",
        "Submitted": "2014-09-10T00:00:00",
        "Title": "Implement CodeDOM APIs in F# core to allow designer support.",
        "Text": "",
        "Votes": 3,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-09-16T00:00:00",
            "Text": "An implementation of some of the CodeDom APIs is available at http://fsprojects.github.io/FSharp.Compiler.CodeDom with corresponding nuget package. Please contribute to that component.\r\nDon Syme, BDFL F# Language/Library evolution"
        }
    },
    "6427953": {
        "Number": "6427953",
        "Submitter": "Dave Thomas",
        "Submitted": "2014-09-12T00:00:00",
        "Title": "Expand F#'s Observable module to be more in line with Reactive Extensions",
        "Text": "With F#'s Observable module we only have:\r\nadd, choose, filter, map, merge, pairwise, partition, scan, split, subscribe.\r\nIt would be great to expand the default F# experience along the same lines that the Collections are being enhanced, adding in missing functions like: buffer, delay, interval, sample, throttle, timeout, timestamp, generate, etc",
        "Votes": 29,
        "Comments": [
            {
                "Submitter": "Phillip Trelford",
                "Submitted": "2014-09-12T09:14:00",
                "Content": "A while back I wrote a small extension library, MiniRx https://minirx.codeplex.com/ with many of the features you suggested which has now been bundled up and maintained in FSharpX: https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/Observable.fs\r\nIt might be interesting to cherry pick some of the methods and add them to FSharp.Core."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-09-16T04:49:00",
                "Content": "I agree this should be done, though as a full, independent, cross-platform, properly documented F# component and nuget package (e.g. see http://fsharp.org/community/projects). But my opinion is it should not be done in FSharp.Core.\r\nIn other words I'd like to see the Observable part stripped out of FSharpx and made into FSharp.Control.Observable nuget component. This should combine the best of the FSharpx.Observable and FSharp>Reactive etc. It can build on Rx if needed."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:48:00",
                "Content": "There is a relevant community project here: https://github.com/fsprojects/FSharp.Control.Reactive/"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "“Completed” is not quite the right tag to close this with but it’s certainly not “Declined”.\r\nThis topic is now in progress through the F# library https://github.com/fsprojects/FSharp.Control.Reactive/\r\nPlease use and contribute to this library, or use Rx directly.\r\nControl.Reactive may well need more work, but from the point of view of the language/core-library design, it is best that people use and contribute to that library.\r\nSee also https://github.com/fsprojects/FSharp.Control.AsyncSeq.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6449416": {
        "Number": "6449416",
        "Submitter": "Matthew Parkinson",
        "Submitted": "2014-09-17T00:00:00",
        "Title": "Automatically convert captured mutable locals into refs.",
        "Text": "There are several places where refactoring code can cause it not to compile due to captured mutable locals. For instance,\r\nlet mutable worklist = ...\r\nfor c in collection do worklist <- c::worklist\r\nIf this gets converted, to a data structure that doesn't work with \"for\" but does expose some form of iter method:\r\nlet mutable worklist = ...\r\ncollection.iter (fun c -> worklist <- c::worklist)\r\nThis doesn't compile, and you need to write\r\nlet worklist = ref ...\r\ncollection.iter (fun c -> worklist := c::!worklist)\r\nAlso, if you wanted to factor out the worklist adding code\r\nlet mutable worklist = ...\r\nlet add c = worklist <- c :: worklist\r\nfor c in collection do add c\r\nThe compiler could automatically insert the refs where necessary using a pretty simple analysis, and this awkward corner of when you can write mutable and when you can't would disappear.",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Mårten Rånge",
                "Submitted": "2014-09-17T13:42:00",
                "Content": "While I think the idea is nice and better than the implicit capture by value in C# I have some concerns\r\nlet c = x\r\nlet mutable c = x\r\nThe big difference here is that the compiler allows writes to c. AFAIK the generated IL is very similar.\r\nIf I understand your proposal *if* c was captured by a lambda it would then convert this into ref x.\r\nRefs in F# requires AFAIK an object allocation. The cost is small but not zero. In addition it generates more objects for the GC to collect.\r\nSome F# users are already concerned about certain idioms in F# requires object allocations when running on platforms with a weak GC (like XBOX).\r\nSo I would be somewhat reluctant to have non-zero cost changes to the generated code based on the subtle condition if a mutable variable was captured or not.\r\nBut chances are it's just me that thinks this way."
            },
            {
                "Submitter": "Matthew Parkinson",
                "Submitted": "2014-09-18T04:31:00",
                "Content": "@Mårten, thanks for your comment. It is very valid concern.\r\nThe compiler will throw out code based on \"subtle condition\"s, I think this may be a barrier to adoption for some users. We have to balance that against, the later problems of silent allocation for more constrained situations.\r\nI would propose we have a compiler option to give warning for this allocation. All existing compiling code would compile identically.\r\nThere are also many cases where the compiler would be able to optimise away the allocation due to inlining. If the closures gets inlined, then the code doesn't need to do allocation. At the moment, this is not possible, as the check occurs before the optimiser."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-10T11:03:00",
                "Content": "I've worked on this with Matt today and am happy with the design proposal. I've noticed a lot of beginners getting tripped up by the sudden switch between \"mutable\" and \"ref\" and over time I've come to believe that the regularity Matt proposes is a better place to be.\r\nThe design is\r\n(a) Implicitly promote local \"let mutable\" to a ref allocation when captured by closures, including object expressions, sequence expressions etc.\r\n(b) Give an optional (off-by-default warning) when this happens, similar to warning \"1182\" for unused variables"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-12T00:00:00",
            "Text": "This is now completed and available in preview releases of F# 4.0.\r\nFor an early Visual Studio preview release see here (cross platform releases will follow) – http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx\r\nDon Syme, F# Language Evolution"
        }
    },
    "6466039": {
        "Number": "6466039",
        "Submitter": "Patrick Q",
        "Submitted": "2014-09-21T00:00:00",
        "Title": "Add \"lengthBy\" function to Seq/Array/List",
        "Text": "Currently there is no function that returns a number representing how many elements in a specified collection satisfies a condition.\r\nFor instance consider what we need to do to count the number of odd numbers in a list:\r\nlet numbers = [ 5; 4; 1; 3; 9; 8; 6; 7; 2; 0 ]\r\nlet oddsCount = numbers |> List.filter (fun n -> n % 2 = 1) |> List.length\r\nIt would be much more efficient and convenient to have a lengthBy function to allow the following:\r\nlet oddsCount = numbers |> List.lengthBy (fun n -> n % 2 = 1)\r\nGetting a count based on a predicate is such a fundamental operation that I believe there should be a single dedicated function. In C# for instance there is an overload for the Count method that provides this functionality and it's equivalent absence in F# appears to be a bit of an oversight.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2014-09-21T07:11:00",
                "Content": "I think countBy do this job. So Seq.countBy is already available, so you can write\r\nlet oddsCount = numbers |> Seq.countBy (fun n -> n % 2 = 1)\r\ncountBy is planned for List and Array - see here https://github.com/fsharp/FSharpLangDesign/blob/master/CoreLibraryFunctions.md\r\nPR is here https://visualfsharp.codeplex.com/SourceControl/network/forks/forki/fsharp/contribution/7079#!/tab/comments"
            },
            {
                "Submitter": "Patrick Q",
                "Submitted": "2014-09-21T08:58:00",
                "Content": "Sergey, I initially had the same thought as you did, but the existing CountBy function provides very different functionality. For a given sequence, the result is sequence of tuples. Each tuple represents the result of the supplied function and the associated count.\r\nSo for \"let oddsCount = numbers |> Seq.countBy (fun n -> n % 2 = 1)\", the result is the sequence: seq [(true, 5); (false, 5)]. The proposed lengthBy function would simply return 5, representing the number of odd numbers in the collection."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:38:00",
                "Content": "This has been discussed in this thread : https://github.com/fsharp/FSharpLangDesign/issues/36\r\nMy conclusion is that adding \"Where\" variations of functions - e.g. countWhere, mapWhere etc. is not appropriate given the explosion of variations this would cause.\r\nPlease feel free to continue the discussion here."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "I’m marking this as declined since it is not included in the F# 4.0 FSharp.Core design. However please feel free to continue the discussion.\r\nDon Syme"
        }
    },
    "6468512": {
        "Number": "6468512",
        "Submitter": "Alex Baggett",
        "Submitted": "2014-09-21T00:00:00",
        "Title": "Add Named States (an extension of record types)",
        "Text": "Essentially it would let you add a name to specific set of values in a record. and reuse that set when initializing something to a specific state or configuration.\r\nIt would look something like this:\r\ntype Permissions = { clientServices: bool ; ManagesUsers:bool; InternalContact:bool;}\r\n|ProjectManager = {clientServices = true; ManagesUsers = false; IneralContact:true; }\r\n|Administrator = {clientServices = false; ManagesUsers = true; IneralContact:false; }\r\n|Recruiter = {ClientServices = false; ManagesUsers= true; InternalContact:true;}\r\ntype User = {FirstName :string; LastName; permissions:Permissions; }\r\nlet Stevo = {FirstName = \"Stephen\"; LastName = \"Rogers\"; permissions = Permissions.ProjectManager }",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-09-22T11:50:00",
                "Content": "How is this different from defining values in a module? Definition and usage would be almost unchanged. E.g.\r\ntype Permissions = { clientServices: bool ; ManagesUsers:bool; InternalContact:bool;}\r\nmodule Permissions =\r\nprojectManager = {clientServices = true; ManagesUsers = false; InternalContact:true; }\r\nadministrator = {clientServices = false; ManagesUsers = true; InternalContact:false; }\r\nrecruiter = {clientServices = false; ManagesUsers= true; InternalContact:true;}\r\ntype User = {FirstName :string; LastName; permissions:Permissions; }\r\nlet Stevo = {FirstName = \"Stephen\"; LastName = \"Rogers\"; permissions = Permissions.projectManager }"
            },
            {
                "Submitter": "Max Malook",
                "Submitted": "2014-09-25T13:03:00",
                "Content": "Sure it's something more concise that\r\ntype Permissions = { clientServices: bool ; ManagesUsers:bool; InternalContact:bool;} with\r\nstatic member ProjectManager = {clientServices = true; ManagesUsers = false; InternalContact=true; }\r\nstatic member Administrator = {clientServices = false; ManagesUsers = true; InternalContact=false; }\r\nstatic member Recruiter = {clientServices = false; ManagesUsers= true; InternalContact=true;}\r\nSo why this extended syntax?"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-05T02:46:00",
                "Content": "Agree with Max and exercitus vir - no need for this, just use let bindings in a module."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:34:00",
                "Content": "There are a number of proposals aroundn to extend the support for records in F# in ways that can fairly easily be programmed today by using either\r\n(a) object members on record types; or\r\n(b) a module of functionality related to the record type; or\r\n(c) an object type instead of a record type\r\nAll seem sufficiently good solutions and more general. Because of this, I agree with the comments below."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "Thanks for the suggestion! See comment above by me.\r\nDon Syme, BDFL for F# Language/Core Library evolution"
        }
    },
    "6474950": {
        "Number": "6474950",
        "Submitter": "citykid",
        "Submitted": "2014-09-23T00:00:00",
        "Title": "allow more flexible construction of structs",
        "Text": "in F# it is not possible to have a constructor for a struct that sets only some fields. For structs that have an expicit field layout (low level discriminating unions so to say) this is very prohibiting.\r\nc#\r\nstruct Point\r\n{\r\nprivate readonly int _x;\r\nprivate readonly int _y;\r\npublic Point(int x) : this() // Will set _y = 0, make this possible in fä\r\n{\r\n_x = x;\r\n}\r\n}\r\nf#\r\ntype Point =\r\nstruct\r\nval X: float\r\nval Y: float\r\nnew(x: float, y: float) = { X = x; Y = y }\r\nnew(x: float) = ? // how to call this() or new() here? <<<<<<<<======\r\nend",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:58:00",
                "Content": "You do this: https://gist.github.com/dsyme/4dc266348f47303f6b99\r\nOur use DefaultValue: https://gist.github.com/dsyme/2fceed8074e56f17a761"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:58:00",
                "Content": "Will close this since you can use the techniques below"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion! I’ve added links to how you can do this. Declining per my comments\r\nDon Syme, F# Language Evolution"
        }
    },
    "6475447": {
        "Number": "6475447",
        "Submitter": "Loic Denuziere",
        "Submitted": "2014-09-23T00:00:00",
        "Title": "Fix ReflectedDefinition for top-level pattern-matched let bindings",
        "Text": "Right now, when you do something like this:\r\n[<ReflectedDefinition>]\r\nlet (a, b) = (1, 2)\r\nThe compiled result is roughly equivalent to:\r\nlet private generatedIdent = (1, 2)\r\n[<ReflectedDefinition>] let a = fst generatedIdent\r\n[<ReflectedDefinition>] let b = snd generatedIdent\r\nAs you can see, the actual expression (1, 2) doesn't get reflected. This makes such definitions unusable for most use cases of ReflectedDefinition. As far as I can tell, this could be fixed by simply adding a ReflectedDefinition of generatedIdent.",
        "Votes": 9,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "I’ve marked this as approved for F# 4.x+.\r\nAn implementation and testing would need to be provided by someone in the F# community (possibly including Microsoft or Microsoft Research, though not limited to them). Currently, initial implementations of approved language design can be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details on contributing to the F# language and core library.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6499392": {
        "Number": "6499392",
        "Submitter": "Daniel Robinson",
        "Submitted": "2014-09-29T00:00:00",
        "Title": "Wildcard self identifiers",
        "Text": "Two underscores are frequently used in member definitions to denote an ignored \"self\" identifier. This seems like a hack given that the language already provides a wildcard pattern that represents an unused value.",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2014-09-29T11:16:00",
                "Content": "Forgot the link to the old VS UserVoice item: https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3745318-allow-wildcard-self-identifiers"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2014-10-10T01:48:00",
                "Content": "I think one underscore is enough to denote an unused \"self\" identifier. The language has to be consistent. One underscore has already been in use to denote an unused value in the match expression."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2014-10-15T16:59:00",
                "Content": "Thanks for the invitation. I hope to be able to contribute to the F# tools eventually, but my schedule won't allow it at present. Hopefully someone else will be willing to take this on."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-11-26T06:50:00",
                "Content": "Are self-identifiers actually needed at all? I know they're in there for historical reasons, but I don't see any actual use for them.\r\nConsidering F# still has the \"base\" keyword, I see no reason we can't use the normal \"this\" as well."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2014-12-08T10:43:00",
                "Content": "Richard, here's one use: http://stackoverflow.com/a/5356224/162396"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-07-20T22:34:00",
                "Content": "Isn't a single underscore just a convention? You can use any other lower-case letter or non-letter-character as a last match to match anything. It seems that the underscore itself has no special meaning in F# other than being allowed as type parameters without leading '."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "I’m marking this as approved in principle for F# 4.×. you are invited to submit a quality and tested implementation would be needed, to be submitted to http://github.com/Microsoft/visualfsharp.\r\nSee http://fsharp.github.io/2014/06/18/fsharp-contributions.html for details about contributing to the F# language and core library\r\nFWIW I’ve actually taken a look at this once or twice and it was surprisingly invasive to implement. But by all means give it a go and ask if you need help.\r\nDon Syme\r\nBDFL F# Language/Core Library Evolution"
        }
    },
    "6520906": {
        "Number": "6520906",
        "Submitter": "luketopia",
        "Submitted": "2014-10-03T00:00:00",
        "Title": "Allow infinite numeric sequences",
        "Text": "F# has various syntaxes for defining numeric sequences. Some examples:\r\n> { 0 .. 5 };;\r\nval it : seq<int> = seq [0; 1; 2; 3; 4; 5]\r\n> seq { 0 .. 5 };; // Same thing (seq keyword is optional)\r\nval it : seq<int> = seq [0; 1; 2; 3; 4; 5]\r\n> { 0 .. 2 .. 10 };;\r\nval it : seq<int> = seq [0; 2; 4; 6; 8; 10]\r\n> [for x in 0 .. 5 -> x * x];; // brackets can be omitted in for .. in loop\r\nval it : int list = [0; 1; 4; 9; 16; 25]\r\nI think it would be useful to omit the final argument to allow infinite sequences. I'm envisioning something like this:\r\n{ 1 .. } // The positive integers\r\n{ 2 .. 4 .. } // The positive even integers\r\nThese are IMO more readable than their Seq.initInfinite equivalents:\r\nSeq.initInfinite ((+)1)\r\nSeq.initInfinite (fun n -> 2 * (n + 1))\r\nWe could also use three dots for the final ellipsis to make the intent more explicit, but I'm not sure this is really useful.\r\nHaskell allows this functionality as follows:\r\n[ 1 .. ] -- The positive integers\r\n[ 2, 4 ... ] -- The positive even integers\r\nAnother nice thing Haskell allows you to do is count down with sequences, but attempting to do that with F# will result in an empty sequence.\r\nseq { -1 .. -2 .. -10 } // F# - empty sequence\r\n[-1, -2 .. -10 ] -- Haskell - all negative integers\r\nThat probably can't be changed due to backwards compatibility, and I'm not even sure if it would be desirable anyway.",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Christoph Rüegg",
                "Submitted": "2014-10-04T03:04:00",
                "Content": "Regarding counting down: \"seq { -1 .. -2 .. -10 }\" returns -1,-3,-5,-7,-9 for me, so it does seem to be supported (tried in LINQPad 4, not sure which F# version it uses)."
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2014-10-04T04:31:00",
                "Content": "Hmm... I must have tested it without including the step. In that case, it works just like Haskell, so you can ignore that last part. Good catch!"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:10:00",
                "Content": "I'm quite OK to leave infinite sequence literals out of F#. They are just a bit of a minefield waiting to go off when the sequence accidentally gets iterated. It think it's better to be much more explicit when creating infinite sequences. e.g. Seq.initInfinite etc."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion. Declined per comment below.\r\nBest regards\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "6521454": {
        "Number": "6521454",
        "Submitter": "Eriawan Kusumawardhono",
        "Submitted": "2014-10-04T00:00:00",
        "Title": "Add STM (Software Transactional Memory) feature into F# as language feature and into compiler as well",
        "Text": "STM, Software Transactional Memory is becoming not just relevant, but it's also for handling concurrency problems. Also to provide atomicity and also provide modularity in a sense of chaining functions of operations.eazily.\r\nAlso compositional operations is easier to create and it's transparent to reason the code.\r\nSample in Haskell:\r\nmodule Main where\r\nimport Control.Monad\r\nimport Control.Concurrent\r\nimport Control.Concurrent.STM\r\n\r\nmain = do shared <- atomically $ newTVar 0\r\nbefore <- atomRead shared\r\nputStrLn $ \"Before: \" ++ show before\r\nforkIO $ 25 `timesDo` (dispVar shared >> milliSleep 20)\r\nforkIO $ 10 `timesDo` (appV ((+) 2) shared >> milliSleep 50)\r\nforkIO $ 20 `timesDo` (appV pred shared >> milliSleep 25)\r\nmilliSleep 800\r\nafter <- atomRead shared\r\nputStrLn $ \"After: \" ++ show after\r\nwhere timesDo = replicateM_\r\nmilliSleep = threadDelay . (*) 1000\r\n\r\natomRead = atomically . readTVar\r\ndispVar x = atomRead x >>= print\r\nappV fn x = atomically $ readTVar x >>= writeTVar x . fn\r\nI gave this feedback to have 2 votes because this is very important but I understand this feature will require lots of sample cases and prototypes in the language.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-05T02:32:00",
                "Content": "It's approachable with computation expressions, no need for language support.\r\nFSharpx library contains an implementation here https://github.com/fsprojects/fsharpx/blob/43400739ac8957318f256dc9f669d0276de2499a/src/FSharpx.Core/Stm.fs and the famous Santa kata ported from Haskell here https://github.com/fsprojects/fsharpx/blob/b356a656c9c718fc2ff066d3fe2207fcca552de7/docs/content/Santa.fsx"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "As Vasily (Basil) indicates, this is approachable as a library in F#. There is no need to add anything to the F# language (though arguably some things could be added to the .NET runtime implementations, though that’s a different matter).\r\nDon Syme, BDFL F# Language/Core Library Evolution"
        }
    },
    "6528482": {
        "Number": "6528482",
        "Submitter": "Jack Fox",
        "Submitted": "2014-10-06T00:00:00",
        "Title": "Incorporate the Stream functions from Nessos/Streams into Core collections",
        "Text": "Efficient functional-style pipelines on streams of data. The main design behind Streams is inspired by Java 8 Streams and is based on the observation that many functional pipelines follow the pattern\r\nsource/generator |> lazy |> lazy |> lazy |> eager/reduce\r\nSource/generator are functions that create Streams like Stream.ofArray/Stream.init.\r\nLazy functions take in streams and return streams like Stream.map/Stream.filter, these operations are fused together for efficient iteration.\r\nEager/reduce are functions like Stream.iter/Stream.sum that force the Stream to evaluate up to that point.\r\nSee https://github.com/nessos/Streams\r\nand http://arxiv.org/abs/1406.6631",
        "Votes": 28,
        "Comments": [
            {
                "Submitter": "Jack Fox",
                "Submitted": "2014-10-06T09:42:00",
                "Content": "I'm making the perhaps Naive assumption that replacing the current Core.Collections module functions with their Streams equivalents is technically feasible. This may potentially be a breaking change for some users. There is nothing preventing you from putting a side effect into the Map function, for instance. Some behavior of that side effect could change. Therefore from the point of view of semantic versioning, F# 4.0 is the right time to do this."
            },
            {
                "Submitter": "Nick Palladinos",
                "Submitted": "2014-10-06T10:38:00",
                "Content": "Stream has different design center than Seq but they are complementary. Seq is based on a pull model (external iteration) and Stream is based on a push model (internal iteration). As an example Seq.zip cannot be implemented in Stream as an \"intermediate\" combinator but it can be implemented as a producer."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T11:31:00",
                "Content": "I don't think just replacing Seq by Stream is possible (Nick, tell me if I'm wrong), so it's unlikely we'll bring this into FSharp.Core. However I strongly encourage the use of the Nessos Stream library where appropriate."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Declining this because AFAIK Stream can’t be used as a replacement for Seq without either some semantic or performance changes. I think it is better we promote the use of Stream as a high-quality add-on library and continue to improve it.\r\nMore comments and input welcome though – perhaps Java 8 will gradually lead people to expect this in the core. But equally we have to be training people to select from available extra libraries."
        }
    },
    "6528970": {
        "Number": "6528970",
        "Submitter": "Robert Fuszenecker",
        "Submitted": "2014-10-06T00:00:00",
        "Title": "The base keyword shouldn't be a keyword.",
        "Text": "As the 'this' pointer is not a keyword, the 'base' identifier shouldn't be, too. We could use the form i.e.\r\ntype Derived() =\r\ninherit Base() as someBase\r\nmember myDerived.Print() =\r\nsomeBase.Print()",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-10-06T14:00:00",
                "Content": "Hi,\r\nCould be great in a more F#-ish way, i.e. inherit someBase = Base()"
            },
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-10-14T09:45:00",
                "Content": "@Anonymous: I prefer Robert's proposal because it mirrors the \"as this\" syntax that we already have."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:19:00",
                "Content": "I don't see there's anything much to be gained with changing this decision at this point. If you need to use \"base\" then use ``base``."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "See comment above.\r\nTo elaborate, the decision to make “base” a keyword as distinct from naming “this” was made in F# 1.×. We did consider allowing the naming of “base”, but decided against it, preferring to keep the OO-inheritance-base-call mechanism (which is kind of unpleasant) very syntactically distinct from the ability to name and recursively refer to “this” (which in to some extent can be used in nicely functional ways).\r\nIn general when decisions like this have already been made and are known, stable, tested and documented, then we are unlikely to change the decision unless it’s really critical to do so.\r\nThanks\r\nDon Syme, BDFL F# Language/Core Library Evolution"
        }
    },
    "6531829": {
        "Number": "6531829",
        "Submitter": "Robert Jeppesen",
        "Submitted": "2014-10-07T00:00:00",
        "Title": "Allow TypeProviders to supply location with errors",
        "Text": "When a custom type provider fails, the type provider will typically throw, there is not much else to do.\r\nI suggest to add the ability to add an error location when something fails. This would allow to pinpoint with squigglies where the error is in ie json/sql/whatever.\r\nPerhaps the simplest non-breaking implementation would be to add a known exception type that contains a file location and a range. So the TP still just throws, but adds this information where possible.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2014-10-30T06:58:00",
                "Content": "See also this proposal [/ideas/suggestion-5663288-allow-type-providers-to-report-warnings-to-the-com,](/ideas/suggestion-5663288-allow-type-providers-to-report-warnings-to-the-com,.md) these should probably be combined"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "Approved in principle for F# 4.0 (or later, depending), along with “allow type providers to report warnings”. subject to a suitable implementation being submitted. Both are entirely reasonable\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language/Library evolution"
        }
    },
    "6533279": {
        "Number": "6533279",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2014-10-07T00:00:00",
        "Title": "IDE improvement",
        "Text": "F# Depth Colorizer Extension for Visual Studio 2013 [1] offers an entirely different, light years better quality of coding and readability of code in F# and deserves to be part of Visual Studio rather than a separate extension. Please turn the depth-colorizing functionality offered by that extension into a default IDE feature and part of the F# Language Service. The ability to write code that's VERY easy-to-read and understand (available to everyone, not only those who downloaded and installed the extension) will have a positive impact on the language popularity and improve the F# position in the TIOBE Programming Community index.\r\nP.S. Xamarin Studio is also a good candidate to make this functionality available as a default IDE feature.\r\nReference:\r\n1. F# Depth Colorizer Extension for Visual Studio 2013 //http://visualstudiogallery.msdn.microsoft.com/07636c36-52be-4dce-9f2e-3c56b8329e33",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Виктор Милованов",
                "Submitted": "2014-10-13T02:09:00",
                "Content": "Why not just use the extension?"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2014-10-13T03:41:00",
                "Content": "Almost all modern IDEs provide syntax highlighting, but not a single IDE provides depth colorizing as a default feature. Programmers who are starting to learn F#, as a rule, do not know about F# Depth Colorizer Extension for Visual Studio. Only experienced programmers know about it. If the functionality offered by that extension were available for all F# programmers regardless of their experience of coding in F#, it would have a positive impact on the language popularity and easiness of coding."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "Please see the Visual F# Power Tools where this feature is available, http://fsprojects.github.io/VisualFSharpPowerTools/\r\nNote that since this suggestion related to the Visual F# IDE Tools rather than the F# language itself, it rightly belongs in https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools\r\nDon Syme"
        }
    },
    "6536829": {
        "Number": "6536829",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2014-10-08T00:00:00",
        "Title": "Implement OCaml's new match/exception syntax",
        "Text": "Implement the feature that is nicely described in the following post:\r\nhttps://blogs.janestreet.com/pattern-matching-and-exception-handling-unite/",
        "Votes": 42,
        "Comments": [
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2014-10-14T06:18:00",
                "Content": "Consider the following hypothetical example:\r\nlet readLines (reader : unit -> string) : string list =\r\nlet rec loop acc =\r\ntry\r\nlet l = reader ()\r\nloop (l :: acc)\r\nwith e ->\r\nList.rev acc\r\nloop []\r\nThis will make successive calls on a reader function until an exception is raised (e.g. IOException), after which the accumulated lines will be returned. The trouble with this example is that it is not tail-recursive, since the recursive call lies inside a try block. Typically, one would have to rewrite the above example like so:\r\nlet readLines (reader : unit -> string) =\r\nlet rec loop acc =\r\nlet result = try reader () |> Choice1Of2 with e -> Choice2Of2 e\r\nmatch result with\r\n| Choice1Of2 l -> loop (l :: acc)\r\n| Choice2Of2 e -> List.rev acc\r\nloop []\r\nThis is an extremely clumsy piece of code which also results in additional allocations. OCaml solves this problem by offering a unifying exception handling with pattern matching:\r\nlet readLines (reader : unit -> string) =\r\nlet rec loop acc =\r\nmatch reader () with\r\n| l -> loop (l :: acc)\r\n| exception e -> List.rev acc\r\nloop []\r\nThe above ensures that the recursive call is tail recursive, eliminates unnecessary allocations and is easy to read."
            },
            {
                "Submitter": "Joerg Beekmann",
                "Submitted": "2014-10-14T06:30:00",
                "Content": "This is a very nice solution; means production code can look just as nice as sample code!"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-14T06:47:00",
                "Content": "Looks very nice."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-10-14T13:41:00",
                "Content": "Just be careful, they use exceptions for flow control in OCaml because they're cheap on that runtime. On .NET exceptions are very expensive and should not be used for standard control flow. I would consider that IOException sample to be very bad form on .NET."
            },
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2014-10-14T14:42:00",
                "Content": "(Also continuing from https://twitter.com/eiriktsarpalis/status/521968130097049601)\r\nPerhaps the example I gave was a bit unfortunate (I basically just converted it from Yaron's blog post) but the annoyance still exists in F#. Even if exceptions are not intended for control flow, you still have very realistic use cases in which functions are passed lambdas with no particular guarantees on exception safety. In order for your code to be tail recursive, you have to give your code the Choice<_,_> treatment which I agree is more ugly than it is inefficient. A nice example is when implementing the continuation monad with exceptions, e.g.\r\ntype Cont<'T> = ('T -> unit) -> (exn -> unit) -> unit\r\nThe correct monadic bind will have to be implemented like this:\r\nlet bind (f : Cont<'T>) (g : 'T -> Cont<'S>) : Cont<'S> =\r\nfun sc ec -> f (fun t -> let r = try g t |> Choice1Of2 with e -> Choice2Of2 e in match r with Choice1Of2 s -> s sc ec | Choice2Of2 e -> ec e) ec\r\nWhereas with the match/exception syntax it would be like this:\r\nlet bind (f : Cont<'T>) (g : 'T -> Cont<'S>) : Cont<'S> =\r\nfun sc ec -> f (fun t -> let r = match g t with s -> s sc ec | exception e -> ec e) ec\r\nTo give you a bigger perspective, here is a somewhat complete continuation/exception monad implementation:\r\nhttps://github.com/nessos/MBrace.Cloud/blob/master/MBrace.Cloud/CloudBuilder.fs\r\nPerhaps one criticism to this feature would be that it might somehow encourage people to use exceptions as control flow? I don't quite see this, most people out there realise that .NET exceptions are expensive. Other than that, it might not be as common a pattern in F#, but I do come across it quite frequently myself."
            },
            {
                "Submitter": "Greg Chapman",
                "Submitted": "2014-12-03T14:08:00",
                "Content": "If we had something like Scala's Try, we could do the readLines example today.\r\ntype Either<'a,'b> = Left of 'a | Right of 'b\r\nlet Try f = try Right (f()) with e -> Left e\r\n{...}\r\nmatch Try reader with\r\n| Right l -> loop (l::acc)\r\n| Left e -> List.rev acc\r\nI wish F# had either Scala's notion of call-by-name, or (my preference) a nicer syntax for delayed expressions. For some reason, something like:\r\n{| expr |}\r\nreads nicer than:\r\n(fun()-> expr)\r\neven if they compile to exactly the same thing.\r\nIf {| expr |} was a syntax for a delayed expression, you could implement the bind example using:\r\nmatch Try {| g t |} with Right s -> s sc ec | Left e -> ec e) ec"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:55:00",
                "Content": "Eirik, what would be the desugaring in quotations and computation expressions?\r\nthanks\r\ndon"
            },
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2016-06-28T09:01:00",
                "Content": "Hi Don,\r\nI would imagine that desugaring (both in comp exprs and quotations) could take the following form. The code\r\nasync {\r\nmatch expr with\r\n| Pat1 -> cexpr1\r\n| Pat2 -> cexpr2\r\n| exception Pat3 -> cexpr3\r\n| exception Pat4 -> cexpr4\r\n}\r\nwould transform to\r\nasync.Delay(fun () ->\r\nmatch (try Choice1Of2 expr with e -> Choice2Of2 e) with\r\n| Choice1Of2 Pat1 -> cexpr1\r\n| Choice2Of2 Pat2 -> cexpr2\r\n| Choice2Of2 Pat3 -> cexpr3\r\n| Choice3Of3 Pat4 -> cexpr4)\r\nThis should work fine, assuming no match! feature is added to computation expressions in the future. In such a case, a match! implementation would have to manage the exception handling logic explicitly."
            },
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2016-06-28T09:10:00",
                "Content": "Similarly, the non-monadic expression\r\nmatch expr with\r\n| Pat1 -> expr1\r\n| Pat2 -> expr2\r\n| exception Pat3 -> expr3\r\n| exception Pat4 -> expr4\r\nwould desugar to\r\nlet mutable exn = Unchecked.defaultof<Exception>\r\nlet mutable result = Unchecked.defaultof<'T>\r\ntry result <- expr with e -> exn <- e\r\nmatch exn with\r\n| null ->\r\nmatch result with\r\n| Pat1 -> expr1\r\n| Pat2 -> expr2\r\n| Pat3 -> expr3\r\n| Pat4 -> expr4"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6538074": {
        "Number": "6538074",
        "Submitter": "amazingant",
        "Submitted": "2014-10-08T00:00:00",
        "Title": "Add support for Haskell-style type annotations",
        "Text": "Although it's typically preferred to let the compiler handle types, it is often necessary to provide type annotation. Sometimes this is to help the compiler understand the types a function can take, often it is done to help other developers understand your code, and in my personal use, I frequently add type annotations to ensure the compiler will catch typos I make which change a function's return type.\r\nAlthough not as verbose as other .NET languages, the F# type annotations do add verbosity to a function definition, look cluttered compared to Haskell's syntax (personal opinion), and do not match the type format provided by the compiler or interactive environment.\r\nI propose adding syntax to allow defining a function's type with a syntax closer to Haskell's. Since the :: operator is already in use, my proposal is to create a new operator such as => for these purposes; a new keyword could suffice as well, or simply new use of the val keyword currently used in signature files.\r\nMy initial suggestion is as follows:\r\nlet f => int -> int -> int\r\nlet f x y = x * y\r\nWhile the inclusion of variable names would reduce the terseness of the syntax and would provide little benefit to readability or comprehension, such a change would provide consistency with the format output by fsi.exe and seen in Visual Studio with IntelliSense. An more complex type signature with such a format:\r\nlet f => a:(int -> string -> int) -> x:string list -> y:int -> int list\r\nlet f a x y = List.map (a y) x\r\nIn these examples, neither of the code snippets would typically need type annotations, and the annotations here are much larger than the implementation itself. However, the former syntax (my preference) would greatly reduce the length of function declarations in more complex functions. The latter option, while I would prefer it over the current syntax, would introduce an additional location where variable names would have to be changed during refactoring.\r\nIt is my opinion that were such a syntax to be provided, use of both the new and current syntaxes together should provide a compiler warning to the effect of \"Multiple type annotations provided for function {0}. Consider removing extra type annotations to simplify refactoring of your code.\"",
        "Votes": 58,
        "Comments": [
            {
                "Submitter": "Loic Denuziere",
                "Submitted": "2014-10-14T09:42:00",
                "Content": "If we implement this (which I think would be a good idea), we should definitely use the same syntax as .fsi files.\r\nval f : int -> int -> int\r\nlet f x y = x * y"
            },
            {
                "Submitter": "Sergey Yavnyi",
                "Submitted": "2014-10-27T04:47:00",
                "Content": "Nice idea.\r\nAnother (but somewhat clunky) alternative that you can already use is\r\nlet f : int -> int -> int = fun x y -> x * y"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-11-06T04:41:00",
                "Content": "Sergey, thanks for pointing that out. Since this is already possible, it does not seem that this suggestion really adds much value."
            },
            {
                "Submitter": "amazingant",
                "Submitted": "2015-01-07T11:17:00",
                "Content": "@Sergey I agree that alternative looks a bit clunky, but it can be rearranged enough that I'm happy with it:\r\nlet f : int -> int -> int =\r\nfun x y -> x * y\r\nIt feels a little odd not adding a full indentation level, but the second line only needs one extra space (or tab, if you're one of those) beyond the indentation for the signature line; with just one space it still feels like the fun line is still part of the function header, without requiring the body of the code to gain another indentation level."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:02:00",
                "Content": "This is related: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6237585-allow-inline-keyword-in-the-case-let-f-fun-a"
            },
            {
                "Submitter": "Tobias Burger",
                "Submitted": "2016-01-11T07:55:00",
                "Content": "The more I code in Haskell/Elm/PureScript the more I like the way of how type are declared in this languages.\r\nYou can \"emulate\" this style by using an .fsi file alongside your .fs file, but the declaration and the implementation is physically separated and for scripts there is no way to declare this kind of type annotations.\r\nI'm with Loic: the declaration should be the same as for .fsi files.\r\nI find it easier to read/understand (and implement) the function by looking at the second declaration.\r\nlet map (mapper: 'a -> 'b) (m: M<'a>) : M<'b> = ...\r\nval map : ('a -> 'b) -> M<'a> -> M<'b>\r\nlet map mapper m = ..."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-01-16T01:39:00",
                "Content": "Never worked with Haskell, but after I've tried Idris I've started to miss having type annotations over my functions, or at least some of them...\r\nDeclaration style should ofc be same as in fsi files..."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T14:06:00",
                "Content": "Why not just this syntax?\r\nlet f : int -> int -> int\r\nlet f x y = x * y\r\nAlso what would be the syntax for \"member\" declarations? This?\r\nmember M : int -> int\r\nmember this.M(x) = x + 4\r\nAlso what would be the syntax for \"let rec\" declarations in a mutually recursive group?"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-02-10T13:42:00",
                "Content": "What about:\r\nf : int -> int -> int\r\nlet f x y = x * y\r\n...and ...\r\nM : int -> int\r\nmember this.M(x) = x + 4\r\nsame for let rec"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-11T11:55:00",
                "Content": "This is possible using the following (already supported) syntax:\r\nlet add : int -> int -> int =\r\nfun x y -> x * y\r\nThe only restriction is that you currently cannot add \"inline\" to the function value:\r\nlet add : int -> int -> int =\r\ninline fun x y -> x + y\r\nLifting this restriction has been requested and approved by Don Syme here, so someone just needs to propose a tested PR: [/ideas/suggestion-6237585-allow-inline-keyword-in-the-case-let-f-fun-a](/ideas/suggestion-6237585-allow-inline-keyword-in-the-case-let-f-fun-a.md)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6547517": {
        "Number": "6547517",
        "Submitter": "Will Smith",
        "Submitted": "2014-10-10T00:00:00",
        "Title": "Record types can be marked with the Struct attribute",
        "Text": "A simple idea, record types can become structs; effectively, allowing record types to have the performance characteristics of structs.\r\nExample:\r\n[<Struct>]\r\ntype Vector3 = { X: float32; Y: float32; Z: float32 }",
        "Votes": 64,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-10-10T16:20:00",
                "Content": "It was agreed upon that struct records should not be able to call their base ctor."
            },
            {
                "Submitter": "Will Smith",
                "Submitted": "2014-10-10T16:21:00",
                "Content": "https://visualfsharp.codeplex.com/discussions/569437 More Info"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-08-23T03:46:00",
                "Content": "It'd be fantastic if they supported the `with` keyword for copying"
            },
            {
                "Submitter": "Cameron Taggart",
                "Submitted": "2015-12-15T11:18:00",
                "Content": "This suggestion and \"short tuples compiled as structs\" [1] both regard increasing performance by using structs in certain situations. I would love to know more about which situations this benefits. I think it may be partially answered on stackoverflow.[2] Is there any difference in performance today with records and tuples?\r\nI've been hacking the F# AST lately. It is a discriminated union of tuples [3]. Would there be any performance difference if it was represented as a discriminated union of records? Would making it a discriminated union of struct records change its performance characteristics? I am not suggesting we change it. I'm just using it as an example.\r\n[1] [/ideas/suggestion-6148669-short-tuples-compiled-as-structs-up-to-25x-per](/ideas/suggestion-6148669-short-tuples-compiled-as-structs-up-to-25x-per.md)\r\n[2] http://stackoverflow.com/questions/521298/when-to-use-struct\r\n[3] https://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs#L415"
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-03-02T10:10:00",
                "Content": "See https://github.com/Microsoft/visualfsharp/pull/620 for the latest implementation"
            },
            {
                "Submitter": "Schmoopy",
                "Submitted": "2016-05-05T00:36:00",
                "Content": "This is FANTASTIC. I actually am updating my current base to convert a record to a struct for performance (the small type gets created millions of times which was not initially planned)"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-07T07:21:00",
                "Content": "This is a great idea. Can you add a bit more details what this would be translated to and how it can be used? Is this simply syntactic sugar for declaring an ordinary struct, but being able to use the (much nicer) syntax of records? Does a struct record still have a default non-overridable parameterless constructor? Does it support pattern matching and type inference?"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-07T08:10:00",
                "Content": "This feature has been merged. More information can be found here: https://github.com/Microsoft/visualfsharp/pull/620\r\nIt includes the answer to one of my questions: The default non-overridable parameterless constructor of structs exists, but cannot be called from F#. I guess {... with ...}, pattern matching and type inference will also work if this still a record."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-07T08:13:00",
                "Content": "Cross-reference to single case unions compiled as structs:\r\n- initial feature suggestion: [/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs](/ideas/suggestion-6147144-allow-single-case-unions-to-be-compiled-as-structs.md)\r\n- F# RFC FS-1014: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1014-struct-unions-single-case.md"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-17T00:00:00",
            "Text": "This feature is approved for inclusion in a future revision of the F# language\r\nThe RFC is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1008-struct-records.md\r\nThe implementation is almost done, please see the link in the RFC\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6555102": {
        "Number": "6555102",
        "Submitter": "Hans Rischel",
        "Submitted": "2014-10-13T00:00:00",
        "Title": "Add a Compare function with only three values Smaller, Equal or Greater",
        "Text": "// The below function\r\n//\r\n// compareWith: 'a -> 'a -> CompareWithResult\r\n// when 'a : comparison\r\n//\r\n// enables the convenient programming style:\r\n//\r\n// match compareWith x y with\r\n// | Less -> ...\r\n// | Equal -> ...\r\n// | Greater -> ...\r\n//\r\n// This is well-known in SML but not (yet) available in F#.\r\ntype CompareWithResult = | Less | Equal | Greater\r\nlet compareWith x y =\r\nif x < y then Less\r\nelse if x = y then Equal\r\nelse Greater",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T07:08:00",
                "Content": "For better or for worse, the ship has sailed on this. FSharp.Core already uses three representations of comparers\r\n1. the \"implicit\" comparison semantics of the \"compare\" operation\r\n2. Curried comparison functions T -> T -> int\r\n3. IEqualityComparer objects (which have an OO version signature of #2)\r\nAdding another representation of the return type for comparison would I think be too problematic for the overall library design. The decision to use an integer was effectively made in .NET 1.x and in F# 1.x we decided to stick with this decision."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-15T00:00:00",
            "Text": "Declined, see comment above"
        }
    },
    "6563758": {
        "Number": "6563758",
        "Submitter": "Daniel Bradley",
        "Submitted": "2014-10-15T00:00:00",
        "Title": "Add AsyncSeq, a sequence where each item is fetched asynchronously",
        "Text": "Incorporate asynchronous sequences with associated module (with similar methods to the Seq module) and computation expression builder.\r\nExisting implementations:\r\nFSharpx: https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/AsyncSeq.fs\r\nExtCore: https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Collections.AsyncSeq.fs",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Alfonso Garcia-Caro",
                "Submitted": "2014-10-15T03:45:00",
                "Content": "Using event streams in an ordered fashion seems to be the best fit for AsyncSeq, but as async APIs increase they may have other uses and it make sense to add them to the core. For example, I'm using them to handle async cursors in the HTML5 IndexedDB API."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-14T11:56:00",
                "Content": "I believe this should be done as an independent nuget package. It is extremely useful.\r\nI would recommend creating a new project at http://github.com/fsprojects/FSharp.Control.AsyncSeq and just getting this under way"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:38:00",
                "Content": "This is addressed through http://github.com/fsprojects/FSharp.Control.AsyncSeq. Please use that library."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Completed through the library linked in the comments"
        }
    },
    "6564576": {
        "Number": "6564576",
        "Submitter": "Robert Jeppesen",
        "Submitted": "2014-10-15T00:00:00",
        "Title": "Move user settings out of .fsproj file",
        "Text": "Command line parameters for debugging are stored in the F# project file. This makes it hard to keep your commits clean.\r\nMy suggestion is to do the same as C#, where this information is stored in .csproj.user, which is not put in version control.\r\nThis doesn't really have anything to do with the language itself, but it *is* part of the package.",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2014-10-15T08:14:00",
                "Content": "YES! Please do this."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T12:07:00",
                "Content": "This is really the Visual F# Tools, and not the F# language or core library.\r\nPlease move this to https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools. I think there is already a tracking item there.\r\nThanks!\r\nDon"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-10-15T12:08:00",
                "Content": "And ideally just make the submit fixes and tests to the Visual F# Tools code, what you request is entirely reasonable :)"
            },
            {
                "Submitter": "Robert Jeppesen",
                "Submitted": "2014-10-16T03:36:00",
                "Content": "Moved to https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/6568436-move-user-settings-out-of-fsproj-file"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-20T00:00:00",
            "Text": "Moved as discussed in the notes"
        }
    },
    "6564836": {
        "Number": "6564836",
        "Submitter": "Pierre Irrmann",
        "Submitted": "2014-10-15T00:00:00",
        "Title": "Add an active pattern to match constant decimal in quotations",
        "Text": "Just like there are active patterns to detect ints or longs in quotations, I think that it would be useful to be able to detect easily decimals. Today we have to match against a specific call to MakeDecimal, which is a compiler internal function.",
        "Votes": 3,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/Veritax/fsharp/contribution/7580\r\nDon Syme, BDFL F# Language/Core Library Evolution"
        }
    },
    "6566155": {
        "Number": "6566155",
        "Submitter": "exercitus vir",
        "Submitted": "2014-10-15T00:00:00",
        "Title": "Improve F# Project System",
        "Text": "I am not sure this is the right place to request this and I have no experience with the F# Project System.\r\nBut every time some important (and obvious) feature for a tool relating to F# is requested, the developers of the tool note that it is not possible or heavily restricted because of F#'s crappy project system.\r\nFor example, Folder Organization in Visual F# Power Tools: http://fsprojects.github.io/VisualFSharpPowerTools/folderorganization.html\r\nIs there something that can be done about this? C# does not seem have to this problem. This is one of the most important and most urgent roadblocks for F# to become a truly first-class language in Visual Studio.",
        "Votes": 5,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2014-10-20T00:00:00",
            "Text": "Good suggestion (and don’t forget you can contribute to the Visual F# Tools to help improve them).\r\nThe right place for this item is https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools\r\n(This uservoice is for the F# language and core library. See fsharp.org/guides/engineering/issues for where to submit issues.)\r\nThanks!"
        }
    },
    "6586320": {
        "Number": "6586320",
        "Submitter": "Bartosz Sypytkowski",
        "Submitted": "2014-10-20T00:00:00",
        "Title": "Optimization of mutliple pipeline operators used in single statement",
        "Text": "Using an example:\r\n```fsharp\r\nlet f x y z = ...\r\nlet fn = f <| 1 <| 2\r\n```\r\nSecond line will result with generation of IL code for intermediate classes and delegates for each `<|` operator used in this single statement. Desired behavior would be to optimize this code to equivalent of `let fn = f 1 2`, that means all following pipeline intermediate results should be aggregated into single one containing all applied partial function applications.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T14:01:00",
                "Content": "I think a PR for this could just be submitted directly to the http://github.com/Microsoft/visualfsharp repository. It doesn't need to be tracked here as a language design item."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "As per comment, please just submit a PR directly to the http://github.com/Microsoft/visualfsharp repository."
        }
    },
    "6586873": {
        "Number": "6586873",
        "Submitter": "Janek Paw",
        "Submitted": "2014-10-20T00:00:00",
        "Title": "Bottom type",
        "Text": "Bottom type\r\nBottom type for all types. Allows you to implement usefull functions like unimplemented (see scala ???)",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2014-10-22T03:57:00",
                "Content": "This is definitely better than e.g. failwith, which returns an 'a instead of a bottom type, which would be more appropriate."
            },
            {
                "Submitter": "Kai Noda",
                "Submitted": "2014-10-28T20:29:00",
                "Content": "We may introduce a new [<NoReturn>] attribute, borrowed from GCC, and mark functions such as Environment.Exit with it.\r\nCf. https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html"
            },
            {
                "Submitter": "Greg Chapman",
                "Submitted": "2014-11-15T11:02:00",
                "Content": "I'm not really familiar with Scala, but I like what I understand of the ??? construct, so lately I've been using this in F#:\r\n[<GeneralizableValue>]\r\nlet TODO<'a> : 'a = raise (NotImplementedException())\r\nwhich lets me write TODO whereever I'm not ready to supply an implementation. Would a bottom type provide benefit beyond this?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:08:00",
                "Content": "We considered this for F# 1.0 but decided to stick to the OCaml way of just using a type variable. We won't revisit that decision at this point"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment below."
        }
    },
    "6588026": {
        "Number": "6588026",
        "Submitter": "Lincoln Atkinson",
        "Submitted": "2014-10-20T00:00:00",
        "Title": "Implement Option.ofNullable, Option.toNullable",
        "Text": "Various .NET APIs use Nullable<'T> to represent something that might/might not contain data. Having a built-in function to convert to/from F# option type would be quite handy.\r\nSee similar suggestion here: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6103054-add-option-ofnull-to-help-remove-nulls",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-20T23:33:00",
                "Content": "Why not to pull all Option.xxx from ExtCore and/or FSharpx then?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-10T11:27:00",
                "Content": "See https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-01-21T00:00:00",
            "Text": "Completed for F# 4.0, see https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7672\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "6603685": {
        "Number": "6603685",
        "Submitter": "Jared Hester",
        "Submitted": "2014-10-23T00:00:00",
        "Title": "Parameterized and First Class Modules",
        "Text": "Extend the F# module system to allow paramaterization via functors (that's why the keyword is reserved right?)\r\nFirst class modules where a module declared with an abbreviation/alias is equal to a module declared with the original module name (unlike OCaml)\r\nIt seems like a more robust module system would provide a functional alternative to MEF with a cleaner abstraction model.\r\nPerhaps the `pure` keyword could be used in conjunction with `functor` to enforce a restraint against immutability to ensure the functor is applicative?\r\nSee \"F-ing modules\"\r\nhttp://www.mpi-sws.org/~rossberg/papers/Rossberg,%20Russo,%20Dreyer%20-%20F-ing%20Modules%20%5BJFP%20Draft%5D.pdf",
        "Votes": 55,
        "Comments": [
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2014-10-26T18:05:00",
                "Content": "Is this roughly the same as [/ideas/suggestion-5664242-simulate-higher-kinded-polymorphism](/ideas/suggestion-5664242-simulate-higher-kinded-polymorphism.md) ?"
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2014-10-26T18:10:00",
                "Content": "Alternatively, is [/ideas/suggestion-5665042-allow-extension-interfaces](/ideas/suggestion-5665042-allow-extension-interfaces.md) another good possibility that would work with more .NET libraries?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:09:00",
                "Content": "The decision not to support functors and first class module values in F# is a long standing one.\r\nThere are several reasons for this. First, it brings quite a lot of complexity. Second, it can require features like higher kinded type parameters in .NET, or else requires artificial limitations on the functor feature. Third, the feature tends to sit uncomfortably with other features (or potential features) such as object programming, interface types, constraints and type classes.\r\nMy inclination is to not revisit this. However keeping this issue open is useful as a way to measure the level of interest in this feature."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declining per my comment below,\r\nDon Syme, F# Language Evolution"
        }
    },
    "6628026": {
        "Number": "6628026",
        "Submitter": "Kai Noda",
        "Submitted": "2014-10-28T00:00:00",
        "Title": "Accept integer literals like 12_345 for readability",
        "Text": "Simple modification to lex.fsl should suffice.\r\nOther languages with a similar feature:\r\nPerl\r\nhttp://perldoc.perl.org/perldata.html#Scalar-value-constructors\r\nRuby\r\nhttp://www.ruby-doc.org/core-2.1.3/doc/syntax/literals_rdoc.html#label-Numbers\r\nJava 7\r\nhttp://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html\r\nC++11 (use single quote)\r\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.pdf\r\njust to name a few...",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-10-29T14:26:00",
                "Content": "It's supported in D language as well."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2014-11-10T04:58:00",
                "Content": "I believe that Kai Noda's suggestion is good, but should be extended. F# compiler has to accept all numeric (both integer and floating-point with an optional suffix) literals with underscores between their digits like the Ada 2012 compiler does. In other words, the use of underscores between digits of numeric literals has to be supported for all numeric types: byte, sbyte, int16, uint16, int (int32), uint32, int64, uint64, float, float32, etc.\r\nIt also has to be supported not only for decimal base numeric literals, but also for binary, octal and hexadecimal base numeric literals like in Ada 2012, the world's premier language for engineering mission-critical, safety-critical and security-critical real-time software (in Ada this feature has existed since 1980).\r\nFor instance, the following numeric literals have to be accepted by the F# compiler:\r\n12_345\r\n123_456.01\r\n123_456.789_345f\r\n0xFFFF_FFFF\r\n0b00_10_10_10y\r\n0o_77_71_L\r\n0x40_1E_00_00_00_00_00_00_LF\r\nThe suggested feature will improve program readability, safety, security and reliability. For instance, it can help improve the F# position in the financial application development domain where numeric literals with accidental typos in a high-frequency trading algorithm can incur huge financial losses.\r\nMoreover, adding underscores between digits in numeric literals for better readability has to be optional, not mandatory feature of F#. So, it will have no adverse impact on the existing codebase and, therefore, does not constitute a breaking change in the programming language.\r\nFinally, I believe the suggested feature is closely associated with non-breaking changes in the printf format string syntax, namely with the introduction of new flags in format placeholders enabling to display underscores between digits for numeric literals. They will be especially useful for debugging purposes. For instance, printf(\"%3_3d\", 12345) has to result in \" 12_345\", while printf(\"%03_03d\", 12345) has to result in \"012_345\"."
            },
            {
                "Submitter": "Greg Sieranski",
                "Submitted": "2014-11-15T21:55:00",
                "Content": "Going to take a crack at this. Are there some references I can utilize?"
            },
            {
                "Submitter": "Marc Sigrist",
                "Submitted": "2014-11-17T11:26:00",
                "Content": "This feature is also considered for C# 6.0 (see \"Additional Numeric Literal Formats\" at http://msdn.microsoft.com/en-us/magazine/dn683793.aspx)."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-16T12:03:00",
                "Content": "While we are at it, it would be very useful to be able to specify metric prefixes for orders of magnitude:\r\ncenti = 10^(-2)\r\nmilli = 10^(-3)\r\nmicro = 10^(-6)\r\nnano = 10^(-9)\r\npico = 10^(-12)\r\nhecto = 10^2\r\nkilo = 10^3\r\nmega = 10^6\r\ngiga = 10^9\r\ntera = 10^12\r\nwhich could be used like this:\r\nlet number = 5_kilo = 5000"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-06-19T08:16:00",
                "Content": "Great accomplishment! This feature is in great demand. Thank you!"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-17T00:00:00",
            "Text": "Approved in principle, this should be simple for someone to implement\r\nRFC is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1005-underscores-in-numeric-literals.md\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "6642034": {
        "Number": "6642034",
        "Submitter": "Don Syme",
        "Submitted": "2014-10-31T00:00:00",
        "Title": "Add slicing syntax to F# lists",
        "Text": "The F# list type already supports an index operator, xs.[3]. This is done despite the fact that lists are linked lists in F# - lists are just so commonly used in F# that in F# 2.0 it was decided to support this.\r\nSince an index syntax is supported, it makes sense to also support the F# slicing syntax, e.g. xs.[3..5]. It is very strange to have to switch to an array type to use slicing, but you don't have to make that switch for indexing.",
        "Votes": 1,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-08T00:00:00",
            "Text": "This has been approved as an F# 4.0 language feature, and the implementation has been completed here: https://visualfsharp.codeplex.com/SourceControl/changeset/83106bf0f7d1984b8a52c4d2219f68faaba1693d. (This fslang.uservoice.com entry was added mainly for tracking, visibility and discussion)"
        }
    },
    "6655318": {
        "Number": "6655318",
        "Submitter": "Onur",
        "Submitted": "2014-11-03T00:00:00",
        "Title": "Code Contracts support",
        "Text": "This has been discussed but I believe it should be F# that can fix it.\r\nF# compiler does a lot of magic. Especially if we put Contract.Requires to the beginning of a method or a constructor, F# can (if it is a constructor it will) put additional code.\r\nThere is nothing code contract team can do anything about this because this is about how F# compiler works. It basically adds code to the prologue methods and ctors. What compiler can do is to respect System.Diagnostics.Contract class and don't put any code above it.\r\nExample:\r\nSuppose you have this code:\r\ntype RationalEx =\r\nval numerator : int\r\n\r\nnew(num : int) as this =\r\n{ numerator = num }\r\nthen\r\nContract.Requires(this.numerator>0)\r\nthis.Check(this.numerator)\r\n\r\nmember this.Check(num:int)=\r\nContract.Requires(num > 0 )\r\n()\r\nWhen it is compiled and checked from reflector what you will see is\r\nFor the constructor:\r\npublic RationalEx(int num)\r\n{\r\nFSharpRef<Program.RationalEx> this = new FSharpRef<Program.RationalEx>(null);\r\nbase();\r\nthis.numerator@ = num;\r\nthis.contents = this;\r\nthis.init@5 = 1;\r\nContract.Requires(LanguagePrimitives.IntrinsicFunctions.CheckThis<Program.RationalEx>(this.contents).numerator@ > 0);\r\nLanguagePrimitives.IntrinsicFunctions.CheckThis<Program.RationalEx>(this.contents).Check(LanguagePrimitives.IntrinsicFunctions.CheckThis<Program.RationalEx>(this.contents).numerator@);\r\n}\r\nand for the method\r\npublic void Check(int num)\r\n{\r\nif (this.init@5 < 1)\r\n{\r\nLanguagePrimitives.IntrinsicFunctions.FailInit();\r\n}\r\nContract.Requires(num > 0);\r\n}\r\nas you see it adds some magic code on top of the contract code by magic. And this causes contract checker and rewriter to fail",
        "Votes": 24,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T11:39:00",
                "Content": "Why doe this require a fix in F# rather than in the Code Contracts tool?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Declining this because it is the remit of the code contracts tool. I think they should make a fix in this case, or simply ignore the added F# initialization checking code.\r\nFurther discussion and input welcome.\r\nDon Syme, F# Language and Core Library evolution"
        }
    },
    "6656490": {
        "Number": "6656490",
        "Submitter": "Vasily Kirichenko",
        "Submitted": "2014-11-03T00:00:00",
        "Title": "Allow to declare new types inside functions",
        "Text": "The idea is inspired by \"Voldemont\" typed from D language http://wiki.dlang.org/Voldemort_types\r\nIn short, you are allowed to define types inside function scope and return instances of such types from the functions. The proposing syntax is as following:\r\nlet func x =\r\ntype Nested = { Value: int }\r\n{ Value = x }\r\nlet nested = func 1\r\nlet v = nested.Value\r\nThe type of the nested type is inferred as \"func.Nested\". You cannot add type annotations anywhere in code though:\r\nlet func x: func.Nested = // not allowed\r\ntype Nested = { Value: int }\r\n{ Value = x }\r\nlet nested: func.Nested = func 1 // not allowed\r\nNested types cannot be used as types of arguments, however it's possible to write function with statically resolved type parameters to safely deal with such types.\r\nIn D you can use nested types as types for template function arguments like this:\r\nauto getVoldemont() {\r\nstruct Voldemont {\r\nint Value;\r\n}\r\nreturn Voldemont(1);\r\n}\r\nint func(T)(T voldemont) {\r\nreturn voldemont.Value;\r\n}\r\nauto voldemont = getVoldemont();\r\nauto value = func(voldemont); // template func instantiation\r\nAs for me, the main usecase for nested types is replacement for tuples as return types which would hugely increase code readability.",
        "Votes": 23,
        "Comments": [
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2014-11-08T05:57:00",
                "Content": "I think it is a very useful idea that is able to add more expressiveness to the language and flexibility to F# programmers in implementing their algorithms."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2015-01-20T08:50:00",
                "Content": "So this is kind of like anonymous types (albeit nested types) except they can escape function scope?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T11:43:00",
                "Content": "This is a duplicate of this one (which has more votes so will be treated as the canonical one): http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663202-allow-to-define-types-at-expression-scopes"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663202-allow-to-define-types-at-expression-scopes"
        }
    },
    "6668206": {
        "Number": "6668206",
        "Submitter": "Daniel Bradley",
        "Submitted": "2014-11-05T00:00:00",
        "Title": "Warn when literal attribute is used with lowercase name",
        "Text": "The identifier of a literal must begin with an uppercase letter (as defined in 7.1 of the spec). If you assign the literal attribute with an identifier with lowercase first letter, it will ignore the literal attribute without any warning. Could we emit a warning when the literal attribute is not in effect due to the identifier used?",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Daniel Bradley",
                "Submitted": "2014-11-05T11:39:00",
                "Content": "Here's a link to a SO question where the behaviour is currently confusing: http://stackoverflow.com/questions/3890037/literal-attribute-not-working"
            },
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2014-11-08T14:18:00",
                "Content": "I think that it is already supported in FSharpLint tool http://fsprojects.github.io/FSharpLint/\r\nsee `LiteralNamesMustBePascalCase` rule in http://fsprojects.github.io/FSharpLint/FSharpLint.NameConventions.html"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-23T00:00:00",
            "Text": "This is approved, for F# 4.x or later\r\nCompleted her:e https://github.com/Microsoft/visualfsharp/pull/666\r\nDon Syme, F# Language Evolution"
        }
    },
    "6672368": {
        "Number": "6672368",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "Do not lock type provider dlls when compiling/editing",
        "Text": "This is a huge pain in developing type providers.\r\nMaybe it's possible to use the same strategy used for FSI recently?",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-11-06T05:41:00",
                "Content": "Do you have problems debugging TPs in an Experimental VS instance?"
            },
            {
                "Submitter": "Gustavo Guerra",
                "Submitted": "2014-11-06T05:59:00",
                "Content": "It forces you to keep closing and reopening the second VS instance, which is very time consuming.\r\nAdditionally, this means that you can't keep the project and the tests in the same solution. For example, in FSharp.Data, if I'm changing anything which is actually not even related to TPs, I have to build, open the test solution, build and run the tests, then close that second solution to be able to do more changes. It completely kills anything even remotely close to TDD"
            },
            {
                "Submitter": "Ben Lappin",
                "Submitted": "2015-09-29T07:00:00",
                "Content": "What is Experimental VS?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:05:00",
                "Content": "I'm closing this in the F# Language User Voice because it's a Visual Studio or FSharp.Compiler.Service issue. Please raise a bug in those repos."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per comment below – this belongs in Microsoft\\visualfsharp or FSharp.Compiler.Service"
        }
    },
    "6672381": {
        "Number": "6672381",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "Allow negative indices in indexing and slicing like python",
        "Text": "Example: permit usage of a.[..-2] instead of a.[..a.Length-1]\r\nThe compiler could just do that conversion behind the scenes, so it would work with existing types that have custom indexing and slicing",
        "Votes": 33,
        "Comments": [
            {
                "Submitter": "Kit Eason",
                "Submitted": "2014-11-06T06:32:00",
                "Content": "This would be so freakin' useful in the code I am writing right now!"
            },
            {
                "Submitter": "Goswin",
                "Submitted": "2014-11-10T08:46:00",
                "Content": "I am not sure if this schould be default.\r\nI am doing this with an extension member:\r\nlet inline getNegIndex i len =\r\nlet j = if i<0 then len + i else i\r\nif j<0 || j >= len then failwithf \"Cannot get index %d from %d items (for given negative index %d ) \" j len i\r\nelse j\r\ntype ``[]``<'T> with\r\nmember inline arr.GetItemNeg i = arr.[getNegIndex i arr.Length]"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-11-13T05:15:00",
                "Content": "I remember this discussion coming up in CoffeeScript and it's surprisingly hard to do when you involve variables. For example:\r\narr.[..x] // Should the compiler insert a check to see if x is negative?"
            },
            {
                "Submitter": "Brody Berg",
                "Submitted": "2015-02-09T13:13:00",
                "Content": "Here is the CoffeeScript discussion: https://github.com/jashkenas/coffeescript/wiki/FAQ\r\nI don't think the CoffeeScript source-to-source compilation-time constraints apply to the F# compiler in this case."
            },
            {
                "Submitter": "Gusty",
                "Submitted": "2015-09-29T08:28:00",
                "Content": "I like it. FSharpPlus had that feature longtime:(https://github.com/gmpl/FSharpPlus/blob/0f0550000077cb9da3f340612a84911e92c1a790/FSharpPlus/Extensions.fs#L49)\r\nnote that the GetSlice there support also negatives at the beginning of the string.\r\nBut now I see that in F#4.0 it doesn't work anymore since GetSlice was added in the F# core (without the negatives) and shadows the method in F#+ so if this feature is not accepted an option would be to avoid shadowing those functions further defined in Libraries.\r\nThis way everybody is free to decide to use negative indexing by using a library or writing an extension method."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6672490": {
        "Number": "6672490",
        "Submitter": "exercitus vir",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "subtyping for discriminated unions",
        "Text": "We need be able to explicitly specify (structural) subset relationships of discriminated unions (similar to polymorphic variants in OCaml but defined at type definition). There are many uses cases for this.\r\nFor example:\r\ntype Superset = A | B | C\r\n//structural subset relation must be explicitly declared, but only in the definition\r\ntype Subset :> Superset = A | B\r\n//no need to repeat subset relation because a superset can always handle all cases of any subset\r\nlet accept_subset (superset : Superset ) =\r\nmatch superset with\r\n| A -> \"A\"\r\n| B -> \"B\"\r\n| C -> \"C\"\r\n//it does not matter that A is ambiguous (Superset.A and Subset.A) because subset case would be cast to Superset type anyway\r\n//but it should also be possible to specify Subset.A, which would be cast to the Superset type\r\nlet accepted_subset = accept_subset A\r\nlet accept_superset (subset : Subset ) =\r\nmatch subset with\r\n| A -> \"A\"\r\n| B -> \"B\"\r\n//it does not matter that A is ambiguous (Superset.A and Subset.A) because superset case would be cast to Subset type anyway\r\n//but it should also be possible to specify Superset.A, which would be cast to the Subset type\r\nlet accepted_superset = accept_superset A\r\nThis would not break backwards compatibility as it is currently possible to hack this together using explicit static member constraints and additional interfaces (one interface per case), but that is really ugly and repetitive.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-14T13:21:00",
                "Content": "I just realized that this is enables nominal subtype polymorphism, not structural subtype polymorphism since the subtype relationship is made explicit with `:>`."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:14:00",
                "Content": "I renamed the suggestion to clarify that it is about introducing new nominal subtypes.\r\nThis is definitely an interesting idea. Of course it's the natural partner to allowing nominal subtyping on records, which we don't allow\r\nAlthough this is a fascinating suggestion, my inclination is that I have to decline this simply because I would decline the corresponding nominal-subtyping-on-records feature."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2016-07-09T10:47:00",
                "Content": "I don't understand the reason for declining this. Could you please reconsider?\r\nI can see no use cases for subtyping of records, but there are common use cases for subtyping of unions. Not all F# features need to be symmetric."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Many thanks for the suggestion. I’ve declined it per my comment below, please see what I wrote there\r\nBest wishes\r\nDon Syme, F# Language Evolution"
        }
    },
    "6672675": {
        "Number": "6672675",
        "Submitter": "Remko Boschker",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "An CLIVirtual attribute",
        "Text": "Just as you can use CLIMutable to store records using Entity Framework wouldn't is be nice to be able to set an CLIVirtual attribute on a record field of an ICollection type so that Entity Framework can do lazy loading. See also http://stackoverflow.com/questions/26775760/how-to-create-a-virtual-record-field-for-entity-framework-lazy-loading",
        "Votes": 22,
        "Comments": [
            {
                "Submitter": "luketopia",
                "Submitted": "2014-11-10T17:40:00",
                "Content": "In addition to making the property virtual, you would also have to make the record type non-sealed since EF creates dynamic proxy types that inherit from the base entity to override the virtual properties. Right now, all record types are sealed."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6672880": {
        "Number": "6672880",
        "Submitter": "Gustavo Guerra",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "Add a Option.getOrDefault and other new functions to the Option module",
        "Text": "Like List.nth, defaultArgs has the parameters in the \"wrong order\" to be able to be used in partial application. List.item is solving that problem, we should also do the same for defaultArg",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-11-06T07:58:00",
                "Content": "I think a better name is getOrElse (it's also used in Scala). I would also like to add several other functions, like:\r\nofNull\r\nofNullable\r\ntoNullable\r\nattempt\r\norElse\r\ngetOrTry\r\norTry\r\nflatten\r\n(we use all of them in Visual F# Power Tools https://github.com/fsprojects/VisualFSharpPowerTools/blob/3299b8cc99bea9430149df0338304b60c8a6405b/src/FSharpVSPowerTools.Core/Utils.fs#L49-L91)\r\nThere are many others in ExtCore https://github.com/jack-pappas/ExtCore/blob/master/ExtCore/Pervasive.fs#L727-L923 and in FSharpx https://github.com/fsprojects/fsharpx/blob/master/src/FSharpx.Core/ComputationExpressions/Monad.fs#L86-L285\r\nI think we should collect all of them in a table (like it's with collections on codeplex) and discuss what should be added into FSharp.Core (it'd be fine to do the same with Choice)."
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2014-11-06T08:03:00",
                "Content": "I'm not sure if they've been defined in the 4.0 pull requests but I always define something like:\r\nOption.resolve : 'T -> 'T option -> 'T\r\nOption.resolveBy : (unit -> 'T) -> 'T option -> 'T\r\nOption.tryResolve : 'T option -> 'T option -> 'T option\r\nOption.tryResolveBy (unit -> 'T option) -> 'T option -> 'T option"
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-02-23T03:56:00",
                "Content": "Other nice-to-haves:\r\nOption.map2: ('a -> 'b -> 'c) -> 'a option -> 'b option -> 'c option\r\nOption.map3: ('a -> 'b -> 'c -> 'd) -> 'a option -> 'b option -> 'c option -> 'd option\r\nThe List module defines map2 and map3, so it'd be natural to add these to the Option module as well."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-02-23T04:16:00",
                "Content": "It'd also be nice with a built-in computation builder."
            },
            {
                "Submitter": "Mark Seemann",
                "Submitted": "2016-02-23T09:01:00",
                "Content": "Opened a GitHub issue for this: https://github.com/Microsoft/visualfsharp/issues/980"
            },
            {
                "Submitter": "Enrico Sada",
                "Submitted": "2016-03-01T09:10:00",
                "Content": "created RFC https://github.com/fsharp/FSharpLangDesign/issues/60"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-29T00:00:00",
            "Text": "Approved-in-principle to make some sensible additions to the Option module\r\nDetails about naming and exact additions will need to be finalized.\r\nWe will create an RFC for this at https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThanks\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6673905": {
        "Number": "6673905",
        "Submitter": "Daniel Robinson",
        "Submitted": "2014-11-06T00:00:00",
        "Title": "Allow parameterless constructors in structs",
        "Text": "This will simplify the somewhat arcane rules of struct initialization and provide greater parity with class definition syntax. This StackOverflow question (http://stackoverflow.com/questions/12600574/argument-validation-in-f-struct-constructor/12603786#12603786) illustrates the counterintuitiveness of validating constructor args.\r\n[<Struct>]\r\ntype S1 =\r\nval M : int\r\nnew(m) =\r\n{ M = m }\r\nthen if m < 0 then invalidArg \"m\" \"negative\"\r\nwould become:\r\n[<Struct>]\r\ntype S2(m) =\r\ndo if m < 0 then invalidArg \"m\" \"negative\"\r\nmember val M = m\r\nA similar change is planned for C# 6.0 (https://roslyn.codeplex.com/discussions/562559).\r\nThis would open the door to let/do bindings and auto-properties in structs. As noted in the C# discussion, it requires more precise usage of Unchecked.defaultof<T> vs. new T().",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T10:58:00",
                "Content": "C# eventually pulled this feature out of C# 6.0. I think we should not do it in F# for that reason alone."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. See comment below about this feature being pulled from C# 6.0.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6686290": {
        "Number": "6686290",
        "Submitter": "Greg Chapman",
        "Submitted": "2014-11-08T00:00:00",
        "Title": "Avoid boxing when comparing value types",
        "Text": "When emitting code for comparison operators, the F# compiler already special-cases numeric types. I suggest that, when other value types have the appropriate operator, code is emitted to use it. I.e., the compiler should produce the equivalent of:\r\nlet inline (<=) (x: ^a when ^a: struct) (y: ^a) =\r\n(^a: (static member (<=): ^a * ^a -> bool) (x, y))",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Abel",
                "Submitted": "2015-12-17T20:50:00",
                "Content": "Just a note: while this has status \"declined\", it was a duplicate and the duplicate has been completed/resolved in F# 4.0."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2014-11-10T00:00:00",
            "Text": "This is effectively a duplicate of [/ideas/suggestion-6098490-add-a-module-of-efficient-non-structural-equality](/ideas/suggestion-6098490-add-a-module-of-efficient-non-structural-equality.md)\r\nDon Syme, F# Language Evolution"
        }
    },
    "6690744": {
        "Number": "6690744",
        "Submitter": "TeaDrivenDev _",
        "Submitted": "2014-11-09T00:00:00",
        "Title": "Properly print 'None' for option types from FSI",
        "Text": "FSI output properly handles 'Some x', but often prints 'None' as 'null', apparently when the value is part of a larger type.\r\nlet x : uint16 option = None\r\ncorrectly results in: val x : uint16 option = None\r\nlet y : string * uint16 option = \"\", None\r\ninstead prints: val y : string * uint16 option = (\"\", null)",
        "Votes": 18,
        "Comments": [
            {
                "Submitter": "Grant Crofton",
                "Submitted": "2014-11-13T04:03:00",
                "Content": "Yes please, this can be pretty annoying (especially when trying to show people F#)"
            },
            {
                "Submitter": "FANG Colin",
                "Submitted": "2014-12-07T18:35:00",
                "Content": "> printfn \"%A\" (1, None)\r\nprintfn \"%A\" None\r\nprintfn \"%O\" (1, None)\r\nprintfn \"%O\" None\r\n(1, null)\r\n<null>\r\n(1, )\r\n<null>"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "This should certainly be fixed, as much as possible\r\nDon Syme, F# Language Evolution"
        }
    },
    "6696105": {
        "Number": "6696105",
        "Submitter": "luketopia",
        "Submitted": "2014-11-10T00:00:00",
        "Title": "Implement 'contains' functions for collections",
        "Text": "Seems like there should be a simple 'contains' function in all the collection modules, e.g.\r\nList.contains\r\nSeq.contains\r\nArray.contains\r\nRight now we have 'exists', but it seems cumbersome to have to do Seq.exists ((=)value) all the time, and this might be confusing to newcomers. I think this is a common enough operation that it merits its own function.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2014-11-11T02:15:00",
                "Content": "It's already done - see https://visualfsharp.codeplex.com/wikipage?title=Status"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2014-11-12T00:00:00",
            "Text": "See below, done in F# 4.0"
        }
    },
    "6697507": {
        "Number": "6697507",
        "Submitter": "Hodza Nassredin",
        "Submitted": "2014-11-11T00:00:00",
        "Title": "add possibility to use custom hash code generation for types",
        "Text": "Current implementation has some probems with collisions rate but fr backwards-compat reasons it couldn't be changed. https://github.com/fsharp/fsharp/issues/343\r\nWe need some way to use custom generatior and change it at compile time.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2015-07-29T14:21:00",
                "Content": "Not really addressing your issue, but with https://github.com/Microsoft/visualfsharp/pull/513 changes the performance profile of your issue a bit.\r\n32-bit run\r\n------------\r\ngood keys\r\nstruct custom 1.336040 sec 0.000000 collisions\r\nstruct auto 2.028021 sec 0.776863 collisions\r\nstruct auto explicit 1.245075 sec 0.776863 collisions\r\nbad keys\r\nstruct custom 3.273634 sec 0.061892 collisions\r\nstruct auto 7.006841 sec 0.777033 collisions\r\nstruct auto explicit 5.811893 sec 0.777033 collisions\r\n64-bit run\r\n------------\r\ngood keys\r\nstruct custom 1.370548 sec 0.000000 collisions\r\nstruct auto 2.040873 sec 0.776863 collisions\r\nstruct auto explicit 1.242726 sec 0.776863 collisions\r\nbad keys\r\nstruct custom 3.380021 sec 0.061840 collisions\r\nstruct auto 7.008352 sec 0.777050 collisions\r\nstruct auto explicit 5.819077 sec 0.777050 collisions\r\nAnd I don't really understand your issue anyway. i.e. you can already create an IEqualityComparer to use, or alternatively you can use the [<CustomEquality>] attribute like\r\n[<CustomEquality; NoComparison>]\r\ntype StructTuple<'T,'T2> =\r\nstruct\r\nval fst: 'T\r\nval snd : 'T2\r\nnew(fst: 'T, snd : 'T2) = {fst = fst; snd = snd}\r\ninterface IEquatable<StructTuple<'T,'T2>> with\r\nmember a.Equals (b:StructTuple<'T,'T2>) =\r\nEqualityComparer<'T>.Default.Equals(a.fst, b.fst) && EqualityComparer<'T2>.Default.Equals(a.snd, b.snd)\r\noverride x.GetHashCode () =\r\nCmpHelpers.combine (EqualityComparer<'T>.Default.GetHashCode(x.fst)) (EqualityComparer<'T2>.Default.GetHashCode(x.snd))\r\noverride x.Equals (other:obj) =\r\nmatch other with\r\n| :? StructTuple<'T,'T2> as other -> LanguagePrimitives.GenericEqualityER x other\r\n| _ -> false\r\nend"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:04:00",
                "Content": "The way to do this is to manually implement GetHashCode and Equals on your key type. That's just how you do it."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Declined per Paul’s comment: just use a custom IEqualityComparer or Equals/GetHashCode\r\nDon Syme, F# Language Evolution"
        }
    },
    "6699130": {
        "Number": "6699130",
        "Submitter": "Bryan Edds",
        "Submitted": "2014-11-11T00:00:00",
        "Title": "Consider implementing static mixins to make the functional style more convenient in F#",
        "Text": "Here is a conversation from stackoverflow chat that provide context for this language feature idea -\r\nAshtonKJ -\r\nDoes anyone else occassionally want to have inheritance with records?\r\nI mean I hate inheritance from a behaviour point of view. But I like it from a data inheritance point of view.\r\n\r\nVandroiy -\r\nHmh. I guess it could be useful in rare cases, but I never felt a real need.\r\n\r\nAshtonKJ -\r\nI guess I can use a DU for what I want to do. Thinking about things in terms of unions still isn't second nature for me yet\r\n\r\nVandroiy -\r\nHuh... okay, I don't get how these two topics relate here, but good if you solved it :)\r\n\r\nAshtonKJ -\r\nEsentially I want something that has data only inheritance.\r\nWhich I can do with a DU and some trickery.\r\nI think.\r\nOr not.\r\nDamn\r\nSigh\r\nOOP it is in this case :(\r\n\r\nVandroiy -\r\nWhat are you trying to do?\r\n\r\nAshtonKJ -\r\nIdeally what I would like is a DU, with properties that exist on the base type.\r\nBut it doesn't seem like I can do that.\r\n\r\nVandroiy -\r\nI have the impression that inheritance is mostly good if the base class is small. Otherwise, I prefer composing of smaller types and then making helper functions to shorten common cases.\r\n\r\nAshtonKJ -\r\nYeah. My thing is data inheritance is fine. I don't like behavioural inheritance\r\n\r\nVandroiy -\r\nWhat do you mean by data in this case? A good argument against inheritance is that people like to think in clusters; thus it is hard to think about types that are comprised of lots of fine-grained components. This argument works for heterogeneous data as well. (For homogeneous data, I'd guess that either collections apply or you've ended up with a case that asks for a type provider.)\r\n\r\nAshtonKJ -\r\nBy data in this case I mean something like\r\n(An example close to what I am doing)\r\nI have tasks of various types. All the tasks have certain shared characteristics. The different sub tasks have their own unique additions\r\nAnd they will be handled differently (which is why I like the DU idea)\r\nBecause the matching would make my life much easier.\r\n\r\nweismat -\r\nI would strongly recommend to read \"Practical Object-Oriented Design in Ruby: An Agile Primer \" - most OO stuff is done poorly, if done properly OO is first about responsibility and exchanging messages, not about inheritance - the inheritance debacle comes frequently from dependency injection/testing\r\n\r\nAshtonKJ -\r\nI don't really like the OO way of doing things, but it is still what I am most familiar with. And yes, OO SHOULD be about messaging / responsibility. But mostly it isn't\r\n;)\r\n\r\nVandroiy -\r\n@AshtonKJ Is it much too verbose to just go with standard composition? Like this: fssnip.net/om\r\n\r\nAshtonKJ -\r\nNot too verbose. Just was hoping that I would find a better way.\r\nSo, a musician's parent's died and he was given the chance to take over the family business. He refused. He favoured composition over inheritance.\r\n\r\nVandroiy -\r\nlol\r\n\r\nAshtonKJ -\r\nI can't remember where I saw that one. But it made me snicker\r\nAnyways, done pretending to work for today. I think I am now going to play some games\r\n\r\nVandroiy -\r\nHave fun!\r\n\r\nBryan Edds -\r\n@AshtonKJ, I would recommend trying to make composition work rather than OOP.\r\nYes, it is more inconvenient.\\\r\nUltimately, what I think you really want is mixins for data types.\r\nNot inheritance per se.\r\nWith mixins, data composition would act more like inheritance in that you wouldn't need to write forwarding functions for each 'subtype'.\r\nIt might be high time someone recommended mixins as an F# language feature.\r\nIt really would be very useful generally as i've hit the same problem you have several times as well.\r\nand while I've solved it well enough with data composition and forwarding, it feels like a missing piece in the F# ecosystem\r\nand the last thing we want is people resorting to OO too early, thus infeecting their architectures with the unfortunately self-propagating property of OO.\r\n\r\nAshtonKJ -\r\n@BryanEdds How would you envision it working?\r\n\r\nBryan Edds -\r\nBasically, a mixin in this case would generate a bunch of forwarding functions from type A to B along with compositing A's data fields into type B.\r\nThere would be no actual 'subtyping' (EG - casting B to A)\r\n\r\nIbasa -\r\nis forwarding even necessary in that case\r\n\r\nBryan Edds -\r\nfor convenience, yes\r\n\r\nIbasa -\r\ncompiler could just plain copy paste the method and fields\r\n\r\nBryan Edds -\r\nwell, technically, maybe not\r\nthis form of mixin without subtyping would work well with F#'s compile-time duck typing (structural 'subtyping')\r\nI really think F# is ripe for this feature.\r\n\r\nIbasa -\r\ndoesn't play nice with C# interop though\r\n\r\nBryan Edds -\r\nneither does F#'s type extensions\r\n\r\nIbasa -\r\nbut still if there was a clean way of doing it that kept interop nice that would be good\r\n\r\nBryan Edds -\r\ndon't hold yer breath on that\r\nit's just not there\r\n\r\nIbasa -\r\nyeh it would be pretty merg to express in CIL metadata\r\nI guess maybe mixins as interfaces, + extension methods\r\n\r\nBryan Edds -\r\nmaybe bits and pieces of the implementation could be made more .net-ish here and there\r\n\r\nIbasa -\r\nbut then you still have the issue of fields\r\n\r\nBryan Edds -\r\nbut overall, you'll have to deemphasize .netness\r\nnow, maybe if .net did mixins, then there'd be something to talk about in terms of idiomaticy\r\n\r\nAshtonKJ -\r\nOk, so that game doesn't do it for me. Le sigh\r\n\r\nBryan Edds -\r\nbut it doesn't at all, so we're on our own\r\nThe original conversation is also linked here - http://chat.stackoverflow.com/transcript/message/19890630#19890630",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2014-11-11T09:31:00",
                "Content": "Agree with this in principle - there are times where you want to share fields across records. The only way to do it now is by making a separate record type and making that a child field of the two top-level record types (so a sort of composition approach). It would be nice to have the ability to share those properties in a more lightweight fashion (even if this was erased away)."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2014-11-11T09:33:00",
                "Content": "Posting a chat log instead of clearly and concisely stating your suggestion doesn't bode well for gathering support from the community."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-11-11T09:44:00",
                "Content": "Danial Rocinson, please feel free to do your part and write a summary. I have some other pressing stuff I have to do today, so I can't polish this as much as we would both like. And on the other hand, a chat context can be extremely illuminating in its own way if one is willing to spend the time on it."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2014-11-11T10:33:00",
                "Content": "Here's a link to the extended chat log -\r\nhttp://chat.stackoverflow.com/rooms/51909/conversation/data-type-composition-via-mixins"
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-11-13T01:16:00",
                "Content": "The details are lost in the chat. Can someone summarise."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-11-15T09:14:00",
                "Content": "+1. What's this all about?"
            },
            {
                "Submitter": "Frank Joppe",
                "Submitted": "2014-11-16T09:12:00",
                "Content": "I'm casting a vote for the feature of Record inheritance. And honestly, I would like Record to be even a bit more like a class, having a constructor (with parameters), but keeping the current Record advantages with the equality comparison."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2016-01-09T06:06:00",
                "Content": "Frank: If it's just a constructor that takes in all the fields, how is this any different from the current native syntax e.g. { Field = value; Field 2 = value2 } etc. aside from possibly saving a tiny bit of text at the cost of readability e.g. new Record(value, value2) ?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Closing as this suggestion needs to be more concrete (not just a chat log)\r\nDon Syme, F# Language Evolution"
        }
    },
    "6713716": {
        "Number": "6713716",
        "Submitter": "Greg Chapman",
        "Submitted": "2014-11-13T00:00:00",
        "Title": "Extended augmentations for functional types",
        "Text": "When working with F#'s \"functional\" types (e.g., records and unions), I\r\nhave often wished that one could organize a module like:\r\n| Functional Type Declarations (without augmentations)\r\n| Functions manipulating the declared types\r\n| Augmentations for the declared types (e.g., with equality and\r\ncomparison defined using the functions declared above).\r\nI have particularly wanted this when the types are mutually recursive; I\r\nbelieve in that case it is much clearer to be able to define the types\r\nalone without mixing in the code from augmentations.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Marc Sigrist",
                "Submitted": "2014-11-26T05:19:00",
                "Content": "You can actually do this already now, using intrinsic extensions (see http://msdn.microsoft.com/en-us/library/dd233211.aspx). As long as the extensions are defined in the same file, they are compiled as \"real\" members of the type."
            },
            {
                "Submitter": "Greg Chapman",
                "Submitted": "2015-02-14T13:05:00",
                "Content": "For completeness, I'll just note that an augmentation (even in the same file) cannot provide an interface implementation (and so cannot provide an IComparable for a [<CustomComparison>] type). Also, providing an Equals override in an augmentation results in a deprecation warning."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "Yes, this can be done today, as per the comment from Marc Sigrist\r\nDon Syme, F# Language Evolution"
        }
    },
    "6717137": {
        "Number": "6717137",
        "Submitter": "Aleksander Heintz",
        "Submitted": "2014-11-14T00:00:00",
        "Title": "Allow for completely in-memory compilation",
        "Text": "With the introduction of Roslyn and ASP.Net 5 code is being compiled in-memory and on demand. This allows for drastically reduced compilation times (in some cases there is no disk IO at all). I've written a provider for F# to be used in ASP.NET 5 (it can be found at https://github.com/YoloDev/YoloDev.FSharp.AspNet), which uses `FSharp.Compiler.Service` to do the compilation.\r\nNow, there are several problems with the way it works today.\r\n1. Iit can't run on .NET Core due to the fact that `FSharp.Compiler.Service` doesn't.\r\n2. The compiler does not have any real (that I could figure out at least) API. If you read the code for the FSharp Asp .NET 5 provider, you'll see that it builds up a list of compiler arguments as strings. In Roslyn, you build up syntax trees, and metadata references, and then hand those to a \"compilation\" which does the work of compiling your code, whereas the F# compiler as of today takes a list of strings which are options and filenames, and then parses those strings (which could have just been option values) and goes and reads the files (which in many cases I just wrote to disk to enable the F# compiler to find them) and then produces an assembly on disk (which I don't need). Now, the `FSharp.Compiler.Service` project has managed to enable me to reduce the amount of IO I have to do by shimming the file-system (with a global state variable, which makes me have to lock the whole compilation process to ensure thread safety) and in theory it should be able to compile to a dynamic assembly however that doesn't work for some reason. Which brings me to my next point:\r\n3. It does not allow for in memory (only) compilation.\r\nMy suggestion is to follow the Roslyn model. Build up a Compilation object consisting of SyntaxTrees, MetadataReferences and some options. And have apis for creating the assembly to a stream, instead of just to disk.",
        "Votes": 195,
        "Comments": [
            {
                "Submitter": "Aleksander Heintz",
                "Submitted": "2014-11-14T06:35:00",
                "Content": "Also, (as it seems I can't, or can't figure out how at least), would an admin kindly change the title to \"Create a better compiler API\"?"
            },
            {
                "Submitter": "David Karlaš",
                "Submitted": "2014-11-14T12:34:00",
                "Content": "If TypeScript got Roslyn support... Shouldn't F# too?\r\nhttp://blogs.msdn.com/b/typescript/archive/2014/11/12/announcing-typescript-1-3.aspx"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-14T17:22:00",
                "Content": "Please add suggestions about FSharp.Compiler.Service at https://github.com/fsharp/FSharp.Compiler.Service/.\r\nThe FCS API is being improved all the time - for example recently functionality to take an AST and compile it was added by Nessos. So part of what you want is there. You can certainly implement all of the above as relatively simple improvements and simplifications to the current API.\r\nIf you need a hand, then people (myself, Anh-Dung Phan, Tomas Petricek and others like the Nessos guys) are here to help.\r\nBTW adding an FCS-Roslyn bridge would be fabulous"
            },
            {
                "Submitter": "Aleksander Heintz",
                "Submitted": "2014-11-24T18:33:00",
                "Content": "As I stated in my blog post over at http://alxandr.me/2014/11/23/f-in-asp-net-5-the-good-the-bad-and-the-really-ugly/, I think it's the completely wrong way to go about this. These APIs should be added to the compiler. Not appended on some fork of it that has to be kept in sync manually."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-25T09:21:00",
                "Content": "Hi Alexsander,\r\nYes, we're aware of that. It is very likely that the F# compiler (including the open edition, the Visual F# compiler and the Visual F# IDE Tools) will eventually be rebuilt on top of the FCS component.\r\nThis is a non-trivial task for Visual F# Tools since there are very, very high stability requirements. Also, the Visual F# Tools splits the compiler DLLs into two separate instances (one for compilation, and one smaller part for the language service, to reduce memory footprint of binary sizes a little - an awkward split not needed by other tooling). We'll get there, but we don't want to block all of this: http://fsharp.github.io/FSharp.Compiler.Service/#Projects-using-the-F-Compiler-Services.\r\nSo in a sense what you're doing is adding APIs to the likely core component of the _future_ F# compiler. It is the future :)\r\nRoslyn took 5 years to do this, but the process was internal at Microsoft - and I can assure you it was similar. For F#, we're doing the right thing to achieve eventual convergence - while also allowing the F# community to incubate the F# Compiler Service component to be a useful and general component. Using it for ASP.NET vNext is exactly what we need to proof the component at this stage - it's hugely useful to see and support these use cases before we reverse-integrate back into the Visual F# Tools.\r\nIf it helps, the process for integrating F# language updates into FCS is simple and just involves a \"git pull\", since the repos share a common aligned source code history. It's the least of our problems :)\r\nI'd be very glad to talk through all this with you on Skype if you'd like, and to help you with your diffs.\r\nCheers!\r\nDon\r\np.s. Some of your criticisms of the F# compiler code are also valid - there is a lot we've been unable to cleanup because we were using a \"source drop\" model of open source. Applying cleanup is getting easier. And yes, there is lots to do :)"
            },
            {
                "Submitter": "Enrico Sada",
                "Submitted": "2015-11-17T03:03:00",
                "Content": "work started, both in fsharp compiler service and visualfsharp\r\nref https://github.com/fsharp/FSharp.Compiler.Service/issues/266"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:46:00",
                "Content": "This is an FSharp.Compiler.Service feature, as Enrico points out work has started towards its implementation"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Duplicate, see https://github.com/fsharp/FSharp.Compiler.Service/issues/266\r\nwhich covers the ongoing work for this feature."
        }
    },
    "6723648": {
        "Number": "6723648",
        "Submitter": "TeaDrivenDev _",
        "Submitted": "2014-11-15T00:00:00",
        "Title": "Display current parameter type in tooltip for generic function",
        "Text": "I posted this on CodePlex (https://visualfsharp.codeplex.com/workitem/172), and Don Syme asked me to put it here as well.\r\nThe C# editor in Visual Studio displays the actual parameter types involved in the tooltips for generic class instances and method invocations. The F# editor only does that for objects and methods, but oddly not for F# types/functions; shouldn't this information be quite readily available?\r\nHaving this kind of information at hand would especially make it quite a bit easier to follow the transformation of data through pipe chains, even more so as this type of display is also completely absent for lambdas at this time.",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-05-21T18:19:00",
                "Content": "I don't understand this feature request. Could you please elaborate or provide a code sample?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:55:00",
                "Content": "This should really go in the Visual Studio Tools user voice. But it's important to do, we should just get it done :)"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Not really a language item, but this should be implemented in the Visual F# Tools and the F# COmpiler Service"
        }
    },
    "6730304": {
        "Number": "6730304",
        "Submitter": "Anonymous",
        "Submitted": "2014-11-17T00:00:00",
        "Title": "Add try-with-finally for consistency",
        "Text": "F# supports try-with, try-finally, but not try-with-finally.\r\nI know this can be workarounded, and that it is sometimes requested, but I think that for consistency it is a *nice to have* to be on par with C#.\r\nhttp://stackoverflow.com/questions/2078603/f-exception-handling-constructs\r\nhttp://stackoverflow.com/questions/1789682/how-do-i-ignore-exceptions-in-f",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2014-11-17T08:35:00",
                "Content": "Hey Denis,\r\nDo you think there is something more than consistency with C# as a rationale?\r\nI guess I don't see any intrinsic reason why using a nested try/with is not clearer to reason about and keeps the constructs more orthogonal. Combining two orthogonal constructs into a single combined syntax isn't really normal - there has to be an intrinsic reason for it. I'll admit I've never quite understood _why_ C# needed to do this - I always thought it came from first supporting multiple \"catch\" blocks (because they didn't have pattern matching in exception handlers), and then they just tacked on an optional \"finally\" and/or \"fault\" block.\r\nMashing constructs together into a single construct can make things harder for the user, as they will expect that there is some semantic reason for offering the combination - i.e. there is something special that can only be done by the combined syntax.\r\nAlso, try/finally are really pretty rare in F# due to the use of \"use\" in async, sequences etc."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2014-11-17T09:08:00",
                "Content": "there is a PR with a sample implementation for discussion: https://visualfsharp.codeplex.com/SourceControl/network/forks/OkayX6/visualfsharptools/contribution/7701"
            },
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2014-11-17T13:09:00",
                "Content": "Agreed with Don here, I also do not understand why we need this.\r\nI do not remember when I needed try-finally actually"
            },
            {
                "Submitter": "Marc Sigrist",
                "Submitted": "2014-11-27T08:17:00",
                "Content": "When I first saw the F# try... with/finally rules, I thought they were strange, because I was used to C#. However, in practice, this has never bothered me during four years of F# programming. I can't remember when I actually used try...finally in F#. And now that I have read Don's answer below, the F# implementation also makes sense to me from a language coherence point of view. Thus, I am not in favor of adjusting to C#."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6735157": {
        "Number": "6735157",
        "Submitter": "M Sheik Uduman Ali",
        "Submitted": "2014-11-18T00:00:00",
        "Title": "Scala like 'case class' feature in 'type' definition",
        "Text": "I would like to have Scala like 'case class' feature in 'type' definition. In F# 3.0, type definition is too verbose",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2014-11-23T16:28:00",
                "Content": "Could you please provide an example of syntax?\r\nI think that F# Discriminated Unions are more elegant than Scala case classes http://msdn.microsoft.com/en-us/library/dd233226.aspx"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-11-26T02:52:00",
                "Content": "sealed abstract class DU\r\ncase class Case1(field1: Int, field2: String) extends DU\r\ncase class Case1(field3: List[DU]) extends DU\r\nvs\r\ntype DU =\r\n| Case1 of field1: int * field2: string\r\n| Case1 of field3: DU list\r\nSo who is verbose now?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "F# discriminated unions play this role\r\nDon Syme, F# Language Evolution"
        }
    },
    "6747534": {
        "Number": "6747534",
        "Submitter": "Anonymous",
        "Submitted": "2014-11-20T00:00:00",
        "Title": "Add an effect system",
        "Text": "https://www.cl.cam.ac.uk/~dao29/publ/haskell14-effects.pdf\r\nEmbed the ideas in this paper, but in F# instead of Haskell. I am pretty sure one of the authors is familiar with F#.",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2014-12-03T05:19:00",
                "Content": "Similar to StackOverflow, I feel that here you should post a summary of the idea, not just a link to something else (considering your link is to a whole paper, very few people will actually read it and therefore know what you're proposing)."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2014-12-03T10:42:00",
                "Content": "Thanks for the comment -- good point. To be fair to myself, I will not do the paper justice so was trying to avoid misrepresenting, but I will try to explain what it is that I want from this feature:\r\nThe Type System provides some information about what a function or expression does, but it currently does not describe everything that it does. Some functions have *side effects* and it is possible to embed those into the type system, or to enhance the type system with an effects system that keeps an honest accounting of what side effects might be happening.\r\nThe most well known example of a similar concept is checked exceptions in Java, although that is probably not a ringing endorsement.\r\nThe effects that you would be interested in would be exceptions, divergence, IO (or as Tomas has pointed out) a more granular view of IO, allocations, reads and writes (also see http://tomasp.net/blog/2014/update-monads/index.html for some details on a monad for something like this).\r\nThe key idea is that we can get some more honesty out of the type system by also tracking what the possible effects that a function might produce. We can then isolate Pure or Total code from code that we want to be at the boundaries.\r\nSee also http://research.microsoft.com/en-us/projects/koka/ for a Microsoft implementation of a similar idea.\r\nOne argument against would be that much of the BCL would be a hot mess of side effecting APIs. My strong suspicion is that adding an effects system would help to put pressure on API designers to design better, more functional APIs."
            },
            {
                "Submitter": "Suminda Sirinath Salpitikorala Dharmasena",
                "Submitted": "2014-12-07T00:39:00",
                "Content": "+1 for this. I have run out of votes but would vote for this."
            },
            {
                "Submitter": "Phylos",
                "Submitted": "2015-01-18T00:45:00",
                "Content": "While this would certainly be a nice addition to the language, the amount of effort and resources required would probably best be directed elsewhere. I would think it would be much more valuable to have the relatively limited resources available for core F# language development add type classes and higher kinds to the language. Such powerful additions would provide the basic building blocks to take F# to the next level."
            },
            {
                "Submitter": "Greg Rosenbaum",
                "Submitted": "2015-03-14T16:04:00",
                "Content": "This feature already exists in F*, which is an experimental language designed for proofs and verification of computer programs. The language is based on F#. Here is a tutorial on the language:\r\nhttps://www.fstar-lang.org/tutorial/\r\nNote that I don't support this feature, since I feel it's unnecessary. I'd really rather they added higher kinds and maybe type classes. I'm just telling you the code already exists."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T11:26:00",
                "Content": "I agree with Phylos and others that adding an effect system is beyond the scope of F# as things stand, except in purely research/experimental versions (which as a researcher I'd love to play with!). See also my comments on dependent types, [/ideas/suggestion-6062821-add-dependent-types](/ideas/suggestion-6062821-add-dependent-types.md)\r\nNote that a Rust-like effect/ownership system aimed at the specific problem of data races in concurrent programs is listed as a separate suggestion: [/ideas/suggestion-6972958-mezzo-rust-like-features-for-f-code-to-be-data-ra](/ideas/suggestion-6972958-mezzo-rust-like-features-for-f-code-to-be-data-ra.md) (but would also be a huge undertaking)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below\r\nDon Syme, F# Language Evolution"
        }
    },
    "6752948": {
        "Number": "6752948",
        "Submitter": "Arash Sahebolamri",
        "Submitted": "2014-11-21T00:00:00",
        "Title": "Support bind (e.g. \"await\") in the middle of expressions, possibly using !! operator",
        "Text": "that does the binding implicitly; so that it wouldn't be necessary to bind every monadic expression to a name. In the case of async workflows, it would behave like the C# await keyword.\r\nWith this operator, instead of this:\r\nlet task= tasync{\r\nlet! response = http.GetAsync(uri)\r\nlet! string = response.Content.ReadAsStringAsync()\r\nlet! res = processAsync(string)\r\nreturn res\r\n}\r\nit would be possible to write code like this:\r\nlet task= tasync{ return !! processAsync(!!(!!http.GetAsync(uri)).Content.ReadAsStringAsync()) }\r\nOr write this:\r\nlet t= opt{ return ((!!x) + !!y) / !!z}\r\ninstead of this:\r\nlet t= opt{\r\nlet! xx = x\r\nlet! yy = y\r\nlet! zz = z\r\nreturn (xx + yy) / zz\r\n}",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Wallace Kelly",
                "Submitted": "2015-05-28T12:11:00",
                "Content": "In your examples, you have `tasync`. Is that a typo? Or is `tasync` a real thing?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:54:00",
                "Content": "Wallace - it's a typo I think."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6776696": {
        "Number": "6776696",
        "Submitter": "Steven Taylor",
        "Submitted": "2014-11-27T00:00:00",
        "Title": "simplify assigning a mutable DU value",
        "Text": "please provide a simplified way to work with mutable discriminated union values similar to the simplified announcement [1].\r\nThe current scheme depends upon the ref keyword. It would be nice to replace ref with mutable, and then be able to use the cleaner <- operator rather than :=. This would then be more consistent for folk who get used to the \"it just works\" syntax (see [1]).\r\nInstead of:\r\ntype AST = | Keyword of string ref\r\nlet theDuValue = AST.Keyword (ref \"test\")\r\nlet (Keyword(v)) = theDuValue in v := \"new value\"\r\nwe could have:\r\ntype AST = | Keyword of mutable string\r\nlet theDUValue = AST.Keyword (\"test\")\r\nlet (Keyword(v)) = theDUValue in v <- \"new value\"\r\nIt's a slightly contrived example, but this syntax does have has its uses.\r\nAn example in ref form from Microsoft.FSharp.Compiler (file: tast.fs)\r\nTraitConstraintInfo =\r\n| TTrait of TTypes * string * MemberFlags * TTypes * TType option * TraitConstraintSln option ref\r\nmember x.Solution\r\nwith get() = (let (TTrait(_,_,_,_,_,sln)) = x in sln.Value)\r\nand set v = (let (TTrait(_,_,_,_,_,sln)) = x in sln.Value <- v)\r\nNote: TraitConstraintSln uses the option type. The \"<-\" here has nothing to do with a simplified syntax\r\n[1] http://blogs.msdn.com/b/fsharpteam/archive/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015.aspx\r\nClosed Today at 2:12 AM by latkin\r\nPlease open as a feature request at UserVoice\r\ncomments\r\n* latkin wrote Today at 2:12 AM\r\n* Thanks for the feature suggestion. We ask that language feature requests be opened and discussed at https://fslang.uservoice.com/.\r\n* Take a look at http://stackoverflow.com/a/2221803/1366219 for a discussion on this topic. There are various complications and design considerations that come into play here.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:26:00",
                "Content": "I think it's best to just define a settable property on the DU that does what you want."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6803533": {
        "Number": "6803533",
        "Submitter": "Ryan Riley",
        "Submitted": "2014-12-04T00:00:00",
        "Title": "Support .NET Core and CoreCLR",
        "Text": ".NET Core is the new cloud runtime model for the CLR and used in ASP.NET vNext.",
        "Votes": 374,
        "Comments": [
            {
                "Submitter": "Raymen Scholten",
                "Submitted": "2015-02-11T09:46:00",
                "Content": "I think this is becoming more and more important with the latest open sourcing of the CoreCLR"
            },
            {
                "Submitter": "Henrik Feldt",
                "Submitted": "2015-04-03T03:56:00",
                "Content": "I think this is especially important to get to run on small linux distros, like https://github.com/gliderlabs/docker-alpine which I predict will gain a lot of popularity in the docker community."
            },
            {
                "Submitter": "Jarle Stabell",
                "Submitted": "2015-05-28T16:46:00",
                "Content": "With support for this, we would find ourselves having the moral duty of removing all Perl and PHP scripts from this planet. ;)\r\nF# could perhaps also become important in enabling a realistic (and superior) NodeJS alternative.\r\nAnd help those who are trying to tell the world that F# is a great alternative to Python and R."
            },
            {
                "Submitter": "Johann Dirry",
                "Submitted": "2016-02-21T15:03:00",
                "Content": "I find this very important, because some really good libraries are written in F# these days and without F# support I can't use them in UWP projects."
            },
            {
                "Submitter": "Troy Robinson",
                "Submitted": "2016-04-06T18:54:00",
                "Content": "Was this completed? Looks like it may have been with this?\r\nhttps://github.com/Microsoft/visualfsharp/pull/499"
            }
        ],
        "Status": "started",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "Strictly speaking this issue is not meant for https://fslang.uservoice.com, since it is about targeting a particular platform with the tooling, rather than the F# language or core library design itself.\r\nHowever, I’m leaving it open for now since it’s getting so many votes. We may close it sometime soon to release the votes.\r\nIn any case, this work is planned by the Microsoft visualfsharp team and other contributors. Please contribute to the work at the http://github.com/Microsoft/visualfsharp repository and follow that repository for more details and updates.\r\nRelevant issues: https://github.com/Microsoft/visualfsharp/issues/387 and https://github.com/Microsoft/visualfsharp/pull/499\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6826972": {
        "Number": "6826972",
        "Submitter": "Patrick McDonald",
        "Submitted": "2014-12-10T00:00:00",
        "Title": "Add curry and uncurry functions",
        "Text": "let curry f x y = f (x, y)\r\nlet uncurry f (x, y) = f x y\r\nAs implemented in Fsharpx. I have a sample implementation here:\r\n[https://visualfsharp.codeplex.com/SourceControl/network/forks/PatrickMcDonald/visualfsharp?branch=curry]",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Pierre Irrmann",
                "Submitted": "2014-12-12T04:48:00",
                "Content": "I was about to suggest the same one this morning! I give it my last remaining 2 votes..."
            },
            {
                "Submitter": "Patrick McDonald",
                "Submitted": "2014-12-12T06:11:00",
                "Content": "It seems F# already has the uncurry function, AKA the \"backward double pipe\" operator (<||)\r\nhttps://visualfsharp.codeplex.com/SourceControl/network/forks/PatrickMcDonald/visualfsharp/contribution/7759\r\nI don't think the curry function can be implemented as an operator as it takes 3 arguments.\r\nAlso, it seems curry/uncurry has been discarded as an idea previously, from reading this discussion [although this discussion doesn't mention the existence of (<||)]:\r\nhttps://github.com/fsprojects/fsharpx/issues/165"
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2014-12-15T06:58:00",
                "Content": "There's also ||> for uncurrying as well."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T09:35:00",
                "Content": "F# has no flip/curry/uncurry operators in the prelude - we did consider them of course in F# 1.x but made a definite decision not to include them. OCaml made the same decision at that time. Code that uses these is often of reduced readability. Not always, but in my experience too often."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6832419": {
        "Number": "6832419",
        "Submitter": "Isaac Abraham",
        "Submitted": "2014-12-11T00:00:00",
        "Title": "Length constraints on lists and arrays",
        "Text": "Whilst you can pattern match on lists in order to get compiler support on the length of them, it would be great if we had compiler support for list length for e.g. arguments to functions. Things like Seq.head or even list destructuring can't be proven to not go pop except through pattern matching, but if we had the ability to add length constraints to e.g. a list passed in as an argument to a function this would simplify lots of boilerplate code e.g.\r\nlet foo(myListOfItems:int list<3>) = () // myListOfItems must be three elements long.\r\nor even\r\nlet foo ([ a;b;c;]) = () // automatically unwrap the list of three elements into a b and c.\r\nNot saying that the above syntax would necessarily be the way to go - just ideas as to achieving the aim of getting better compiler support for working with lists.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2014-12-15T08:03:00",
                "Content": "As far as I understand this requires dependent types which are very, very unlikely to be added to F# in any observable future."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2014-12-15T09:53:00",
                "Content": "Isn't a fixed-length list just a tuple?"
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2014-12-26T11:23:00",
                "Content": "@Vasily - I know diddly about writing compilers :-) But can this not be done with things like units of measure i.e. metadata that gets erased at runtime; could this not be done in a similar manner?\r\n@Daniel - not really - you can't use all the list or sequence operations etc. on them."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2015-01-15T06:06:00",
                "Content": "You could write a function now to currently turn a tuple of identical items into a sequence, such as:\r\nlet asSeq (one, two, three) = seq { yield one; yield two; yield three }\r\nPerhaps you could use a type provider to generate useful functions or extension methods for you.\r\nAs for language support, perhaps it would be better to try and get special support from the compiler to let you treat Tuple<T, T, T, ...> as seq<T>."
            },
            {
                "Submitter": "Craig Stuntz",
                "Submitted": "2015-03-16T21:42:00",
                "Content": "You indeed need dependent types for constraints on cardinal length, but some really useful special cases which don't quite require dependent types are lists of length 0 and 1. Here's a Haskell solution for >0 which doesn't require dependent types:\r\nhttps://wiki.haskell.org/Non-empty_list"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T09:29:00",
                "Content": "It is possible to deal with some special cases via integer parameters or other existing uses of constraint solving. However that can lead the programmer to use the feature during problem exploration, but then the feature falls down at some point. The programmer must then back out and remove the use of the feature."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6906132": {
        "Number": "6906132",
        "Submitter": "Bryan Edds",
        "Submitted": "2014-12-31T00:00:00",
        "Title": "Implement first-class lensing / lenses in F#",
        "Text": "When working with complex state structures, functional programming is, without a great deal of additional tooling (tooling that does not satisfactorily exist in F#), highly inconvenient, verbose, and even error-prone. These problems are so pronounced that many cite them as a reason to label functional programming itself as inapplicable to the domains within which complex state structures are inherent!\r\nAs functional programmers, we believe otherwise, and many even believe that it is in the domain of dealing with complex state artifacts that functional programming is especially beneficial and necessary! However, with such weak syntactic constructs such as these -\r\nlet a = { a with B = { a.B with C = c }}}\r\n- we win ourselves no favors.\r\nAnd even in the narrow context of such a small problem, simple and promising solutions abound. For example, why doesn't this syntax have a semantics assigned to it in F#? -\r\nlet a = { a with B.C = c }\r\nOr better, given that we know at compile-time that there is a means of constructing A and B, why we can't assign a semantics to this -\r\nlet a = a.B.C $= c\r\n- and generate all the backing code for such a pure functional update automatically?\r\nAnd why restrict such nice syntax to only record fields? Why not let it be applicable to all members who support the concept of readability and updatability (EG - lensability) such as with here -\r\ntype Entity with\r\n\r\nmember gui.Enabled = gui?Enabled : bool\r\nstatic member setEnabled (value : bool) (gui : Entity) = gui?Enabled <- value\r\nso that we can finally utter -\r\nlet entity = entity.Enabled $= anotherEntity.Enabled\r\nIn other words, why not give the compiler some way of recognizing 'lensability' implicitly for simple cases (and perhaps explicitly with simple declarations in more refined cases such as with Map values), ultimately enabling good syntax to take advantage of it all?\r\nAnd yes, there have been library solutions to the problem of lensing proposed in F#. However, in experience I have found the library solution to be embarrassingly inadequate. This is due to the fact that F# does not provide out-of-the-box (nor shall it in the reasonably near-future) the language constructs necessary to build a sufficiently expressive lens library... and not even for the straight-forward use cases I outlined above! And, even if such language constructs were available, I still doubt that a form of expression as understandable and succinct as the syntax I proposed could be achieved.\r\nFor that reason, I did and still do conclude that it is necessary to build lensing as a first class construct in the language. This is so that instead of attempting to use kindedness to express lensing, the simpler (and admittedly more muscled) approaches of syntactic expansion / IL generation may be used. Thus this user suggestion.\r\n(On a side note, perhaps if we had a sophisticated and general syntactic macro system in F# like I suggested here - [/ideas/suggestion-5674940-implement-syntactic-macros,](/ideas/suggestion-5674940-implement-syntactic-macros,.md) the solution could again be proposed as a library. However, given that such a feature whose design and implementation is daunting and not yet to be even approved in principle, this too is a non-starter for an urgently-needed construct.)\r\nTo expand on the design proposal further, et's look at the subtle distinction I've made in the words I've used above. Specifically, we notice a distinction between -\r\nLensing - viewing or updating a value contained by another functional value\r\nLenses - a general mechanism by which lensing is achieved\r\nWe've already seen the syntax I propose for lensing where the lens itself is contextually implied -\r\nlet a = a.B.C $= c // here a new value of a is constructed and bound to a shadowing binding of a.\r\nNow say we want to pull out the lens itself that it might be passed around for lensing later. Obviously, we will need a syntax for that as well. However, the desired form taken by that syntax is more nebulous, so here are a few options -\r\nlet abcLens = lens <@ A.B.C @> // here's a syntax that utilizes code quotations: verbose but maybe easier to implement in the compiler?\r\nlet abcLens = lensOf A.B.C OR lensOf<A.B.C> // here's lens with a new keyword lensOf: succinct, but not perfect backward compatibility\r\nlet abcLens = {$ A.B.C $} // ugly, but succinct and probably backward compatible (but maybe not as I've yet to study F#'s AST in-depth).\r\n...and there are presumably many more possible forms. After all, for literally ALL the syntax I've proposed in this thread, I've merely been riffing!\r\nAdditionally, there would need to be a syntax for allowing user-defined induction of other things into the category of 'lensability'.\r\nFor example, say we have a type whose members are described at run-time like so -\r\ntype A with\r\n\r\nstatic member getB (a : A) = a?B : bool\r\nstatic member setB (b : bool) (a : A) = a?B <- value\r\nWe should be able to decorate the view and update functions like so -\r\ntype A with\r\n\r\n[<Viewable \"B\">] static member getB (a : A) = a?B : bool\r\n[<Updatable \"B\">] static member setB (b : bool) (a : A) : A = a?B <- value\r\nIn conclusion, F# needs first-class support for lensing / lenses because it current set of language features is inadequate to provide a library solution, and because lensing / lenses is such a fundamental property of functional programming in stateful systems. While my design proposal certainly will have some flaws that need to be smoothed over, I think it is a good enough start to get something in the works!",
        "Votes": 165,
        "Comments": [
            {
                "Submitter": "Christopher Stevenson",
                "Submitted": "2015-01-09T22:14:00",
                "Content": "Coming from an object-oriented background, I find it difficult to understand what lenses are, besides 'functional version of properties'. Even though this proposal is rather lengthy, I'm not really understanding what the benefit of this is, besides some vague notion of more concise field setting of copied records.\r\nIf someone could point to a good primer, I'd appreciate it."
            },
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2015-01-12T11:22:00",
                "Content": "Functional properties is a pretty good way of putting it. The one part that Bryan didn't really cover well in this is that the lens is an instance of an object itself. So given his example of \"lens <@ A.B.C @>\" that would create a lense for field C of field B of type A. That lens object is a function that can either get that value from an instance of A, or set that value on an instance of A (returning a new A).\r\neg something like:\r\nlet l = lens <@ A.B.C @>\r\nlet a = // create some A value\r\nlet c = get l a // c is now the same as a.B.C\r\nlet newC = // create some C value\r\nlet newA = set l a newC // newA is now the same as { a with B = { a.B with C = newC } }\r\nLenses themselves aren't massively complex, it's pretty much just:\r\ntype Lense<a', b'> = { getter : a' -> b'; setter : a' -> b' -> a' }\r\nlet get lense obj -> lense.getter obj\r\nlet set lense obj value -> lense.setter obj value\r\nbut with that you can then add composibility and other nice functional things on top. The awkard bit of lenses is constructing those getter/setter functions (more so the setter), but the construction of those functions is also trivial to the compiler."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-01-19T11:27:00",
                "Content": "I think it is critical to look at the different versions of this concept and how they evolved in Haskell -- my understanding, weak as it may be, is that it took a while to get to ekmett's package and that is the one that you would want to model it after.\r\nOne key thing that you want to preserve would be in addition to a regular getters and setters, you want the ability to set a value with function that uses the original value. For example, if you have a property that is an integer, you should be able to set it with an incrementing function:\r\nf x = x + 1\r\nand all of the variations that you might want with that."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-01-19T11:48:00",
                "Content": "I think those are just a matter of defining the right operators.\r\nI think also there is a marked difference in the scope of what Haskell's lenses accomplishes and what we actually need in F#. The two may differ more than one may initially think. Or not - I too am no expert.\r\nHowever, I think it would be great to ask Edward Kmett himself to take a look at the lens proposal during the design process. Though he is busy as always, and even though he's not an F# user AFAIK, I think he would willing to prioritize some time for it.\r\nI have his contacts, and he spends a good deal of time on #Haskell on Freenode IRC."
            },
            {
                "Submitter": "Andrew Cherry",
                "Submitted": "2015-02-13T06:19:00",
                "Content": "I think I commented a bit on this elsewhere in a discussion, but it came up again just now in another context ( https://github.com/SuaveIO/suave/pull/206#discussion_r24602874 ), and @dsyme thought it might be useful to include here...\r\nI use lenses (Aether library), but they're not the Kmett library style of lens (which, from memory, are van Laarhoven lenses). With our type system as it stands, we're restricted to the more naive style of lens that Aether implements (get, set pairs). I do still find that they're useful however.\r\n(See that linked discussion for a little more detail and some examples).\r\nHowever... I'm not sure I can agree with lenses, as a concept, becoming a language feature. It's overly specific, to my mind. Either we need to be saying something like\r\n\"We need a better way of modifying properties in deeply nested immutable data structures\", which would be reasonable perhaps, or we should be saying \"we need the type system to be a bit different/more to enable us to write some functional techniques which would make, e.g. lenses, possible\". I'm not sure that lenses as a thing though is a language level change."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-14T11:47:00",
                "Content": "On the specific question of \"{ a with B.C = d }\"... One possibility would be to give a semantics to this as follows:\r\n{ a with ...; b.c = d } --> { a with b = { a.b with c = d}; ...}\r\nIn addition, we could also allow \"setting\" properties which are not record-defined properties, e.g.\r\n{ a with ...; b = c } --> { a with ... }._set_b(c)\r\nWith these two rules we would have:\r\n{ a with b.g = c; d = e } --> a._set_b(a.b._set_g(c))._set_d(e)\r\nwhere \"a\" can be any kind of object as long as it has _set_b and _set_b \"functional property setters\". The naming _set_b could be discussed.\r\nThis is a fairly simple language feature which could be of some help, and would also address the \"use record 'with' syntax on non-record types\" request ([/ideas/suggestion-6420709-allow-record-like-obj-with-newvals-syntax-for)](/ideas/suggestion-6420709-allow-record-like-obj-with-newvals-syntax-for).md)"
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-02-14T23:46:00",
                "Content": "Hi Don!\r\nI somewhat regret suggesting lensing semantics for -\r\nlet a = { a with B.C = c }\r\nThis is because B is currently used to specify the containing type of C.\r\nInstead, I really do think we want a semantics for this more unique syntax -\r\nlet a = a.B.C $= c\r\nWhy overload existing syntax if we don't have to?"
            },
            {
                "Submitter": "Jack Fox",
                "Submitted": "2015-08-02T19:27:00",
                "Content": "The Microsoft team has published their short-term roadmap https://github.com/Microsoft/visualfsharp/issues/563 and the long-term roadmap is coming. There are limited resources and they are deploying them wisely. What the community can do on the side is improve the documentation and publicize existing projects like http://fsprojects.github.io/FSharpx.Extras/ where lens support (among other overlooked gems) already exists."
            },
            {
                "Submitter": "Giacomo Stelluti Scala",
                "Submitted": "2015-08-03T13:22:00",
                "Content": "I've voted it.\r\nI'm wondering if one day F# will have functors like OCaml, this could be implemented as library but with a deeper and more elegant support."
            },
            {
                "Submitter": "Henrik Feldt",
                "Submitted": "2015-08-10T01:29:00",
                "Content": "I find this proposal overly syntax-oriented: it's supposedly needed because \"lenses are such a fundamental property of functional programming in stateful systems\", but you can in fact easily program in a stateless manner even when using sockets, file handles, semaphores etc.\r\nInstead, add facilities to the language to write higher kinded types, that would enable us to write van Laarhoven (http://twanvl.nl/blog/haskell/cps-functional-references) lenses, or enable us to have an officially supported Applicative namespace, or allow us to export static signatures (or type classes and instances) from modules.\r\nLanguage design should be free from muck; oriented towards creating the language as a total function of its input: code, rather than lots of small partial functions over code."
            },
            {
                "Submitter": "Andrew Cherry",
                "Submitted": "2015-08-10T06:22:00",
                "Content": "I don't think my opinion has changed much from commenting back in February. Aether (disclaimer, i'm the maintainer) provides a reasonable library solution (in my opinion) given the constraints of the language. Even the limited possibilities that Aether provides have proven very useful when writing other libraries and being able to work with complex structures effectively. (See for example the approach that Freya takes to providing lenses in to OWIN state to provide strongly typed, safe access to request/response properties).\r\nA specific extension of the language to support lens functionality (and realistically people only seem to be talking about \"functional properties\" which in my head is a small subset of the usefulness of lenses and related techniques - lenses with prisms, transducers, etc. etc.) seems over specific and maybe a little short sighted in terms of not attacking the problem in a more interesting way.\r\nAs Henrik mentions, an extension of the type system would enable us to write a far more general and useful system as a library, rather than baking specific approaches in to a language core. I'm with Henrik on this one - I would vote for careful selection of a few key extensions to the core of the language and type system which would enable new things to be built as libraries, rather than baking things that seem useful today in to the language itself. That way lies PHP."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T13:58:00",
                "Content": "This suggestion was also relevant (and the same idea is mentioned above)\r\n[/ideas/suggestion-5663252-extended-record-with-syntax-to-work-with-nested-pr](/ideas/suggestion-5663252-extended-record-with-syntax-to-work-with-nested-pr.md)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T04:08:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6906132-implement-first-class-lensing-lenses-in-f"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2016-04-20T10:14:00",
                "Content": "It seems that van Laarhoven style lenses allowing polymorphic updates can be encoded in F#: http://fssnip.net/7Pk"
            },
            {
                "Submitter": "Ivan J. Simongauz",
                "Submitted": "2016-09-03T05:19:00",
                "Content": "What about observable lenses, this is almost necessary for WPF and so on.\r\ntype\r\nchange<'t> =\r\n| Intent\r\n| Await\r\n| Change of 't\r\ntype ObservableLense<'t, 'tv> = ('t -> 'tv, 't -> 'tv -> 'tv, IObservable<'tv change>)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6909164": {
        "Number": "6909164",
        "Submitter": "Alexander Baggett",
        "Submitted": "2015-01-01T00:00:00",
        "Title": "Implement types within types",
        "Text": "It would look something like this\r\ntype Music() =\r\ntype Note() =\r\nstatic member x = 10\r\nstatic member sixteenth = 40",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Alexander Baggett",
                "Submitted": "2015-01-01T03:23:00",
                "Content": "oh dang this doesn't preserve spaces... that makes it hard."
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-01-05T01:54:00",
                "Content": "Search for \"nested\" please."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-16T11:12:00",
                "Content": "Duplicate: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085086-nested-types-for-f"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-01-23T00:00:00",
            "Text": "Duplicate, http://fslang.uservoice.com/forums/245727-f-language/suggestions/6085086-nested-types-for-f"
        }
    },
    "6923281": {
        "Number": "6923281",
        "Submitter": "Vladimir",
        "Submitted": "2015-01-05T00:00:00",
        "Title": "Add possibility to use break and continue in f# loops. And do while loop",
        "Text": "It very often looks better than recursion, and it would be wonderful to have this possibility",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Vladimir",
                "Submitted": "2015-01-05T05:50:00",
                "Content": "And it would be wonderful to add the same things to sequences"
            },
            {
                "Submitter": "Richard Minerich",
                "Submitted": "2015-01-12T12:05:00",
                "Content": "I have mixed feelings about this. On one hand there have been cases where having this would be useful for porting code from other languages, on the other I'd be worried that many would start to use these in cases that are more clearly expressed as recursion and in so doing make the code much more difficult to understand and maintain."
            },
            {
                "Submitter": "Phylos",
                "Submitted": "2015-01-18T00:32:00",
                "Content": "I don't think this is a good idea, as it would encourage perpetuating imperative programming approaches to those new to F#."
            },
            {
                "Submitter": "Vladimir",
                "Submitted": "2015-02-09T04:08:00",
                "Content": "but when we working with arrays, it's not so clear to use recursion. Especially, when we must modify the array. In this case recursion looks very ugly, especially, we must send a lot of arguments there.\r\nP.S. I also like functional style, but in some cases imperative style is much better. And it's very sad when I cant use the best way to resolve some problem in my favorite language, and should use for that, for example, c#"
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2015-02-17T08:39:00",
                "Content": "I'm also not convinced this is a good idea - most of the time when I was learning F# and I wished for break or continue it was because I didn't know how to use the appropriate F# sequence function yet. `Pick` and `find` are two functions that come to mind in helping get out of the imperative way of thinking.\r\nIf you have any examples on where it's truly necessary or preferable to use break / continue I'd love to see them, only because I can't think of any myself."
            },
            {
                "Submitter": "Vladimir",
                "Submitted": "2015-03-06T07:04:00",
                "Content": "Sequences is very slow and there are some situation when performance is required. For example when you work with matrices. Also you can't always use Array module, because its functions always copy array, that is not very well in most cases. So if you can said, how to work with it without recursion, I will be very glad.\r\nI see very often, when some one use \"rec loop\" for making loops functionality. I think it's awful.\r\nI think if you don't need loops (with break and continue) you can don't to use it. I think it's not a big problem to implement this feature and you can decide for yourself, should you use it or not."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "6952125": {
        "Number": "6952125",
        "Submitter": "Richard Dalton",
        "Submitted": "2015-01-11T00:00:00",
        "Title": "Create 'filteri' and 'foralli' functions for the various collections Array, List, Seq",
        "Text": "mapi allows us to map a collection using not just the items in the collection but also the index of each item.\r\nCould we do something similar with filter?\r\nlet nums = [0; 1; 2; 3; 4; 5; 6; 7]\r\nlet atEvenPos = List.filteri (fun i x -> i%2=0) nums\r\nResult\r\natEvenPos = [0; 2; 4; 6]",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:40:00",
                "Content": "Combining this with http://fslang.uservoice.com/forums/245727-f-language/suggestions/6368913-add-array-foralli to cover both \"filteri\" and \"foralli\""
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:51:00",
                "Content": "In F# 4.0 we added List/Array/Seq.indexed, that's enough to satisfy the most common use cases for these without exploding the range of possible functions."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below – using Seq.indexed is enough in F# 4.0, though if necessary the user can write fresh functions explicitly.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "6958404": {
        "Number": "6958404",
        "Submitter": "Isaac Abraham",
        "Submitted": "2015-01-13T00:00:00",
        "Title": "Allow opening of static classes (matching the C# design)",
        "Text": "You currently can't \"open\" a static class e.g. System.Console - only modules or namespaces. We should be able to also open static classes as well.",
        "Votes": 31,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-22T15:32:00",
                "Content": "I agree. Modules are compiled down to static classes anyway, so there should be no technical reason for disallowing it."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:49:00",
                "Content": "Yes, this should I suppose be implemented to match the corresponding C# feature, since static classes will begin to be more common coming from the C# world."
            },
            {
                "Submitter": "Marc Sigrist",
                "Submitted": "2016-02-10T06:15:00",
                "Content": "As in C#, static classes defined in F# will probably become more common. If so, would we still require static classes in F# to be defined via [<AbstractClass; Sealed>]? Or, would it make sense to reuse the static keyword known from 'static member' for 'static type'?"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion. Approved in principle.\r\nWe will open an RFC for this in due course https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs"
        }
    },
    "6961420": {
        "Number": "6961420",
        "Submitter": "Tuomas Hietanen",
        "Submitted": "2015-01-14T00:00:00",
        "Title": "Adopt the (C#/ES6) fat arrow \"=>\" syntax for lambda functions",
        "Text": "\"x => x+1\" is just faster to write than \"fun x -> x+1\"",
        "Votes": 12,
        "Comments": [
            {
                "Submitter": "Tuomas Hietanen",
                "Submitted": "2015-01-14T01:23:00",
                "Content": "F# is usually succinct, but the \"fun\"-keyword breaks the flow."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2015-01-15T15:53:00",
                "Content": "Only be mildly annoyed by the (slight) verbosity of \"fun\", I prefer to rather use Haskell's notion (\\x -> x + 1), instead of the fat arrow.\r\nHaving both \"->\" and \"=>\" for the same thing makes the code confusing and inconsistent. Having both (fun x -> x + 1) and (\\x -> x + 1) is less harmful."
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2015-01-16T07:50:00",
                "Content": "I think \"=>\" is not faster to write than \"->\" using any computer keyboard and it makes code look ugly, heavyweight and confusing (with = and >=)."
            },
            {
                "Submitter": "Phylos",
                "Submitted": "2015-01-18T00:27:00",
                "Content": "While it may seem rather superficial, the fact that most languages that are adding lambda functions have a simple syntax is starting to make F#s' syntax look a little bit out-dated. I think replacing the \"fun\" keyword with Haskells' \"\\\" would be a worthwhile change and make F# code cleaner and modern looking. Completely getting rid of the \"fun\" keyword may be too difficult to do, hence the suggestion of using \"\\\".\r\nRather embarrassingly, even Java and JavaScript will soon have lambda function declarations that will be more succinct than F#!!!"
            },
            {
                "Submitter": "Grant Crofton",
                "Submitted": "2015-01-22T04:44:00",
                "Content": "I agree with trek42"
            },
            {
                "Submitter": "stm",
                "Submitted": "2015-02-02T11:34:00",
                "Content": "That's a duplicate, better vote on this:\r\n[/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions](/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions.md)"
            },
            {
                "Submitter": "mikero",
                "Submitted": "2015-02-11T17:21:00",
                "Content": "Given the number of lambdas in F# code - made larger by the fact that F# doesn't support expressions with \"holes\" (_+_) so we need lambdas to re-arrange arguments (unless you are a combinator person), I think the succinctness of => would be nice. It does seem weird that C# code is more functionally succinct. I'd rather see support for (_ + 1) than (\\x -> x+1)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "This is a duplicate: please move your votes to [/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions](/ideas/suggestion-5663774-remove-fun-keyword-from-lambda-expressions.md)\r\nDon Syme, F# Language Evolution"
        }
    },
    "6961444": {
        "Number": "6961444",
        "Submitter": "Tuomas Hietanen",
        "Submitted": "2015-01-14T00:00:00",
        "Title": "Evaluate tuple before fun-keyword in fun-parameters",
        "Text": "Why you do have to have brackets in fun parameters:\r\nfun (x,y) -> x+y\r\nfun x,y -> x+y\r\nThis \"fun\" with \"->\" is already a kind of brackets.",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:47:00",
                "Content": "I think this would be ambiguous, or at least futz with other aspects of the grammar. I will decline this since it would be a small improvement only."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion, it’s appreciated. I’ve marked it as declined per my comment below.\r\nMany thanks\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "6971122": {
        "Number": "6971122",
        "Submitter": "Eugene Baranov",
        "Submitted": "2015-01-16T00:00:00",
        "Title": "Support for tail recursion modulo cons",
        "Text": "",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-01-16T11:11:00",
                "Content": "Unfortunately this is not possible to implement without making the \"list\" type mutable in FSharp.Core.dll"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6972958": {
        "Number": "6972958",
        "Submitter": "Don Syme",
        "Submitted": "2015-01-16T00:00:00",
        "Title": "Mezzo/Rust-like features for F# code to be data-race free",
        "Text": "Languages like Mezzo, Rust and the M# language (internal to Microsoft) either have or are looking at adding type system features that track the status of references that give access to shared memory.\r\nShared-memory coding is less prevalent in F# because of its functional ans Async features, and because of powerful concurrency collections in the .NET class libraries.\r\nHowever writing code with data-races is still possible when using mutable data.\r\nThere is a fairly large and non-trivial design space to addressing this problem, but some type-based techniques are starting to mature. If done \"right\" they can make writing high-performance concurrent, shared memory code \"data-race free\", that is, some F# code would be provably data-race free.\r\nGiven the design of F#, there would likely be \"back doors\" to this feature, especially when libraries are used. It's status would be somewhat like \"Checked arithmetic\".",
        "Votes": 27,
        "Comments": [
            {
                "Submitter": "Jonathan Protzenko",
                "Submitted": "2015-01-17T23:20:00",
                "Content": "Disclaimer: I am the author of Mezzo; I am also not proficient in F#, especially the internals of the type-checking algorithm.\r\nSuch an addition would be great; however, the way I see it, there are a few difficulties.\r\n- There needs to be a way to easily opt-out of the extended checks. The type system may be very smart, but it will never cover all possible patterns. The user should be able to either use run-time checks (locks?) or assert statically \"I know what I'm doing\" and disable the extended checks, possibly locally.\r\n- Somehow related to the first point, we should be careful about not contaminating other codebases. In our experience with Mezzo, we often witnessed a library offer a \"strong\" interface that enforces data-race freedom, only to see clients of this library struggle to use it. As long as there's a way to easily opt-out of the extended checks, this should not be an issue.\r\n- Having an easy way to convert existing codebases is also key to success. Regardless of the technical means that underpin this feature, users should be able to convert codebases piecewise.\r\n- Implementation-wise, this would probably require changes to the type-checker. I don't know if it is unification-based or uses a flow-sensitive type-checking algorithms. It may be easier to implement these checks in the latter case. There's also the question of whether this should be a separate analysis or directly implemented deep within the type-checker. We chose the latter option for Mezzo, but are still unsure whether the former might have been easier.\r\nFrançois and I wrote this paper where we recount the story of Mezzo and try to figure out what worked, what didn't, and what could've been done better <http://gallium.inria.fr/~fpottier/publis/fpottier-protzenko-lessons-mezzo.pdf>. Hopefully, there's some knowledge in there that may be useful.\r\nI'll follow this topic and I'll happily answer more technical questions, if any :)."
            },
            {
                "Submitter": "Phylos",
                "Submitted": "2015-01-18T00:12:00",
                "Content": "This sounds like it would be a wonderful addition to F#, helping to make it the language of choice for writing safe and robust software for the .NET platform."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:23:00",
                "Content": "I'm going to decline this suggestion (which was made by me) because it is too vague.\r\nMore concrete proposals welcome!!"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Declining per comment below – this was a placeholder and much more concrete suggestions would be needed!"
        }
    },
    "6984621": {
        "Number": "6984621",
        "Submitter": "Isaac Abraham",
        "Submitted": "2015-01-19T00:00:00",
        "Title": "Support for [<CLIEvent>] on modules",
        "Text": "As the name suggests. You can create [<CLIEvent>]s on classes as both instance and static members but not on a module. As far as the consuming e.g. C# library, the fact we're using a module in F# is unknown; from the F# side it's a pity you have to create classes for this behaviour rather than more idiomatic modules.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T09:16:00",
                "Content": "Hi Isaac, my feeling is that requiring a class is consistent with the F# language design. CLIEvent is an object-programming feature - like properties, abstract members etc."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T09:16:00",
                "Content": "Also, static events are rare in design."
            },
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2015-07-17T09:19:00",
                "Content": "Understood. Perhaps a warning or error would be preferable to what you currently get though, which kind of falls between both options i.e. it compiles but generates something unexpected."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6987069": {
        "Number": "6987069",
        "Submitter": "Don Syme",
        "Submitted": "2015-01-20T00:00:00",
        "Title": "Restrict \"private\" for items in namespaces to mean \"private to the namespace declaration group\" #43",
        "Text": "For F# 2.x-4.0, as discussed in thie GitHub thread (https://github.com/Microsoft/visualfsharp/issues/43#issuecomment-70650925), a \"private\" module or type in a namespace is actually accessible from anywhere in that assembly contributing to the same namespace.\r\nThe suggestion is to emit a warning when such an item is accessed from outside the immediate namespace declaration group in which it is declared. For example, we would give a warning if it is accessed from another file in the same namespace in the same assembly.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2016-02-25T16:43:00",
                "Content": "To help support abstract data types as explained here - https://vimeo.com/128464151 - and as discussed in a bug report here - https://github.com/Microsoft/visualfsharp/issues/984\r\nI propose that we add one exception to the proposed rule, rendering it -\r\n\"Restrict \"private\" for items in namespaces to mean \"private to the namespace declaration group\" [except where functions are defined in a module with the same name as the type and in the same namespace.]\"\r\nWe can create module with the same name as the type in namespace by using the [<CompilationRepresentation (CompilationRepresentationFlags.ModuleSuffix)>] attribute on the module, which is a common technique in F#.\r\nThis may seem like a minor exception, but it will keep from breaking code that heavily uses the above abstract data type style, such as here - https://github.com/bryanedds/Prime\r\n- and here - https://github.com/bryanedds/NuGameEngine"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "This problem should be fixed via a warning.\r\nThis is approved for inclusion in a future release of the F# language subject to an implementation and detailed design.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6987639": {
        "Number": "6987639",
        "Submitter": "Keith Battocchi",
        "Submitted": "2015-01-20T00:00:00",
        "Title": "Extend the set of expressions supported in provided methods",
        "Text": "There are some (undocumented) constraints on what kinds of quotations can be returned by a type provider's GetInvokerExpression method. In some cases (e.g. the lack of support for PropertyGet nodes) these missing expression cases have been papered over in the ProvidedTypes wrapper by translation to supported equivalents (e.g. MethodCall).\r\nHowever, for some other cases (e.g. FieldGet, FieldSet) there is no reasonable translation to supported equivalents, and for others (e.g. LetRecursive) there's only an awkward translation that is much less efficient than a real implementation would be.\r\nEven in the cases where there is a reasonable translation (like PropertyGet mentioned above), it seems like it would make sense for the compiler to support the expression forms directly - at the moment the set of supported expressions seems ad hoc.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:28:00",
                "Content": "We may move to a model where the low-level ITypeProvider interface doesn't actually use quotations, but rather some representation of code which is independent of System.Type (and actually simpler because of that). That would be a good time to revisit this. Until then I'm going to leave things as they are and close this one as part of bookkeeping, thanks"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Declined per my comment, thanks for the suggestion\r\nDon Syme, F# Language Evolution"
        }
    },
    "6995318": {
        "Number": "6995318",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2015-01-22T00:00:00",
        "Title": "Use the default keyword instead of the [<DefaultValue>] attribute",
        "Text": "Use the default keyword instead of the [<DefaultValue>] attribute\r\nProgramming is a human activity. I think F# code has to be more elegant and readable for human programmers.\r\nSo, instead of coding:\r\ntype MyType() =\r\nlet mutable myInt1 = 10\r\n[<DefaultValue>] val mutable myInt2 : int\r\n[<DefaultValue>] val mutable myString : string\r\nmember this.SetValsAndPrint( i: int, str: string) =\r\n... member body ...\r\nit would be better and more elegant to write:\r\ntype MyType() =\r\nlet mutable myInt1 = 10\r\nval mutable default myInt2 : int\r\nval mutable default myString : string\r\nmember this.SetValsAndPrint( i: int, str: string) =\r\n... member body ...\r\nPlease declare the [<DefaultValue>] attribute as an obsolete (unrecommeded to use in new code) feature in the F# language specification, but remain it in the language for compatibility with the existing codebase.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-02-08T01:38:00",
                "Content": "Attributes like [<DefaultValue>], [<Sealed>], [<AbstractClass>] and [<VolatileField>] were deliberately not made keywords in order to keep language simple AND to embrace FP where all these stuff are not used at all."
            },
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2015-02-14T11:40:00",
                "Content": "Vasily is right - default values for mutable fields are not really \"normal\" in F# and functional programming - it would be more normal in F# to initialize the values of the fields."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "6995974": {
        "Number": "6995974",
        "Submitter": "Don Syme",
        "Submitted": "2015-01-22T00:00:00",
        "Title": "Add Checked.int8/uint8 and Nullable.int8/uint8/single/double",
        "Text": "This is the tracking issue for https://github.com/Microsoft/visualfsharp/pull/19\r\nF# defines \"int8\" and \"uint8\" as synonyms for \"sbyte\" and \"byte\", both as types and operators. While reviewing the behaviour of \"open Checked\" (which brings new versions of operators into scope) we noticed that new versions of the \"int8\" and \"uint8\" operators are not defined in the \"Checked\" module. This is inconsistent, though a simple workaround is to use the checked \"sbyte\" and \"byte\" operators instead.\r\nWe also noticed that \"Nullable.int8\" and \"Nullable.uint8\", \"Nullable.single\" and \"Nullable.double\" are missing.\r\nThe proposal is to add these.",
        "Votes": 1,
        "Comments": [],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Completed, see https://github.com/Microsoft/visualfsharp/pull/19"
        }
    },
    "6997189": {
        "Number": "6997189",
        "Submitter": "Richard Gibson",
        "Submitted": "2015-01-22T00:00:00",
        "Title": "Allow us to bind names multiple times in a pattern match",
        "Text": "Why not allow us to use the same name multiple times in a pattern? I find myself writing code like this an awful lot:\r\nmatch a with\r\n| Some (x, y, z) when x = y && y = z && x = z ->\r\nprintfn \"Something interesting\"\r\n| _ -> printfn \"Something boring\"\r\nAs shorthand for exactly this, why can't I write:\r\nmatch a with\r\n| Some (x, x, x) -> printfn \"Something interesting\"\r\n| _ -> printfn \"Something boring\"",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Isaac Abraham",
                "Submitted": "2015-01-24T08:38:00",
                "Content": "Because you're binding those fields to specific values for use on the right hand side of the -> - it's not for equality checks."
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-02-08T07:44:00",
                "Content": "I think this is a reasonable proposal. It's not contradictory to bind multiple values to a single pattern variable if they are equal. It's reads nicer than the when guard."
            },
            {
                "Submitter": "Marcus Magnusson",
                "Submitted": "2015-02-08T08:33:00",
                "Content": "I agree, I think this would be nice. Shows intention very clearly. I believe this is supported in Erlang, and the little experience I have of Erlang hasn't shown me any drawbacks to this."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "This was considered in F# 1.0-2.0 but was not included.\r\nAmong other things, the various notions of equality in F# (and indeed any programming language) are sufficiently subtle that it is better if uses of equality checks are made explicit at some point in the code.\r\nSo while the feedback is appreciated, this kind of extension is beyond the scope of what we would consider for the F# language at this point.\r\nThanks\r\nDon Syme, F# Language Evolution"
        }
    },
    "7000134": {
        "Number": "7000134",
        "Submitter": "vanh",
        "Submitted": "2015-01-23T00:00:00",
        "Title": "Define a function the same way as define lambda",
        "Text": "Currently the way we define function is: let add1 x = x +1 which is not consistent with the way we define lambda fun x -> x +1. More importantly this will help new learner like me easily distinguish between a function and a value. When reading code, I always find it easier to find a lambda expression because of the fun keyword and the -> than the function. Since code is read more than write it would help save time too.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2015-01-23T06:37:00",
                "Content": "Sorry, I guess I'm not sure what you're asking for.\r\nlet add1 x = x + 1\r\nis just short for\r\nlet add1 = fun x -> x + 1\r\nBoth are legal F#. Is there something else you're after?"
            },
            {
                "Submitter": "Vanh Phom",
                "Submitted": "2015-01-27T18:41:00",
                "Content": "What I mean is:\r\nfun add1 x -> x + 1 define a function name add1 with parameter x and body x + 1\r\nfun x -> x +1 define a no name function (lambda) with parameter x and body x + 1"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-02-08T01:32:00",
                "Content": "Currently \"fun add1 x -> x + 1\" is a (curried) lambda function, so you cannot use this syntax for anything else."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "While we appreciate the feedback, this kind of fundamental syntax change is beyond the scope of the kind of change we would consider for the F# language at version F# 4.0.\r\nThanks\r\nDon Syme, F# Language Evolution"
        }
    },
    "7002776": {
        "Number": "7002776",
        "Submitter": "Francois Brodeur",
        "Submitted": "2015-01-23T00:00:00",
        "Title": "Connect FSI on breakpoint with environment available.",
        "Text": "I work professionally with F# and I really like the language but there is one thing I find annoying when debugging code, sometimes, variables captured thru closures cannot be seen in either locals or doing a mouse-over. This got me thinking into how the debugging could be improved and I think one thing that would be really great is having the possibility to connect FSI when the program is paused and also have it being fed the environment. The possibility to write F# code to inspect the current state would be great.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:44:00",
                "Content": "This should be a suggestion for the Visual F# Tools, at the Visual Studio User Voice."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:45:00",
                "Content": "(This is not specific to the F# language or core library)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per comment"
        }
    },
    "7006663": {
        "Number": "7006663",
        "Submitter": "Tomas Petricek",
        "Submitted": "2015-01-24T00:00:00",
        "Title": "Revise the reserved keyword list (e.g. remove \"method\")",
        "Text": "The keyword \"method\" is currently reserved for future use.\r\nIn many web programming scenarios \"method\" refers to the HTTP method (GET/POST) and the fact that you currently have to escape the keyword and write ``method`` is annoying. Calling function parameter \"meth\" instead works (though some people may find this an unfortunate naming ;-)), but it is against F# coding guidelines. And furthermore, this only helps when you're defining the API, but sometimes you need to consume C# API that already has \"method\" as optional argument.\r\nI think that the F# community is quite happy with using the name \"member\" for declaring all members (including methods, properties and events) and I don't really think there is a need for keeping \"method\" reserved.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T09:11:00",
                "Content": "Tomas - could you possibly extend the proposal to assess the entire reserved-keyword list please? If we're going to revise the list, we should do it wholesale.\r\ncheers!\r\ndon"
            },
            {
                "Submitter": "Gusty",
                "Submitted": "2015-09-29T10:09:00",
                "Content": "I agree, to be fair all reserved keywords should be reviewed. For instance I would be very happy to have keywords available like 'const' which is a very common combinator. If it is not included in the F# core at least give us the option to define it in our libs. Can we also extend the review to operators? Why is $ alone allowed but not composed with other operators?"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-24T00:00:00",
            "Text": "Agreed the list needs revision. Marking as “approved in principle”.\r\nRFC at https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1016-unreserve-keywords.md"
        }
    },
    "7017131": {
        "Number": "7017131",
        "Submitter": "Don Syme",
        "Submitted": "2015-01-27T00:00:00",
        "Title": "Make F# union types like \"list\" that have no subtypes 'sealed'",
        "Text": "The compiled form of the \"list\" type in F# uses a single class. This is also the case for some other F# union types, e.g. ones which are enumerations where no case carries any data. For these types, the compiled representation of the union type should be marked \"sealed\" in F# metadata\r\nThis is a breaking change w.r.t. hypothetical clients in other .NET languages that take advantage of this, though we know of no such instance in practice.",
        "Votes": 1,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-03T00:00:00",
            "Text": "Considering this approved for F# 4.x or the first possible update after this.\r\nDiscussion still very welcome.\r\nImplementations of approved language design items can now be submitted as pull requests to the appropriate branch of http://github.com/Microsoft/visualfsharp. See http://fsharp.github.io/2014/06/18/fsharp-contributions.html for information on contributing to the F# language and core library.\r\nDon Syme, F# Language/Library Evolution"
        }
    },
    "7031066": {
        "Number": "7031066",
        "Submitter": "David Crook",
        "Submitted": "2015-01-30T00:00:00",
        "Title": "Ability to simply move files in the Solution Explorer",
        "Text": "I just want to click, drag and move files around in the solution explorer. As of today I have to unload my solution, edit my fsproj file and move on. How in the world do you do enterprise development like this?",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-02-02T01:11:00",
                "Content": "You can use Visual F# Power Tools to create folders and moves files between them.\r\nWhy do you think enterprise development is different from others that it requires folders a lot? I find neediness of folders very rarely."
            },
            {
                "Submitter": "Pierre Irrmann",
                "Submitted": "2015-02-02T01:18:00",
                "Content": "Even though power tools enable folder creation (except the problem of unique names), the ability to move files with easy dragn'drop would be a nice feature. I've heard colleagues of mine complaining about this missing support."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "Since this is about the Visual F# Tools (rather than the F# language) this belongs at https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools\r\nPlease add an entry there or vote on an existing one.\r\nYour feedback is most welcome though!\r\nThanks!"
        }
    },
    "7031077": {
        "Number": "7031077",
        "Submitter": "David Crook",
        "Submitted": "2015-01-30T00:00:00",
        "Title": "Ability to add web file types to project",
        "Text": "I am building an enterprise FSharp web application with Web API and I can't even add a simply .html page to my solution without cracking open the FSProj file every time.\r\nI spend more time in the FSProj file than actually writing FSharp code.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Patrick McDonald",
                "Submitted": "2015-02-02T06:14:00",
                "Content": "There is currently a Visual Studio extension called 'F# Web Item Templates' which adds this functionality."
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2015-02-03T20:57:00",
                "Content": "See https://visualstudiogallery.msdn.microsoft.com/f1dae7fe-1ecc-4f1b-86b5-32a2970d012a and https://visualstudiogallery.msdn.microsoft.com/39ae8dec-d11a-4ac9-974e-be0fdadec71b. I hope those are of some help."
            },
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2015-02-03T20:59:00",
                "Content": "I should also note that I have a pull request into the Visual F# Tools project to add the web templates. No one has yet submitted the item templates as a PR. http://visualfsharp.codeplex.com/SourceControl/network/forks/riles01/webtemplates/contribution/7650"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "Since this is about the Visual F# Tools (rather than the F# language) this belongs at https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools\r\nPlease add an entry there or vote on an existing one."
        }
    },
    "7031088": {
        "Number": "7031088",
        "Submitter": "David Crook",
        "Submitted": "2015-01-30T00:00:00",
        "Title": "Ability to rename files",
        "Text": "I just want to rename files. If I do this, my content type changes to none, and the file floats to the top. So not only can I not just click and drag (see other request), but I still have to go into the .fsproj file again and chance the type back to Content.\r\nYou really should just make F# easier to deal with, I know there is fancy stuff people want, I want it to, but my goodness I would kill for these simple features!",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "David Crook",
                "Submitted": "2015-01-30T11:09:00",
                "Content": "sorry about my spelling, smaller keyboard than normal."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "Since this is about the Visual F# Tools (rather than the F# language) this belongs at https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools"
        }
    },
    "7039406": {
        "Number": "7039406",
        "Submitter": "Don Syme",
        "Submitted": "2015-02-01T00:00:00",
        "Title": "Add a \"Scripting\" module to FSharp.Core.dll, including a wget function",
        "Text": "I suggest we add a \"Scripting\" module to FSharp.Core.dll (.NET Framework Version) that makes F# Interactive a more fluent and connected scripting environment\r\nMinimally, I want enough that F# scripts can meaningfully bootstrap a connection to a package tool in a succinct header to a script. For example\r\nopen Scripting\r\ncd __SOURCE_DIRECTORY__\r\nif not (fileExists \"paket.exe\") then\r\nwget \"https://github.com/fsprojects/Paket/releases/download/0.26.2/paket.exe&quot;\r\n;;\r\nFor example, this would enable very neat self-contained F# scripts to get and use packages: https://gist.github.com/dsyme/9c95a66a18b2c625b057\r\nSome sample code is below - it is not complete or robust at all, and a considerable amount of discussion would be needed. Not all operations would necessarily be needed - as can be seen above, I only really feel the pain with regard to \"wget\". Further, the \"wget\" would need to be made robust with sensible defaults, e.g. See https://github.com/fsprojects/Paket/blob/master/src/Paket.Bootstrapper/Program.cs#L93-L115.\r\nmodule Scripting =\r\nlet (++) a v = System.IO.Path.Combine(a, v)\r\nlet filename filePath = System.IO.Path.GetFileName(filePath)\r\nlet changext filePath ext = System.IO.Path.ChangeExtension(filePath,ext)\r\nlet extension filePath = System.IO.Path.GetExtension(filePath)\r\nlet fullpath filePath = System.IO.Path.GetFullPath(filePath)\r\nlet rootdir filePath = System.IO.Path.GetPathRoot(filePath)\r\nlet basename filePath = System.IO.Path.GetFileNameWithoutExtension(filePath)\r\nlet dirname filePath = System.IO.Path.GetDirectoryName(filePath)\r\nlet ls dirPath = System.IO.Directory.EnumerateFiles dirPath\r\nlet writeText filePath contents = System.IO.File.WriteAllText(filePath,contents)\r\nlet readText filePath = System.IO.File.ReadAllText(filePath)\r\nlet lines filePath = System.IO.File.ReadAllLines(filePath)\r\nlet linesAsSeq filePath = System.IO.File.ReadLines(filePath)\r\nlet (.>>) contents filePath = System.IO.File.AppendAllText(filePath, contents)\r\nlet (.>) contents filePath = System.IO.File.WriteAllText(filePath, contents)\r\nlet cat filePath = linesAsSeq filePath |> Seq.iter System.Console.Out.WriteLine\r\nlet echo (text:string) = System.Console.Out.WriteLine text\r\nlet wget (url:string) =\r\nuse wc = new System.Net.WebClient ()\r\nlet tmp = System.IO.Path.GetTempFileName()\r\nwc.DownloadFile(url, tmp)\r\nlet target = filename url\r\nSystem.IO.File.Move(tmp,target)\r\n\r\nlet fileExists filePath = try System.IO.File.Exists filePath with _ -> false\r\nlet cd dirPath = System.Environment.CurrentDirectory <- dirPath",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-01T18:25:00",
                "Content": "Note, I'm not particularly attached to the Unix names and don't necessarily think we should add those to a \"Scripting\" module in FSharp.Core.dll. But I am attached to the idea that getting a file from the web robustly and reliably with sensible download defaults suitable for scripting should be much easier than this kind of thing: https://github.com/fsprojects/Paket/blob/master/src/Paket.Bootstrapper/Program.cs#L93-L115\r\nThat's especially because a single \"web fetch\" is an immensely powerful thing when it gets a .NET bootstrapping DLL which can be referenced later in the script. (In the example in the gist, initially the #r \"paket.exe\" reference is shown as unresolved. Once it has been downloaded by the user by executing the first part of the script the reference shows as resolved and can be evaluated)."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-01T18:40:00",
                "Content": "See also this sample, which shows how you can add a Paket.exe download to an F# script without needing \"wget\" - i.e. in a way that works today\r\nhttps://gist.github.com/dsyme/9b18608b78dccf92ba33"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T15:02:00",
                "Content": "I'm closing this since few people have voted for it and it doesn't seem to be blocking people"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-06-25T23:32:00",
                "Content": "I still think this would be really useful. Especially if it was built on top of the dotnetcore apis"
            }
        ],
        "Status": "declined",
        "Response": null
    },
    "7055281": {
        "Number": "7055281",
        "Submitter": "Max",
        "Submitted": "2015-02-05T00:00:00",
        "Title": "Add a symbol for FSI to check whether it's in 64 bit or 32 bit",
        "Text": "Often I want to reference different libraries based on whether the FSI is running in 32 bit or 64 bit mode. I often have to test two versions of an assembly, and it's enough of a pain just changing the flag every time, let alone change the references. Being able to do:\r\n#if 64_BIT\r\n#r \"My64BitLib.dll\"\r\n#else\r\n#r \"My32BitLib.dll\"\r\n#endif",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2015-07-17T08:32:00",
                "Content": "This seems entirely reasonable for scripting code.\r\nI'll mark it as \"approved in principle\", however the Visual F# Tools team and others may have opinions about how we deal with this kind of configuration parameter. Probably the best thing to do is send a PR to http://github.com/Microsoft/visualfsharp and continue the discussion there, then link back to this discussion."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "This is approved for inclusion in a future release of F# subject to an implementation and detailed design. A pull request to implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and testing to http://github.com/Microsoft/visualfsharp. Discussion of the particular version for this to be included in can be made once an implementation is available.\r\nDesign detail can also be discussed below.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7063652": {
        "Number": "7063652",
        "Submitter": "Carl Patenaude Poulin",
        "Submitted": "2015-02-06T00:00:00",
        "Title": "provide reflected definitions by default",
        "Text": "Having access to all code by default would greatly improve the metaprogramming story of F#.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "mikero",
                "Submitted": "2015-02-11T17:09:00",
                "Content": "Or at least using a namespace/module-level attribute or compile switch"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-13T04:13:00",
                "Content": "As of F# 3.1 you can add the ReflectedDefinition attribute to a module.\r\nCheers\r\nDon"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-02-14T00:00:00",
            "Text": "This is really already done – RefelctedDefinition is allowed on modules"
        }
    },
    "7067304": {
        "Number": "7067304",
        "Submitter": "luketopia",
        "Submitted": "2015-02-07T00:00:00",
        "Title": "Add Haskell-style operator sections",
        "Text": "Imagine that you have a list of integers, and you want to filter it down to all the numbers greater than 10. You might erroneously try to partially apply the greater than operator as follows:\r\nnums |> Seq.filter ((>) 10)\r\nUnfortunately, this won't have the intended effect, because the arguments are applied to the operator in the wrong order. To get the intended effect you have to do\r\nnums |> Seq.filter ((<) 10)\r\nwhich looks backwards and is confusing. Therefore, you end up often just using a lambda to control the order of application without reversing the operator.\r\nnums |> Seq.filter (fun x -> x > 10)\r\nWhat you really want is Haskell's notion of operator sections, where you can place one of the operands inside the parentheses on either side of the operator to make it clear which argument you intend to apply first.\r\nSo for instance, to find all the numbers greater than 10 you do\r\nnums |> Seq.filter (>10)\r\nwhereas to find all the numbers 10 is greater than you do\r\nnums |> Seq.filter (10>)\r\nI think this would fit very well with the existing syntax. Haskell has both notations and it doesn't cause any issues except with minus due to its duality as a unary and binary operator. As a side note, Haskell also allows sections to be used with functions called with the infix notation (that places the function name in backticks), which is sometimes more succinct than a lambda.\r\nhttps://wiki.haskell.org/Section_of_an_infix_operator",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:29:00",
                "Content": "To me this doesn't sit well as an addition to F#. First, the resolution of \"<\" and \">\" in the F# syntax is non-trivial because of their use as type applications. Next, the bar to change and extend the F# expression syntax is high indeed at this stage - the utility gained needs to be large, and the application domain broad.\r\nSo my inclination is to decline this."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7068430": {
        "Number": "7068430",
        "Submitter": "luketopia",
        "Submitted": "2015-02-08T00:00:00",
        "Title": "Add 'except' function to core collection modules",
        "Text": "In C# you can do\r\nxs.Except(ys)\r\nWithout defining a function, the F# equivalent is\r\nxs |> Seq.filter (fun x -> ys |> Seq.exists ((=)x) |> not)\r\nOf course, with the F# 4.0 collection normalization you can replace \"Seq.exists ((=)x)\" with \"Seq.contains x\".\r\nIf you convert to a Set first then there's Set.difference but the problem is that it is not in correct order for partial application so can't be used in a pipeline, and the other argument also needs to be a set.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-02-08T09:33:00",
                "Content": "If we add this, then it needs to be done for array, seq and list."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-14T12:14:00",
                "Content": "This is a reasonable suggestion.\r\nAn implementation of this for Seq, Array and List with full testing and performance analysis on empty, small and large inputs would be needed (with appropriate optimizations when the inputs are arrays or ICollection), and testing under a range of inputs to check that F# equality semantics are being used. Performance comparisons with the LINQ implementation should also be made.\r\nAlthough this wasn't on the list of functions for F# 4.0 FSharp.Core 4.4.0.0 update, if you're quick about a PR we could still consider it for that release. Even if it isn't accepted for that release (indeed, it is quite possible it wouldn't be), it would still be useful to have the PR prepared and in place for some later library update.\r\nDon"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-02-14T17:04:00",
                "Content": "Thanks for the response! I think this would be a good first PR for me but it probably won't make it on time due to other things I'm working on, plus needing to get the CLA signed."
            },
            {
                "Submitter": "David Obadz",
                "Submitted": "2015-02-15T05:34:00",
                "Content": "xs |> Seq.filter (not << flip Set.contains (set ys)) <= wish we didn't need the flip.."
            },
            {
                "Submitter": "Patrick McDonald",
                "Submitted": "2015-02-20T03:52:00",
                "Content": "I've create a PR on github for this: https://github.com/Microsoft/visualfsharp/pull/253\r\nThe implementations suggested here are different from the LINQ implementation, as LINQ removes duplicates from the results."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-04-09T00:00:00",
            "Text": "This proposal has been accepted and completed as part of F# 4.0, see https://github.com/Microsoft/visualfsharp/pull/253#issuecomment-87232623\r\nDon Syme, F# Language Evolution"
        }
    },
    "7072844": {
        "Number": "7072844",
        "Submitter": "Isaac Abraham",
        "Submitted": "2015-02-09T00:00:00",
        "Title": "Utilise CLR union types for discriminated unions",
        "Text": "CLR has native support for union types; these could provide optimization and performance opportunities for F# discriminated unions.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "David Taylor-Fuller",
                "Submitted": "2015-02-16T17:31:00",
                "Content": "Would love to know why this wasnt done in the initial implementation."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-05-21T18:09:00",
                "Content": "Also interested. Does anyone have more information on native union types in the CLR?"
            },
            {
                "Submitter": "Sam Isaacson",
                "Submitted": "2015-07-14T04:58:00",
                "Content": "When you say \"native support for union types\" do you mean the usage of attributes <StructLayout( LayoutKind.Explicit )> or something else?\r\nI currently have a need for a DU type that is not heap allocated - this is causing performance problems via the \"JIT_new\" operation being expensive."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:24:00",
                "Content": "It would be good to have some mock-up code with performance comparisons for this."
            },
            {
                "Submitter": "Zoltan Podlovics",
                "Submitted": "2015-12-30T07:55:00",
                "Content": "A proof of concept explicit structlayout based demo available at:\r\nhttps://github.com/Microsoft/visualfsharp/pull/620\r\nhttps://gist.github.com/zpodlovics/80e12e2de35cf73e6e03\r\nHowever, it limited only to blittable types. Combine it with blittable type constraint and you can have stack allocated DU."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "7089800": {
        "Number": "7089800",
        "Submitter": "Nils Lück",
        "Submitted": "2015-02-13T00:00:00",
        "Title": "Add more persistent collections",
        "Text": "Immutability is one of the large advantages of functional programming. However, in order to effectively utilize such immutability, a good set of persistent data structures are necessary.\r\nOther modern functional programming languages like Scala and Clojure offer a much richer set of immutable data structures, which makes F# feel lacking in this respect, and this in turn encourages developers to fall back to regular .NET collections.\r\nWhereas third party alternatives exist, common data structures are so general, that they should be in the std. library. We should at least add the following:\r\n- persistent queue\r\n- persistent vector\r\nBut we could consider adding more efficient HAMT based maps/sets, and immutable arrays, as well",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-13T04:11:00",
                "Content": "Use System.Collections.Immutable? https://msdn.microsoft.com/en-us/library/dn385366(v=vs.110).aspx"
            },
            {
                "Submitter": "Nils Lück",
                "Submitted": "2015-02-13T13:28:00",
                "Content": "Then we should at least provide a nice wrapper api for those - working with the C# api is cumbersome at best. Also, it doesn't seem overly consistent with the custom map/set implementation we have now.\r\nFurther, their chosen data structures are inferior at best. A Bitmapped vector trie is much faster than an AVL tree vector. And the current queue implementation was not persistent the last time I looked in the source.\r\nOne of the key advantages of a language like clojure is that it provided a rich set of efficient immutable and persistent data structures, all with a nice and consistent API. This makes working with immutable data a joy. One of the reasons, I assume, they spend much energy on that part."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-02-14T11:16:00",
                "Content": "Nils - have you checked out FSharpx.Collections? That may be a good place to contribute top-quality immutable data structure implementations. ExtCore is another possibility.\r\nHowever I agree it would be good to bring the best of these streams together into an FSharp.Collections.Immutable"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:16:00",
                "Content": "All in all I think this belongs outside FSharp.Core. I am very supportive of better immutable collections (and we actually have a fabulous set of collections in System.Collections.Immutable -= which are actually very nice to use from F#).\r\nBut I think any F# view of these (or additions to them) is best developed as an add-on package."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:21:00",
                "Content": "As mentioned below, there are many good options for additional immutable collections with F# - some of the options are listed below.\r\nThe recommendation is that any additional new immutable collections should be added to F# community libraries (with nuget packages) or as new standalone nuget packages. Listing the packages on http://fsharp.org and putting their implementation in http://github.com/fsprojects is a good option."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as completed – evolution will be done through additional packages like those mentioned, and there are already several good packages available.\r\nFor discussion see the comments below. Further discussion and links to newly available libraries welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7089811": {
        "Number": "7089811",
        "Submitter": "Nils Lück",
        "Submitted": "2015-02-13T00:00:00",
        "Title": "Include an Option workflow in the std. lib",
        "Text": "An Option workflow/monad is incredibly useful when working with Options, and a common enough pattern that it should be provided by default rather than in third party libraries.",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:18:00",
                "Content": "The current design position is that this is best done in community libraries. However I'd be interested in further feedback about whether this should be in FSharp.Core"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:42:00",
                "Content": "I propose to decline this since I'm basically OK with this being in user code or in a community library, rather than in FSharp.Core."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion. Declined per my comment below.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "7090326": {
        "Number": "7090326",
        "Submitter": "Don Syme",
        "Submitted": "2015-02-13T00:00:00",
        "Title": "Make the single-line use of [<Literal>] consistent",
        "Text": "See https://github.com/Microsoft/visualfsharp/issues/229\r\nSome declaration constructs allow attributes on the same line as the keyword for the declaration, e.g.\r\n[<Measure>] type kg\r\n[<Measure>] type m\r\nHowever this doesn't work for \"let\" bindings, e.g.\r\nhttps://cloud.githubusercontent.com/assets/445888/6168930/cd4fc538-b2c9-11e4-8961-6efa3f0e4080.png\r\nRight now the consistent way to do things is always to use multiple lines, e.g.https://cloud.githubusercontent.com/assets/445888/6168957/07eb7688-b2ca-11e4-887e-97e8de7c90c9.png.\r\nThe suggestion is to make this consistent by allowing single-line use everywhere, if that is technically possible.",
        "Votes": 6,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Closing as this idea (listed by me) as it has little support"
        }
    },
    "7090613": {
        "Number": "7090613",
        "Submitter": "Robert Jeppesen",
        "Submitted": "2015-02-13T00:00:00",
        "Title": "Allow type providers to affect update-check",
        "Text": "In short, if a TP uses a file, and that file changes, the needs-update check has no way of knowing to rebuild the project.\r\nSome suggestions here: https://github.com/Microsoft/visualfsharp/issues/234",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:20:00",
                "Content": "Looking at the original issue, @latkin confirmed that using the \"Content\" item type should solve things. If that's not the case please add more detail to that issue."
            }
        ],
        "Status": "declined",
        "Response": null
    },
    "7096866": {
        "Number": "7096866",
        "Submitter": "Anonymous",
        "Submitted": "2015-02-14T00:00:00",
        "Title": "Release the F# Visual Studio plugin code",
        "Text": "It would be very interesting to have access to the VS plugin code for F#, particularly the debugger integration.\r\nIt would allow tools vendors (IntelliFactory, Xamarin...) to re-use and even tweak the debugger. Community contributors could work towards improving the F# debugging experience, for example by adding support for autos and \"Edit and Continue\".",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Sergey Tihon",
                "Submitted": "2015-02-15T05:10:00",
                "Content": "Have you checked https://github.com/Microsoft/visualfsharp/tree/fsharp4/vsintegration ?"
            },
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-06-15T03:43:00",
                "Content": "It should be closed since Visual F# Tools is fully open sourced now."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "see comments"
        }
    },
    "7098665": {
        "Number": "7098665",
        "Submitter": "mikero",
        "Submitted": "2015-02-15T00:00:00",
        "Title": "Provide a concise and performant item+index for loop (\"with index\")",
        "Text": "It's a very common pattern to want to get an item and its index, especially for code that is meant to be performant.\r\nCurrently (AFAIK) to get the index and item from a sequence or collection you must use iteri() (or Zip with a range) -- this causes code to become syntactically less clear (esp. when nested) and is less performant than adding a mutable counter inside each loop:\r\nseq1 |> Seq.iteri (fun index item ->\r\n...\r\nseq2 |> Seq.iteri (fun index2 item2->\r\n...)\r\n...)\r\nI suggest that a for loop with an additional \"with\" clause:\r\nfor item with index in seq1\r\n....\r\nor\r\nfor item in seq with index\r\n....\r\nThe advantage of this syntax is that (a) it uses the existing \"with\" keyword and (b) it does not conflate the index with the user's data as the tuple used in iteri does.\r\nThis would be roughly equivalent to:\r\nlet mutable index = 0\r\nfor item in seq do\r\n...\r\nindex <- 1 + index\r\nHowever, the goal would eventually be for the compiler in the case of native collections (arrays, lists, etc.) to avoid the call the iterator and access successor items directly, as the C# compiler foreach does in some cases.\r\nOne could imagine that this pattern could be extended by the user (a la workflows) to provide a richer item than an index - such as an object that provides a mutator/zipper function, etc., but that a whole other kettle of fish.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:13:00",
                "Content": "I've often wanted something in this zone for F# comprehension syntax. I'd appreciate additional feedback on this proposal and ideas about alternative syntaxes"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:46:00",
                "Content": "In F# 4.0 Seq.indexed has been provided as a marking combinatory, please use that."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined in favour of using Seq.indexed in F# 4.0, see comment below"
        }
    },
    "7099985": {
        "Number": "7099985",
        "Submitter": "Sven Grosen",
        "Submitted": "2015-02-15T00:00:00",
        "Title": "Support Multiple Properties in StructuredFormatDisplayAttribute",
        "Text": "There's currently a limitation in StructuredFormatDisplayAttribute whereby you can only provide a single property in the Value.\r\nSo for a type like this: type Person = {First: string; Last: string} I have to create another property like FullName to use in StructuredFormatDisplayAttribute. The fix/enhancement should be easy to do, and something I could probably just do myself.\r\nI first broached this subject on StackOverflow and Tomas Petricek suggested I create an issue for this. Here's the link to the SO question: http://stackoverflow.com/questions/28505368/can-i-use-multiple-properties-in-a-structuredformatdisplayattribute",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-05-21T18:09:00",
                "Content": "This is planned for F# 4.0: http://blogs.msdn.com/b/dotnet/archive/2015/04/29/rounding-out-visual-f-4-0-in-vs-2015-rc.aspx\r\nSee section \"Multiple properties in [<StructuredFormatDisplay>]\""
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "See comments – in F# 4.0"
        }
    },
    "7119363": {
        "Number": "7119363",
        "Submitter": "Gauthier Segay",
        "Submitted": "2015-02-19T00:00:00",
        "Title": "An attribute enforcing usage (in F# code) of named parameters at callsite",
        "Text": "In some code, it's critical to have function/methods called with parameter names at call site, for readability reasons, but also for correctness.\r\nI would like F# to enforce this using an attribute for example: [<EnforceNamedParametersAtCallSite>]\r\nsuppose we have this code (for sake of showing the idea):\r\ntype Foo() =\r\nmember x.Bar(b, a) = (a, b)\r\nlet foo = new Foo()\r\nfoo.Bar(1.00, 0.00)\r\nfoo.Bar(a = 1.00, b = 0.00)\r\nnow suppose we have this slight change in the code (just swapped the parameter names)\r\ntype Foo() =\r\nmember x.Bar(b, a) = (a, b)\r\nthis would not produce the expected result\r\nfoo.Bar(1.00, 0.00)\r\nWith the proposed feature:\r\ntype Foo() =\r\n[<EnforceNamedParametersAtCallSite>]\r\nmember x.Bar(b, a) = (a, b)\r\nfoo.Bar(1.00, 0.00) // doesn't compile, expects usage of parameter names\r\nAnother example is with FSharp.Data.SqlClient's SqlCommandProvider, which defines methods taking parameters based on their order of appearance in the sql code.\r\nsamplesql1.sql\r\n------------------------------------\r\ndeclare @numerator float\r\ndeclare @denominator float\r\nset @numerator = @a\r\nset @denominator = @b\r\nselect @numerator / @denominator\r\nsamplesql2.sql\r\n------------------------------------\r\ndeclare @numerator float\r\ndeclare @denominator float\r\nset @denominator = @b // swapped this line, didn't change anything else\r\nset @numerator = @a\r\nselect @numerator / @denominator\r\nsample1.fsx\r\n------------------------------------\r\n#r @\"..\\tools\\nuget\\packages\\FSharp.Data.SqlClient\\lib\\net40\\FSharp.Data.SqlClient.dll\"\r\nopen FSharp.Data\r\ntype divideInSql = SqlCommandProvider< \"sample1.sql\", YourConnectionString>\r\nlet cmd = new divideInSql()\r\ncmd.Execute(0.0, 1.0) // work but wait bellow (don't want that to compile)\r\ncmd.Execute(a = 0.0, b = 1.0) // works\r\ncmd.Execute(b = 1.0, a = 0.0) // works\r\nsample2.fsx\r\n------------------------------------\r\n#r @\"..\\tools\\nuget\\packages\\FSharp.Data.SqlClient\\lib\\net40\\FSharp.Data.SqlClient.dll\"\r\nopen FSharp.Data\r\ntype divideInSql = SqlCommandProvider< \"sample2.sql\", YourConnectionString>\r\nlet cmd = new divideInSql()\r\ncmd.Execute(0.0, 1.0) // fails divide by 0 (don't want that to compile)\r\ncmd.Execute(a = 0.0, b = 1.0) // works\r\ncmd.Execute(b = 1.0, a = 0.0) // works\r\n------------------------------------\r\nWe have seen by now that change of order in a sql file provokes havoc.\r\nAPI design wise, some people might want to enforce that callsite will use named parameters to avoid those kind of misshaps.\r\nI hope the description is clear enough.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:04:00",
                "Content": "I can see the rationale.\r\nIt feels uncomfortable to add a bespoke attribute for this though I don't have specific better suggestions as yet. There's nothing quite like this in the F# language design, apart from the requirement to name record fields in the { a=1; b = 2} construction syntax, which is of course a related problem."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "7138324": {
        "Number": "7138324",
        "Submitter": "Steven Taylor",
        "Submitted": "2015-02-24T00:00:00",
        "Title": "Record type inference suggestion",
        "Text": "Note that if the record {a: int; b: int} is declared last, then type + argument name type inference will not work. Switching the order around resolves the issue. However, this behaviour can be a little mentally jarring.\r\nThe lightweight syntax is very useful. It'd be great to strengthen it up.\r\nmodule Eg1 =\r\ntype AB = {a: int; b: int}\r\ntype A = {a: int}\r\ntype B = {b: int}\r\nlet a = {a=1}\r\nlet b = {b=2}\r\nlet ab = {a=1;b=2}\r\nmodule Eg2 =\r\ntype A = {a: int}\r\ntype B = {b: int}\r\ntype AB = {a: int; b: int} // <- NB. only the order has changed\r\nlet a = {a=1} // fail\r\nlet b = {b=2} // fail\r\n// note that example 3 resolves the ambiguity with the dot syntax on the first named field, but that's not the point.\r\nmodule Eg3 =\r\ntype A = {a: int}\r\ntype B = {b: int}\r\ntype AB = {a: int; b: int}\r\nlet a = {A.a=1}\r\nlet b = {B.b=2}\r\nlet ab = {a=1;b=2}",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-02-28T07:19:00",
                "Content": "There was a relevant thread there:\r\nhttps://groups.google.com/forum/#!topic/fsharp-opensource/vb3pTUAcRVs"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:38:00",
                "Content": "Yes, it looks reasonable to be more flexible here. I will mark this as approved-in-principle"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Marking this as approved-in-principle, per my comment below\r\nWe will open an RFC for this in due course, though the change should not be large\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme, F# Language Evolution"
        }
    },
    "7138426": {
        "Number": "7138426",
        "Submitter": "Steven Taylor",
        "Submitted": "2015-02-24T00:00:00",
        "Title": "make match phrases passable as an argument value",
        "Text": "when walking tree DU structures, it would be useful to pass match expressions to a walking function instead of being forced to hardwire it. Perhaps this also requires a match signature.\r\ne.g.\r\nstatic member walk ast =\r\nlet rec walk ast = ast |> function | ListOfX(_,l) -> [for e in l -> walk e] |> List.concat | e -> [e]\r\nwalk ast",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2015-02-26T05:51:00",
                "Content": "You can already do this, match functions can be passed as lambdas."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:07:00",
                "Content": "Yes, this is what \"function\" is for as far as I understand the request."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7156040": {
        "Number": "7156040",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2015-03-01T00:00:00",
        "Title": "Please make a correct ‘modulus’ for F#",
        "Text": "Please fix a bug in the F# compiler. Everybody needs correct values for negative numbers. The algorithm calculating a modulo should respect the existing math rules. For example, 11 % 5 = 1 (correct), but -11 % 5 is -1 (bug), should be 4 (correct value).\r\nFor instance, m mod n: for integers m and n, m mod n is the integer for which 0 <= r < n and m-r is a multiple of n. For example, 11 mod 5 = 1, and -11 mod 5 = 4.\r\nDetails of discussion and suggested corrections to the algorithm of the % operator are here: 1) http://gettingsharper.de/2012/02/28/how-to-implement-a-mathematically-correct-modulus-operator-in-f/\r\n2) Distinctions between rem and mod: http://mathcentral.uregina.ca/QQ/database/QQ.09.12/h/eric1.html",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "Fraser Waters",
                "Submitted": "2015-03-12T07:11:00",
                "Content": "This matches the behavior of % in C# (and nearly every other language), it would also be a significant breaking change. But adding a new builtin function to do this would be a good idea."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:06:00",
                "Content": "Just to confirm that our decision in F# 1.0 was to follow C#'s design here.\r\nWe would welcome a PR to github.com/Microsoft/visualfsharp/ to add a new operator."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-06-22T23:15:00",
                "Content": "` %. ` should be that operator"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-07-03T13:49:00",
                "Content": "Another option would be to move `mod` from the set of keywords in \"mlcompatibility\" mode to the standard language keywords"
            },
            {
                "Submitter": "Alexei Odeychuk",
                "Submitted": "2016-07-05T13:13:00",
                "Content": "I agree with Jared Hester (July 03, 2016 11:49). The \"mod\" operator would be a great addition to the F# language!\r\nFor example, the \"mod\" exists in Object Pascal (Delphi), No. 12 in TIOBE Language Popularity Index.\r\nAs to \"%.\" operator suggested by Jared Hester (June 22, 2015 21:15), I believe it would add nothing to code readability. Programming is a human activitiy. The more readable and correct code, the better for programmers and language popularity.\r\nI am strongly in favor of the \"mod\" operator."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "7156559": {
        "Number": "7156559",
        "Submitter": "Steven Taylor",
        "Submitted": "2015-03-01T00:00:00",
        "Title": "modules to extend a DU",
        "Text": "If you extend a DU with a static member, there is no way to define and use Active Patterns or Partial Active Patterns from within such a member. I propose that we create a way to do this.\r\nOtherwise, to group such items under a similar name, we need to come up with a new area.\r\nSay:\r\ntype AST = | One | Two\r\nmodule ASTEx =\r\nIf you don't go with a new module, it's possible to overuse the catch all pattern for reasons of convenience:\r\n| _ -> failwith \"failed\"\r\nIt'd be better to default to type safe expression that would warn you to incomplete coverage.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-03-01T18:25:00",
                "Content": "Steve, I'm not understanding the proposal, could you give further details?\r\nI think currently you can add static (and instance) members to the whole DU, is that something which is related to what you would like to have supported?"
            },
            {
                "Submitter": "Steven Taylor",
                "Submitted": "2015-03-02T03:47:00",
                "Content": "Yes you can add static members (and instance) members to the whole DU. That's not the issue. What you can't do, to my knowledge, is include active patterns (or partial active patterns) to be used while defining these static / instance member definitions. It'd be nice to be able to do this. I I sometimes cover all cases explicitly... as the _ wildcard hides when the DU has had an additional member placed in it. I like the warning that pops up. When in a module, if you wanted to skip being explicit every time, you might use an Active Pattern (like perhaps there are broad categories in your DU). I think there's an extra opportunity here to place this load onto the compiler. Active Patterns tend tom cut down the amount of effort needed to set-up / maintain your match statements\r\nDoes that make sense?"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-03-05T15:16:00",
                "Content": "Steven, I think I understand what you explain about maintaining matches and avoiding _ wildcard (see this where I define a SetTimeout/DontSetTimeout https://github.com/smoothdeveloper/FSharp.Data.SqlClient/commit/dce847e3ab3d189cf414d9bc74b7399a39fdf5a5#diff-84c178c9589f3c3838173d2c2a6988eaR60) but I don't see how this fits in the DU you would have defined.\r\nI think your suggestion would get more thorough feedback if you could make a better sample of the issue with current language, and how adding the feature would fix the usage of _ wildcard or reduce the burden of maintaining the matches."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:05:00",
                "Content": "Yes, more detail please (as per Gauthier's comment)"
            },
            {
                "Submitter": "Steven Taylor",
                "Submitted": "2016-03-13T18:41:00",
                "Content": "you can add static to a DU definition, but not post the definition. Say you've got some recursive DU structure, or simply that you'd like to remove clutter (the statics) from the direct DU definition -- this isn't currently possibly. This can lead to a programming style conflict whereby it is possible to extend general types after-the-fact, but not DUs. A good example of a well written, but a little cluttered DU based structure can be seen in HTML type provider.\r\nIt's more the need to have a extra grouping strategies for function to get around such shortfalls."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above. More details are needed.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7184398": {
        "Number": "7184398",
        "Submitter": "luketopia",
        "Submitted": "2015-03-08T00:00:00",
        "Title": "Cartesian product function for collections",
        "Text": "It's often useful to compute the Cartesian product (cross join) of two collections. I always end up writing something like this:\r\nlet cross xs ys =\r\nseq {\r\nfor x in xs do\r\nfor y in ys ->\r\nx, y\r\n}\r\nI think it would be useful to have this in the standard collection modules.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:04:00",
                "Content": "The FSharp.Core 4.0.0.0 ship has sailed. It seems reasonable for FSharp.Core vNext, though I'd like to see more input on this., e.g. do other languages have this in core functional collection libraries, ,what naming do they use etc.?"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-08-02T07:59:00",
                "Content": "Python calls it \"product\". https://docs.python.org/2/library/itertools.html#itertools.product"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "I’m marking this approved-in-principle, see RFC FS-1002 https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1002-cartesian-product-for-collections.md\r\nThe function would need to be added to List, Array and Seq. I would prefer a different name – I suggest “allPairs”"
        }
    },
    "7199500": {
        "Number": "7199500",
        "Submitter": "Robert Kuzelj",
        "Submitted": "2015-03-12T00:00:00",
        "Title": "Allow nested Computation Expression for writing Builder Like DSLs",
        "Text": "type DirectionBuilder() =\r\nmember self.Yield(()) = []\r\n[<CustomOperation(\"left\")>]\r\nmember self.Left (acc, degree) = somefn degree\r\n[<CustomOperation(\"right\")>]\r\nmember self.Right (acc, degree) = somefn degree\r\n[<CustomOperation(\"velocity\")>]\r\nmember self.Velocity (acc, ()) = new VelocityBuilder()\r\nand VelocityBuilder() =\r\nmember self.Yield(()) = []\r\n[<CustomOperation(\"accelerate\")>]\r\nmember self.Accesslarate (acc, v) = somefn v\r\n[<CustomOperation(\"decelerate\")>]\r\nmember self.Decelerate (acc, v) = somefn v\r\nlet direction () = new DirectionBuilder()\r\ndirection() {\r\nright 90\r\nleft 30\r\nvelocity() {\r\naccelerate 1\r\n}\r\n}",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T13:43:00",
                "Content": "More design detail, use-cases and motivation would be needed here. This would be a pretty substantial feature - what's the killer app for this? The above case is not convincing enough for me."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7200206": {
        "Number": "7200206",
        "Submitter": "Alexei Odeychuk",
        "Submitted": "2015-03-12T00:00:00",
        "Title": "Please make correct type casting for bigint in F#",
        "Text": "I have been using the forward pipe to convert values and came up against the problem where the following code would work\r\nlet IntToFloat = 10 |> float\r\nlet FloatToInt = 10.0 |> int\r\nBut the equivalent bigint code would not work:\r\nlet FloatToBigint = 10.0 |> bigint\r\nThe reason why FloatToBignint does not compile is because the F# compiler is looking for a function called bigint that has an input of type float!\r\nSo, as soon as I had the following function declared:\r\nlet bigint(x:float) = bigint(x)\r\nthe code:\r\nlet FloatToBigint = 10.0 |> bigint\r\nworks perfectly.\r\nPlease make correct type casting for bigint in F# in order to eliminate the need to declare a helper function.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Lincoln Atkinson",
                "Submitted": "2015-03-16T12:37:00",
                "Content": "This will actually work the way you want in F# 4.0, due to the \"constructors as first-class functions\" feature.\r\n`float` and `int` in your example are generic inline *functions* which are defined to facilitate casts. Here's an example of their implementation https://github.com/Microsoft/visualfsharp/blob/fsharp4/src/fsharp/FSharp.Core/prim-types.fs#L4356\r\n`bigint`, on the other hand, is simply a *type alias* for `System.Numerics.BigInteger` https://github.com/Microsoft/visualfsharp/blob/fsharp4/src/fsharp/FSharp.Core/math/z.fs#L336\r\nBefore F# 4.0, you could construct an instance by calling the ctor like `bigint(10.0)`, but it was not supported to use the type name like a function, e.g. `10.0 |> bigint`. With F# 4.0 this is now supported, and your example code works fine."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "See Lincoln’s comment – this will work the way you want in F# 4.0\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "7211642": {
        "Number": "7211642",
        "Submitter": "Greg Rosenbaum",
        "Submitted": "2015-03-14T00:00:00",
        "Title": "Lazy properties",
        "Text": "A big problem of records and discriminated unions is that they cannot store computed (\"memoized\") data. For example, you cannot have a linked list store its own length without having it as a constructor parameter (which has obvious problems). The ability to cache computed data is a big advantage of immutable objects, because the data will never change and thus never needs to be recalculated.\r\nA very simple and elegant solution to this problem is having lazy properties. A lazy property is backed by lazy<'a> field behind the scenes. Here is an example of syntax: https://gist.github.com/Springwight/ae423184487a1d6fc831",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:35:00",
                "Content": "While I appreciate the effort to make common tasks simple, as it stands I don't think this suggestion fits well with the F# language design.\r\n- Adding \"lazy\" to a member would bee odd, since members are already computed on-demand.\r\n- It is fairly easy to amortize a member in a class by adding an explicit \"let x = lazy ...\" binding. In a record, an auxiliary class containing static data can be used.\r\n- There are several ways to implement laziness (e.g. is a lock taken during execution, is a \"null\" used to indicate a not-yet-computed value etc.) and it is in general better to make this explicit - apart from the built-in \"lazy\" for expression level constructs.\r\nLastly, I guess it goes without saying that there is a very high bar for new declaration constructs since effectively all F# programmers will need to understand them."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7228061": {
        "Number": "7228061",
        "Submitter": "Greg Rosenbaum",
        "Submitted": "2015-03-16T00:00:00",
        "Title": "Compound types",
        "Text": "This is a feature present in Scala.\r\nA compound type is an extension of flexible types that involves multiple type constraints on a type parameter. You specify compound types like this:\r\nlet example (a : 'a :> I1 & I2) = ...\r\nlet example (a :> I1 & I2) = ...\r\nlet example<'a when 'a :> I1 & I2>() = ...\r\nThese are similar to:\r\nlet example (a : 'a when 'a :> I1 and 'a :> I2) = ...\r\nlet example<'a when 'a :> I1 and 'a :> I2>() = ...\r\nThe & symbol is chosen not to conflict with the word 'and' when specifying multiple type constraints.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Jon Ludwig",
                "Submitted": "2015-03-23T13:25:00",
                "Content": "Syntactically I think it would be nice to use the word \"and\" instead of \"&\" since we already use \"and\" in the more verbose version."
            },
            {
                "Submitter": "Greg Rosenbaum",
                "Submitted": "2015-04-01T13:00:00",
                "Content": "@Jon Ludwig, yes I initially wanted to use the word 'and', but it makes things more difficult to parse, both for humans and for the compiler. E.g. consider `let example<'a, 'b when 'a :> I1 and I2 and 'b :> I2>. I think it should be possible to immediately distinguish between a compound type and another type constraint. Other options are 'a :> I1 I2 (just using a space), 'a :> I1+I2, 'a :> I1 with I2 (this is how it's written in Scala). I'm also hesitating of using the comma."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T14:02:00",
                "Content": "As a piece of history, we proposed a variation on compound types for C# and .NET many moons ago (in 1999) http://blogs.msdn.com/b/dsyme/archive/2012/07/05/more-c-net-generics-history-the-msr-white-paper-from-mid-1999.aspx :)\r\nDo you want \"I1 & I2\" to be a first-class type?\r\nDon Syme, F# Language Evolution"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T15:04:00",
                "Content": "I'm inclined to decline this. While I appreciate the logic of compound types it doesn't seem to add enough to the F# language design to do this, given the lack of votes here and the complexity it will inevitable bring."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining – see comment below from Don Syme"
        }
    },
    "7334486": {
        "Number": "7334486",
        "Submitter": "Jared Hester",
        "Submitted": "2015-03-26T00:00:00",
        "Title": "Normalize Collections API for Array2D Module",
        "Text": "With the upcoming rollout of the normalized collections API across the List, Array, and Seq modules, it would be great to see Array2D ( and possibly the other higher dimension Array Modules) brought into the fold.\r\nA large portion of the collections API (avg, contains, exists, find, fold, forall, max, min, scan, sum, etc.) could be implemented for Array2D in a way that conforms with the other collections modules.\r\nOther functions like append and concat should be workable if they enforce constraints on the length of the [,]'s dimensions similiar to the ones on the length of collections for the zip functions.\r\nFunctions like filter that will likely remove elements in a manner that doesn't map to a filled 'T [,] could return 'T [] instead.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:55:00",
                "Content": "Hi Jared\r\nMy view is that this best lies outside the core. It would be entirely reasonable to have it in an FSharp.Core.ArrayFunctions community project and nuget package.\r\nDon Syme, F# Language and Core Library Evolution"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7370455": {
        "Number": "7370455",
        "Submitter": "David Torbonof",
        "Submitted": "2015-03-29T00:00:00",
        "Title": "Add `apply` function to Seq, List and Array",
        "Text": "Simply a function a la\r\nlet apply (mapping: 'T -> 'U) (source: seq<'T>) : seq<'T * 'U> = source |> Seq.map (fun x -> (x, mapping x))\r\nThis would for instance be useful when creating graphs like\r\n[0. .. 0.01 .. 1.] |> Seq.apply sin |> plot",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:53:00",
                "Content": "I feel this is more a convenience function than something to have in the core. Also, is\r\n[ for x in 0 .. 0.01 .. 1.0 -> (x,sin x) ]\r\ntoo much?\r\nCheers\r\nDon Syme"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7408423": {
        "Number": "7408423",
        "Submitter": "Jason K",
        "Submitted": "2015-04-01T00:00:00",
        "Title": "Support [<ProjectionParameter>] on non-CustomOperations, eg. for in () do",
        "Text": "The following CE builder intends to accept a Domain which has enumerable-like members and, for this situation, return a bool. But the member of the domain being checked varies. I try to parameterize the selection of the member, rather than just expecting the member directly (which changes the type).\r\nThis code type-checks as is, but it requires the full lambda as the `over` parameter to For.\r\ntype Domain = interface end\r\ntype Projection<'R> =\r\nabstract member source : Table<'R>\r\nand Table<'R> = inherit Projection<'R>\r\nand Table<'R, 'K> =\r\ninherit Table<('R * 'K)>\r\nabstract member row : 'R\r\nabstract member key : 'K\r\ntype proj<'R> = Projection<'R>\r\ntype table<'R> = Table<'R>\r\ntype Engine<'D> when 'D :> Domain =\r\nabstract member from: 'R table * ('R proj -> 'U) -> 'U\r\nabstract member where: ('R -> bool) * 'R proj -> 'R proj\r\nabstract member any: ('R -> bool) * 'R proj -> bool\r\nabstract member select: ('R -> 'S) * 'R proj -> 'S proj\r\ntype A = { ID : int; Name : string }\r\ntype B = { ID2 : int; Name2 : string }\r\ntype MyDomain =\r\ninherit Domain\r\nabstract member As : A table\r\nabstract member Bs : B table\r\ntype CommandBuilder<'D> when 'D :> Domain () =\r\n// [<CustomOperation(\"for\")>] **no effect (?)**\r\nmember __.For ([<ProjectionParameter>] over : ('D -> 'R table), expr : ('R proj -> _)) = // [<ProjectionParameter>] is ignored\r\n(fun (engine : Engine<'D>, domain : 'D) -> engine.from(over(domain), expr))\r\nmember __.Yield x = x\r\n[<CustomOperation(\"select\")>]\r\nmember __.Select (over : (Engine<'D> * 'D -> 'R proj), [<ProjectionParameter>] mapping : ('R -> _)) =\r\n(fun (engine : Engine<'D>, domain : 'D) -> engine.select(mapping, over(engine, domain)))\r\n[<CustomOperation(\"where\", MaintainsVariableSpace = true)>]\r\nmember __.Where (over : (Engine<'D> * 'D -> 'R proj), [<ProjectionParameter>] byPredicate : ('R -> bool)) =\r\n(fun (engine : Engine<'D>, domain : 'D) -> engine.where(byPredicate, over(engine, domain)))\r\n[<CustomOperation(\"any\", MaintainsVariableSpace = true)>]\r\nmember __.Any (over : (Engine<'D> * 'D -> 'R proj), [<ProjectionParameter>] byPredicate : ('R -> bool)) =\r\n(fun (engine : Engine<'D>, domain : 'D) -> engine.any(byPredicate, over(engine, domain)))\r\nmember __.Quote() = ()\r\nmember __.Run(q) = q\r\nlet command = new CommandBuilder<MyDomain>()\r\nlet invariant1 =\r\ncommand {\r\nfor a in (fun _d -> _d.As) do // should be `for a in d.As do`\r\nany (a.Name = \"disallowed value\")\r\n}\r\nlet invariant2 =\r\ncommand {\r\nfor b in (fun _d -> _d.Bs) do // should be `for a in d.Bs do`\r\nany (b.Name2 = \"disallowed value\")\r\n}\r\nlet domainInvariants = [ invariant1; invariant2 ]",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:51:00",
                "Content": "Hi Jason, could you provide a link to a gist with this code? thanks\r\nDon Syme"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:18:00",
                "Content": "Here's the gist: https://gist.github.com/dsyme/6623d02d1a6065a7f9e0"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:19:00",
                "Content": "When you say \"should be `for a in d.Bs do`\" - where would \"d\" be bound?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:58:00",
                "Content": "This hasn't been updated in a while and there are pending questions below. I propose to decline this."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declined per my comment below. Please contact me if you have more informaiton on this – I’m not opposed to the suggestion I just need to understand exactly what’s involved\r\nDon Syme, F# Language Evolution @dsyme"
        }
    },
    "7413124": {
        "Number": "7413124",
        "Submitter": "Greg Rosenbaum",
        "Submitted": "2015-04-01T00:00:00",
        "Title": "Attributes to help resolve type inference",
        "Text": "Sometimes, you want to have a main overload for a method and then some secondary overloads that take arguments in different forms. For example, if you're writing a dictionary, you might want to have:\r\nAddRange (pairs : seq<'key * 'value>)\r\nAddRange (pairs : seq<KeyValuePair<'key, 'value>>)\r\n\r\nHowever, this would normally make type inference impossible, because writing `x.AddRange vs` would be ambiguous. Sometimes though, we really want one method to be inferred, and other overloads are provided for special cases, or for interoperability with other .NET languages.\r\nIn such cases, it could be possible to use a special attribute, `DefaultOverloadAttribute`, that specifies the overload the inference procedure should try first. A more powerful alternative would be an `OverloadPriorityAttribute` that accepts an `int`, and creates a sequence of methods to try one after the other.\r\nThe attribute should automatically generate some documentation that specifies it is the primary overload.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:38:00",
                "Content": "I understand the suggestion and can see the motivation\r\nHowever my inclination is not to add more special cases to the overload resolution rules unless really critical for interoperability purposes. The F# programmer always has the option of avoiding the use of overloading"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined: see my comment below"
        }
    },
    "7414162": {
        "Number": "7414162",
        "Submitter": "Greg Rosenbaum",
        "Submitted": "2015-04-01T00:00:00",
        "Title": "Type parameter grouping",
        "Text": "Sometimes, we want to have a method or type where some of the type parameters must be specified explicitly, while others could be inferred. For example, consider:\r\nList.cast<'from,'to>\r\n\r\nIn this case, the `'from` parameter can always be inferred (unless we're putting the method into a function value), but the `'to` parameter may need to be specified explicitly.\r\nType parameter groupings allow you to specify some groups of type parameters, and have the compiler infer the rest. The above function for example might look like this:\r\nList.cast<'to;'from> //two groups of type parameters\r\n\r\nWe can specify the first group of type parameters alone, invoking the function as `List.cast<int>`, or specify both type parameters at once giving `List.cast<int;string>` (if we want to put it in a function value for example).\r\nThis works when dealing with types as well. For example, given a type defined:\r\ntype Example<'first, 'second; 'third>(...) = ...\r\n\r\nWe can specify `Example<int, string>` and leave `'third` to be inferred (possibly generic), or we can specify the full `Example<int, string; int>`.\r\nOf course, there is an issue with overload resolution, which is why I think type parameter grouping shouldn't b the default behavior. In the case of overload resolution, the compiler will always attempt to infer parameter groupings last, and try other things first (e.g. or `List.cast<int>` it will first look for `List.cast<'t>`)",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T14:31:00",
                "Content": "I understand the proposal. We would probably do it differently, by marking some type parameters as \"not required\", i.e. inferable. I'll decline that since I believe that suggestion is covered elsewhere."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per comment"
        }
    },
    "7574961": {
        "Number": "7574961",
        "Submitter": "Vasily Kirichenko",
        "Submitted": "2015-04-15T00:00:00",
        "Title": "Override `ToString` for discriminated unions and records",
        "Text": "It's a pain and dirty to add `override x.ToString() = sprintf \"%A\" x` to every type in order to make `String.Format()` happy:\r\ntype T1 =\r\n{ Id: int\r\nVersion: string }\r\noverride x.ToString() = sprintf \"%A\" x\r\ntype DU =\r\n| C1 of int\r\n| C2\r\noverride x.ToString() = sprintf \"%A\" x\r\nI think it's very easy to teach the compiler generate this override automatically for all user types.",
        "Votes": 181,
        "Comments": [
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2015-04-15T03:38:00",
                "Content": "This is a real world issue and a problem in projects like paket or https://github.com/adamchester/EaToSql/blob/master/src/EaToSql/Model.fs"
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2015-04-15T03:44:00",
                "Content": "Also it's hard to debug such types without the automatic tostring implementation. Debugger just shows the type name."
            },
            {
                "Submitter": "Matthew Peacock",
                "Submitted": "2015-04-21T18:21:00",
                "Content": "However, %A is very very slow, ideally the implementation should not do any reflection at runtime, but be based on code generated at compile time."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-19T18:00:00",
                "Content": "I am against this. ToString() carries no semantics. To what kind of string? Is it an atomic value or structured value? Is it for logging or display to the user? There is no consistency. The ToString() method should simply be deprecated.\r\nYou can always simply call sprintf \"%A\" any structural type to get a good structured representation even if its very slow."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-06-23T00:00:00",
            "Text": "Marking as planned, though we need to work out the details\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "7640829": {
        "Number": "7640829",
        "Submitter": "Виктор Милованов",
        "Submitted": "2015-04-21T00:00:00",
        "Title": "Allow access modifies to auto properties getters and setters",
        "Text": "member val Property = 10 with get, private set",
        "Votes": 30,
        "Comments": [
            {
                "Submitter": "ADMIN\r\nfsharporg-lang (F# Software Foundation Language Group, F# Software Foundation)",
                "Submitted": "2016-02-04T17:39:00",
                "Content": "I'm fine with this suggestion. We considered it for F# 3.0 but cut it, since you can always implement this pattern in a more expanded form using \"let\" and explicit get/set.\r\nIt won't be high priority for myself, but if some one does it, that is great\r\nWill mark this approved-in-principle (will show as \"planned\")"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Marked approved-in-principle, see comments. This won’t be high priority but is we get a quality PR for it we will accept it."
        }
    },
    "7745940": {
        "Number": "7745940",
        "Submitter": "Brad Phelan",
        "Submitted": "2015-04-29T00:00:00",
        "Title": "Allow types to behave also like modules.",
        "Text": "I find this kind of coding annoying\r\nmodule Foo =\r\ntype T = { a:int, b:int }\r\nlet xxx t = t.a\r\nlet yyy t = t.b\r\n\r\nit would be much more compact and have less noise in the type system to allow\r\ntype Foo =\r\n{ a:int, b:int }\r\nwith\r\nlet xxx t = t.a\r\nlet yyy t = t.b\r\nSo you can do\r\n{ a = 10; b = 20 } | Foo.xxx",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-04-30T08:23:00",
                "Content": "The following works:\r\ntype Foo =\r\n{ a:int; b:int }\r\nwith\r\nstatic member xxx t = t.a\r\nstatic member yyy t = t.b"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:10:00",
                "Content": "As pointed out below, adding static members to types is close to what you want."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7770276": {
        "Number": "7770276",
        "Submitter": "Nick Cooper",
        "Submitted": "2015-04-30T00:00:00",
        "Title": "Language Integrate transpilers",
        "Text": "Create a framework similar to computation expressions, but built using Roslyn or whatever compiler-like framework would be necessary so that subexpressions would be well-formed and type-safe.\r\nXML Example:\r\nlet x1 = xml {%\r\n<?xml version 1.0\"?>\r\n<PurchaseOrder OrderDate=\"1999-10-20\">\r\n<Items>\r\n....\r\n</Items>\r\n</PurchaseOrder> %}\r\nlet v2 = x1.Root.Attribute(\"OrderDate\").Value\r\nSQL:\r\nlet x = sql {%\r\nINSERT INTO TestTable([ID], [Name]) VALUES (@ID, @Name) %}\r\nx.Parameters.AddWith(\"@ID\", 3)\r\nx.Parameters.AddWith(\"@Name\", \"My Name\")\r\nOr LaTeX, or C#, or CIL, or any other parser that one could imagine.",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-05-04T04:18:00",
                "Content": "Have you seen type providers? They are exactly what you want."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-05-07T07:09:00",
                "Content": "Type providers do not invoke the compiler to work with the text. I'm talking about syntactic help (from an addition compiler) while inside the {% Escape Sequence %} that has Intellisense and such."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-05-07T07:11:00",
                "Content": "I'll add an additional example:\r\nlet cs = CSharp {%\r\npublic class Person\r\n{\r\npublic string Name { get; set; }\r\n}\r\n%}\r\nAs far as the XML version goes, VB supports this currently"
            },
            {
                "Submitter": "Jack Fox",
                "Submitted": "2015-05-09T10:26:00",
                "Content": "For SQL Server (and any SQL DB linked database through SS) this already exists. http://fsprojects.github.io/FSharp.Data.SqlClient/ It is built out even further than the documentation suggests. A lot of features still not fully documented."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:06:00",
                "Content": "This seems out of scope for F# given the existing features - instead we would extend the type provider mechanism to continue to allow processing of external languages to be offloaded to external compiler plugin components."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nThe idea of allowing language embeddings is certainly not a bad one but given the success of things like embedded SQL processing in the SqlClient type provider it feels that any feature in this area would have to be based around evolving and extending the type provider mechanism. Perhaps a synthesis of ideas is what’s needed here.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7813977": {
        "Number": "7813977",
        "Submitter": "George",
        "Submitted": "2015-05-04T00:00:00",
        "Title": "Indentation of new lines should be dependent on the *start* of the previous line, not the end of it",
        "Text": "The following layout requires that content after the 'View<' be indented beyond the endding '<' on the following lines which makes the level of indentation dependent on the type name. Which is silly.\r\n[<AbstractClass>]\r\ntype View<\r\n'Events,\r\n'Window when\r\n'Window :> Window and\r\n'Window : (new : unit -> 'Window)\r\n>(?window) =\r\nlet window = defaultArg window (new 'Window())\r\nmember this.Window = window",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:42:00",
                "Content": "Could you please post a gist for this that preserves layout?"
            },
            {
                "Submitter": "George",
                "Submitted": "2015-06-10T11:59:00",
                "Content": "Here is the gist:\r\nhttps://gist.github.com/anonymous/18108a3fbaa79433ce65.js"
            },
            {
                "Submitter": "George",
                "Submitted": "2015-06-10T12:07:00",
                "Content": "Here is the gist:\r\nhttps://gist.github.com/anonymous/18108a3fbaa79433ce65\r\nTo clarify, FSharp currently imposes indentation constraints based on the occurrence of special delimiting characters in preceding lines. The result is indentation becomes dependent on the selection of identifier names. This constraint also waste space and undermines the ability to structure the source code semantically."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T07:05:00",
                "Content": "Hi George,\r\nWe could consider \"<\" as opening a new indentation context. However I think in practice it's unlikely that we would modify the design and implementation of the indentation aware syntax in order to support this.\r\nThis is partly because the processing of \"<\" is already quite complicated because of the disambiguation of \" a<b\" and \"a<b>\", and partly because of the stability requirements in the syntax processing.\r\nA pull request to allow this might explore the design space and build confidence and I'd be interested to see one."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:08:00",
                "Content": "Closing in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/9156844-relax-some-of-the-indentation-rules"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/9156844-relax-some-of-the-indentation-rules and linking back here"
        }
    },
    "7814040": {
        "Number": "7814040",
        "Submitter": "George",
        "Submitted": "2015-05-04T00:00:00",
        "Title": "This user voice entry form should allow code samples",
        "Text": "Suggestions are often clarified with code. The suggestion box should therefore allow code samples. consequently, it needs to support mono-space fonts and not collapse spaces from input.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-05-12T14:32:00",
                "Content": "Maybe posting link to github's gist or similar is valid approach until uservoice gets us a feature for that?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:40:00",
                "Content": "Yes, please post a gist instead"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-06-09T00:00:00",
            "Text": "Changing uservoice is not possible for us – until now please just post a gist"
        }
    },
    "7845018": {
        "Number": "7845018",
        "Submitter": "Richard Minerich",
        "Submitted": "2015-05-06T00:00:00",
        "Title": "Make the result of the dict function implement IDictionary",
        "Text": "The fact that the type returned by dict doesn't implement IDictionary makes reflection difficult and inefficient, it also make this type different than all other .NET Core Dictionary implementations",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2015-05-10T21:49:00",
                "Content": "IReadOnlyDictionary<_,_> as well would be good."
            },
            {
                "Submitter": "Steffen Forkmann",
                "Submitted": "2015-05-11T05:18:00",
                "Content": "I tried to implement this at https://github.com/Microsoft/visualfsharp/pull/436"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "This is approved for inclusion in a future release of the F# core library subject to an implementation and detailed design. Completion of the pull request to implement this feature will be necessary, see the link above.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7887270": {
        "Number": "7887270",
        "Submitter": "Don Syme",
        "Submitted": "2015-05-09T00:00:00",
        "Title": "Allow all inferrable SRTP constraints to be written in signatures",
        "Text": "See https://github.com/Microsoft/visualfsharp/issues/392. Basically F# will in some situations infer statically-resolved-constraints like\r\n(A or ^b) : (static member X : ...)\r\nwhere A is a concrete class name. However these constraints can't be written in signatures. It is reasonable to lift this restriction",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Mark Laws",
                "Submitted": "2015-05-09T07:43:00",
                "Content": "BTW, the real problem is that it's not just in signature files; it can make it hard to write the necessary constraints for actual code too."
            },
            {
                "Submitter": "Mark Laws",
                "Submitted": "2016-06-22T09:22:00",
                "Content": "PR made for RFC 1017 to track this issue: https://github.com/fsharp/FSharpLangDesign/pull/103"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1017-fix-srtp-constraint-parsing.md\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7916448": {
        "Number": "7916448",
        "Submitter": "Dmitry Morozov",
        "Submitted": "2015-05-11T00:00:00",
        "Title": "AddObsoleteAttribute method on ProvidedStaticParameter",
        "Text": "",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:39:00",
                "Content": "This is entirely reasonable and we would accept a PR to implement this.\r\nDon Syme"
            },
            {
                "Submitter": "luketopia",
                "Submitted": "2015-07-31T07:07:00",
                "Content": "I'm confused about what is being suggested here. Are we talking about the ProvidedStaticParameter that's internal to FSharp.Data.TypeProviders.dll? Most type providers I've seen provide their own implementation of ProvidedStaticParameter via their ProvidedTypes.fs. Should an issue be opened on FSharp.TypeProviders.StarterPack instead?"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "This is approved for inclusion in a future release of F# subject to an implementation and detailed design. A pull request\r\nto implement this feature will be necessary and we encourage contributors to submit one with adequate design detail and\r\ntesting to http://github.com/Microsoft/visualfsharp. Discussion of the particular version for this to be included in can\r\nbe made once an implementation is available.\r\nDesign detail can also be discussed below.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "7932663": {
        "Number": "7932663",
        "Submitter": "Mat P",
        "Submitted": "2015-05-13T00:00:00",
        "Title": "Make numeric type conversions preserve units",
        "Text": "Currently it's awkward to convert between numeric types and preserve the units, since we end up with a whole raft of conversion functions like:\r\nlet i2f (x: int<'u>) : float<'u> =\r\nfloat x |> LanguagePrimitives.FloatWithMeasure\r\nwhere for N numeric types, we have N^2 of these functions.\r\nIdeally, the functions int, float, decimal, etc., would preserve the units automatically.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:39:00",
                "Content": "I suspect the breaking change implications of this would make it tricky to do.\r\nDon Syme"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8007312": {
        "Number": "8007312",
        "Submitter": "Dmitry Morozov",
        "Submitted": "2015-05-17T00:00:00",
        "Title": "warn about unused namespace",
        "Text": "It would be nice if F# compiler had a switch to warn about unused namespace similar to --warnon:1182 - unused bindings. This can be lower cost solution to what in Visual C# addressed by \"Remove Unused Usings\" refactoring.",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Vasily Kirichenko",
                "Submitted": "2015-05-18T00:15:00",
                "Content": "The closest thing is \"Gray out unused opens\" in Visual F# Power Tools. And it was tricky to implement."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T13:38:00",
                "Content": "As Vasily says, \"grey out unused namespace\" in the Visual F# Power Tools is close (and I think FCS-based tooling is the way we would always address for F#)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Closing this. The “greying out unused namespaces” is available in the Visual F# Power Tools. The core implementation can be reused in other tools such as FSharpLint.\r\nFurther comments, use cases, information and discussion welcome\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8014059": {
        "Number": "8014059",
        "Submitter": "Andrzej Kukuła",
        "Submitted": "2015-05-18T00:00:00",
        "Title": "Make call syntax simpler for statically resolved member constraints",
        "Text": "The idea is basically explained by the following code:\r\n// this works as expected\r\ntype Example() =\r\nmember __.F(i) = printfn \"%d\" i\r\nlet inline f (x : ^a) =\r\n(^a : (member F : int -> unit) (x, 1))\r\n(^a : (member F : int -> unit) (x, 2))\r\nf (Example())\r\n// this doesn't work\r\nlet inline f (x : ^a when ^a : (member F : int -> unit)) =\r\n// the compiler knows that there must be member F and its signature\r\n// so the following should be possible\r\nx.F(1)\r\nx.F(2)\r\nYou can also view this code highlighted at http://pastebin.com/CHMj7xQG",
        "Votes": 29,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T18:32:00",
                "Content": "Oh yes, much more readable!\r\nI have incorporated your suggestion in my suggestion for \"Interfaces as simple, reusable and named sets of member constraints on statically resolved type parameters\": http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:35:00",
                "Content": "I think this is totally reasonable, marking it as approved-in-principle.\r\nNote also that a naked type alias can imply multiple constraints, giving a way to name collections of constraints\r\nhttps://gist.github.com/dsyme/bfed2eed788c7ba58ccc"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Approved in principle. Thanks for the suggestion.\r\nWe will add an RFC for this in due course, see https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs\r\nWe will need to consider whether to simplify calls for static members as well."
        }
    },
    "8016057": {
        "Number": "8016057",
        "Submitter": "Ruffian Eo",
        "Submitted": "2015-05-18T00:00:00",
        "Title": "Modules and Namespaces seem kind of redundant and are confusing at times. Maybe it would be an idea if a module were implicitly a namespace.",
        "Text": "The all different approaches which need to be taken for either targeting an F# only audience or a generic .NET audience cannot be entirely made invisible. Yet, when writing code in F# the question \"Namespace or Module or both?\" is annoying to bits. Not that anyone really cares or wants to spend time and energy pondering these questions. If a Module were internally implicitly treated as if also being a namespace, some of those quirks might go away and people could write modules by default.",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "Christopher Stevenson",
                "Submitted": "2015-05-31T00:46:00",
                "Content": "It's worth noting in MSIL, all methods have to be within a class. There are no namespace level functions."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T18:37:00",
                "Content": "Elaborating on Christopher's comment: This is required for other languages to use namespaces or modules written in F#. For example, namespace will still be namespaces in C#, but modules are compiled to a static class. You cannot \"import\" static classes like you can entire namespaces in C#."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T05:17:00",
                "Content": "We considered this at length in the F# 1.x-2.0 design process in 2006-2009. In the end, we decided not to support namespace level values and functions, but instead allowed \"module M\" declarations at the head of a file. Any compilation mapping for values-and-functions-in-namespaces would cause technical difficulties and the tradeoff came down on the side of the current design."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for rationale and discussion see the comments.\r\nFurther discussion welcome.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8065539": {
        "Number": "8065539",
        "Submitter": "Mark Seemann",
        "Submitted": "2015-05-21T00:00:00",
        "Title": "Add a function to return a constant value",
        "Text": "Sometimes, you have to pass a function to a higher-order function, but you want that function to always return the same value, so you may end up writing something like\r\nlet ploeh = myHigherOrderFunction (fun _ -> 42) \"Foo\"\r\nIt would be nice with a built-in function that does this, sort of a dual of the built-in 'ignore' function.\r\nSomething like\r\nlet konst x _ = x\r\nwhich would enable you to write something like\r\nlet fnaah = myHigherOrderFunction (konst 1337) \"Bar\"",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2015-05-21T10:40:00",
                "Content": "Like the idea, but suggest naming it 'constant'. konst smells like something from KDE."
            },
            {
                "Submitter": "Daniel Robinson",
                "Submitted": "2015-05-21T10:43:00",
                "Content": "If 'constant' is too long, 'always' also reads nicely."
            },
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2015-05-23T09:03:00",
                "Content": "All the better if we could make this independent of argument count. https://clojuredocs.org/clojure.core/constantly"
            },
            {
                "Submitter": "Frank Shearar",
                "Submitted": "2015-05-27T03:31:00",
                "Content": "@Dax Clojure's constantly (and Common Lisp's CONSTANTLY) only takes one argument. Its _returned function_ takes any number of arguments.\r\nA naive implementation might look like\r\nlet constantly x = fun ([<System.ParamArray>] ignored) -> x"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:54:00",
                "Content": "Since it is so easy to define this function as a utility in your own code I'm not sure we need have it in the F# library.\r\nThis is consistent to the design approach we've take to a number of other functionals, e.g. swapping the elements of a tuple, or a function to do pointwise \"and\" and \"or\" on two Boolean-valued functions."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Many thanks for the suggestion\r\nI’m declining this because we did explicitly consider this in F# 1.0 (and also F# 4.0) and decided against adding a function to the prelude for this. I don’t think we should revisit that decision at this point.\r\nThe Operators prelude is a space of names we have to use somewhat conservatively. The name “konst” is not particularly pleasing, and the function is very, very simple to define as a helper function. So in balance we decided not to include this.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "8072277": {
        "Number": "8072277",
        "Submitter": "exercitus vir",
        "Submitted": "2015-05-21T00:00:00",
        "Title": "Allow inline on functions which call private or internal union cases",
        "Text": "A lot of time you we to ensure a valid construction of union types by making its cases private or internal. E.g.\r\n```F#\r\ntype e_mail = private e_mail of string\r\nlet inline e_mail_from_string s =\r\nif s |> is_valid //checks e-mail is in valid format\r\nthen s |> e_mail |> Some\r\nelse None\r\n```\r\nThis ensure that values of type e_mail are in a valid format, but this sample does not compile because inline is not allowed on functions which call private or internal functions such as the single case of the e_mail discriminated union.\r\nThis restriction should be removed for cases of discriminated unions because a lot of times functions are simply unwrapping the values of single case unions or doing very little work that does not warrant a virtual dispatch.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:50:00",
                "Content": "Why not just add a static member to the union type which does the validation?\r\nAlso, allowing inlining would break the abstraction boundary defined by private/internal. Using a static member associated with the type -or using \"internal\" instead of \"private\" seems adequate.\r\nI will mark this one as declined because allowing inline to break abstraction boundaries would be a significant departure for F# language design."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-07-17T11:09:00",
                "Content": "Good point. Thanks for the explanation. I now understand the reason."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8107647": {
        "Number": "8107647",
        "Submitter": "Dax Fohl",
        "Submitted": "2015-05-25T00:00:00",
        "Title": "Extend `with` keyword support to record definitions",
        "Text": "In the process of converting a large-ish Clojure app to F#, which I prefer due to the type safety, I find many situations where I have large records that differ by only an item or two.\r\nFor instance, in Clojure, I grab a user's huge configuration record from the DB, and then append a couple of calculated fields to it before returning to the next layer. So that means in F#, I need\r\ntype UserDbData = {...many fields..}\r\ntype UserData = {...many fields... ...calculated fields}\r\nlet createUserData(dbData:UserDbData) = {...many fields=many fields... ...calculated fields = calculate fields...}\r\nlet createUserDbData(userData:UserData) = {...many fields=many fields...}\r\nIt would be great to have language support for these situations, where you could define\r\ntype UserDbData = {fields}\r\ntype UserData = {UserDbData with other fields}\r\nlet createUserData(dbData:UserDbData) = {dbData with other fields}\r\nlet createUserDbData(userData:UserData) = {userData ::>> UserDbData} //or something like that\r\nAs to whether this would be done under the hood by inheritance or whether it's just shorthand for a new otherwise-unrelated record type, I can see pros and cons of each. I somewhat lean toward the latter.",
        "Votes": 8,
        "Comments": [
            {
                "Submitter": "Dax Fohl",
                "Submitted": "2015-05-28T07:59:00",
                "Content": "One reason inheritance might be the better option is that if the types are otherwise unrelated, is that you wouldn't be able to use a UserData in a function that accepts UserDbData, so that may lead to a bunch of logic duplication. But record inheritance seems antithetical to F#, so I just don't think I'd go that way.\r\nSo, this maybe would need to be combined with a structural typing feature (again, similar to Clojure where you do have named records but can add extra fields, but in F# that would be structurally-verified at compile time).\r\nOr some statically-resolved type constraint feature would also work:\r\nlet myFunc<^user when ^user ::?>> UserDbData>(user: ^user) = ..."
            },
            {
                "Submitter": "Nathan-Madonna Byers",
                "Submitted": "2015-06-01T13:07:00",
                "Content": "Something similar to Elm's record types (see http://elm-lang.org/learn/Records.elm) would be really useful in F#."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T20:21:00",
                "Content": "If they are related, then you could make them classes and inherit the base class and add the extra fields there. If you want the simplicity of records, then you could wrap the base record as a component of the record with additional fields."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:10:00",
                "Content": "This is really related to the question of C#-style anonymous types for F#, since you are effectively making up a type definition on the fly. I will close this suggestion in favour of http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f and link it there."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion. I’ve merged it with http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "8140617": {
        "Number": "8140617",
        "Submitter": "Phillip Trelford",
        "Submitted": "2015-05-27T00:00:00",
        "Title": "Extend custom numeric types to support floating point literals",
        "Text": "Currently you can define custom numeric types for integer values.\r\nIt would be nice to be able to handle floating point values too, e.g.\r\ntype complex = Complex of double * double\r\ntype imaginery = Imaginery of double\r\nwith\r\nstatic member (+) (lhs:double,Imaginery(rhs)) = Complex(lhs,rhs)\r\nmodule NumericLiteralI =\r\nlet FromZero () = Imaginery 0.0\r\nlet FromOne () = Imaginery 1.0\r\nlet FromInt32 (x) = Imaginery (double x)\r\nlet FromInt64 (x:int64) = Imaginery (double x)\r\nlet FromDouble (x:float) = Imaginery x // extension\r\nlet polar = 1.5 + 2.5I",
        "Votes": 13,
        "Comments": [
            {
                "Submitter": "trek42",
                "Submitted": "2015-06-06T19:19:00",
                "Content": "This will be a very desired feature now that Xamarin unified API uses 'System.nfloat' to represent native float type and no longer uses either float or double. Because of this, I have to keep writing \"nfloat <float-literal>\" (e.g. \"nfloat 2.0\") for all float literals of nfloat type. It will greatly improve clarity and avoid verbosity if I could just say \"2.0nf\" where 'nf' denotes native float values."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:45:00",
                "Content": "This is a nice suggestion - the Xamarin use-case below is of particular interest.\r\nI'm not marking it as \"approved\" as yet but I'd be interested in seeing a pull request ironing out any lurking design details."
            },
            {
                "Submitter": "Abel",
                "Submitted": "2016-02-05T08:26:00",
                "Content": "@fsharporg-lang: The link to the suggestion \"in favour of\" is actually *this* suggestion. It seems that you mean to say you are actually going to implement this? Or did you mean to point to another suggestion?"
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-03-04T00:00:00",
            "Text": "Now marking as planned, which means we can move to an RFC https://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nThe details remain to be worked out however\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "8151819": {
        "Number": "8151819",
        "Submitter": "Wallace Kelly",
        "Submitted": "2015-05-28T00:00:00",
        "Title": "Add support for forward piping the result of an async workflow",
        "Text": "The sample code looks much better at https://gist.github.com/WallaceKelly/f146180d5946b2b004bb\r\nWhen calling an async function within an async workflow, we sometimes end up with code like the following:\r\nlet getDataFromServer1() =\r\nasync {\r\nlet! data = downloadData()\r\nreturn\r\ndata\r\n|> Seq.where isUseful\r\n|> Seq.sortBy sortSelector\r\n|> Seq.toList\r\n}\r\nNotice that we must bind the result to a label and then pipe the result using that label.\r\nIf we use Async.RunSynchronously, the syntax is much cleaner. Because Async.RunSynchronously returns the result 'T, we can build a single pipeline, as follows, without having to bind the result to a label:\r\nlet getDataFromServer2() =\r\nasync {\r\nreturn\r\ndownloadData()\r\n|> Async.RunSynchronously\r\n|> Seq.where isUseful\r\n|> Seq.sortBy sortSelector\r\n|> Seq.toList\r\n}\r\nHowever, the problem with relying on Async.RunSynchronously is that it can be inefficient. Unlike the solution that uses let!, the calling thread is blocked and not available to do other work.\r\nSome have suggested that Async.map solves this problem. However, Async.map returns an Async<'T>, not a 'T (like Async.RunSynchronously). Using Async.map works, but it too requires cluttering the code with a temporary label:\r\nlet getDataFromServer3() =\r\nasync {\r\nreturn!\r\ndownloadData()\r\n|> Async.map(fun d ->\r\nd\r\n|> Seq.where isUseful\r\n|> Seq.sortBy sortSelector\r\n|> Seq.toList)\r\n}\r\nWhat could be a\r\nWhat we want is the efficiency of let! or Async.map, but the pipeline syntax of Async.RunSynchronously.\r\nThere are several options. We could introduce a pipeline-like operator, which works like let!. For example, we could use !>. The code might look like this:\r\nlet getDataFromServer4() =\r\nasync {\r\nreturn\r\ndownloadData()\r\n!> Seq.where isUseful\r\n|> Seq.sortBy sortSelector\r\n|> Seq.toList\r\n}\r\n\r\nThe compiler would simply translate the above into the equivalent of getDataFromServer1().\r\nAlternatively, we could add a function that accomplishes the same. We might call it Async.RunAsynchronously. In this case, the code would be:\r\nlet getDataFromServer5() =\r\nasync {\r\nreturn\r\ndownloadData()\r\n|> Async.RunAsynchronously\r\n|> Seq.where isUseful\r\n|> Seq.sortBy sortSelector\r\n|> Seq.toList\r\n}\r\n\r\nAgain, the resulting IL would be the same as getDataFromServer1()\r\n\r\nIn summary, we want something that works like let!, but for forward-piping.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Wallace Kelly",
                "Submitted": "2015-05-29T09:50:00",
                "Content": "I received this suggested operator...\r\nlet (|>>) xA x2y = async.Bind (xA, x2y >> async.Return)\r\n...which works very nicely....\r\nasync {\r\nreturn! downloadData()\r\n|>> Seq.where isUseful\r\n|>> Seq.sortBy sortSelector\r\n|>> Seq.toList\r\n}\r\nBased on this, I'm considering deleting this suggestion. Thoughts?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-06-09T00:00:00",
            "Text": "Declined as suggested by the author\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "8169411": {
        "Number": "8169411",
        "Submitter": "Anonymous",
        "Submitted": "2015-05-30T00:00:00",
        "Title": "Allow match! in async workflows",
        "Text": "Instead of writing:\r\nasync {\r\nlet! m fetch_something()\r\nmatch m with\r\n| ...\r\n}\r\nit would be nice to write\r\nasync {\r\nmatch! fetch_something() with\r\n| ...\r\n}",
        "Votes": 32,
        "Comments": [
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-06-01T09:01:00",
                "Content": "Is this different from Joinads?\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/5663965-integrate-joinads-extension"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T12:56:00",
                "Content": "@Anonymous - yes, it is different (and much simpler)"
            },
            {
                "Submitter": "George",
                "Submitted": "2015-06-10T10:37:00",
                "Content": "Nice."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T20:13:00",
                "Content": "Yes, this consistent with the other keywords."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:42:00",
                "Content": "We considered this in the F# language design but declined it, partly because of the possibility to reserve the syntax for the joinad feature.\r\nIf we did something in this area it would probably be to allow an \"await\" or \"bind\" at any point in the non-higher-order (non-lambda) control-flow structure of an F# expression, for particular kinds of computation expressions which support rewriting to a local CPS style. However that is a larger feature than the one proposed here."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing per my comment below"
        }
    },
    "8210280": {
        "Number": "8210280",
        "Submitter": "Xavier Zwirtz",
        "Submitted": "2015-06-02T00:00:00",
        "Title": "Add plugable preprocesser support to compiler",
        "Text": "Add support for handing in a preprocessor dll to the compiler.\r\nA preprocessor dll would be able to receive the AST at different stages of the compile process and modify it.\r\nIt would be specified with --pre assembly-name.dll\r\nYou would have a type Main that exposes different functions depending on the stage that you want to modify.\r\nmodule Main =\r\n// receives raw unprocessed text and returns a string to advance.\r\n// would allow for extension of syntax and reader macros\r\nlet Reader code =\r\nmodify code\r\n// receives an untype checked but syntactically valid AST.\r\n// returns an AST\r\nlet ProcessAST ast =\r\nmodify ast\r\n// recieves an a type checked AST.\r\n// if your preprocesser does not need to process an untyped tree this simplifies development\r\nlet ProcessTypedAST ast =\r\nmodifyTyped ast\r\nThis would allow for a variety of compile time enhancements to be added to F# ala Lisp and D, with out locking the language down to a single implementation.\r\nFor instance, in Racket a file may be begun with #lang {nameOfLang} that directs the compiler to the language to use. Using the above\r\nsuggestion the same functionality could be added by the community, allowing for different languages to have transpilers written for them\r\nand then transformed during the compile process.\r\nIt would also allow for more \"simple\" plugins to be made, like syntactic macros.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Xavier Zwirtz",
                "Submitted": "2015-06-02T21:44:00",
                "Content": "This is a different suggestion to adding syntactic macros. This is more about making the compiler pluggable and customizable. Macros would still do better as a first class language feature, however they could be iterated on quickly by the community as a preprocesser extension and pulled back into the compiler when consensus is reached by the community."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T12:55:00",
                "Content": "I believe the appropriate place for this suggestion would be FSharp.Compiler.Service. It is unlikely we would add full pluggable syntactic phase translations in the F# language specification itself.\r\nDon Syme, F# Language and Core Library Evolution"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T01:32:00",
                "Content": "@Xavier: Have you already posted this as a suggestion to FSharp.Compiler.Service?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. It is being marked as declined – for discussion see the comments above.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8220417": {
        "Number": "8220417",
        "Submitter": "lr",
        "Submitted": "2015-06-03T00:00:00",
        "Title": "add a 'flatten' library function to generically flatten a tree to a sequence",
        "Text": "I need this function in most of my projects in one way or another, so I always copy/paste it. It's not a big hassle, but I think it is general enough to warrant inclusion in the std lib.\r\nThe idea is to traverse a tree by passing a 'root' and a function to extract the 'children'. This works for both actual tree types and anything logically representing a tree like the directory structure.\r\nSample Usage:\r\nget all files from directory and subdirectories in a single line:\r\n\"c:\\test\" |> flatten Directory.GetDirectories |> Seq.collect Directory.GetFiles |> Seq.toArray\r\nsample implementation:\r\nlet rec flatten func source = seq {\r\nyield source\r\nfor x in func source do\r\nyield! flatten func x\r\n}\r\nI got the general idea from these SO Posts:\r\nhttp://stackoverflow.com/questions/10253161/efficient-graph-traversal-with-linq-eliminating-recursion\r\nhttp://stackoverflow.com/questions/11830174/how-to-flatten-tree-via-linq\r\nSince F# has yield!, we don't need to explicitly use Stack<'T> like in C#.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-09T12:48:00",
                "Content": "While the function is a fine thing, I don't think it fits with the current F# core library design by itself - there is no generic library of tree-traversing or tree-mapping functions - instead you write an appropriate for your tree type.\r\nIt is also not easy to make a one-size fits all function. For example, even for this function in many cases it would be better to return the flattened tree as an array or list, rather than a on-demand sequence.\r\nDon Syme, F# Language and Core Library Evolution"
            },
            {
                "Submitter": "George",
                "Submitted": "2015-06-10T10:35:00",
                "Content": "Why not bring the tree into the standard collections conversion treatment\r\nSeq.ofTree : (parser: 'node -> 'node seq) (root: 'node)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Many thanks for this suggestion. However, I’m declining this for the reasons given in the comments above.\r\nDon Syme, F# Language Evolution"
        }
    },
    "8306538": {
        "Number": "8306538",
        "Submitter": "thinkb4coding",
        "Submitted": "2015-06-10T00:00:00",
        "Title": "Allow quotations of expressions used as Type Provider arguments",
        "Text": "This would enable scenarios where the type provider can rewrite, or abstract at compile time F# code and emit new one.\r\nIt could replace a macro system without the need for new syntax or tooling.",
        "Votes": 30,
        "Comments": [
            {
                "Submitter": "thinkb4coding",
                "Submitted": "2015-06-10T04:20:00",
                "Content": "It could be used by transpilers to check validity and emit code at design/compile time"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-06-10T07:16:00",
                "Content": "Hi @thinkb4coding\r\nI would very much be in favour of this feature for F# vNext.\r\nSee also http://fslang.uservoice.com/forums/245727-f-language/suggestions/6023655-allow-passing-other-types-of-parameters-to-type-pr"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T14:08:00",
                "Content": "Just to note that this would almost certainly require this to have been fully implemented: [/ideas/suggestion-5675977-allow-type-providers-to-generate-types-from-other](/ideas/suggestion-5675977-allow-type-providers-to-generate-types-from-other.md)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "8393964": {
        "Number": "8393964",
        "Submitter": "exercitus vir",
        "Submitted": "2015-06-12T00:00:00",
        "Title": "Interfaces as simple, reusable and named sets of member constraints on statically resolved type parameters",
        "Text": "The suggestion is that any interface can be used as a named set of member constraints on statically resolved type parameters (just like generic type parameters) .\r\nThis suggestion achieves 4 desirable properties of member constraints on statically resolved type parameters with new kind of constraint that is non-invasive and simple to use:\r\n1) simplified syntax improves writability\r\n2) grouping constraints improve readability and makes declaration explicit\r\n3) naming a set of constraints allow reuse of those constraints\r\n4) ability to reuse existing interfaces as a named set of member constraints allows retroactively implementing interfaces on existing types (solves many reasons why people want type classes)\r\nIt's syntax and semantics are similar to the type constraint specified with `:>`. The suggested syntax for the new kind of constraint is `:^`.\r\nIt works with any (existing) interface. For example,\r\ntype IDuckish = //an interface for duck-like types\r\nabstract member Quack: unit -> string\r\nlet inline quackLikeADuck (d : ^d when ^d :^ IDuckish) = //note the `:^` instead of `:>`\r\nd.Quack(); //syntax for invokation also much simpler*\r\n*The simpflied syntax for member invokations is inspired by this suggestion: http://fslang.uservoice.com/forums/245727-f-language/suggestions/8014059-improve-constraints-and-make-call-syntax-easier-fo\r\nThis suggestion subsumes this suggestion: http://fslang.uservoice.com/forums/245727-f-language/suggestions/6343928-allow-naming-of-member-constraints",
        "Votes": 16,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T22:12:00",
                "Content": "Note: This effectively allows simple to use structural subtyping as opposed to nominal subtyping currently provided by interfaces, so you could call this kind of constraint a \"structural interface constraint\".\r\nThis could also allow efficient extension interfaces* even on sealed types and value-types where if the function is expecting a statically resolved type parameter with a structural interface constraint, then it could just inline the functions of the extension interface.\r\n*extensions interfaces suggested here: http://fslang.uservoice.com/forums/245727-f-language/suggestions/5665042-allow-extension-interfaces"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-12T22:29:00",
                "Content": "Regarding my last comment, the advantage of extension interfaces is that it makes the supported functions explicit even if the extension interface is only used as a structural interface constraint.\r\nI suggest the following syntax for extension interfaces, which is consistent with extension members:\r\ntype TypePretendingToBeADuck with\r\ninterface IDuckish with\r\nmember this.quackLikeADuck() = \"Quack\""
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T10:09:00",
                "Content": "One more advantage of this suggestion: All usage of member constraints defined by an interface could finally be renamed via the Refactor->Rename command in Visual Studio since they would identified by the interface they belong to. This is currently not possible since member constraints do not have a global name."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T10:20:00",
                "Content": "Here is a suggestion for an event shorter syntax if the interface is the only constraint on `d`(just like with generic type parameters):\r\nlet inline quackLikeADuck (d :^ IDuckish) = //again, just `:^` instead of `:>`\r\nd.Quack() //exactly like invokation of dynamically resolved members as before"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T11:58:00",
                "Content": "This idea could even be extended to static member constraints where instead of using an interface as a named set of member constraints, we could use a *module* signature as a named set of *static* member constraints. This is similar to how a type class is defined as a set of functions, but being static members in F# enforces a single instance of a type class for a type.\r\nmodule Duckish = //module as structural interface for static members\r\nval quack : unit -> string //just like a function signature in signature files\r\ntype TypePretendingToBeADuck =\r\nmodule Duckish with //syntax just like interface implementation\r\nlet quack() = \"quack\" //will be translated to a static member of the same name\r\nlet inline quackLikeADuck (d : ^d when ^d :^ Duckish) = //module as named set of static member constraints\r\n^d.quack() //syntax consistent with invokation of static member"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T12:12:00",
                "Content": "Here is an example where a module signature as named set of static member constraints would be useful. Tomas Petricek shows you can implement custom numeric types like this: http://tomasp.net/blog/fsharp-custom-numeric.aspx/. The module signature would look like this:\r\nmodule Numeric<'n> =\r\nval FromZero : unit -> 'n\r\nval FromOne : unit -> 'n\r\nval FromInt32 : int -> 'n\r\nval FromInt64 : int64 -> 'n\r\nAnd can be used as a static member constraint in an inline function like this:\r\nlet inline zero (n : ^n when ^n :^ Numeric) =\r\n^n.FromZero()"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-13T12:19:00",
                "Content": "Please ignore this and my last two comments if you don't care about modules as named sets of *static* member constraints. The original suggestion was only about interfaces as named set of member constraints.\r\nIf using a module signature as a named set of static member constraints does interest you, I suggest to call this kind of constraint \"module signature constraint\"."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-06-22T08:06:00",
                "Content": "I'm confused about the proposed implementation for this suggestion. It seems like Interfaces already do a lot of what you'd like them to :\r\n-----------------------------------------------------------------------------------------------------\r\n| type Gunslinger = abstract shoots : int -> int\r\n| type Incinerator = abstract incinerate : int -> int\r\n| type Elite = abstract harbinger : int -> int -> int\r\n|\r\n| let maelstrom (derringer:'a when 'a :> Gunslinger\r\n| and 'a :> Incinerator\r\n| and 'a :> Elite ) shot =\r\n| shot |> (derringer.incinerate >> derringer.shoots >> derringer.harbinger 22)\r\n-----------------------------------------------------------------------------------------------------\r\n` :> ` is the upcast operator, is ` :^ ` supposed to be static type resolution operator or something like that?\r\nI think this is a better way to get the properties you're looking for\r\nhttp://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-22T15:27:00",
                "Content": "Hello Jared, thanks for pointing out that my suggestion might not have\r\nbeen clearly articulated.\r\nYes, ` :> ` is the upcast operator and also used to specify type constraints of (dynamically resolved) type parameters as in your example. I have not seen members being defined as function types, so thanks for making me learn something, but that does not solve the problem I am trying to solve.\r\n`:>` can only be used for (nominal) interfaces as type constraints on dynamically resolved type parameters. I am asking for structural interfaces that can be used as type constraints on statically resolved type parameters. To make it explicit syntactically and reduce ambiguity for the compiler, we could use \":^\" inspired by \"^\" for statically resolved type parameters and inspired by ` :> ` for dynamically resolved type constraints.\r\nThe goal of my suggestion is simply to ease the pain of declaring groups of explicit member constraints. They get really ugly really fast and they are not reusable. Being able to reuse existing interfaces to group several explicit member constraints into a structural interfaces is what my suggestion is about. I also haven't figured out how to indent several explicit member constraints without getting an indentation warning, but that is another problem.\r\nRegarding the implementation, the compiler would basically just inject the explicit member constraints derived from the specified interface for you. If the argument actually explicitly implements a (nominal) interface, then it could replace the structural interface constraint with the nominal interface constraint, or not - it would work either way because implementations of nominal interfaces already have the required structure of asked for by structural interfaces.\r\nI hope that makes it clear. If not, just let me know."
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2015-06-22T22:47:00",
                "Content": "I think it would be confusing to change interfaces in the manner that you're suggesting\r\nas it would break one of the rules of interfaces -\r\n\"Interface methods can be called only through the interface, not through any object of the type that implements the interface.\"\r\nThese \"statically resolved interfaces\" would also be fairly limited in their functionality. They couldn't support constructor constraints like ` 'T when 'T : (new : unit -> 'T) ` (interfaces can't define constructors); or static member and operator constraints (interfaces cannot define static members); and I can't see a way for them to support the - base type, null, value type, reference type, or unmanaged constraints either.\r\n\"statically resolved interfaces\" also fall short for constraints on functions ::\r\n---------------------------------------------------------------------------------------\r\nlet inline constraint_func (argA:^a) (argB:^b)\r\n(**) (func: ^a-> ^b-> ^c when ^a:( static member (+) : ^a * ^b -> ^b )\r\n(*.............................*) and ^b : ( static member (+) : ^b * ^a -> ^b )\r\n(*.............................*) and ^c : ( static member (*) : ^c-> ^c -> ^c )\r\n(*.............................*) and ^c : ( member toA: unit-> ^a )) : ^c =\r\n(**) let arg1 = (^c:(member toA:unit-> ^a)(func argA argB))\r\n(**) let arg2 = argA + argB\r\n(**) func arg1 arg2\r\n// ^ this is working ( albeit useless =P )code\r\n---------------------------------------------------------------------------------------\r\nWhen multiple types need constraints, using interfaces necessitates an interface per distinct type. However, following the syntax of my constraint suggestion, it could easily be defined as one cohesive unit\r\n( http://fslang.uservoice.com/forums/245727-f-language/suggestions/8509687-add-constraints-as-a-language-construct )\r\n---------------------------------------------------------------------------------------\r\nconstraint ( ^a-> ^b -> ^c : abc_multplus ) =\r\n(*.*) when ^a : ( static member (+) : ^a * ^b -> ^b )\r\n(*.*) and ^b : ( static member (+) : ^b * ^a -> ^b )\r\n(*.*) and ^c : ( static member (*) : ^c -> ^c -> ^c )\r\n(*.*) and ^c : ( member toA : unit -> ^a ))\r\nlet inline higherFn ( funk : ^f when ^f : abc_multplus ) ( arg1 : ^g ) = ....\r\n---------------------------------------------------------------------------------------\r\nAdding a distinct language construct for constraints really seems like the best way to collect a\r\nheterogeneous mix of constraints into a modular, composable, and extendable expression"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-07-14T09:47:00",
                "Content": "Jared, thanks for your feedback. I agree that \"statically resolved\" or \"structural\" interfaces would be fairly limited. But they would still be very usefu for the simple problem they are solving. The fact is, declaring simple explicit member constraints is ugly. And the complex explicit member constraints are of course much more powerful than the simple structural interfaces. But in 90% of cases you don't need the other constraints like null, etc.\r\nStatic member constraints could be expressed as member signatures since this is what they basically are as I described in my comments below.\r\nI disagree with the rule you quoted though. This rule applies to nominal interfaces, because this is the only kind available in .NET. Structural interfaces are a different kind of interface. I am just suggesting to be able to reuse the syntax and existing nominal interfaces. I don't think that it would cause any confusion as it's rather seamless and unobtrusive."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T11:31:00",
                "Content": "Note that type aliases can be used to name groups of constraints, see https://gist.github.com/dsyme/bfed2eed788c7ba58ccc\r\nAlso, I will close this as a duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6343928-allow-naming-of-member-constraints. This isn't an exact duplicate, and also incorporates http://fslang.uservoice.com/forums/245727-f-language/suggestions/8014059-improve-constraints-and-make-call-syntax-easier-fo, but they are close enough together that we don't need to track them separately"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Per my comment, closing this as a duplicate of http://fslang.uservoice.com/forums/245727-f-language/suggestions/6343928-allow-naming-of-member-constraints.\r\nThis isn’t an exact duplicate, I know, e.g. it also incorporates http://fslang.uservoice.com/forums/245727-f-language/suggestions/8014059-improve-constraints-and-make-call-syntax-easier-fo, but they are close enough together that we don’t need to track them separately"
        }
    },
    "8401578": {
        "Number": "8401578",
        "Submitter": "exercitus vir",
        "Submitted": "2015-06-13T00:00:00",
        "Title": "Generic `TypeWithMeasure` and `TypeWithoutMeasure` functions for adding units of measure on any type",
        "Text": "Currently, the Core.LanguagePrimitives module only provides the following functions to add units of measure to decimal, double (= float) and single (=float32), respectively:\r\nDecimalWithMeasure : decimal -> decimal<'u>\r\nFloat32WithMeasure : float -> float<'u>\r\nFloatWithMeasure : float32 -> float32<'u>\r\nand the Core.Operators module overloaded functions for removing units of measure on decimal, double (= float) and single (=float32):\r\ndecimal : ^T -> decimal\r\nfloat : ^T -> float\r\nfloat32 : ^T -> float32\r\nEven though all the other primitive numeric types are also annotated with [<MeasureAnnotatedAbbreviation>], you cannot use them to carry a unit of measure, because the needed conversion functions are missing. And since `MeasureAnnotatedAbbreviation` is a public attribute, we would should be able to add units of measure on *any* type.\r\nSo, I propose to add the following generic functions to the Core.LanguagePrimitives module as follows:\r\nTypeWithMeasure<'T, 'U> : 'T -> 'U\r\nTypeWithoutMeasure<'T, 'U>: 'U -> 'T\r\nwhere 'U is 'T with the measure.\r\nCurrently, DecimalWithMeasure, Float32WithMeasure, FloatWithMeasure are all implemented using the same generic function:\r\nlet inline retype<'T,'U> (x:'T) : 'U = (# \"\" x : 'U #)\r\nSo `TypeWithMeasure` and `TypeWithoutMeasure` could simply reuse this function. I realize that retype might not be entirely safe, but implementors of custom types that can carry units of measure can then implement two type-safe functions:\r\n//custom type\r\ntype SomeType = ...\r\n//custom type that can carry measure\r\n[<MeasureAnnotatedAbbreviation>]\r\ntype SomeType <[<Measure>] 'm> = SomeType\r\n//module with conversion functions for custom type\r\nmodule SomeType =\r\nlet inline SomeTypeWithMeasure (withoutMeasure : SomeType) : SomeType<'m> = TypeWithMeasure withoutMeasure\r\nlet inline SomeWithoutMeasure (withMeasure : SomeType<'m>) : SomeType = TypeWithMeasure withMeasure",
        "Votes": 2,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-14T11:31:00",
                "Content": "I just noticed that the following functions also exist, but I still think that we need a generic version:\r\nInt16WithMeasure : int16 -> int16<'u>\r\nInt32WithMeasure : int32 -> int32<'u>\r\nInt64WithMeasure : int64 -> int64<'u>\r\nSByteWithMeasure : sbyte -> sbyte<'u>"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-14T12:08:00",
                "Content": "You could solve the safety issue by introducing a new attribute similar to `GeneralizableValueAttribute` for value restriction. For example, `TypeWithMeasure` and `TypeWithoutMeasure` should only be callable from functions with an Attribute that might be called `ValueReturnedWithMeasureAttribute` and `ValueReturnedWithoutMeasureAttribute` to prevent accidental usage of `TypeWithMeasure` and `TypeWithoutMeasure`."
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-18T11:49:00",
                "Content": "I also noticed that removing units of measure using functions such as `float` or `double` compiles to (in release mode) for example `(Double) doubleValue` in CIL. Unless this cast is ignored by the CLR if the value is of the same type as the desired cast, this explicit cast should not appear in the CIL produced by F#.\r\nI would be interested to know if currently `(Double) doubleValue` is optimized to simply `double` by the CLR to avoid unnecessary casts."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-18T04:43:00",
                "Content": "Take a look at this gist.\r\nhttps://gist.github.com/dsyme/b80086ce5c5a0dc1a9f7\r\nAlthough there is a change of representation in the conversion for units <-> no units, the effect is still basically as you want it. (if you want to minimize the cost of the representation conversion you could use a struct type)"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "8431944": {
        "Number": "8431944",
        "Submitter": "exercitus vir",
        "Submitted": "2015-06-16T00:00:00",
        "Title": "Allow to specify fully qualified name of property in `StructuredFormatDisplayAttribute`",
        "Text": "Currently, specifying the name of a property in `StructuredFormatDisplayAttribute` prepends the fully qualified name of the property named between {}.\r\nI would like to use a property in `StructuredFormatDisplayAttribute` that is part of an interface, but this is not possible because interfaces are explicitly defined. So currently, I have to define a dummy property directly on the type and call the property of the interface from there.\r\nIt would be much nicer if I could specify {Interface.Property} or {FullyQualifiedNameOfInterface.Property} instead.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-18T00:00:00",
            "Text": "Treating this issue as covered by http://fslang.uservoice.com/forums/245727-f-language/suggestions/8432340-inherit-structuredformatdisplayattribute-specifi to avoid too many micro issues related to the same general problem/feature area"
        }
    },
    "8432340": {
        "Number": "8432340",
        "Submitter": "exercitus vir",
        "Submitted": "2015-06-16T00:00:00",
        "Title": "Inherit `StructuredFormatDisplayAttribute` specified on interface",
        "Text": "Annotating an interface with `StructuredFormatDisplayAttribute` should be inherited by types that implement that interface. This would safe a lot of repetitive code when an interface requires a property that is used by `StructuredFormatDisplayAttribute` is implemented by a type.\r\nThis suggestion would require the support of the following suggestion to work this way: http://fslang.uservoice.com/forums/245727-f-language/suggestions/8431944-allow-to-specify-fully-qualified-name-of-property",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:35:00",
                "Content": "What would happen when multiple interfaces implement this attribute?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T08:59:00",
                "Content": "Also, why would this require the fully qualified name? Wouldn't the attribute on the interface use the non-fully-qualified name?"
            },
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-07-17T11:15:00",
                "Content": "Ah, thanks for the good questions. I did not think about multiple interfaces implementing the attribute. The fully qualified name would have been required for `StructuredFormatDisplayAttribute` to to see the member of the interface. But it seems that it is better if that is not possible since the member directly on the type guarantees that there is only one member with that name.\r\nYou can decline this request as I understand now that this would not be possible technically."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declined per request"
        }
    },
    "8474713": {
        "Number": "8474713",
        "Submitter": "exercitus vir",
        "Submitted": "2015-06-18T00:00:00",
        "Title": "Allow to use struct constructors as functions",
        "Text": "Similar to the suggestion [Allow to use class constructors as functions](http://fslang.uservoice.com/forums/245727-f-language/suggestions/5663317-allow-to-use-class-constructors-as-functions), it would be nice if we use constructors of structs as functions.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:33:00",
                "Content": "I double checked and this is implemented in F# 4.0, see https://gist.github.com/dsyme/f07a195a5f0f412b34ec\r\nPlease link to a gist if there are cases that are not covered by this."
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "(this feature is in F# 4.0 – see comment above)"
        }
    },
    "8509687": {
        "Number": "8509687",
        "Submitter": "Jared Hester",
        "Submitted": "2015-06-22T00:00:00",
        "Title": "Add constraints as a language construct",
        "Text": "Allow the declaration of named constraints that can have other named constraints nested within them and are resolved at runtime or compile time based on their structure , e.g.\r\nconstraint (^a:eatsDrinksSleeps) =\r\nwhen ^a : equality\r\nand ^a : comparison\r\nand ^a : (static member Hungry: bool)\r\nand ^a : (member chews: string -> bool)\r\nand ^a : (member drinks: float -> bool)\r\nand ^a : (member sleepsFor: float with get,set)\r\nlet inline go_wild (beast:^a when ^a: eatsDrinksSleeps) = ...\r\n--------------------------------------------------------------------------------\r\nThey could also be defined on flexible types that take generic parameters -\r\nconstraint (#seq<'a> : greatData) =\r\nwhen 'a: struct\r\nand 'a: comparison\r\nand 'a: equality\r\nlet calc (col:'a when 'a:greatData) = ....",
        "Votes": 36,
        "Comments": [
            {
                "Submitter": "exercitus vir",
                "Submitted": "2015-06-22T15:32:00",
                "Content": "Related suggestion: http://fslang.uservoice.com/forums/245727-f-language/suggestions/8393964-interfaces-as-simple-reusable-and-named-sets-of-m?tracking_code=bd9d860150afdb439a2ef3ab649e0374\r\nThe advantage of that suggestion is that it simplifies the syntax of explicit member constraints, does not require a new keyword (albeit a new operator) and can reuse existing interfaces and its syntax."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:49:00",
                "Content": "This gist shows how to name collections of member constraints today: https://gist.github.com/dsyme/bfed2eed788c7ba58ccc"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-10T11:19:00",
                "Content": "Because it is already possible to name sets of constraints using the technique below, I am going to decline this request. Also the request http://fslang.uservoice.com/forums/245727-f-language/suggestions/5762135-support-for-type-classes-or-implicits is overlapping and can be used to cover the general suggestion to have a trait/constraint/type-class facility in the language"
            },
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2016-02-28T07:31:00",
                "Content": "Don, in your gist, you can't use the members without restating the constraints, what the point?\r\nI think Jared was after something like this:\r\nlet inline go_wild (beast:^a when ^a: eatsDrinksSleeps) =\r\n(* *) beast.chews \"snack\"\r\n(* *) beast.drinks \"potion\"\r\n(* *) if not beast.Hungry then printfn \"BURP!\"\r\nnot something which force to state the constraint in a cryptic way at each usage of beast."
            },
            {
                "Submitter": "William Blum",
                "Submitted": "2016-05-01T23:08:00",
                "Content": "Thanks Don for sharing the Gist but unfortunately the type alias trick does not solve the problem for purely static member constraints. In the following example for instance I want to express the same set of constraints for both ^T1 and ^T2 without having to repeat them.\r\ntype Combine< ^T1,^ T2 when\r\n^T1 : (static member print : string -> unit)\r\nand ^T1 : (static member flush : unit -> unit)\r\nand ^T2 : (static member print : string -> unit)\r\nand ^T2 : (static member flush : unit -> unit)\r\n> =\r\nstatic member inline printAndFlushBoth m =\r\n(^T1:(static member print : string -> unit) m)\r\n(^T2:(static member print : string -> unit) m)\r\n(^T1:(static member flush : unit -> unit) ())\r\n(^T2:(static member flush : unit -> unit) ())\r\nFollowing your gist I could define a type alias encoding the two constraints (write and flush) but my constraints being entirely static I have no way to refer to the type alias it in a type annotation since there exist no variable of static type.\r\nAnother benefit of named constraints is that the 'comparison' and 'equality' constraints could be defined in the F# core library instead of being hard-coded in the language.\r\nDo you have another trick up your sleeve for the above example? If not, would you consider reopening this suggestion?"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-10T00:00:00",
            "Text": "Thanks for the suggestion. It is entirely reasonable and it’s taken me a long time to mark it as declined. I’ve listed the reasons below – and http://fslang.uservoice.com/forums/245727-f-language/suggestions/5762135-support-for-type-classes-or-implicits can be used as a placeholder for requests in the type-class/constraint area\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "8556646": {
        "Number": "8556646",
        "Submitter": "mikero",
        "Submitted": "2015-06-26T00:00:00",
        "Title": "Add atom syntax",
        "Text": "Add a syntax for atoms a.k.a. keywords a.k.a. self-evaluating symbols.\r\n:foo (or 'foo, or #foo - whichever causes the least problems)\r\nWhere foo otherwise follows the rules for an identifier, is simply turned into \"foo\" at compile time. (It would also be nice of '-' were also added to the list of allowable characters for the atom.)\r\nE.g.:\r\n(\"fido\", :is-a, :pet) is of type string*string*string",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Shawn Hoover",
                "Submitted": "2015-10-30T14:10:00",
                "Content": "Is there a particular reason why self-evaluating symbols don't exist in a lot of statically typed languages? I've been wondering about it since hearing Rich Hickey stress in some talks the idea of using generic data (maps, vectors, lists) at subsystem boundaries. Obviously they've been around a long time in Lisp, Erlang, and Ruby, for example. Is it just that generic maps are used less in F# so whatever efficiency or syntactic gains of keywords is less useful?\r\nI see someone bothered to make a library in Haskell: https://hackage.haskell.org/package/hxt-9.3.1.15/docs/Data-Atom.html"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:31:00",
                "Content": "Why wouldn't it have some new type \"Atom\" (e.g. a single field struct wrapping a string)"
            },
            {
                "Submitter": "mikero",
                "Submitted": "2016-02-04T18:36:00",
                "Content": ">Why wouldn't it have some new type \"Atom\" (e.g. a single field struct wrapping a string)\r\nThat's fine too -- I was just trying to create the least amount of friction possible and make the Atom an erased type.\r\nThey should always be interned strings so that they are object.== with an atom or a string with the same chars w/o doing a strcmp. (Wouldn't the wrapping interfere with this?)\r\nAh, the atom could be a global object in the assembly so, :foo would be\r\n\r\nnamespace __atoms {\r\nstatic readonly string __gsym_foo = \"foo\";\r\n}\r\nor, per your comment:\r\nstatic readonly string __gsym_foo = new Atom(\"foo\");\r\nSo we could get pretty-print the right way, or store properties on the atom or whatever.\r\nSo the compiler turns :foo into __atoms.__gsym_foo, and :foo == :foo is always true, at least in the same assembly. (Although getting the symbol from a dynamic string (which is not the normal use case) still requires a lookup.)\r\nIf we had symbols and a lightweight first-class map syntax (please!) then I'd be at least 34.7% happier:\r\nlet map = #{:foo 1 :bar 2; :baz 3} --> map<string,int> or map<Atom,int>\r\nmatch map with #{:foo 1 :bar n :REST more} -> /* n =2, more=[ (:baz,3) ] */\r\n(Of course, reader macros would let us do these things ourselves :) and make me 99 44/100 percent happier. Even w/o homoiconicity, I'd deal that the AST transforms to get macros and reader macros - but I know it's a bit of a sticky wicket as well.)\r\nI'm using Clojure over F# for a current project now for some of these reasons, even though I'd much prefer to stay in the .Net ecosystem, and F# in particular -- I'll end up having to do loosely-coupled Java/.Net interop.\r\nAnother option (or related one) is to improve F#'s default use of \"?\" dynamic access, so that out of the box it does all the fast expando object / call-site caching stuff, etc., but still let it be overridable.\r\nIt seems to be that record/class syntax and map syntax and pattern matching could be merged, so that the same pattern could match any complete or partial sum type, and that this would afford a way to do a sort of \"gradual typing\" in F#. Basically I could use record syntax that was a *partial* specification of the record - the backing store would be a map, not a class, and then the type could \"graduate\" to a fully-specified type at some point backed as a class/struct. Devil is in the details..."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "8592088": {
        "Number": "8592088",
        "Submitter": "Boris",
        "Submitted": "2015-06-28T00:00:00",
        "Title": "Make records extensible a la Elm",
        "Text": "It seems very useful when types don't fully defined in advance, but I don't sure if it is possible in F#.\r\nhttp://elm-lang.org/guide/core-language#records",
        "Votes": 14,
        "Comments": [
            {
                "Submitter": "Xavier Zwirtz",
                "Submitted": "2015-06-29T15:02:00",
                "Content": "This could be accomplished by type providers if it was possible for type providers to return records."
            },
            {
                "Submitter": "Boris",
                "Submitted": "2015-06-30T07:37:00",
                "Content": "Type Providers is a (only) design/compile-time story, and extensible records is a run-time one.\r\nFor exampe in AI applications like an Expert System You (your users) have no VS nor Type Providers and still have to introduce new concepts wich can(definitely will) affect types. Working with external data sources that mutated somehow after You used Type Providers without recompilation is at least problematic. With extensible records we could have almost dynamic languages flexibility.\r\nPlease look at http://elm-lang.org/docs/records for the ext rec details."
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-08-13T11:43:00",
                "Content": "Worth pointing out that the idea comes from Microsoft Research's own Daan Leijen. The link below to elm includes a link to the paper \"Extensible records with scoped labels\", but I will add it here for convenience -- seems to solve quite a few problems very naturally: http://research.microsoft.com/pubs/65409/scopedlabels.pdf"
            },
            {
                "Submitter": "trek42",
                "Submitted": "2015-09-05T00:38:00",
                "Content": "Added a more elaborate proposal for this: see [/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete](/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete.md)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:27:00",
                "Content": "Closing in favour of the more elaborate proposal at [/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete](/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete.md)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Closing in favour of the more conrete proposal at [/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete](/ideas/suggestion-9633858-structural-extensible-records-like-elm-concrete.md)"
        }
    },
    "8696917": {
        "Number": "8696917",
        "Submitter": "Brad Collins",
        "Submitted": "2015-07-03T00:00:00",
        "Title": "Modify Option.map return None in case of null",
        "Text": "Java 8's methods on Optional return None in case any operation yields null. Case in point is Optional.map.\r\nAssume that a Session type has a User property that could be null. The following should return None instead of Some(null):\r\nSome(app) |> Option.map (fun a -> a.Session)\r\nThe use case is when interoperating with C#, where nulls are more common.",
        "Votes": 0,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2015-07-07T15:51:00",
                "Content": "That would break the functor law \"fmap id = id\". Java can sort of get away with it (though I haven't seen any formal analysis of this) because you can't construct the equivalent of Some(null), but as we know that's not the case in F#."
            },
            {
                "Submitter": "Brad Collins",
                "Submitted": "2015-07-10T14:14:00",
                "Content": "I see. I didn't think about the algebraic laws. I was coming from Java 8 in which their Optional type does handle null by converting it to a None (or Empty, in Java parlance). F#'s new Option.ofObj() is probably sufficient.\r\nAlso, my apologies for my code sample in the original post. I was working with some sample code in which you could walk the property tree this way:\r\napp.Session.User.Name\r\nI accidentally posted the app.Session code snippet instead of the session.User snippet. My apologies for being confusing."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:10:00",
                "Content": "The current behaviour is appropriate for F# - if the type being returned has null as a true value - or even an abnormal value - then we preserve that."
            },
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2015-09-01T07:19:00",
                "Content": "Here's an article explaining in detail what I briefly mentioned in my previous comment: https://developer.atlassian.com/blog/2015/08/optional-broken/"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "See above response\r\nDon Syme, F# Language Evolution"
        }
    },
    "8733178": {
        "Number": "8733178",
        "Submitter": "Enrique A. Casanovas Pedre",
        "Submitted": "2015-07-06T00:00:00",
        "Title": "Revert back to an accepted feature the delayed implementation of interfaces",
        "Text": "Please see:\r\nhttp://stackoverflow.com/questions/31248797/delay-the-implementation-of-interface-methods\r\nAllow this as a normal, valid and completly legal code:\r\ntype MyCollection<'T> =\r\n{ Data : 'T list }\r\ninterface IEnumerable<'T>\r\ninterface IEnumerable\r\nlet getEnumerator { Data = d } =\r\n(d :> seq<_>).GetEnumerator()\r\ntype MyCollection<'T> with\r\ninterface IEnumerable<'T> with\r\nmember this.GetEnumerator() = getEnumerator this\r\ninterface IEnumerable with\r\nmember this.GetEnumerator() = (getEnumerator this) :> _\r\nCurrently the compiler says:\r\nInterface implementations in augmentations are now deprecated. Interface implementations should be given on the initial declaration of a type.\r\nThis style allows for a more idiomatic and functional approach of developing in F#.",
        "Votes": 24,
        "Comments": [
            {
                "Submitter": "Tomas Petricek",
                "Submitted": "2015-07-06T21:47:00",
                "Content": "I also prefer to define types in this way (core type definition, followed by a module with functions, followed by an augmentation that exposes the functionality in an OO friendly way), so I support the suggestion. Especially since it's pretty much just a matter of removing a warning :-)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T06:06:00",
                "Content": "The technical reason that this is deprecated is that initialization may be unsound, e.g. https://gist.github.com/dsyme/d02446c3e139a7b81f28.\r\nThe F# approach to this would be to add dynamic initialization checks to initialization sequence in cases where this construct is used and there is intervening top-level data (e.g. see http://research.microsoft.com/apps/pubs/default.aspx?id=79951)\r\nThis is in theory feasible - similar checks are done for static data initialization in classes and it would be great to share the implementation - but it is non-trivial to implement and comes with a runtime cost which must be avoided for all existing code. Also, there have historically been a lot of niggling issues with that particular feature.\r\nSo in short this is feasible, but is not simply a matter of turning the deprecated feature back on."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:53:00",
                "Content": "I'm closing this per my comment below, and in favour of this suggestion: [/ideas/suggestion-11723964-allow-types-and-modules-to-be-mutually-referential](/ideas/suggestion-11723964-allow-types-and-modules-to-be-mutually-referential.md)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Many thanks for the suggestion. I’m closing it per my comment below, and in favour of this suggestion: [/ideas/suggestion-11723964-allow-types-and-modules-to-be-mutually-referential](/ideas/suggestion-11723964-allow-types-and-modules-to-be-mutually-referential.md)\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "8784865": {
        "Number": "8784865",
        "Submitter": "Anonymous",
        "Submitted": "2015-07-09T00:00:00",
        "Title": "F# interactive could support saving and loading its state to/from a file",
        "Text": "It would be great to be able to do something like:\r\n#save \"CurrentState.dmp\"\r\n...\r\n#restore \"CurrentState.dmp\"\r\nIt would be especially useful for interactive experimentation that deals with larger data",
        "Votes": 9,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T05:54:00",
                "Content": "I don't know of any implementations of process checkpointing on Windows. See also https://en.wikipedia.org/wiki/Application_checkpointing"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-07-17T05:56:00",
                "Content": "I presume on Linux that existing process checkpointing techniques could be used, but it would be interesting to have it documented.\r\nA state-serializing implementation based on the Nessos Vagabond library may be technically feasible, but only for a limited range of serializable data."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:45:00",
                "Content": "I'm closing this because it's very hard to achieve in a cross-platform way, and out of scope for fsi.exe/fsharpi in the core tooling\r\nHowever it would be totally reasonable to build a checkpointing fsharpi on Linux based on the F# Compiler Service, where you can build and design your own F# Interactive executable utilizing what is available in the FSharp.Compiler.Service DLL"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Closing per my comment below., please take a read.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "8863204": {
        "Number": "8863204",
        "Submitter": "Dmítrij Jevgénijevič Ačkásov",
        "Submitted": "2015-07-14T00:00:00",
        "Title": "New keyword \"where\" (syntactic sugar)",
        "Text": "Current F# code is very head heavy. Most functions have implementation at the end and predeclarations at the top. The Haskell keyword \"where\" would help to reverse this relation.\r\nex:\r\nlet ffffffff a b c = let i=5 in (a+b+c)*i\r\nis identical to\r\nex:\r\nlet ffffffff a b c = (a+b+c)*i where let i=5",
        "Votes": 0,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-07-17T00:00:00",
            "Text": "Closing issue with zero votes"
        }
    },
    "8899330": {
        "Number": "8899330",
        "Submitter": "Weirong Zhu",
        "Submitted": "2015-07-16T00:00:00",
        "Title": "F# compiler should support CallerLineNumber, CallerFilePath etc",
        "Text": ".Net has attributes like CallerLineNumber, CallerFilePath (see MSDN https://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.callerlinenumberattribute(v=vs.110).aspx). These are supported by C# compiler but not F# compiler. This seems to be an important feature to have. Especially when writing service components, the logging facility normally requires a compile-time approach to populate the file path and line number. In C/C++, this can be achieved by implementing the logging API using Macros. In C#, it can be done with CallerLineNumber, CallerFilePath attributes. There seems no viable approach in F#. Moreover, if there's an existing C# logging library that used CallerLineNumber attribute, such library cannot be taken advantage easily from F# (unless we passing __LINE__, __SOURCE_DIRECTORY__ and __SOURCE_FILE__ explicitly at every call site of logging API, which is tedious)",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Lincoln Atkinson",
                "Submitted": "2016-04-07T12:17:00",
                "Content": "FYI - I am working on this feature as a project for the 2016 FSSF mentoring program with Avi Avni (@AviAvni3). Progress here: https://github.com/latkin/visualfsharp/tree/latkin-caller-info-attrs"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed. RFC and link to pull request is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1012-caller-info-attributes.md\r\nThis is an entirely reasonable recent .NET/C# standard to implement. Certainly, .NET object-type APIs using these attributes should be respected.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8909788": {
        "Number": "8909788",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2015-07-17T00:00:00",
        "Title": "Disable or add a warning to mutable use bindings",
        "Text": "See also https://github.com/Microsoft/visualfsharp/issues/535#issuecomment-122262582",
        "Votes": 1,
        "Comments": [],
        "Status": "started",
        "Response": {
            "Responded": "2016-06-22T00:00:00",
            "Text": "This is approved for inclusion in a future release of F#.\r\nPR at https://github.com/Microsoft/visualfsharp/pull/1277\r\nNo RFC is needed for this feature.\r\nDon Syme, F# Language and Core Library Evolution."
        }
    },
    "8951176": {
        "Number": "8951176",
        "Submitter": "Anonymous",
        "Submitted": "2015-07-20T00:00:00",
        "Title": "Add namespace as a parameter to SqlDataConnection",
        "Text": "Right now there doesn't appear to be any way to define a namespace to be passed to SqlMetal. This is problematic when you have a database object named System as it conflicts with System imports/usings.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "luketopia",
                "Submitted": "2015-07-30T18:56:00",
                "Content": "I have run into this problem as well. I'm not sure being able to control the namespace provides any benefit since the namespace is only used in the code generation process and the generated types are ultimately relocated / nested under the root provided type. I think that the type provider just needs to pass some dummy namespace when calling SqlMetal rather than nothing as it does now."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:17:00",
                "Content": "Moved to https://github.com/fsprojects/FSharp.Data.TypeProviders/issues/8"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Moved see below"
        }
    },
    "8968375": {
        "Number": "8968375",
        "Submitter": "Steven Taylor",
        "Submitted": "2015-07-21T00:00:00",
        "Title": "extend all collection types with one function.",
        "Text": "it's great that the collection APIs have been padded out. However, it'd be nice to be able to generically extend all collections types with, say, a Seq. Then conversion to / from alternative collection type could be implemented automatically by the compiler. Subsequently, having a mechanism to optimise with additional cases when it became important would be useful.\r\nWe can achieve this with function wrappers, but it'd be nice to make mechanical steps like these more automatic.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Many thanks for the suggestion\r\nDeclining this as it is not a specific design proposal, so it’s difficult to know what’s being voted on.\r\nIf you’d like to re-propose, please resubmit with a more detailed description of the problem with examples and/or a more concrete design proposal.\r\nthanks\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "8998102": {
        "Number": "8998102",
        "Submitter": "Steven Taylor",
        "Submitted": "2015-07-23T00:00:00",
        "Title": "comment in supporting files",
        "Text": "if code is self documenting, adding comments later for API purposes gets in the way of readability. Padding out with comments also gets in the way of a well crafted level of code density. Therefore it'd be nice to be able to comment functions in supporting files, and to have a mechanism for VS / F# to both maintain these links, and link to the relevant information for intenseness purposes.\r\nAdditionally, a transitive, find inherited comment would be quite useful too. VS could have a InheritedIntellisense tag.\r\nPerhaps a code merge as a part of the build process would suffice.\r\nThe idea of sprinkling comments in code for automatic document generation, although useful, seems back-to-front for an actively maintained code base (assuming good tooling support). It'd be nice to separate things out and to have things flowing in the reverse direction too.",
        "Votes": 0,
        "Comments": [
            {
                "Submitter": "luketopia",
                "Submitted": "2015-07-27T20:18:00",
                "Content": "Have you looked into F# signature files? These allow you to have your API comments in a separate file from your implementation, just as you described.\r\nhttps://msdn.microsoft.com/en-us/library/dd233196.aspx"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "zero votes, declined"
        }
    },
    "9027133": {
        "Number": "9027133",
        "Submitter": "Phillip Trelford",
        "Submitted": "2015-07-26T00:00:00",
        "Title": "Make \"do\" optional in for and while loops",
        "Text": "Currently all for and while loops must specify \"do\" before the statements:\r\nfor i = 1 to 10 do\r\nprintfn \"Hello World\"\r\nThis does not feel intuitive for developers coming from Python or BASIC. The \"do\" should not be required by the parser as for example \"in\" is no longer required in the default light syntax mode.",
        "Votes": 43,
        "Comments": [
            {
                "Submitter": "luketopia",
                "Submitted": "2015-08-17T18:53:00",
                "Content": "I sometimes forget the \"then\" on an if/else/elif and wonder if it could be made optional along the same lines. Only other thing I can think of that is like this is the \"with\" in a match expression, though I kind of like one that for some reason."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-08-23T08:30:00",
                "Content": "Oppose. This is of little utility, and does not jibe with the way ML parsing is intended to work. Same opposition applies to optional 'then'."
            },
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-08-23T08:31:00",
                "Content": "Also oppose due to the inconsistency this will create among code bases and styles so late in the game. It just isn't buying us much."
            },
            {
                "Submitter": "Richard Gibson",
                "Submitted": "2015-08-27T09:19:00",
                "Content": "I don't think this is even possible. You need the `do` keyword to separate the `for` expressions from the code that is being executed in the loop.\r\nUsing your example, you would like to write:\r\nfor i = 1 to count printfn \"Hello world\"\r\nDid you mean:\r\nfor i = 1 to count do printfn \"Hello world\"\r\nor:\r\nfor i = 1 to (count printfn \"hello world\") do ..."
            },
            {
                "Submitter": "Phillip Trelford",
                "Submitted": "2015-11-11T03:59:00",
                "Content": "Richard, I'd expect the `do` keyword may still be used when writing multiple statements on a single line, just as the `in` keyword is still required in F# in this scenario. This is how Ruby approaches while & for loops, see http://www.tutorialspoint.com/ruby/ruby_loops.htm"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:13:00",
                "Content": "I do understand that Python and BASIC users may find the extra \"do\" and \"then\" keywords non-intuitive. In a different world, we may have opted to use \":\" or some other line-terminator.\r\nHowever, I think this decision is now fixed in stone for F#, I don't see us making this specific change in anything but a wholesale revision of the language syntax, which is not on the agenda any time soon.\r\nSo I'm marking this as declined."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "See my comment below\r\nDon Syme, F# Language Evolution"
        }
    },
    "9129526": {
        "Number": "9129526",
        "Submitter": "Metastatic",
        "Submitted": "2015-08-01T00:00:00",
        "Title": "Add a way to prevent async execution at compiletime",
        "Text": "There are sometimes operations such as COM that don't play very well with threading. It would be nice if there was a way to denote that a function is not threadsafe and cannot be used from within a thread. e.g. if someone tries to use parallel a compile error would show up indicating that the function cannot be used from within a thread.",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Fyodor Soikin",
                "Submitted": "2015-08-09T17:37:00",
                "Content": "What do you mean by \"within a thread\"? All code execution happens on _some_ thread. So if a particular function was prohibited from executing \"within a thread\", it could not be executed at all."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Many thanks for the suggestion\r\nDeclining this as it is not a specific design proposal, so it’s difficult to know what’s being voted on.\r\nIf you’d like to re-propose, please resubmit with a more detailed description of the problem with examples and/or a more concrete design proposal.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "9156844": {
        "Number": "9156844",
        "Submitter": "Tomas Petricek",
        "Submitted": "2015-08-03T00:00:00",
        "Title": "Relax some of the indentation rules",
        "Text": "Currently, the general rules for indentation in F# is that the code on the next line should be indented further than the thing that determines its starting point on the previous line.\r\nThere are a number of cases where this quite annoyingly means that you have to indent things very far (or, to avoid that, add lots of unnecessary line breaks). One example is when you have nesting in a method call. For example:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions(Options(colorAxis=ColorAxis(values=[| -100;0;100;200;1000 |], colors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nNow, there is almost no way to make this code snippet look decent. I would want to write something like this:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions(Options(colorAxis=ColorAxis(values=[| -100;0;100;200;1000 |],\r\ncolors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nBut this is not allowed, because \"colors\" should start after the opening parenthesis of ColorAxis, so I would need 50 spaces! To make the number of spaces smaller, you can add additional newline (to get the \"ColorAxis\" more to the left), but this looks pretty bad:\r\nChart.Geo(growth)\r\n|> Chart.WithOptions\r\n(Options\r\n(colorAxis =\r\nColorAxis\r\n(values=[| -100;0;100;200;1000 |],\r\ncolors=[| \"#77D53D\";\"#D1C855\";\"#E8A958\";\"#EA4C41\";\"#930700\" |])))\r\nAnother example is very similar, but with list expressions. I want to write:\r\nlet pop2010 = series [ for c in wb.Countries ->\r\nc.Name => c.Indicators.``CO2 emissions (kt)``.[2010]]\r\nThis actually works, but it gives warning. Again, it wants me to indent the second line so that it is after \"for\", but then I'm not saving pretty much anything by the newline. Or, I can introduce lots of additional newlines and write:\r\nlet pop2010 =\r\nseries\r\n[ for c in wb.Countries ->\r\nc.Name => c.Indicators.``CO2 emissions (kt)``.[2010]]\r\nI think that in situations like these, the rules should be relaxed. In particular, we should not require new line to be intended further than the \"starting thing\" on the previous line. Just further than the previous line.",
        "Votes": 54,
        "Comments": [
            {
                "Submitter": "Tomas Petricek",
                "Submitted": "2015-08-03T19:09:00",
                "Content": "Posted to F# Snippets, which actually *shows* the indentation! http://fssnip.net/rZ"
            },
            {
                "Submitter": "DK",
                "Submitted": "2015-08-04T06:36:00",
                "Content": "As a matter of fact, I don't find the solution to the problem that you've posted to be that bad. I do however prefer it in a slightly different style: http://fssnip.net/s0\r\nGiven enough complexity even this would start becoming too unwieldy, and would require extracting values out into let bindings. But for this example, I personally think this is more than sufficient."
            },
            {
                "Submitter": "Fredrik Forssen",
                "Submitted": "2015-08-04T08:18:00",
                "Content": "What annoys me most is the records. I would prefer to be able to use something looking like the K&R bracing for records, but the F# compiler wants me to either write oneliners or indenting a lot (or putting the braces on their own lines, heresy!)\r\nI'd love to be able to do this (. instead of space since uservoice hates whitespace)\r\ntype Person = {\r\n....Name : string\r\n....Age : int\r\n}\r\nlet calvin = {\r\n....Name = \"Calvin\r\n....Age = 8\r\n}"
            },
            {
                "Submitter": "Anonymous",
                "Submitted": "2015-08-04T16:17:00",
                "Content": "+1000 if I could. Constantly annoyed by this while writing F#."
            },
            {
                "Submitter": "Alexandre Szymocha",
                "Submitted": "2015-12-07T02:37:00",
                "Content": "I LOVE this proposition!\r\nI’m currently using\r\n#nowarn \"62\"\r\n#light \"off\"\r\nat the top of every file. This removes the pythonic indentation and allows me to write my code shapelessly, but it’s tedious."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T13:09:00",
                "Content": "See also http://fslang.uservoice.com/forums/245727-f-language/suggestions/7813977-indentation-of-new-lines-should-be-dependent-on-th"
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-09-27T23:54:00",
                "Content": "BTW, records have been mentioned in a separate suggestion: [/ideas/suggestion-15696774-relax-indentation-rules-on-records](/ideas/suggestion-15696774-relax-indentation-rules-on-records.md)\r\nI feel the records idea is a subset of this one, which would also cover lists and arrays (and so on). So although I'm 100% in favor of the records suggestion, I've put my limited votes on this one instead.\r\nAlso, I'd like to mention one thing that I haven't seen mentioned yet. I'd like to be able to put the closing delimiter on a line of its own, indented at the same level as the following code. E.g.,\r\nlet myFunction () =\r\n....let someList = [\r\n........\"foo\"\r\n........\"bar\"\r\n........\"baz\"\r\n....]\r\n....let otherList = [1; 2; 3]\r\n....// Other code follows"
            }
        ],
        "Status": "open",
        "Response": null
    },
    "9161242": {
        "Number": "9161242",
        "Submitter": "Marco Falda",
        "Submitted": "2015-08-04T00:00:00",
        "Title": "Weight code translation complexity",
        "Text": "Some data types of the F# language are translated in a complex way using classes (e.g.: discriminated unions), while other types could have \"hidden\" costs, for instance non-structural equality/comparison operators or heap allocated structures. It would be nice to add a sort of profile mode to show how many low level instructions (CIL?), weighted according to their efficiency, are required for translating each F# line, like the \"-a\" command line option of Cython; look at the bottom of this page: http://docs.cython.org/src/quickstart/cythonize.html.",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Thanks for the suggestion.\r\nI think the best place to implement such a feature would be in FSharpLint or some other upstack tooling, rather than the language/compiler itself.\r\nMany thanks\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "9168976": {
        "Number": "9168976",
        "Submitter": "Don Syme",
        "Submitted": "2015-08-04T00:00:00",
        "Title": "Add \"complement\" and \"logicalNot\" operators to resolve the confusion with \"~~~\"",
        "Text": "When used on user-defined types, the ~~~ operator resolves to op_LogicalNot rather than the expected op_OnesComplement. See https://github.com/Microsoft/visualfsharp/issues/457#issuecomment-104900399 for a workaround.\r\nThis should be fixed FSharp.Core. An attempt to fix this transparently failed, see https://github.com/Microsoft/visualfsharp/pull/458.\r\nA plan to address this going forward is at https://github.com/Microsoft/visualfsharp/pull/458#issuecomment-127711336 but will require an update to FSharp.Core.",
        "Votes": 1,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2015-08-04T00:00:00",
            "Text": "Approved in principle for F# 4.x+ at next FSharp.Core update. See ongoing discussion on github threads as well.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "9183845": {
        "Number": "9183845",
        "Submitter": "Eirik George Tsarpalis",
        "Submitted": "2015-08-05T00:00:00",
        "Title": "Add System.Collections.ICollection implementations to F# list/set/map",
        "Text": "ICollection is a useful interface that inherits IEnumerable. Inputs implementing ICollection are utilized by libraries such as LINQ, Nessos.Streams and MBrace in order to optimize partitioning of data. Curiously, none of the F# collections (list/set/map) implement ICollection (however the latter two do implement ICollection<T>, which is a different interface designed for mutable collections). It is currently impossible to extract the length/count of a boxed list/map without performing some sort of reflection, which is not always desirable.\r\nI suggest that future versions of F# core implement this.\r\nSee also https://github.com/Microsoft/visualfsharp/issues/570#issuecomment-128000307",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Lincoln Atkinson",
                "Submitted": "2015-08-05T11:55:00",
                "Content": "In order to accurately track the length of a list, an additional length field would need to be added to every node. That would be a not insignificant increase the size of lists.\r\nAlso worth noting that the F# runtime is allowed to cheat and mutate lists in the name of performant front-to-back list creation. If length needs to be tracked, some of these implementations will be required to perform a second pass to update the length fields (e.g. List.filter, which builds result list front to back but has no way to know final length ahead of time)"
            },
            {
                "Submitter": "Lincoln Atkinson",
                "Submitted": "2015-08-05T12:07:00",
                "Content": "So while I agree 100% that fast access to .Length would be very useful in a number of situations, it would come at the price of memory and CPU for all users, all the time. That's not to be taken lightly.\r\nAnd in fairness I must also note that some runtime APIs would in fact benefit from this - e.g. List.length (obviously), List.nth/List.take/List.skip (can detect 'index out of range' type errors cheaply)."
            },
            {
                "Submitter": "Eirik George Tsarpalis",
                "Submitted": "2015-08-06T04:03:00",
                "Content": "Good point.\r\nMy thinking in this case was not to make .Length a constant time operation, but rather expose the current .Length implementation for untyped access. Perhaps the ICollection.Count property comes with the implicit assumption that it should be constant time, however in practice the performance of .Length is acceptable and in fact much, much better than running Seq.length.\r\nMy motivation behind this feature request is the following: when writing libraries that consume user-supplied IEnumerables (such as PLINQ) it is often good practice to specialize on the input type. This is particularly true in the case in the case of parallel/distributed computation where proper partitioning of input data is important. If I were to write a partitioning function that accepts IEnumerable<T>, handling lists is no problem (given that my library is F# aware):\r\n```\r\nlet partition (n : int) (ts : seq<'T>) =\r\nmatch ts with\r\n| :? 'T [] as ts -> partitionArray n ts\r\n| :? ('T list) as ts -> partitionList n ts\r\n| :? ICollection<'T> as c -> partitionCollection n c\r\n(* add more cases here *)\r\n| _ -> partitionSeq n c // slowest, most naive approach\r\n```\r\nIf I were to write the same partitioning function for IEnumerable, my options become more limited\r\n```\r\nlet partition (n : int) (e : IEnumerable) =\r\nmatch e with\r\n| :? System.Array as a -> partitionArray n a\r\n| :? ICollection as c -> partitionCollection n c\r\n| _ ->\r\n// no longer possible to identify lists, need to rely on clunky reflection\r\nlet t = e.GetType()\r\nif t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<_ list> then\r\n// etc etc\r\n```"
            },
            {
                "Submitter": "Paul Westcott",
                "Submitted": "2015-08-07T04:57:00",
                "Content": "I always think of properties as O(1) operations. ICollection.Count should thus remain as as O(1) operation. If you want untyped access like it then a sperate interface like IFSharpList should be created that implements Length or named like a function Count() as per the IEnumerable<> extension. (Maybe it could implement other functionality as well; maybe IsEmpty; GetElementtType; maybe it derives from IEnumerable... Maybe I'm just clutching at straws!)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:43:00",
                "Content": "Re this:\r\n> Also worth noting that the F# runtime is allowed to cheat and mutate lists ...\r\nFSharp.Core does this but only before list objects escape back to user code. (in any case it's not relevant to the issue under discussion here, just mentioning this in case people were wondering)"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:18:00",
                "Content": "In balance I think this is a reasonable suggestion and will mark it approved-in-principle\r\nAlternatively we could implement IReadOnlyCollection https://msdn.microsoft.com/en-us/library/hh881542(v=vs.110).aspx now that FSharp.Core 4.4.0.0+ target .NET 4.5 and .NET 4.0 is old history."
            },
            {
                "Submitter": "Marc Sigrist",
                "Submitted": "2016-02-10T04:55:00",
                "Content": "FWIW, I have worked in several larger F#-to-C# projects, and I have used IReadOnlyCollection extensively. So I think implementing IReadOnlyCollection would be a great idea."
            }
        ],
        "Status": "planned",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Approved in principle, see my comment below\r\nWe will open an RFC for this in due course.\r\nhttps://github.com/fsharp/FSharpLangDesign/tree/master/RFCs\r\nDon Syme, F# Language Evolution"
        }
    },
    "9288600": {
        "Number": "9288600",
        "Submitter": "Bang Jun-young",
        "Submitted": "2015-08-12T00:00:00",
        "Title": "Have String.ofList in the standard library",
        "Text": "Wouldn't it be convenient if String.ofList function was part of the standard library? The implementation is quite straightforward:\r\nmodule String =\r\nlet ofList (list: list<char>) =\r\nlist |> (System.Text.StringBuilder() |> List.fold (fun sb c -> sb.Append(c))) |> string",
        "Votes": 5,
        "Comments": [
            {
                "Submitter": "Bang Jun-young",
                "Submitted": "2015-08-14T10:17:00",
                "Content": "This has been superceded by String.ofSeq. Go to [/ideas/suggestion-9324276-have-string-ofseq-in-the-standard-library](/ideas/suggestion-9324276-have-string-ofseq-in-the-standard-library.md) and vote for it!. :-)"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "see alternative suggestion"
        }
    },
    "9324276": {
        "Number": "9324276",
        "Submitter": "Bang Jun-young",
        "Submitted": "2015-08-14T00:00:00",
        "Title": "Have String.ofChars in the standard library",
        "Text": "Wouldn't it be convenient if String.ofChars function was part of the standard library? The implementation is quite straightforward:\r\nmodule String =\r\nlet ofSeq (seq: char seq) =\r\nseq |> (System.Text.StringBuilder() |> Seq.fold (fun sb c -> sb.Append(c))) |> string\r\nCurrently, we have to use an inefficient chaining to convert a seq of characters to a string:\r\n['a'; 'b'; 'c'] |> Array.ofList<char> |> System.String\r\nwhich can be simplified with String.ofChars:\r\n['a'; 'b'; 'c'] |> String.ofChars\r\nString.ofSeq also can be handy for profiles like PCL where the String type is not regarded as seq<char>.",
        "Votes": 10,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T12:06:00",
                "Content": "Given that this would be pretty low-performance in any case, the use of StringBuilder appears adequate to cover this case."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "9432192": {
        "Number": "9432192",
        "Submitter": "Robert Sim",
        "Submitted": "2015-08-21T00:00:00",
        "Title": "Allow type abbreviation extensions",
        "Text": "Currently this code is disallowed:\r\ntype Statistics =\r\nMap<string,double>\r\nwith\r\nstatic member parse (inStr:string) =\r\n...\r\nIt would be very useful to be able to extend type abbreviations so we don't have to wrap the underlying type inside a record.",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Will Smith",
                "Submitted": "2015-09-06T12:55:00",
                "Content": "What is wrong with this?:\r\ntype Statistics = Statistics of Map<string, double> with\r\nstatic member parse (insTr:string)=\r\n..."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Thanks for the suggestion.\r\nGiven the way that type abbreviations are compiled (they are erased by the F# compiler), it is unlikely that we would allow extensions of abbreviations themselves – for example, would the method be available on the abbreviated type as well? How/where would the method exist in the compiled form?\r\nFWIW we considered this in F# 1.0 but decided against it. I don’t think anything specific has changed to warrant us revising that choice at this stage.\r\nAs stated in the comment, using a single-case discriminated union or a single-element record type is a suitable workaround.\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "9451143": {
        "Number": "9451143",
        "Submitter": "Jared Hester",
        "Submitted": "2015-08-23T00:00:00",
        "Title": "Compiler Plugins like Rust",
        "Text": "In Rust compiler plugins are user created libraries that can extend syntax behavior with new syntax extensions, lint checks, etc.\r\nA compiler plugin system would enable a laboratory of experimentation with language features, giving them the potential to prove themselves trough implementation and application. There are definitely some language features that people have requested that may not seem like a worthwhile investment of resources due to their lack of relevance to a broad spectrum of users, but a compiler plugin system could remove that roadblock from their path toward reification.\r\nA compiler plugin system facilitates a marketplace of ideas. The interchange of approaches, goals, pitfalls and adaptations will distill the best augmentations to the point where they might even be worthy of being incorporated as a part of the core language.\r\nhttp://smallcultfollowing.com/rust-int-variations/imem-umem/guide-plugin.html",
        "Votes": 59,
        "Comments": [
            {
                "Submitter": "Bryan Edds",
                "Submitted": "2015-08-23T08:23:00",
                "Content": "Yes, one reason Haskell is so 'inexplicably' popular is because that language is so hackable. Anyone with sufficient need can extend the language in way unanticipatable by its original designers.\r\nWhile a market place for language ideas may seem chaotic at first, it draws a surprising level of participation and cooperation. Like how boost was just a library that ended up helping C++ evolve in fundamental ways, F# plugins will eventually be tremendously beneficial in guiding the future of F#, and in a principled way.\r\nThis could also hold off a non-cooperative fork of which I keep hearing murmurs :) It appears to be time to open this pressure valve in the community, I think."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T12:43:00",
                "Content": "This is best registered as an FSharp.Compiler.Service request.\r\nThere is no current plan to have the fsc.exe compiler shipped as part of the Visual F# Tools or the fsharpc compiler shipped on Mono accept plugins. However using FSC it is possible to create a new binary that does compilation and accepts plugins."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Declining per my comment below: right now this is best registered as an FSharp.Cpmpiler.Service feature request.\r\nDon Syme, F# Language Evolution"
        }
    },
    "9472671": {
        "Number": "9472671",
        "Submitter": "Anonymous",
        "Submitted": "2015-08-24T00:00:00",
        "Title": "Enable compression of FSharp.Core.dll with --standalone",
        "Text": "Currently when one uses the --standalone+ option with fsc, all the binaries required to run the program (from a F# perspective, not including CLR) are pulled into the main target. This includes FSharp.Core.dll, which weighs in at 1.4MB, this is due to a large amount of strings, and compressing FSharp.Core.dll with 7ZIP yields a footprint of 319KB, which is significantly less overhead.\r\nI propose that the --standalone command line should be equipped with the ability to compress binaries, perhaps --standaloneCompress.",
        "Votes": 4,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T11:13:00",
                "Content": "You should be able to use ILMerge or other tools instead, which I believe have options for slicing out only the functionality that is used."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "See comment – please use another tool such as ILMerge, and/or contribute to that tool if it doesn’t have required functionality.\r\nDon Syme, F# Language Evolution"
        }
    },
    "9484395": {
        "Number": "9484395",
        "Submitter": "Oskar Gewalli",
        "Submitted": "2015-08-25T00:00:00",
        "Title": "Add Result<'Success,'Failure> to FSharp.Core",
        "Text": "In order to be able to write code that you can easily consume that does not throw an exception have a fsharp core type with the following signature:\r\ntype Result<'TSuccess,'TError> =\r\n| Success of 'TSuccess\r\n| Error of 'TError\r\nfrom\r\nhttps://github.com/fsharp/fsharp/issues/479",
        "Votes": 17,
        "Comments": [
            {
                "Submitter": "Mauricio Scheffer",
                "Submitted": "2015-08-28T05:34:00",
                "Content": "There's already an isomorphic type in FSharp.Core : https://msdn.microsoft.com/en-us/library/ee353439.aspx .\r\nI'd say error handling through discriminated unions belongs to the user lib area, e.g. FSharpx, Chessie, etc."
            },
            {
                "Submitter": "Ben Lappin",
                "Submitted": "2015-12-28T07:58:00",
                "Content": "I really like this model and believe it is useful enough to warrant inclusion in the language. Note the inclusion in other languages (e.g. Rust).\r\nThis model - specifically returning a success result (of varying type) or an error result (of a single type) - lends itself extremely well to the computation expression:\r\nlet resultOrError = result {\r\nlet! result1 = thingThatMayFail1()\r\nlet! result2 = thingThatMayFail2 result1\r\nreturn result2 }\r\nmatch resultOrError with\r\n| Success x -> ... // proceed along success path\r\n| Failure e -> ... //handle error\r\nThe expected behavior of this computation expression is fairly clear (at least to me), and it would be nice not to have to include a file or library to use it in all my projects (and I do use it all the time).\r\nAdditional reading: Scott W's description of \"Railway Oriented Programming\" http://fsharpforfunandprofit.com/posts/recipe-part2/"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T09:20:00",
                "Content": "In balance I think adding this type to FSharp.Core would be a good thing. Using Choice has obvious problems in clarity\r\nOne thing I wonder is if it should wait until a struct-union feature is available so the type could be a struct."
            },
            {
                "Submitter": "Oskar Gewalli",
                "Submitted": "2016-02-07T03:09:00",
                "Content": "What kind of testing would you like to be done?\r\nPerhaps some example usage?\r\nThe obvious construct to also expose would be something like\r\nResult.Try : (unit->'T1) -> Result<'T1, Exception>\r\nas can be seen in Chessie:\r\nhttps://github.com/fsprojects/Chessie/blob/master/src/Chessie/ErrorHandling.fs#L29\r\nand in rust:\r\nhttps://doc.rust-lang.org/std/result/#the-try-macro\r\nhowever, \"Try\" collides with a .net keyword, so it not be ok to use."
            },
            {
                "Submitter": "thinkb4coding",
                "Submitted": "2016-02-12T15:24:00",
                "Content": "Yep, having struct union for this would be even more awsome"
            },
            {
                "Submitter": "Enrico Sada",
                "Submitted": "2016-02-14T05:59:00",
                "Content": "Create F# RFC 1004 ( https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1004-result-type.md )\r\nPlease continue discussion in https://github.com/fsharp/FSharpLangDesign/issues/49"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-08-02T00:00:00",
            "Text": "Completed. The RFC is here: https://github.com/fsharp/FSharpLangDesign/blob/master/RFCs/FS-1004-result-type.md\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "9514506": {
        "Number": "9514506",
        "Submitter": "Loic Denuziere",
        "Submitted": "2015-08-27T00:00:00",
        "Title": "Relax inference for array/list/seq literals with #subtypes",
        "Text": "See here for some context: http://websharper.com/question/80117/allow-doc-element-to-take-seq-doc-children\r\nCurrently, if the context decides that a given array/list/seq literal has type seq<#T> (for example if it is passed to a function that expects that), then the exact subtype of T is decided by the first element of the sequence, and if any subsequent element is more general then it is a type error. It would be nice if the type could be generalized instead.\r\nExample:\r\ntype Animal() = class end\r\ntype Dog() = inherit Animal()\r\nlet feed (animals: seq<#Animal>) = ()\r\n// Type error on `Animal()`: expected Dog, got Animal\r\nfeed [ Dog(); Animal() ]",
        "Votes": 7,
        "Comments": [
            {
                "Submitter": "Robert Kuzelj",
                "Submitted": "2015-11-01T12:21:00",
                "Content": "This is my biggest pain when interfacing with other (class based) libraries in F#.\r\nIt makes almost impossible to write even the lightest functional wrapper around such libraries. except one start to wrap all child classes into distinct union value constructors."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:10:00",
                "Content": "The example works if you just drop the # flexibility: https://gist.github.com/dsyme/a02b19b9e55ab392a06d"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T06:12:00",
                "Content": "I will mark this particular request as declined because it's not entirely clear what is being proposed here. Please reopen with a more concrete suggestion and lots of examples? I understand there is pain in this area but we need further motivating examples.\r\nThanks!"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Per my comment, the example works if you drop the use of # flexibility in this case\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "9526842": {
        "Number": "9526842",
        "Submitter": "Ed A",
        "Submitted": "2015-08-28T00:00:00",
        "Title": "Give 'A+B+...' as a type shorthand for Choice<A,B,...>",
        "Text": "We can't have anonymous discriminated unions but sometimes we don't want to bother making a new type for simple choices. At the moment, Fsharpers have a shorthand for Tuple<A,B>, Tuple<A,B,C...> so why not have a shorthand for choices as well? I agree that using discriminated unions to do this normally is very good practice because we can label each case to help us see the meaning of the type. But there are cases where we just want to quickly say \"this can return an A or a B'. This happens a lot if you are writing functions that do a job inside another function. Writing a new union type for this one function is overkill so we use Choice<_>.\r\nThe only problem I can see is that forming and unpacking things of type Choice<A,B,C> is a bit tedious and involves using the Choice1of3 etc union types. As an extra (and this is might be a terrible idea) we could do terse pattern matching on A+B+C by writing something like\r\nlet f : (int+int+string) -> int =\r\nfunction\r\n//first case\r\n|a -> a\r\n|+|\r\n//middle case\r\n|0 -> 1\r\n|b -> (2 + b)\r\n|+|\r\n//final case\r\n|str -> (str.length)\r\nOr some similar syntax where we identify which case we are working on by separating them in the same order. If our Choice type was bigger than 3, this would of course become somewhat unmaintainable and not very readable. But if we are only working with a small number of choices in a one-off function, this might help avoid unnecessary clutter.\r\nThere also might be a way of making a terse replacement for the 'Choice1of3' syntax. Perhaps in1, in2 in3 etc",
        "Votes": 1,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2015-09-07T00:00:00",
            "Text": "Thanks for the suggestion. While I appreciate the intent here, this is something we decided against in F# 1.0 in order to balance code readability v. special syntax. I don’t think anything specific has changed to warrant us revising that choice at this stage.\r\nMany thanks\r\nDon Syme\r\nF# Language Evolution"
        }
    },
    "9626979": {
        "Number": "9626979",
        "Submitter": "Semyon Grigorev",
        "Submitted": "2015-09-04T00:00:00",
        "Title": "Nonconstant arguments for type providers",
        "Text": "An idea is allow developers to use not string constants only but string expressions which can be statically calculated to regular set. It may be useful to improve sql type provider flexibility.\r\nAn example:\r\nlet getPersons maleOnly =\r\nlet s = “select mane, id from persons ”\r\nlet filter =\r\nif maleOnly\r\nthen “where gender = ‘m’”\r\nelse “”\r\nuse cmd = new SqlCommandProvider<s + filter, connectionString>()\r\ncmd.Executre()\r\nThe set of query expression values can be statically calculated. It can be described with regexp {\"select mane, id from persons\" (\"where gender = ‘m’\"|\"\")}. So, syntax correctness can be checked, parsing can be performed (there are some works on regular set parsing: http://link.springer.com/chapter/10.1007%2F978-3-642-17164-2_10, http://www.easychair.org/smart-program/PSI2015/2015-08-26.html#talk:10362 \"Relaxed Parsing of Regular Approximations of String-Embedded Languages\"). So it is not necessary to parse each element of the set and parsing can be implemented effectively. This way we can check query correctness and get information for typed result generation. Seems that we have enough information for type provider creation.\r\nShort demo of string-embedded SQL support in MS VS: https://youtu.be/P3FFg02-edc",
        "Votes": 0,
        "Comments": [],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-03T00:00:00",
            "Text": "Declining as now at zero votes."
        }
    },
    "9633858": {
        "Number": "9633858",
        "Submitter": "trek42",
        "Submitted": "2015-09-05T00:00:00",
        "Title": "Structural, extensible records like Elm (concrete proposal)",
        "Text": "(this is similar to [[/ideas/suggestion-8592088-make-records-extensible-a-la-elm](/ideas/suggestion-8592088-make-records-extensible-a-la-elm.md),]([/ideas/suggestion-8592088-make-records-extensible-a-la-elm](/ideas/suggestion-8592088-make-records-extensible-a-la-elm.md),.md) but more concrete).\r\n== Motivations ==\r\nF#'s record type is good at representing a group of fields, but is also limited and inflexible:\r\n* Not Extensible -- it's hard to extend an existing record type with new fields. To extend type A without elaborating all its fields, the only choice is to create a nested structure that holds A as one field. However, many times a flat structure is more desirable (e.g. it is a better way to model the data, simpler, more readable, etc), and this is hard to do.\r\n* Inflexible -- F#'s record type is nominal and doesn't support inheritance, which makes sharing common logic that works on structurally similar records very difficult. (Using inline functions with SRTP could achieve this, but the ugly/heavy syntax and other constraints of SRTP often create more problems than benefits).\r\nI believe what's missed is a structural typing for record (a la Elm), and it's possible to add this to F# with great benefits.\r\n== Proposal: Flexible Record Type ==\r\nThe core idea is to use '#' (currently for flexible type) to decorate records, so as to distinguish these “flexible records” from nominal record types.\r\nExamples:\r\n==== Defining Ad-hoc Flexible Records ====\r\n// for normal records. the type must be predefined.\r\ntype A = { x: int; y: int }\r\nlet a = { x = 10; y = 10 }\r\n// the type of ‘b’ is #{x: int; y: int}.\r\n// the type doesn’t need to be predefined.\r\nlet b = #{ x = 10; y = 10 }\r\n// type annotation and mutable are also possible.\r\nlet c = #{ x: int = 10; y = 20 }\r\nlet d = #{ mutable x = 10; y = 10 }\r\n// flexible records are extensible.\r\n// e0 doesn’t change the type.\r\n// e1, e2, e3 adds, removes, updates fields respectively.\r\nlet e0 = #{ b with y = 100 }\r\nlet e1 = #{ b with z = 100 }\r\nlet e2 = #{ b - y }\r\nlet e2 = #{ b with y = “new field type” }\r\n// We can definitely combine two flexible records\r\n// as long as their fields are disjoint.\r\n// below ‘Z’ is #{ x = 10; y = 10 }\r\n// ‘U’ is #{x = 10; y = 10; u = 100 }\r\nlet X = #{ x = 10 }\r\nlet Y = #{ y = 10 }\r\nlet Z = #{ X; Y }\r\nlet U = #{ X; Y with u = 100 }\r\n// Flexible records make defining default field values\r\n// tremendously easier, because we can define default values\r\n// per field, independently of the enclosing type.\r\n//\r\n// Below gives default value for ‘z’ but leaves ‘x’ and ‘y’ open.\r\n// This is hard to simulate with current F# record, where the\r\n// { default_instance with fields } syntax requires ‘default_instance’\r\n// to be fully defined.\r\n//\r\nlet DefaultZ = #{ z = 100 }\r\nlet xyz = #{ DefaultZ with x = 10; y = 20 }\r\n==== Defining Flexible Record Types ====\r\n// We can give names to flexible record types,\r\n// and they are just type alias.\r\n//\r\n// B is a type alias of #{x: int; y: int}.\r\ntype B = #{x: int; y: int}\r\n// Both nominal and flexible records can hold flexible\r\n// record fields.\r\ntype Nominal = { b: B }\r\ntype Flexible = #{ b: B }\r\n// Instance of ’Nominal’\r\nlet nominal = { #{ x = 10; y = 10 } }\r\n// Instance of ‘Flexible’\r\nlet flexible = #{ #{ x = 10; y = 10 } }\r\n==== Functions With Flexible Records ====\r\n// Functions can take flexible record parameters.\r\nlet f (r: B) = …\r\nlet g (r: #{x: int; y: int}) = …\r\n// We can call f and g with ‘a’, ‘b’, ‘e1’ defined above.\r\n// Note that ‘a’ (of type A) and ‘e1’ have structurally\r\n// compatible types, so they can be called directly\r\n// without any conversion.\r\n//\r\n// For implementation, the compiler could add desugar code\r\n// at call sites to make this work (e.g.., adding virtual dispatches\r\n// to access fields of ’a’ and ‘e1’ through flexible type B).\r\nlet _ = f a, f b, f e1\r\nlet _ = g a, g b, g e1\r\n// Flexible record type can be inferred and hold generic fields.\r\n// The signature of ‘h1’ is #{ x: ’T; y: int } -> ’T * int\r\n// The signature of ‘h2’ is #{ x: ’T } -> ’T\r\nlet h1 (r: #{_}) = r.x, (r.y + 1)\r\nlet h2 (r: #{x: _}) = r.x\r\n// It’s also very useful to return flexible record type.\r\n// This is usually more readable than returning a tuple.\r\n// Below we can use result.x, etc.\r\nlet h3 … = … in #{ x = x; y = y; z = z }\r\nlet result = h3 …\r\n(note: this implements this suggestion: [[/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f](/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f.md))]([/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f](/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f.md)).md)\r\n==== Extra Feature: Partially Apply Records to Functions ====\r\nThere are already suggestions for supporting named and optional parameters on let-binding functions ([[/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m](/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m.md)).]([/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m](/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m.md))..md)\r\nA way to achieve this is to allow partially applying the fields of a record\r\n(nominal or flexible) to a function based on parameter names. But we need a new syntax to distinguish this to normal function application. I think a reasonable choice is to use “##{}”, which means “flexible application”. I don’t really enjoy the particular operator, but I think it’s quite acceptable.\r\n// syntax: “Function ##record”.\r\n// g is (fun x -> x + 10 + 20).\r\nlet f x y z = x + y + z\r\nlet g = f ##{ y = 10; z = 20 }\r\n// c = 130.\r\n// d is (fun x y -> x + y + 30)\r\n// e is 60.\r\nlet a = { x = 10; y = 20 }\r\nlet b = #{ z = 30; extra_field = “ignored” }\r\nlet c = f ##a 100\r\nlet d = f ##b\r\nlet e = f ##b ##a\r\n// Below is a compiler error\r\n// because the field isn’t compatible.\r\nlet _ = f ##{x = “string” }\r\n== Notes on Implementation of Runtime ==\r\nI think there are multiple ways to implement this, for example to make flexible record an interface\r\nwhose fields are virtual properties, and compiler automatically injects adapter objects to when calling a function with compatible but not identical records.\r\nThere might be clever ways to avoid the virtual dispatch for common cases, e.g., if there is no mutable field involved, we can make the flexible record type concrete, and do a field-wise copy at callsites when calling a function with compatible but not identical records.\r\n== Summary ==\r\nI think this opens lots of opportunities, and the fact that it can achieve the goal of some other suggestions (“C#-like anonymous type; named parameters for let-binding) suggests it may be an appropriate language construct and bring synergy and consistency to the language.\r\nRelated Suggestions:\r\n* [/ideas/suggestion-8592088-make-records-extensible-a-la-elm](/ideas/suggestion-8592088-make-records-extensible-a-la-elm.md)\r\n* [/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f](/ideas/suggestion-5673015-support-c-like-anonymous-types-in-f.md)\r\n* [/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m](/ideas/suggestion-5663215-optional-and-named-parameters-on-let-bindings-on-m.md)\r\nPS: IMHO, ideally structural record should be the default, and nominal record type should require annotation. However this doesn’t seem to be feasible now.",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2015-09-07T05:15:00",
                "Content": "Thanks for the well described proposal. For example I'd not seen the use of this kind of declaration:\r\nlet h1 (r: #{_}) = r.x, (r.y + 1)\r\nto introduce the ability to use r.x and r.y without pre-naming x and y (and without allowing r.mistake in other situations) before.\r\nThere are a couple of things you need to consider. One is the interaction with generics: what is the type of\r\nlet f1 x = #{ a=x; b=x }\r\nand is the return type compatible with\r\nlet f2 x y = #{ a=x; b=y }\r\nAlso, how is this compiled? How many generic type parameters does the underlying class/interface have?\r\nThe other huge issue is about type identity and how to compile such a feature in a cross-assembly compatible way. If an abstract class or interface type is used as the representation, which assembly is that class or interface defined in? Or, to put it another way, is #{x=4} from one assembly compatible with #{x=4} from another assembly? Of course we would like that they are, but how do you implement that?\r\nThis is central to the design space for structural types for F# - it's not that there are multiple ways to implement structural record types (efficiently) - the problem is that there are _no_ ways to implement them on top of .NET (or at least no ways that don't lead to some other kind of limitation).\r\nFor example, you could unify all the similar record types within an assembly (C# does this for its anonymous object representation types), but give the types different identities across different assemblies. This would mean #{ x = 10; y = 10 } from one assembly would not be type-compatible with #{ x = 10; y = 10 } from a different assembly.\r\nLikewise you could choose to tie the identity of a type to a containing module or containing function, so #{ x = 10; y = 10 } in one module was not type-compatible with #{ x = 10; y = 10 } in another module unless they were explicitly type-annotated to refer to a common module.\r\nBut what you can't get for free from .NET is structural types that somehow compile to nominal types in the natural way _and_ with seamless compatibility between objects and types across assembly boundaries."
            },
            {
                "Submitter": "trek42",
                "Submitted": "2015-09-07T09:43:00",
                "Content": "Hi Don — thanks for the thoughtful reply!\r\nI think we want to make all “#{x=4}” objects instantiated\r\nin different assemblies work together seamlessly, otherwise\r\nit is quite unsatisfactory.\r\nI guess one way that might work is to use erased types.\r\nHere’s a layman’s proposal for discussion, please\r\nbear with me if it falls apart completely :-). The idea is that\r\nthe field names are ordered lexicographically and then erased\r\ncompletely in the compiled form, e.g., #{ y: ’U, x: ’T } becomes\r\nFSharp.Core.ErasedRecord<’T, ‘U>, and List<#{x: int}> is just\r\nList<ErasedRecord<int>>, and so on. So all such records\r\nwill be compatible with each other at IL level as long as the\r\nshape is the same.\r\nWe keep F#-accessible metadata for the non-erased record types,\r\nderived types and functions signatures in the assembly, in order to enforce\r\nstronger type safety by F# compiler, which will check that not only the\r\nshape but also field names must be compatible. I don’t know how\r\npowerful the F#-only decorations can be; I wish this could be achieved\r\nin a similar way that we define types with unit-of-measure, erased them\r\nin compiled form, yet still have stronger type safety when consuming them\r\nin F# code.\r\n(With the F#-only decorations the compiler can automatically inject\r\nconversion code between different but structurally compatible record types\r\ne.g., when we call a function taking #{x: int} with an object of type #{x: int, y: int},\r\na new ErasedType<int> is automatically constructed).\r\nFor the first question about generics:\r\n// Signature:\r\n// f1: ’T -> # { a = ’T; b = ’T }\r\n// f2: ’T -> ‘U -> # { a = ’T; b = ‘U }\r\n//\r\n// they are erased to return\r\n// ErasedRecord<’T, ’T> and ErasedRecord<’T, ‘U> respectively.\r\nlet f1 x = #{ a = x; b = x }\r\nlet f2 x y = #{ a = x; b = y }\r\nSo naively I guess their signatures shouldn’t be compatible,\r\nsimilar to that “let f1 x = x, x” and “let f2 x y = x, y” aren’t compatible.\r\nI haven’t spotted a particularly big issue here, but I could well have\r\nmisunderstood the situation here. (let me know!).\r\n===\r\nPS: after I posted the original proposal, I’m leaning towards making structural record types\r\nconcrete instead of interface, for better performance and simplicity. This may mean that\r\nmutable fields can’t be supported (I’m not sure), but I think it’s an acceptable situation\r\nif other parts of the solution can be worked out nicely."
            },
            {
                "Submitter": "Nathan Schultz",
                "Submitted": "2015-11-17T21:00:00",
                "Content": "It might be worth noting that Elm is removing Extensible Record support as of version 0.16.\r\nhttps://github.com/elm-lang/elm-compiler/issues/985"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:17:00",
                "Content": "trek42 - I think it is not possible to get both cross-assembly structural typing and subtype-compatible extensibility.\r\nThere is also a lot of overlap between this and http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f and http://fslang.uservoice.com/forums/245727-f-language/suggestions/6148669-add-support-for-structtuple. From the notes below, this is beginning to look a lot like the StructTuple proposal in its compiled form. But I think you _really_ want to be able to add and remove fields and maintain structural compatibility. I don't think that's possible if compiling to tuple types.\r\nDon't get me wrong - I think this is a great feature - I just think it would have to be completely erased to property bags to actually work in practice. But that would not satisfy typical performance needs."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-05T05:18:00",
                "Content": "I'm going to decline this feature because I don't believe it's possible to implement it satisfactorily within the constraints of the .NET nominal/generics type system, without using complete erasure of the types (or interfaces, which also would bring cross-assembly type identity problems)"
            },
            {
                "Submitter": "trek42",
                "Submitted": "2016-02-06T02:05:00",
                "Content": "Don -- It's a great news that there will be StructTuple in F# !! really looking forward to the open rfc. I think it will be a great enhancement to F#.\r\n====\r\nSome further discussion:\r\nRe: \"But I think you _really_ want to be able to add and remove fields and maintain structural compatibility. I don't think that's possible if compiling to tuple types.\"\r\nto clarify, what I was thinking about is after type-erasure, the tuple types won't be structurally compatible. In other words, mapping two erased tuples based on field order will be wrong. However, all type conversions are statically generated and injected by compiler at compile time, so the field order in erased tuples don't matter.\r\n====\r\nI've been thinking about this proposal since last time, just document them here (not indicating they are useful, but anyway :-) )\r\nI think what I really want is \"anonymous types with subtyping based on field identifiers\". -- Other things are icing on the cake.\r\nNamely (using tuple notation):\r\n#0. Anonymous type -- don't have to typedef it. (tuple satisfies this).\r\n#1. (A:int, B:string) is identical to (B:string, A:int) -- unlike vanilla tuples, field order never matters.\r\n#2. Subtyping -- we can have a function that accepts (A:int, B:string), and any compatible superset (e.g., (A:int, B:string, C:int) ) can be applied without manual conversion (compiler generates conversions at call-sites).\r\n(How to make #1 and #2 work on .NET and across assembly is the hardest part. I really hope there is someway to hack this...)\r\nBeyond that, producing new types by adding/removing fields from existing, *concrete* type is mostly syntax sugar -- they are very useful but not as critical as subtyping (#2), which enables sharing code.\r\nI'm eager to find out whether the StructTuple is completely agnostic to field order (I think order-based mapping is too confusing), and to what extend type conversion among different StructTuple can be introduced."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Thanks for the suggestion, I think it’s a great feature\r\nUnfortunately I have to decline it since I don’t think it’s possible to implement it within the constraints of the .NET nominal/generics type system, while maintaining cross-assembly type identity\r\nThe issue http://fslang.uservoice.com/forums/245727-f-language/suggestions/5673015-support-c-like-anonymous-types-in-f is also highly relevant, as is http://fslang.uservoice.com/forums/245727-f-language/suggestions/6148669-add-support-for-structtuple"
        }
    },
    "9679206": {
        "Number": "9679206",
        "Submitter": "Don Syme",
        "Submitted": "2015-09-08T00:00:00",
        "Title": "DefaultValue attribute should require 'mutable' when used in classes and records",
        "Text": "For structs, adding the DefaultValue attribute to a val declaration (a field) results in a check that the field is mutable, since it doesn't make sense to use an immutable field which only ever has the default value.\r\n[<Struct>]\r\ntype S() =\r\n[<DefaultValue>] val x : C\r\nAssemblyReader.fs(4304,23): error FS0880: Uninitialized 'val' fields must be mutable and marked with the '[<DefaultValue>]' attribute. Consider using a 'let' binding instead of a 'val' field.\r\nFor some reason, this condition is only checked for fields declared in structs. We should likewise give a warning for records and classes:\r\ntype C() =\r\n[<DefaultValue>] val x : C\r\nand\r\ntype R = { [<DefaultValue>] x : C; y : int }",
        "Votes": 1,
        "Comments": [],
        "Status": "planned",
        "Response": {
            "Responded": "2015-09-08T00:00:00",
            "Text": "Approved for inclusion in a future release of F#.\r\nPlease consider contributing to F# by providing an implementation, with adequate testing. The code to be adjusted is around here: https://github.com/fsharp/fsharp/blob/212c3359bf6d83e30c12e53fd2ef283d3257b328/src/fsharp/PostInferenceChecks.fs#L1422. For some reason, the code is only activated for struct/enum type definitions, but it should also apply to record and class type definitions.\r\nDon Syme, F# Language Evolution"
        }
    },
    "9688323": {
        "Number": "9688323",
        "Submitter": "Lev Gorodinski",
        "Submitted": "2015-09-09T00:00:00",
        "Title": "Support custom scheduler in Async",
        "Text": "Some discussion here: https://github.com/Microsoft/visualfsharp/issues/581",
        "Votes": 15,
        "Comments": [
            {
                "Submitter": "Ryan Riley",
                "Submitted": "2015-09-09T13:35:00",
                "Content": "Weird, I thought I added this a long time ago. Perhaps it was declined."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "9738327": {
        "Number": "9738327",
        "Submitter": "Gauthier Segay",
        "Submitted": "2015-09-13T00:00:00",
        "Title": "easier interop with FSharp.Core from other .net languages",
        "Text": "A first example is FSharpOption<T> and it's usage in C#/VB, extend FSharp.Core with this module to make it easier to use:\r\nhttp://fssnip.net/so\r\nThere are other efforts to be made to make FSharp.Core look not too alien in other languages, like being able to await on FSharpAsync.\r\nHaving design guidelines for this type of interop doesn't remove the need for basic F# constructs to be exposed in a convenient way to other dotnet languages.",
        "Votes": 11,
        "Comments": [
            {
                "Submitter": "Gauthier Segay",
                "Submitted": "2015-09-13T05:26:00",
                "Content": "For discrimated union, the root type expose get_Is* methods, it should be exposed as Is* methods instead."
            },
            {
                "Submitter": "Dzmitry Lahoda",
                "Submitted": "2015-09-22T12:46:00",
                "Content": "It would be yet another path to introduce F# into C# heavy bureaucratic enterprise. I know that F# Core is part of .NET 4.5. So just add reference from GAC."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "9799014": {
        "Number": "9799014",
        "Submitter": "Eugene Tolmachev",
        "Submitted": "2015-09-17T00:00:00",
        "Title": "Produce System.Linq.Expressions more efficiently",
        "Text": "Most of .NET query providers are written in C# and use System.Linq.Expressions. While the conversion Expr->Expression is available it introduces significant penalty: http://stackoverflow.com/questions/32592811/why-is-f-expression-tree-generation-is-much-slower-than-c-can-it-be-made-fast",
        "Votes": 30,
        "Comments": [
            {
                "Submitter": "Dzmitry Lahoda",
                "Submitted": "2015-09-22T12:44:00",
                "Content": "Also I want want to use API of Elastic NEST or NHibernate I have to map F# Expr to Linq manually losing some readability of queries."
            },
            {
                "Submitter": "Eugene Tolmachev",
                "Submitted": "2015-10-09T12:42:00",
                "Content": "Alternatively, maybe introduce an argument attribute, similar to ReflectedDefinition, something that would tell the compiler to produce C#-compatible tree from a lambda at compile-time, rather than the code to perform the conversion at runtime?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-03T11:09:00",
                "Content": "I have updated the title to change the suggestion to be about performance."
            }
        ],
        "Status": "open",
        "Response": null
    },
    "9829650": {
        "Number": "9829650",
        "Submitter": "mikero",
        "Submitted": "2015-09-19T00:00:00",
        "Title": "Allow \"as\" in match head",
        "Text": "I always seem to be doing this, which seems natural, but isn't allowed:\r\nmatch ((fn h) as res) with\r\n| ...",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "mikero",
                "Submitted": "2015-09-19T11:19:00",
                "Content": "BTW, the reason is that if there are many following complex matches then you wouldn't need to wrap each in a \"(...) as res\" to capture the original un-de-structured result."
            },
            {
                "Submitter": "Paulmichael Blasucci",
                "Submitted": "2015-09-28T15:56:00",
                "Content": "If you're using this in a lot of match cases, maybe using a local binding before the match would be easier...\r\nlet res = fn h\r\nmatch res with\r\n| ..."
            },
            {
                "Submitter": "mikero",
                "Submitted": "2015-09-28T19:44:00",
                "Content": "But that's a whole extra line, dude :)\r\nSeriously though, it's not big deal, but seems consistent with allowing these in assignments and pattern matches.\r\nThey could just be allowed anywhere:\r\nif (fn h) as res = 42 then printfn \"%d\" res"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-23T11:58:00",
                "Content": "I don't think this adds enough to really be necessary in the language. I'm marking as declined, though thank you for the suggestion."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-01-23T00:00:00",
            "Text": "See comment above,\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "9969603": {
        "Number": "9969603",
        "Submitter": "Ben Lappin",
        "Submitted": "2015-09-29T00:00:00",
        "Title": "Make type aliases enforceable at compile time",
        "Text": "[<Measure>] is enforced by the compiler, but adds no performance overhead and causes no issues for interop.\r\nIt would be nice to have a similar attribute that could be applied to any type.",
        "Votes": 23,
        "Comments": [
            {
                "Submitter": "Harald Steinlechner",
                "Submitted": "2016-02-03T06:25:00",
                "Content": "so you basically propose something like Haskell's newtype?"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T17:00:00",
                "Content": "We decided against this in F# 1.0\r\nIf we make a change here, it would be to implement single-case union types using structs, e.g.\r\n[<Struct>]\r\ntype X = X of int\r\nThis will be just as performant as a \"int\" value and the type gets a proper new nominal type for reflection and other purposes.\r\nAnother factor is the set of members the type would support - when you think of the .NET representation, you can you define new members on the struct type, but not on a type alias."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thanks for the suggestion. I’ve marked it declined with my reasons in the comments below.\r\nBest regards\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "9969741": {
        "Number": "9969741",
        "Submitter": "Ben Lappin",
        "Submitted": "2015-09-29T00:00:00",
        "Title": "Allow type providers to create and provide aliased types",
        "Text": "With SqlEnumProvider, unless I create a CLIEnum, the provided type is a module with members of the value's type (e.g. string).\r\nIt would be nice to be able to provide a type alias for the members that would be visible from other parts of the program to make clear the association with the provided type (e.g. provided type is named \"EmployeeCodes\", and the members are strings with aliased type \"EmployeeCode\").",
        "Votes": 1,
        "Comments": [
            {
                "Submitter": "Ben Lappin",
                "Submitted": "2015-09-29T07:09:00",
                "Content": "Related suggestion (posted by me):\r\n[/ideas/suggestion-9969603-make-type-aliases-enforceable-at-compile-time](/ideas/suggestion-9969603-make-type-aliases-enforceable-at-compile-time.md)\r\nStackoverflow question (not posted by me):\r\nhttp://stackoverflow.com/questions/20567690/can-i-make-multiple-aliases-of-the-same-type-in-an-f-type-provider"
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:39:00",
                "Content": "I believe this is actually possible today, though the ProvidedTypes SDK may need updating. Specifically you just have to create a ProvidedSymbolType with the right name and kind. For example\r\nProvidedSymbolType(ProvidedSymbolKind.FSharpTypeAbbreviation(typeAssembly,typeNamespace, typeName), [])\r\nCertainly the core ITypeProvider mechanism supports this.\r\nI will close this and we can follow up with an issue in https://github.com/fsprojects/FSharp.TypeProviders.StarterPack/"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Closing because this is already possible today in F# 3.0 and beyond, per my comment below\r\nThanks for the suggestion.\r\nDon Syme\r\nF# Language and Core Library Evolution"
        }
    },
    "9980001": {
        "Number": "9980001",
        "Submitter": "Don Syme",
        "Submitted": "2015-09-29T00:00:00",
        "Title": "Make F# quotations and FSharp.Reflection usable with mscorlib and FSharp.Core for other target profiles",
        "Text": "F# quotations have nodes related to tuple, delegate, function, union and record types. Likewise, FSharp.Reflection has helpers related to union and record types.\r\nWhen running on .NET 4.x everything works fine. But if you use ReflectionOnlyLoadFrom to get an FSharp.Core for an alternative profile, then you can't use most F# quotation nodes correctly - all sorts of things go wrong when you try to construct nodes that refer to the types stemming from this \"other profile\" FSharp.Core. Note you are still running .NET 4.x code, but reflecting over assemblies relevant to other profiles.\r\nThis also applies when implementing the System.Reflection types yourself based on information extracted from these DLLs. THis is done in the CommonProviderImplementation in FSharp.Data, e.g. see https://github.com/fsharp/FSharp.Data/tree/dbfe86e00c766de1227e7e1994942ed93f74db97/src/CommonProviderImplementation\r\nThere are workarounds to use backdoors to avoid the checks that the constructors for quotation nodes perform. For example, see https://github.com/fsharp/FSharp.Data/blob/dbfe86e00c766de1227e7e1994942ed93f74db97/src/CommonProviderImplementation/UncheckedQuotations.fs\r\nHowever, this should really be fixed in FSharp.Core. There are various fixes possible: either add the Unchecked family of functions, or make the checks only take into account type names rather than assembly identities.\r\nLikewise fixes should be made in FSharp.Reflection (especially FSharpUnionCase)",
        "Votes": 6,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-01-27T12:27:00",
                "Content": "I started the implementation of this but it is quite tricky. Here's the work in progress. The main thing missing is testing and fixes for FSharpUnionCase https://github.com/dsyme/visualfsharp/tree/quotation-fixes-1\r\nDon Syme"
            },
            {
                "Submitter": "Jared Hester",
                "Submitted": "2016-03-06T01:26:00",
                "Content": "I did a rough sketch of getting union field names with reflection only using TypeInfo\r\nhttps://gist.github.com/cloudRoutine/3884b1ac325bbd5553f9"
            }
        ],
        "Status": "completed",
        "Response": {
            "Responded": "2016-06-17T00:00:00",
            "Text": "Approved, this should always have been allowed.\r\nDon Syme, F# Language and Core Library Evolution"
        }
    },
    "9987774": {
        "Number": "9987774",
        "Submitter": "Robin Munn",
        "Submitted": "2015-09-30T00:00:00",
        "Title": "Allow finer-grained control of \"open\", like Haskell's \"import hiding\"",
        "Text": "Currently, F#'s \"open\" keyword imports everything from the opened namespace, which can result in unexpected shadowing. For example, if I do:\r\nopen Foo\r\n// fn1 and fn2 are defined in Foo\r\nlet bar (x:Foo.DataType) : DataType = x |> fn1 |> fn2\r\nIf a later version of Foo defines a \"bar\" function that does something completely different, I might later write code that tries to call Foo.bar as \"bar\", forgetting that I had created my own \"bar\" function. Worse, if Foo.bar is defined with the type Foo.DataType -> Foo.DataType, then the compiler won't even be able to save me from my mistake!\r\nWhat I'd like to be able to do is specify exactly which names I'm importing from any given module. Something like one of the following syntax examples:\r\nopen Foo using only (fn1, fn2)\r\nopen Foo importing (fn1, fn2)\r\nopen Foo with only (fn1, fn2)\r\nopen Foo with (fn1, fn2)\r\nOr, alternately, to import everything except for a few names:\r\nopen Foo hiding (bar)\r\nlet bar = ... // Be explicit about not shadowing\r\nThe syntax examples I've listed above are only a few possible ideas that I came up with in five minutes; other possible keywords might be better.\r\nThis is related to, but not the same as, the following two suggestions:\r\n[/ideas/suggestion-6958404-allow-opening-of-static-classes-like-modules](/ideas/suggestion-6958404-allow-opening-of-static-classes-like-modules.md)\r\n[/ideas/suggestion-6323201-aliases-for-namespaces](/ideas/suggestion-6323201-aliases-for-namespaces.md)\r\n[/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard](/ideas/suggestion-5690218-allow-open-in-local-declarations-like-in-standard.md)\r\nThe Python community has had a long-standing recommendation NOT to use \"from Foo import *\" (the Python equivalent of \"open Foo\", which imports all its names into the current namespace), due to precisely the kinds of namespace pollution issues that \"open Foo\" can cause. The strong recommendation in Python is to be explicit about what names you're bringing into your local namespace: \"from Foo import (fn1, fn2)\" and I'd like to see F# allow that very good practice as well.",
        "Votes": 21,
        "Comments": [
            {
                "Submitter": "Radek Micek",
                "Submitted": "2015-10-19T15:19:00",
                "Content": "Instead of\r\nopen Foo using only (fn1, fn2)\r\nyou can write\r\nlet fn1, fn2 = Foo.fn1, Foo.fn2\r\nOr instead of opening a module you can create an alias and qualify its values by the alias."
            },
            {
                "Submitter": "Robin Munn",
                "Submitted": "2016-01-09T02:52:00",
                "Content": "While Radek Micek's suggestion of \"let fn1, fn2 = Foo.fn1, Foo.fn2\" works, I find that I don't like doing that. I don't know why, but that (perfectly workable) solution feels \"inelegant\" to me, and I'd still prefer to have an expanded \"open Foo importing (fn1, fn2)\" (or \"open Foo hiding (bar)\") syntax."
            },
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T16:28:00",
                "Content": "I sympathise with this suggestion and thank you for taking the time to make it.\r\nWe have definitely considered constraining \"open\" in F#. Strangely, it doesn't seem as necessary for good software engineering to do this as in Haskell and Python. I think this is because of three reasons\r\n1. F# uses a lot of type-qualified name resolution. So x.ABC resolves the name ABC according to the inferred type of x. This means there are far fewer name clashes as names are brought in. Likewise F# uses a lot of module-qualified name resolution like List.map. Together these mean there are far fewer clashes\r\n2. Since F# is typed (unlike Python), name clashes are almost always caught in practice\r\n3. There is always the cop-out of using \"module X = SomeModule\" or \"global.Foo.Bar\" to resolve things.\r\nSo I am going to mark this as declined. However I would still like to hear of cases where not having this feature has caused bugs in software, particularly when upgrading packages."
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-04T00:00:00",
            "Text": "Thank you for making this suggestion. I’ve marked it as declined per my comment below.\r\nHowever I sympathise with the suggestion and would like to hear more if yo find specific situations where not having this feature has caused bugs,\r\nDon Syme,\r\nF# Language and Core Library Evolution"
        }
    },
    "9989010": {
        "Number": "9989010",
        "Submitter": "Zoltan Podlovics",
        "Submitted": "2015-09-30T00:00:00",
        "Title": "Add blittable type constraints in order to support more robust native interop",
        "Text": "Proper native interop require strict type definition where the type representation is the same both on managed and unmanaged world. This represents a subset of unmanaged types.\r\nWhy this could be important?\r\nThe blittable type constraint could prevent lot's of type errors which may result errors or crashes. While it is possible to implement the check that run at runtime the static compile time check could provide more robust solution.\r\nUnless struct with Sequential and Pack=1 or Explicit layout specified the JIT compiler free to pad the structure align the fields in order to provide better execution.\r\n1) OpenTK project use the following checks for unmanaged (blittable type) tests:\r\nhttps://github.com/mono/opentk/blob/master/Source/OpenTK/BlittableValueType.cs\r\n2) Masterig Structs\r\nhttp://www.developerfusion.com/article/84519/mastering-structs-in-c/\r\n\"What is important is that the compiler will add padding bytes to align the data within a struct. You can control the padding explicitly, but notice that some processors throw an exception if you use data that isn't aligned, and this creates a more complicated problem for .NET Compact users.\"\r\n3) Ecma 355 II.10.1.2 Type layout attributes\r\n\"[Rationale: The default auto layout should provide the best layout for the platform on which the code\r\nis executing. sequential layout is intended to instruct the CLI to match layout rules commonly\r\nfollowed by languages like C and C++ on an individual platform, where this is possible while still\r\nguaranteeing verifiable layout. explicit layout allows the CIL generator to specify the precise layout\r\nsemantics. end rationale]\"\r\n4) F# unmanaged type definition (which should remain as is)\r\n\"5.2.9 Unmanaged Constraints\r\nAn unmanaged constraint has the following form:\r\ntypar : unmanaged\r\nDuring constraint solving (§14.5), the constraint type : unmanaged is met if type is unmanaged as specified below:\r\nTypes sbyte, byte, char, nativeint, unativeint, float32, float, int16, uint16, int32, uint32, int64, uint64, decimal are unmanaged.\r\nType nativeptr<type> is unmanaged.\r\nA non-generic struct type whose fields are all unmanaged types is unmanaged.\"\r\nExample.:\r\nlet safeCall (x : 'T when 'T: blittable and 'T: struct) = nativeCall(x)",
        "Votes": 3,
        "Comments": [
            {
                "Submitter": "Don Syme",
                "Submitted": "2016-02-04T18:12:00",
                "Content": "Combining with this suggestion: https://fslang.uservoice.com/admin/forums/245727-f-language/suggestions/6359526-add-serializable-constraint-for-types"
            }
        ],
        "Status": "declined",
        "Response": {
            "Responded": "2016-02-05T00:00:00",
            "Text": "Merging with http://fslang.uservoice.com/forums/245727-f-language/suggestions/6359526-add-serializable-and-blittable-constraints-fo"
        }
    }
}